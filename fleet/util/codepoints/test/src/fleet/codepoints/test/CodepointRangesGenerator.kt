package fleet.codepoints.test

import java.io.Writer
import java.net.URI
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import kotlin.io.path.Path
import kotlin.io.path.writer

private data class UnicodeData(
  val letters: List<Symbol>,
  val modifierLetters: List<Symbol>,
  val letterNumbers: List<Symbol>,
  val uppercaseLetters: List<Symbol>,
  val titlecaseLetter: List<Symbol>,
  val lowercaseLetters: List<Symbol>,
  val otherLetters: List<Symbol>,
  val currencySymbols: List<Symbol>,
  val connectorPunctuation: List<Symbol>,
  val lineSeparators: List<Symbol>,
  val paragraphSeparators: List<Symbol>,
  val spaceSeparators: List<Symbol>,
)

private data class Symbol(val value: Int, val name: String)

private data class Range(
  val start: Int,
  val end: Int,
  val category: String,
  val comment: String,
)

val hexFormat = HexFormat {
  number {
    prefix = "0x"
    upperCase = true
    removeLeadingZeros = true
  }
}

fun main() {
  Path("./community/fleet/util/codepoints/srcCommonMain/fleet/codepoints/CodepointJavaRanges.kt").writer().use { writer ->
    writer.appendLine("// GENERATED BY fleet.codepoints.test.CodepointRangesGeneratorKt")
    writer.appendLine("package fleet.codepoints\n")
    writer.writeCodepoints("javaIdStartRanges", (Character.MIN_CODE_POINT..Character.MAX_CODE_POINT).asSequence().filter { Character.isJavaIdentifierStart(it) }.asIterable())
    writer.writeCodepoints("javaIdPartRanges", (Character.MIN_CODE_POINT..Character.MAX_CODE_POINT).asSequence().filter { Character.isJavaIdentifierPart(it) }.asIterable())
  }

  val client = HttpClient.newHttpClient()
  Path("./community/fleet/util/codepoints/srcCommonMain/fleet/codepoints/CodepointRanges.kt").writer().use { writer ->
    writer.appendLine("// GENERATED BY fleet.codepoints.test.CodepointRangesGeneratorKt")
    writer.appendLine("package fleet.codepoints\n")

    client.use { client ->
      println("Fetching unicode data properties...")
      val unicodeData = client.send(HttpRequest.newBuilder()
                                      .uri(URI("https://unicode.org/Public/UNIDATA/UnicodeData.txt"))
                                      .build(), HttpResponse.BodyHandlers.ofString()).body().lineSequence()
        .unicodeData()
      writer.writeSourceDescription("https://unicode.org/Public/UNIDATA/UnicodeData.txt", "")
      writer.writeCodepoints("spaceCharRanges", (unicodeData.spaceSeparators + unicodeData.lineSeparators + unicodeData.paragraphSeparators).map { it.value })

      println("Fetching derived unicode properties...")
      val derivedCorePropertiesResponse = client.send(HttpRequest.newBuilder()
                                                        .uri(URI("https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt"))
                                                        .build(), HttpResponse.BodyHandlers.ofString())
        .body()
      val derivedCoreProperties = derivedCorePropertiesResponse.lineSequence().ranges().groupBy(Range::category)
      writer.writeSourceDescription("https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt", derivedCorePropertiesResponse)
      derivedCoreProperties["ID_Start"]?.let { writer.writeRanges("unicodeIdStartRanges", it) }
      derivedCoreProperties["ID_Continue"]?.let { writer.writeRanges("unicodeIdContinueRanges", it) }
      derivedCoreProperties["Default_Ignorable_Code_Point"]?.filter { !it.comment.contains("<reserved") }?.let { writer.writeRanges("identifierIgnorableRanges", it) }
      derivedCoreProperties["Uppercase"]?.let { writer.writeRanges("uppercaseRanges", it) }

      println("Fetching unicode scripts...")
      val scriptsResponse = client.send(HttpRequest.newBuilder()
                                          .uri(URI("https://www.unicode.org/Public/UCD/latest/ucd/Scripts.txt"))
                                          .build(), HttpResponse.BodyHandlers.ofString())
        .body()
      val scripts = scriptsResponse.lineSequence().ranges().groupBy(Range::category)
      writer.writeSourceDescription("https://www.unicode.org/Public/UCD/latest/ucd/Scripts.txt", scriptsResponse)
      scripts["Common"]?.let { writer.writeRanges("commonRanges", it) }
      scripts["Hiragana"]?.let { writer.writeRanges("hiraganaRanges", it) }
      scripts["Katakana"]?.let { writer.writeRanges("katakanaRanges", it) }

      println("Fetching unicode properties...")
      val propertiesResponse = client.send(HttpRequest.newBuilder()
                                             .uri(URI("https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt"))
                                             .build(), HttpResponse.BodyHandlers.ofString())
        .body()
      val properties = propertiesResponse.lineSequence().ranges().groupBy(Range::category)
      writer.writeSourceDescription("https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt", propertiesResponse)
      properties["Ideographic"]?.let { writer.writeRanges("ideographicRanges", it) }
      properties["White_Space"]?.let { writer.writeRanges("whitespaceRanges", it) }
    }
  }
}

fun Writer.writeSourceDescription(url: String, response: String) {
  appendLine("/**")
  appendLine(" * Codepoints are derived from $url")
  response.lineSequence().takeWhile { it.startsWith('#') }.forEach { appendLine(" * ${it.removePrefix("#").trimStart()}") }
  appendLine(" */")
}

private fun Sequence<String>.unicodeData(): UnicodeData {
  val letterNumbers = mutableListOf<Symbol>()
  val letters = mutableListOf<Symbol>()
  val uppercaseLetters = mutableListOf<Symbol>()
  val titlecaseLetter = mutableListOf<Symbol>()
  val lowercaseLetters = mutableListOf<Symbol>()
  val otherLetters = mutableListOf<Symbol>()
  val currencySymbols = mutableListOf<Symbol>()
  val connectorPunctuation = mutableListOf<Symbol>()
  val modifierLetters = mutableListOf<Symbol>()
  val lineSeparators = mutableListOf<Symbol>()
  val paragraphSeparators = mutableListOf<Symbol>()
  val spaceSeparators = mutableListOf<Symbol>()
  filter { it.isNotBlank() && !it.startsWith("#") }.forEach { line ->
    line.split(';').let {
      val value = it[0].toInt(16)
      val name = it[1]
      it.subList(2, it.size).forEach { part ->
        when (part) {
          "Nl" -> letterNumbers.add(Symbol(value, name))
          "Sc" -> currencySymbols.add(Symbol(value, name))
          "L" -> letters.add(Symbol(value, name))
          "Lu" -> uppercaseLetters.add(Symbol(value, name))
          "Lt" -> titlecaseLetter.add(Symbol(value, name))
          "Ll" -> lowercaseLetters.add(Symbol(value, name))
          "Lm" -> modifierLetters.add(Symbol(value, name))
          "Lo" -> otherLetters.add(Symbol(value, name))
          "Pc" -> connectorPunctuation.add(Symbol(value, name))
          "Zl" -> lineSeparators.add(Symbol(value, name))
          "Zp" -> paragraphSeparators.add(Symbol(value, name))
          "Zs" -> spaceSeparators.add(Symbol(value, name))
        }
      }
    }
  }
  return UnicodeData(letters = letters,
                     modifierLetters = modifierLetters,
                     letterNumbers = letterNumbers,
                     uppercaseLetters = uppercaseLetters,
                     titlecaseLetter = titlecaseLetter,
                     lowercaseLetters = lowercaseLetters,
                     otherLetters = otherLetters,
                     currencySymbols = currencySymbols,
                     connectorPunctuation = connectorPunctuation,
                     lineSeparators = lineSeparators,
                     paragraphSeparators = paragraphSeparators,
                     spaceSeparators = spaceSeparators, )
}

private fun collapseIntoRanges(codepoints: Iterable<Int>): List<Int> = buildList {
  var prev: Int? = null
  codepoints.sortedBy { it }.forEach { symbol ->
    if (prev == null) {
      add(symbol)
    }
    else if (prev != symbol && prev != symbol - 1) {
      add(prev)
      add(symbol)
    }
    prev = symbol
  }
  if (prev != null) {
    add(prev)
  }
}

private fun Writer.writeRanges(name: String, ranges: Iterable<Range>) {
  appendLine("internal val $name = intArrayOf(")
  ranges.forEach { range ->
    val start = range.start.toHexString(hexFormat)
    val end = range.end.toHexString(hexFormat)
    appendLine("  $start, $end, // ${range.comment}")
  }
  appendLine(")")
}

private fun Writer.writeCodepoints(name: String, codepoints: Iterable<Int>) {
  appendLine("internal val $name = intArrayOf(")
  collapseIntoRanges(codepoints).windowed(10, step = 10, partialWindows = true).forEach { ranges ->
    appendLine("  ${ranges.joinToString(separator = ",", postfix = ",") { range -> range.toHexString(hexFormat) }}")
  }
  appendLine(")")
}


private fun Sequence<String>.ranges(): Sequence<Range> {
  return filter { it.isNotBlank() && !it.startsWith("#") }.map { line ->
    val (range, name) = line.substringBefore('#').split(";").map { it.trim() }
    val start = range.substringBefore("..").toInt(16)
    val end = range.substringAfter("..").toInt(16)
    Range(start, end, name, line.substringAfter('#').trim())
  }
}