package com.jetbrains.fleet.rpc.plugin.ir

import com.jetbrains.fleet.rpc.plugin.RPC_ANNOTATION_FQN
import com.jetbrains.fleet.rpc.plugin.ir.util.collectRpcMethods
import com.jetbrains.fleet.rpc.plugin.ir.util.hasRpcAnnotation
import com.jetbrains.fleet.rpc.plugin.ir.util.initClassBase
import com.jetbrains.fleet.rpc.plugin.ir.util.isNonSuspendFlowFunction
import com.jetbrains.fleet.rpc.plugin.ir.util.isNonSuspendResourceFunction
import com.jetbrains.fleet.rpc.plugin.remoteApiDescriptorImplClassName
import org.jetbrains.kotlin.backend.common.IrElementTransformerVoidWithContext
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.backend.common.getCompilerMessageLocation
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.util.file
import org.jetbrains.kotlin.ir.util.isInterface
import org.jetbrains.kotlin.ir.util.kotlinFqName

@OptIn(UnsafeDuringIrConstructionAPI::class)
class GenerateDescriptorImplsPass(
  private val irContext: IrPluginContext,
  private val messageCollector: MessageCollector,
) : IrElementTransformerVoidWithContext() {
  override fun visitClassNew(declaration: IrClass): IrStatement {
    if (declaration.hasRpcAnnotation()) {
      require(declaration.isInterface) {
        "Declaration ${declaration.kotlinFqName} is marked with $RPC_ANNOTATION_FQN but is not an interface"
      }
      val context = FileContext(irContext, messageCollector, currentFile)
      // generated by [GenerateDescriptorObjectPass]
      val descriptorClass = declaration.declarations
        .singleOrNullOrThrow { it is IrClass && it.name == remoteApiDescriptorImplClassName }
        ?.let { it as IrClass } ?: error("No descriptor class found for ${declaration.kotlinFqName}")
      initClassBase(context, descriptorClass)
      transferApiStatusAnnotations(from = declaration, to = descriptorClass)

      val rpcMethods = collectRpcMethods(declaration)
        .filter {
          if (it.isSuspend || it.isNonSuspendFlowFunction() || it.isNonSuspendResourceFunction()) {
            true
          }
          else {
            // Forbid unsupported methods
            messageCollector.report(
              CompilerMessageSeverity.ERROR,
              "${declaration.name} should either be suspend, return Resource<out RemoteResource> or return Flow<*> to be supported in @Rpc interface",
              it.getCompilerMessageLocation(declaration.file)
            )
            false
          }
        }
      val clientStubClass = buildClientStub(declaration, rpcMethods, context)
      implementRemoteDescriptorInterface(
        context = context,
        target = descriptorClass,
        rpcInterface = declaration,
        clientStub = clientStubClass,
        rpcMethods = rpcMethods,
      )
    }

    return super.visitClassNew(declaration)
  }
}
