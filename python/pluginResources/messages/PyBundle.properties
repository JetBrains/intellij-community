### Quick fixes ###
QFIX.optimize.imports=Optimize imports

QFIX.add.import.add.import=Add "''{0}''"

QFIX.add.parameter.self=Add parameter ''{0}''
QFIX.add.super=Add super class call

QFIX.add.property=Add property for the field
QFIX.use.property=Use property for the field

QFIX.make.public=Make public

QFIX.convert.to.new.style=Convert to New-style class

QFIX.change.base.class=Change base class

QFIX.create.property=Create property

QFIX.add.encoding=Add encoding declaration

QFIX.NAME.parameters=Parameters of functions and methods


QFIX.NAME.add.method.$0.to.class.$1=Add method {0}() to class {1}
QFIX.failed.to.add.method=<br/>Failed to add a method!<br/><br/>

QFIX.NAME.add.function.$0.to.module.$1=Create function {0}() in module {1}
QFIX.failed.to.add.function=<br/>Failed to add a function!<br/><br/>

QFIX.action.failed=Action failed

QFIX.remove.trailing.semicolon=Remove trailing semicolon

QFIX.dict.creation=Replace dictionary creation
QFIX.list.creation=Replace list creation

QFIX.classic.class.transform=Inherit from object

QFIX.add.global=Add global statement

QFIX.move.from.future.import=Move 'from __future__ import' to a correct place

QFIX.replace.equality=Replace equality

QFIX.augment.assignment=Replace assignment with augmented assignment

QFIX.statement.effect=Replace with function call
QFIX.statement.effect.move.docstring=Move docstring to the proper place

QFIX.statement.effect.introduce.variable=Introduce variable

QFIX.unresolved.reference=Replace ''{0}'' with ''{1}.{0}''

QFIX.unresolved.reference.add.param.$0=Create parameter ''{0}''
QFIX.unresolved.reference.add.param=Create parameter for reference

# UnresolvedRefCreateFunctionQuickFix
QFIX.unresolved.reference.create.function=Create function
QFIX.NAME.unresolved.reference.create.function=Create function ''{0}''

QFIX.introduce.variable=Introduce variable for statement

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=Remove unnecessary backslash in expression

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=Convert docstring to the triple double-quoted string form

#UnresolvedRefTrueFalseQuickFix
QFIX.unresolved.reference.replace.$0=Replace with {0}

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=Remove arguments equal to default

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=Replace function call with set literal

#DocstringQuickFix
QFIX.docstring.add.$0=Add docstring parameter ''{0}''
QFIX.docstring.remove.$0=Remove docstring parameter ''{0}''
QFIX.docstring.insert.stub=Insert docstring

#RemoveDecoratorQuickFix
QFIX.remove.decorator=Remove decorator

#PyRenameUnresolvedRefQuickFix
QFIX.rename.unresolved.reference=Rename reference

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=Move attribute to __init__ method

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=Make method static

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=Make function from method

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.$0.return.$1=Make ''{0}'' return ''{1}''

#PyImplementMethodsQuickFix
QFIX.NAME.implement.methods=Implement abstract methods

QFIX.NAME.remove.assignment=Remove assignment

QFIX.NAME.update.parameters=Update parameters

QFIX.NAME.remove.call=Remove call

QFIX.NAME.move.except.up=Move except clause up

QFIX.NAME.remove.dict.key=Remove this key

QFIX.NAME.add.specifier=Add format specifier character

QFIX.NAME.add.exception.base=Add Exception base class

QFIX.NAME.change.signature=Change signature
QFIX.change.signature.of=Change signature of {0}

QFIX.NAME.remove.argument=Remove argument



QFIX.NAME.rename.argument=Rename argument
QFIX.NAME.rename.element=Rename element

QFIX.NAME.wrap.in.exception=Wrap with Exception call

QFIX.NAME.make.list=Replace tuple with list

#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=Remove underscores in numeric literals

# InstallAndImportQuickFix
QFIX.install.and.import.package=Install and import package
QFIX.NAME.install.and.import.package=Install and import package ''{0}''

QFIX.create.function.in.module=Create function in module
QFIX.ignore.unresolved.reference=Ignore unresolved reference
QFIX.ignore.unresolved.reference.0=Ignore unresolved reference ''{0}''
QFIX.mark.all.unresolved.attributes.of.0.as.ignored=Mark all unresolved attributes of ''{0}'' as ignored
QFIX.fill.paragraph=Fill paragraph
QFIX.add.qualifier=Add qualifier
QFIX.rename.parameter=Rename parameter
QFIX.fix.docstring=Fix docstring
QFIX.create.class=Create class
QFIX.create.class.0=Create class ''{0}''
QFIX.create.class.in.module=Create class ''{0}'' in module {1}
QFIX.remove.trailing.blank.lines=Remove trailing blank lines
QFIX.convert.indents=Convert indents
QFIX.convert.indents.to.tabs=Convert indents to tabs
QFIX.convert.indents.to.spaces=Convert indents to spaces
QFIX.generating.skeletons.for.binary.module=Generating skeletons for binary module
QFIX.generate.binary.stubs=Generate binary stubs
QFIX.replace.with.true.or.false=Replace with True or False
QFIX.add.method.to.class=Add method to class
QFIX.reformat.file=Reformat file
QFIX.bold.html.text=<b>{0}</b>
QFIX.replace.with.type.name=Replace with type name
QFIX.remove.function.annotations=Remove function annotations
QFIX.replace.with.target.name=Replace with target name
QFIX.remove.generic.parameters=Remove generic parameter(s)
QFIX.replace.with.square.brackets=Replace with square brackets
QFIX.surround.with.square.brackets=Surround with square brackets
QFIX.remove.square.brackets=Remove square brackets

# Intentions: INTN
INTN.Family.convert.import.unqualify=Convert 'import module' to 'from module import'
INTN.Family.convert.import.qualify=Convert 'from module import' to 'import module'
INTN.Family.toggle.import.alias=Toggle import alias
INTN.Family.convert.except.part=Convert except part to supported form
INTN.Family.convert.set.literal=Convert set literal two supported forms
INTN.Family.convert.builtin=Convert builtin module import
INTN.Family.convert.dict.comp.expression=Convert dictionary comprehension expression
INTN.Family.convert.string=Convert single-quoted string to double-quoted

INTN.convert.to.from.$0.import.$1=Convert to ''from {0} import {1}''
INTN.convert.to.import.$0=Convert to ''import {0}''

INTN.alias.for.$0.dialog.title=Alias for ''{0}'':
INTN.add.alias.for.import.$0=Add alias to ''{0}''
INTN.remove.alias.for.import.$0=Remove alias ''{0}''

INTN.Family.migration.to.python3=Migration to Python 3

INTN.convert.except.to=Convert 'except exceptClass, Target' to 'except exceptClass as Target'

INTN.convert.set.literal.to=Convert set literal to 'set' method call

INTN.convert.builtin.import=Convert builtin module import to supported form

INTN.convert.dict.comp.to=Convert dictionary comprehension to 'dict' method call

INTN.replace.noteq.operator=Replace not equal operator

INTN.remove.leading.$0=Remove leading {0}
INTN.remove.leading.prefix=Remove prefix

INTN.remove.trailing.suffix=Remove trailing suffix

INTN.replace.list.comprehensions=Convert list comprehensions to supported form

INTN.replace.list.comprehensions.with.for=Convert list comprehensions to for loop

INTN.replace.octal.numeric.literal=Convert octal numeric literal to supported form

INTN.replace.raise.statement=Convert raise statement to supported form

INTN.replace.backquote.expression=Replace backquote expression

INTN.replace.method=Replace method which is not supported in current Python version

INTN.split.if=Split if
INTN.split.if.text=Split into 2 if's

INTN.negate.comparison=Negate comparison
INTN.negate.$0.to.$1=Negate ''{0}'' to ''{1}''

INTN.string.concatenation.to.format=Replace string concatenation with format operator
INTN.replace.plus.with.format.operator=Replace + with string formatting operator
INTN.replace.plus.with.str.format=Replace + with str.format method call

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=Convert format operator usage to str.format method call

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=Convert to f-string literal
INTN.replace.with.method=Replace with str.format method call

INTN.flip.comparison=Flip comparison
INTN.flip.$0=Flip ''{0}''
INTN.flip.$0.to.$1=Flip ''{0}'' to ''{1}''

INTN.convert.string=Convert single-quoted string to double-quoted

INTN.join.if=Join if's
INTN.join.if.text=Join two if's

INTN.convert.dict.constructor.to.dict.literal=Convert dict constructor to dict literal form
INTN.convert.dict.literal.to.dict.constructor=Convert dict literal to dict constructor

INTN.quoted.string=Convert between single-quoted and double-quoted strings
INTN.quoted.string.single.to.double=Convert single-quoted string to double-quoted string
INTN.quoted.string.double.to.single=Convert double-quoted string to single-quoted string

INTN.convert.lambda.to.function=Convert lambda to function

INTN.convert.variadic.param=Convert from variadic to normal parameter(s)

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=Convert triple-quoted string to single-quoted string

# PyBaseConvertCollectionLiteralIntention
INTN.convert.collection.literal.family=Convert collection to {0}
INTN.convert.collection.literal.text=Convert {0} to {1}

# PyConvertTypeCommentToVariableAnnotation
INTN.convert.type.comment.to.variable.annotation.family=Convert type comment to variable annotation
INTN.convert.type.comment.to.variable.annotation.text=Convert to variable annotation


INTN.demorgan.law=DeMorgan law

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=Transform conditional expression into if/else statement

# PyConvertTripleQuotedStringIntention
INTN.doc.string.stub=Insert documentation string stub

#SpecifyTypeInDocstringIntention
INTN.specify.type=Specify type for reference in docstring
INTN.specify.return.type=Specify return type in docstring
INTN.add.parameters.to.docstring=Add parameters to docstring

#SpecifyTypeInPy3AnnotationsIntention
INTN.specify.type.in.annotation=Specify type for reference using annotation
INTN.specify.return.type.in.annotation=Specify return type using annotation

#PyAnnotateTypesIntention/PyAnnotateVariableTypeIntention
INTN.add.type.hints.for.function.family=Add type hints for function
INTN.add.type.hints.for.function=Add type hints for function ''{0}''
INTN.add.type.hint.for.variable.family=Add type hint for variable
INTN.add.type.hint.for.variable=Add type hint for variable ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=Type ''{0}'' cannot be expressed inline in PEP 484 format

#TypeAssertionIntention
INTN.insert.assertion=Insert type assertion

#PyYieldFromIntention
INTN.yield.from=Transform explicit iteration with 'yield' into 'yield from' expression

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=Convert static method to function

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=Convert method to property

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=Convert relative import to absolute
INTN.convert.absolute.to.relative=Convert absolute import to relative

INTN.add.alias.title=Add Alias

# Conflict checker
CONFLICT.name.$0.obscured=Name ''{0}'' obscured by local definitions
CONFLICT.name.$0.obscured.cannot.convert=Name ''{0}'' obscured. Cannot convert.
CONFLICT.occurrence.sing=occurrence
CONFLICT.occurrence.pl=occurrences

### Surround with templates ###
surround.with.whileelse.template=while / else
surround.with.return.template=return
surround.with.try.except.template=try / except

##########################################################################################################################
# Unwrap
##########################################################################################################################
unwrap.if=Unwrap if...
unwrap.while=Unwrap while...
unwrap.for=Unwrap for...
unwrap.with=Unwrap with...
unwrap.try=Unwrap try...
unwrap.else=Unwrap else...
unwrap.elif=Unwrap elif...
remove.else=Remove else...
remove.elif=Remove elif...

### Inspections: INSP ###
INSP.GROUP.python=Python
INSP.GROUP.mako=Mako

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.cannot.appear.past.keyword.arg=Cannot appear past keyword arguments or *arg or **kwarg
INSP.unexpected.arg=Unexpected argument
INSP.unexpected.arg(s)=Unexpected argument(s)
INSP.parameter.$0.unfilled=Parameter ''{0}'' unfilled
INSP.parameter(s).unfilled=Parameter(s) unfilled
INSP.possible.callees=Possible callees
INSP.func.$0.lacks.first.arg=Function ''{0}'' lacks a positional argument
INSP.expected.dict.got.$0=Expected a dictionary, got {0}
INSP.expected.iter.got.$0=Expected an iterable, got {0}
INSP.more.args.that.pos.params=Multiple values resolve to one positional parameter
INSP.multiple.values.resolve.to.positional.$0=Multiple values resolve to positional parameter ''{0}''
INSP.cannot.analyze=This argument list cannot be analyzed

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Methods having troubles with first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called ''{0}''
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'
INSP.usually.named.$0=Usually first parameter of such methods is named ''{0}''
INSP.first.param.must.not.be.tuple=First parameter of a non-static method must not be a tuple

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=Problematic nesting of decorators
INSP.decorator.receives.unexpected.builtin=This decorator will not receive a callable it may expect; the built-in decorator returns a special object

# PyRedeclarationInspection
INSP.NAME.redeclaration=Redeclared names without usage
INSP.redeclared.name=Redeclared ''{0}'' defined above without usage

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=''{0}'' in try block with ''except ImportError'' should also be defined in except block
INSP.unused.import.statement=Unused import statement <code>#ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=Invalid interpreter configured

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ method that returns a value
INSP.cant.return.value.from.init=Cannot return a value from __init__

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=Unreachable code
INSP.unreachable.code=This code is unreachable

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=Reassignment of method's first argument
INSP.first.arg.$0.assigned=Method''s parameter ''{0}'' reassigned

# PyStringFormatInspection
INSP.NAME.str.format=Errors in string formatting operations
INSP.format.requires.no.mapping=Format doesn't require a mapping
INSP.key.$0.has.no.arg=Key ''{0}'' has no corresponding argument
INSP.unexpected.type.$0=Unexpected type {0}
INSP.too.few.keys=Too few mapping keys
INSP.no.format.specifier.char=Format specifier character missing
INSP.format.requires.mapping=Format requires a mapping
INSP.too.many.args.for.fmt.string=Too many arguments for format string
INSP.too.few.args.for.fmt.string=Too few arguments for format string
INSP.incompatible.options=The format options in chunk "{0}" are incompatible
INSP.unused.mapping = Mapping key "{0}" is unused
INSP.unsupported.format.character=Unsupported format character ''{0}''
INSP.manual.to.auto.field.numbering=Cannot switch from manual field specification to automatic field numbering
INSP.auto.to.manual.field.numbering=Cannot switch from automatic field numbering to manual field specification

# PyMethodOverridingInspection
INSP.NAME.method.over=Method signature does not match signature of overridden method
INSP.signature.mismatch=Signature of method ''{0}'' does not match signature of base method in class ''{1}''

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=Incompatible signatures of __new__ and __init__
INSP.new.incompatible.to.init=Signature is not compatible to __init__
INSP.init.incompatible.to.new=Signature is not compatible to __new__

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=Trailing semicolon in statement



# PyUnboundLocalVariableInspection
INSP.NAME.unbound=Unbound local variable
INSP.unbound.local.variable=Local variable ''{0}'' might be referenced before assignment
INSP.unbound.nonlocal.variable=Nonlocal variable ''{0}'' must be bound in an outer function scope
INSP.unbound.name.undefined=Name ''{0}'' can be undefined
INSP.unbound.function.too.large=Function ''{0}'' is too large to analyse

# PyDictCreationInspection
INSP.NAME.dict.creation=Dictionary creation could be rewritten by dictionary literal

# PyListCreationInspection
INSP.NAME.list.creation=List creation could be rewritten by list literal

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=Bad except clauses order
INSP.class.$0.already.caught=Exception class ''{0}'' has already been caught
INSP.class.$0.superclass.$1.already.caught=''{0}'', superclass of exception class ''{1}'', has already been caught

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=Tuple assignment balance is incorrect

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=Classic style class usage
INSP.classic.class.usage.old.style.class=Old-style class
INSP.classic.class.usage.old.style.class.ancestors=Old-style class, because all classes from whom it inherits are old-style


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=Exception doesn't inherit from standard ''Exception'' class

# PyDefaultArgumentInspection
INSP.NAME.default.argument=Default argument is mutable

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=Incorrect docstring
INSP.missing.parameter.in.docstring=Missing parameter {0} in docstring
INSP.unexpected.parameter.in.docstring=Unexpected parameter {0} in docstring

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=Missing or empty docstring
INSP.no.docstring=Missing docstring
INSP.empty.docstring=Empty docstring

# PyDocstringTypesInspection
INSP.NAME.docstring.types=Type in docstring doesn't match inferred type

# PyStatementEffectInspection
INSP.NAME.statement.effect=Statement has no effect
INSP.NAME.statement.message=Statement seems to have no effect


# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__ import must be the first executable statement

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=Comparison with None performed with equality operators

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=Raising a string exception

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=Wrong arguments to call super
INSP.$0.is.not.superclass.of.$1=''{0}'' is not an instance or a subclass of ''{1}''

# PyByteLiteralInspection
INSP.NAME.byte.literal=Byte literal contains characters > 255

# PynonAsciiCharInspection
INSP.NAME.non.ascii=File contains non-ASCII character

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=No encoding specified for file

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=Tuple item assignment
INSP.tuples.never.assign.items=Tuples don't support item assignment

# PyPropertyAccessInspection
INSP.NAME.property.access=Access to properties
INSP.property.$0.cant.be.set=Property ''{0}'' cannot be set
INSP.property.$0.cant.be.read=Property ''{0}'' cannot be read
INSP.property.$0.cant.be.deleted=Property ''{0}'' cannot be deleted

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=Property definitions
INSP.doc.param.should.be.str=The doc parameter should be a string
INSP.strange.arg.want.callable=Strange argument; a callable is expected
INSP.func.property.name.mismatch=Names of function and decorator don't match; property accessor is not created
INSP.getter.return.smth=Getter should return or yield something
INSP.setter.should.not.return=Setter should not return a value
INSP.deleter.should.not.return=Deleter should not return a value
INSP.getter.signature.advice=Getter signature should be (self)
INSP.setter.signature.advice=Setter signature should be (self, value)
INSP.deleter.signature.advice=Deleter signature should be (self)
INSP.accessor.first.param.is.$0=First parameter of an accessor is usually called ''{0}''

# PyCallByClassInspection
INSP.NAME.different.class.call=Calling a method by class using an instance of a different class
INSP.instance.of.$0.excpected=An instance of {0} expected, not the class itself
INSP.passing.$0.instead.of.$1=Passing {0} instead of {1}. Is this intentional?

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=Too broad exception clauses

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=Dictionary contains duplicate keys


# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=Assignment can be replaced with augmented assignment

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=Chained comparisons can be simplified

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=Instance attribute defined outside __init__
INSP.attribute.$0.outside.init=Instance attribute {0} defined outside __init__

# PyProtectedMemberInspection
INSP.protected.member.$0.access=Access to a protected member {0} of a class
INSP.protected.member.$0.access.module=Access to a protected member {0} of a module

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=Argument passed to function is equal to default parameter value
INSP.argument.equals.to.default=Argument equals to default parameter value

# PyAbstractClassInspection
INSP.NAME.abstract.class=Class must implement all abstract methods
INSP.NAME.abstract.class.$0.must.implement=Class {0} must implement all abstract methods

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=Old-style class contains new-style class features
INSP.oldstyle.class.slots=Old-style class contains __slots__ definition
INSP.oldstyle.class.getattribute=Old-style class contains __getattribute__ definition
INSP.oldstyle.class.super=Old-style class contains call for super method

# PyCompatibilityInspection
INSP.NAME.compatibility=Code compatibility inspection

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=Unnecessary backslash

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=Single quoted docstring
INSP.message.single.quoted.docstring=Triple double-quoted strings should be used for docstrings.

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=Missed call to __init__ of super class
INSP.missing.super.constructor.message=Call to __init__ of super class is missed

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=Function call can be replaced with set literal

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=Class specific decorator on method outside class

# PyPackageRequirementsInspection
INSP.NAME.requirements=Package requirements

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=Method may be static
INSP.method.may.be.static=Method <code>#ref</code> may be 'static'

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=Class has no __init__ method
INSP.class.has.no.init=Class has no __init__ method
INSP.parent.$0.has.no.init=Parent ''{0}'' has no __init__ method

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=Assigning function call that doesn't return anything (None)
INSP.none.function.assignment=Function ''{0}'' doesn''t return anything

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=Global variable is undefined at the module level
INSP.NAME.global.$0.undefined=Global variable ''{0}'' is undefined at the module level

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter.display.name=Assignment to 'for' loop or 'with' statement parameter
INSP.NAME.assignment.to.loop.or.with.parameter.display.message=Variable ''{0}'' already declared in ''for'' loop or ''with'' statement above

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=Coroutine ''{0}'' is not awaited

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=Checks that functions decorated by pytest parametrize have correct arguments

# PyHighlightingAnnotator
INSP.python.trailing.suffix.not.support=Python does not support a trailing ''{0}''

INSP.abstract.class.set.as.metaclass=Set ''{0}'' as metaclass
INSP.abstract.class.add.to.superclasses=Add ''{0}'' to superclasses
INSP.compatibility.this.syntax.available.only.since.py3=This syntax available only since py3
INSP.compatibility.check.for.compatibility.with.python.versions=Check for compatibility with python versions:
INSP.docstring.types.fix.docstring=Fix docstring
INSP.docstring.types.change.type=Change {0} type from {1} to {2}
INSP.interpreter.configure.python.interpreter=Configure Python interpreter
INSP.interpreter.interpreter.settings=Interpreter settings
INSP.interpreter.use.interpreter=Use {0}
INSP.interpreter.use.suggested.interpreter=Use suggested interpreter
INSP.mandatory.encoding.encoding.comment.format=Encoding comment format:
INSP.mandatory.encoding.select.default.encoding=Select default encoding: 
INSP.mandatory.encoding.no.encoding.specified.for.file=No encoding specified for file
INSP.method.parameters.metaclass.method.first.argument.name=Metaclass method first argument name
INSP.missing.type.hints.add.type.hints=Add type hints
INSP.missing.type.hints.add.type.hints.for=Add type hints for ''{0}''
INSP.missing.type.hints.only.when.types.are.known.collected.from.run.time.or.inferred=Only when types are known(collected from run-time or inferred)
form.debugger.save.call.signatures=Save call signatures
INSP.package.requirements.requirements.have.been.ignored=Requirements have been ignored
INSP.package.requirements.requirement.has.been.ignored=''{0}'' has been ignored
INSP.package.requirements.add.import=Add import
INSP.package.requirements.administrator.privileges.required=Administrator Privileges Required
INSP.package.requirements.administrator.privileges.required.description=\
  Installing packages into ''{0}'' requires administrator privileges.\n\n\
  Configure a per-project virtual environment as your project interpreter\n\
  to avoid installing packages to a protected area of the file system.
INSP.package.requirements.administrator.privileges.required.button.configure=Configure
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Install Anyway
INSP.pep8.ignore.base.class=Ignore base class
INSP.pep8.ignore.method.names.for.descendants.of.class=Ignore method names for descendants of class
INSP.protected.member.ignore.annotations=Ignore annotations
INSP.protected.member.ignore.test.functions=Ignore test functions
INSP.shadowing.builtins.ignore.shadowed.built.in.name=Ignore shadowed built-in name

INSP.stub.packages.compatibility.ignore=Ignore ''{0}'' compatibility
INSP.arguments.not.declared.but.provided.by.decorator=Following arguments are not declared but provided by decorator: {0}

INSP.abstract.class=Class must implement all abstract methods
INSP.assigning.function.call.that.doesnt.return.anything=Assigning function call that doesn't return anything
INSP.assignment.to.loop.or.with.parameter=Assignment to 'for' loop or 'with' statement parameter
INSP.async.call=Coroutine is not awaited
INSP.attribute.outside.init=Instance attribute defined outside __init__
INSP.calling.non.callable=Trying to call a non-callable object
INSP.dataclass.definition.and.usages=Dataclass definition and usages
INSP.deprecated.function.class.or.module=Deprecated function, class or module
INSP.dunder.slots=Definition of __slots__ in a class
INSP.final.classes.methods.and.variables=Final classes, methods and variables
INSP.global.undefined=Global variable is undefined at the module level
INSP.inconsistent.indentation=Inconsistent indentation
INSP.mandatory.encoding=No encoding specified for file
INSP.missing.type.hints=Missing type hinting for function definition
INSP.named.tuple=Namedtuple definition
INSP.overloads.in.regular.python.files=Overloads in regular Python files
INSP.pep8.naming=PEP 8 naming convention violation
INSP.pep8.coding.style.violation=PEP 8 coding style violation
INSP.protected.member=Access to a protected member of a class or a module
INSP.protocol.definition.and.usages=Protocol definition and usages
INSP.shadowing.builtins=Shadowing built-ins
INSP.shadowing.names=Shadowing names from outer scopes
INSP.stub.packages.compatibility=Stub packages compatibility inspection
INSP.stub.packages=Stub packages advertiser
INSP.type.checker=Type checker
INSP.type.hints=Type hints definitions and usages
INSP.typed.dict=TypedDict definition and usages

# Refactoring
refactoring.will.not.be.accessible=Member, you are trying to move depends on ''{0}'' which will not be accessible after this refactoring
refactoring.error.file.exists=File "{0}" already exists
refactoring.error.directory.exists=Directory "{0}" already exists

# introduce
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)

# introduce variable
refactoring.introduce.variable.dialog.title=Extract Variable
refactoring.introduce.variable.scope.error=Name clashes with existing variable or parameter

# introduce constant
refactoring.introduce.constant.dialog.title=Extract Constant
refactoring.introduce.constant.scope.error=Name is already declared in scope

# introduce parameter
refactoring.introduce.parameter.dialog.title=Extract Parameter

# pull up
refactoring.pull.up.dialog.title=Pull members up to
refactoring.pull.up.dialog.move.members.to.class=Move members to class
refactoring.pull.up.dialog.members.to.be.moved=Following members would be moved
refactoring.pull.up.error.cannot.perform.refactoring.using.selected.elements=Cannot perform pull member up using selected element(s)
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=Cannot perform pull member up: not inside the class
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=Class {0} has no super classes or none of them could be used for refactoring

# push down
refactoring.push.down.dialog.title=Push members down from
refactoring.push.down.error.cannot.perform.refactoring.using.selected.elements=Cannot perform push member down using selected element(s)
refactoring.push.down.error.cannot.perform.refactoring.not.inside.class=Cannot perform pull member down: not inside the class

# inline
refactoring.inline.local.multiassignment=Definition is in multi-assign

# inline function
refactoring.inline.function.title=Inline Function
refactoring.inline.this.only=Inline this invocation only and keep the declaration
refactoring.inline.function=Inline function {0}
refactoring.inline.method=Inline method {0}
refactoring.inline.all.keep.declaration=Inline all invocations and keep the declaration
refactoring.inline.all.remove.declaration=Inline all invocations and remove the declaration
refactoring.inline.function.is.decorator=Function {0} is used as a decorator and cannot be inlined. Function definition will not be removed
refactoring.inline.function.is.reference=Function {0} is used as a reference and cannot be inlined. Function definition will not be removed
refactoring.inline.function.uses.unpacking=Function {0} uses argument unpacking and cannot be inlined. Function definition will not be removed
refactoring.inline.function.generator=Cannot inline generators
refactoring.inline.function.async=Cannot inline async functions
refactoring.inline.function.constructor=Cannot inline constructor calls
refactoring.inline.function.builtin=Cannot inline builtin functions
refactoring.inline.function.special.method=Cannot inline special methods
refactoring.inline.function.skeleton.only=Cannot inline function from binary module
refactoring.inline.function.decorator=Cannot inline functions with decorators
refactoring.inline.function.self.referrent=Cannot inline functions that reference themselves
refactoring.inline.function.star=Cannot inline functions with * arguments
refactoring.inline.function.overrides.method=Cannot inline methods that override other methods
refactoring.inline.function.is.overridden=Cannot inline overridden methods
refactoring.inline.function.global=Cannot inline functions with global variables
refactoring.inline.function.nonlocal=Cannot inline functions with nonlocals variables
refactoring.inline.function.nested=Cannot inline functions with another function declaration
refactoring.inline.function.interrupts.flow=Cannot inline functions that interrupt control flow

# extract method
refactoring.extract.method=Extract method
refactoring.extract.method.error.bad.selection=Cannot perform extract method using selected element(s)
refactoring.extract.method.error.name.clash=Method name clashes with already existing name
refactoring.extract.method.error.returns=Cannot extract method with return instructions inside code fragment
refactoring.extract.method.error.local.variable.modifications=Cannot perform refactoring from expression with local variable modifications inside code fragment
refactoring.extract.method.error.local.variable.modifications.and.returns=Cannot perform refactoring from expression with local variables modifications and return instructions inside code fragment
refactoring.extract.method.error.empty.fragment=Cannot perform refactoring from empty code fragment

refactoring.extract.method.error.class.level=Cannot perform refactoring at class level

# extract superclass
refactoring.extract.super.target.path.outside.roots=Target directory is outside the project. Must be within content roots
refactoring.extract.super.target.class.already.exists=Class ''{0}'' already exists in this module
refactoring.extract.super.name.0.must.be.ident=Name ''{0}'' is invalid. Must be a valid Python identifier
refactoring.extract.super.class.no.members.allowed=None of members could be extracted

# move
refactoring.move.choose.destination.file.title=Choose Destination File
refactoring.move.error.destination.file.contains.class.$0=Destination file already contains class named ''{0}''
refactoring.move.error.destination.file.contains.function.$0=Destination file already contains function named ''{0}''
refactoring.move.error.destination.file.contains.global.variable.$0=Destination file already contains global variable named ''{0}''
refactoring.move.error.cannot.use.module.name.$0=Cannot use module name ''{0}'' in imports

# move module members (top-level)
refactoring.move.module.members=Move module members
refactoring.move.module.members.dialog.title=Move Module Members
refactoring.move.module.members.dialog.table.title=Bulk &move
refactoring.move.module.members.dialog.description.class=Move class {0}
refactoring.move.module.members.dialog.description.function=Move function {0}
refactoring.move.module.members.dialog.description.variable=Move global variable {0}
refactoring.move.module.members.dialog.description.selection=Move selected elements
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=Cannot place elements into a non-Python file
refactoring.move.module.members.error.selection=Cannot perform refactoring using selected element(s)

# Make function top-level
refactoring.make.method.top.level.dialog.title=Make Method Top-Level
refactoring.make.method.top.level.dialog.description=Move method {0} to top-level

refactoring.make.local.function.top.level.dialog.title=Make Local Function Top-Level
refactoring.make.local.function.top.level.dialog.description=Move local function {0} to top-level

refactoring.make.function.top.level.error.nonlocal.writes=Cannot move function with nonlocal writes
refactoring.make.function.top.level.error.self.reads=Cannot move function that contains usages of "self" parameter from outer scope
refactoring.make.function.top.level.error.outer.scope.reads=Cannon move method that references names from the outer scope
refactoring.make.function.top.level.error.private.attributes=Cannot move method that references private instance attributes
refactoring.make.function.top.level.error.attribute.writes=Cannot move method that writes to instance attributes
refactoring.make.function.top.level.error.method.calls=Cannot move method that calls other methods of the same class
refactoring.make.function.top.level.error.special.usage.of.self=Cannot move method that contains special usages of "self" parameter



#change signature
refactoring.change.signature.usage.view.declarations.header=Functions to be refactored
refactoring.change.signature.dialog.validation.name.defined=Name is already defined in scope
refactoring.change.signature.dialog.validation.function.name=Incorrect function name
refactoring.change.signature.dialog.validation.parameter.name=Incorrect parameter name
refactoring.change.signature.dialog.validation.multiple.star=Multiple * arguments are not allowed
refactoring.change.signature.dialog.validation.multiple.double.star=Multiple ** arguments are not allowed
refactoring.change.signature.dialog.validation.default.missing=Default value is missing
refactoring.change.signature.dialog.validation.parameter.missing=Parameter name is missing
refactoring.change.signature.dialog.default.value.checkbox=Use default value in signature:
refactoring.change.signature.dialog.name.label=Name:
refactoring.change.signature.find.usages.of.base.class=Method {0} of class {1}\noverrides method of class {2}.\nDo you want to refactor the base method?
refactoring.change.signature.error.wrong.caret.position.method.name=The caret should be positioned at the name of the method to be refactored
refactoring.change.signature.error.lambda.call=Caret is positioned on lambda call
refactoring.change.signature.error.tuple.parameters=Function contains tuple parameters
refactoring.change.signature.error.not.under.source.root=Function is not under the source root

# convert module to package
refactoring.convert.module.to.package.title=Convert Module to Package

# convert module
refactoring.convert.package.to.module.title=Convert Module to Package
refactoring.convert.package.to.module.error.not.empty.package=Package "{0}" is not empty

refactoring.occurrences.count={0} ({1} occurrences)
refactoring.introduce.field.setup.method=setUp() method
refactoring.introduce.field.cannot.be.used.in.static.methods=Introduce Field refactoring cannot be used in static methods
refactoring.introduce.field.not.in.class=Cannot introduce field: not in class
refactoring.rename.containing.file.with.the.following.name.to=Rename containing file with the following name to: 
refactoring.rename.containing.file.title=Rename Containing File
refactoring.rename.containing.file=Rename containing file
refactoring.rename.parameter.in.hierarchy.to=Rename parameter in hierarchy to:
refactoring.rename.parameters.title=Rename Parameters
refactoring.rename.parameters.in.hierarchy=Rename parameters in hierarchy
refactoring.rename=Rename
refactoring.rename.not.valid.identifier=The name ''{0}'' is not a valid Python identifier. Cannot update import statement in ''{1}''
refactoring.rename.inheritor.classes.with.the.following.names.to=Rename inheritor classes with the following names to:
refactoring.rename.inheritors.title=Rename Inheritors
refactoring.rename.inheritors=Rename inheritors

### Annotators ###
ANN.default.except.must.be.last=default 'except:' must be last

ANN.$0.both.global.and.param=Name ''{0}'' used both as a parameter and as a global

ANN.assignment.to.keyword=assignment to keyword
ANN.cannot.assign.to.debug=cannot assign to __debug__
ANN.unparenthesized.assignment.expressions.are.prohibited.0=Unparenthesized assignment expressions are prohibited {0}
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=Assignment expressions within a comprehension cannot be used in a class body
ANN.ignore.errors.like.this=Ignore errors like this
ANN.function.cannot.be.async=function \"{0}\" cannot be async
ANN.python.does.not.support.yield.from.inside.async.functions=Python does not support 'yield from' inside async functions
ANN.yield.outside.of.function='yield' outside of function
ANN.non.empty.return.inside.asynchronous.generator=non-empty 'return' inside asynchronous generator
ANN.return.outside.of.function='return' outside of function
ANN.can.t.use.starred.expression.here=Can't use starred expression here
ANN.illegal.target.for.variable.annotation=Illegal target for variable annotation
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=Variable annotation cannot be combined with tuple unpacking
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=Variable annotation cannot be used in assignment with multiple targets

python.run.select.script=Select Script
python.run.configuration=Python run configuration
python.run.python=Python

testing.form.inspect.only.subclasses.of.unittest.testcase=Inspect only subclasses of unittest.TestCase

runcfg.tests.cant_rerun=Can't rerun tests since test IDs can't be resolved. Try to delete run configuration, and create new one using right click.
runcfg.tests.empty_suite=Empty suite

### doctest run conf
runcfg.doctest.display_name=Doctests
runcfg.doctest.description=Python's doctests run configuration

### nosetests run conf
runcfg.nosetests.display_name=Nosetests
runcfg.nosetests.description=Python's nosetests run configuration

### pytest run conf
runcfg.pytest.display_name=pytest
runcfg.pytest.description=pytest run configuration
runcfg.pytest.target=&Target:
runcfg.pytest.parameters=&Options:
runcfg.pytest.keywords=&Keywords:

### trial run conf
runcfg.trial.display_name=Twisted Trial

### test run configuration
runcfg.test.display_name=Python tests
runcfg.test.description=Python frameworks supported by PyCharm

### tox
runcfg.tox.runner=tox runner
runcfg.tox=tox

### unittest run configuration
runcfg.unittest.display_name=Unittests
runcfg.unittest.description=Python's unittest run configuration
runcfg.unittest.no_script_name=Please specify script name
runcfg.unittest.no_module_name=Please specify module qualified name
runcfg.unittest.no_class_name=Please specify class name
runcfg.unittest.no_method_name=Please specify method name
runcfg.unittest.no_folder_name=Please specify folder with tests
runcfg.unittest.incorrect.script=Test script name should start with "test" prefix
runcfg.unittest.dlg.tests_group_title=Tests:
runcfg.unittest.dlg.test_script_label=Script:
runcfg.unittest.dlg.class_label=Class:
runcfg.unittest.dlg.method_label=Method:
runcfg.unittest.dlg.function_label=Function:
runcfg.unittest.dlg.folder_path=Folder:
runcfg.unittest.dlg.test_type_title=Test:
runcfg.unittest.dlg.all_in_folder_title=All in folder
runcfg.unittest.dlg.all_in_script_title=Script
runcfg.unittest.dlg.test_class_title=Class
runcfg.unittest.dlg.test_method_title=Method
runcfg.unittest.dlg.folder_title=Tests folder:
runcfg.unittest.no_valid_sdk=Please select a valid Python interpreter
runcfg.unittest.no_module_sdk=Please select a module with a valid Python SDK
runcfg.unittest.no_sdk=Please specify a Python SDK
runcfg.unittest.dlg.select.folder.path=Select folder path:
runcfg.unittest.dlg.select.script.path=Select script path:
runcfg.unittest.dlg.interpreter_options_title=Interpreter options:
runcfg.unittest.dlg.messages.working.dir=Working directory:
runcfg.labels.script_parameters=&Parameters:
runcfg.labels.script=&Script:
runcfg.labels.environment_variables=&Environment variables:
runcfg.labels.interpreter=&Use specified interpreter:
runcfg.labels.use.sdk.of.module=Use SDK of module:
runcfg.labels.interpreter_options=Interpreter &options:
runcfg.labels.working_directory=&Working directory:
runcfg.captions.script_parameters_dialog=Enter script parameters
runcfg.captions.interpreter_options_dialog=Enter interpreter options
runcfg.labels.python.interpreter=&Python interpreter:
runcfg.labels.add.content.roots.to.pythonpath=Add content roots to PYTHONPATH
runcfg.labels.add.source.roots.to.pythonpath=Add source roots to PYTHONPATH
runcfg.labels.path.mappings=Path mappings
runcfg.labels.project=Pro&ject:
runcfg.labels.script.path=Script path
runcfg.labels.module.name=Module name
runcfg.labels.execution=Execution
sdk.error.invalid.interpreter.name.$0=Invalid Python interpreter name ''{0}''!
sdk.select.path=Select Python Interpreter
runcfg.unittest.dlg.pattern=Pattern:

runcfg.testing.no.test.framework=No {0} runner found in selected interpreter

# Consoles messages
python.console=Python Console
python.console.history.root=Python Consoles
python.console.run.anything.provider=Runs Python Console

# UI messages
MSG.title.bad.sdk=Invalid Python SDK
MSG.cant.setup.sdk.$0=Cannot set up a python SDK \nat {0}.\nThe SDK seems invalid.


#Buildout
buildout=Buildout
buildout.unresolved.part.inspection=Buildout config unresolved part inspection
buildout.unresolved.part.inspection.msg=Unresolved part reference
buildout.configurable.enable.buildout.support.checkbox.text=&Enable buildout support
runcfg.unittest.dlg.test_function_title=Function
runcfg.unittest.dlg.keywords=Keywords:
run.configuration.remote.debug.name=Python Remote Debug
run.configuration.remote.debug.visible.name=Python Debug Server
run.configuration.type.description=Starts server for remote debug
run.configuration.show.command.line.action.name=Show Python Prompt

unable.to.stop=Currently running process can't be stopped. Kill it manually first.

#Debug

debug.popup.title.step.into.function=Step Into Function

debug.notification.group=Python Debugger
debug.notification.title.connection.failed=Connection to Python debugger failed

remote.debug.info=Info
remote.debug.server.hint=Launch this debug configuration to start the Debug Server.
remote.debug.server.hint1.5=Update your script:
remote.debug.server.hint2=1. Add pydevd-pycharm.egg from the PyCharm installation to the Python path or execute:
remote.debug.server.hint3=pip install pydevd-pycharm
remote.debug.server.hint4=2. Add the following command to connect to the Debug Server:
remote.debug.settings=Settings
remote.debug.remote.host=Remote host
remote.debug.port=Port:
remote.debug.use.path.mapping=Use path mapping
remote.debug.remote.root.folder=Remote paths prefix:
remote.debug.local.root.folder=Local paths prefix:
remote.debug.local.host=IDE host name:
remote.debug.redirect.output=Redirect output to console
remote.debug.suspend.on.connect=Suspend after connect

python.sdk.getting.remote.interpreter.version=Getting Remote Interpreter Version
python.sdk.directory.macro.description=The directory containing the Python interpreter selected for the project
python.sdk.run.wait=Wait...
python.sdk.scanning.installed.packages=Scanning installed packages...
python.sdk.updating.skeletons=Updating skeletons...
python.sdk.updating.python.paths=Updating Python Paths
python.sdk.unpacking.pre.generated.skeletons=Unpacking pre-generated skeletons...
python.sdk.popup.title=Project Interpreter
python.sdk.popup.interpreter.settings=Interpreter Settings...
python.sdk.popup.add.interpreter=Add Interpreter...
python.sdk.switch.to=Switch to {0}
python.sdk.installing=Installing {0}
python.sdk.downloading=Downloading {0}
python.sdk.running=Running {0}
python.sdk.installing.windows.warning=Windows may require your approval to install Python. Please check the taskbar.
python.sdk.select.conda.path.title=Select Path to Conda Executable
python.sdk.conda.path=Conda executable:
python.sdk.select.location.for.conda.title=Select Location for Conda Environment
python.sdk.creating.conda.environment.title=Creating Conda Environment
python.sdk.select.location.for.virtualenv.title=Select Location for Virtual Environment
python.sdk.creating.virtualenv.title=Creating Virtual Environment
python.sdk.add.python.interpreter.title=Add Python Interpreter
python.sdk.python.interpreter.title.0=Project Interpreter: {0}
python.sdk.new.environment.kind=New {0} environment
python.sdk.next=Next
python.sdk.previous=Previous
python.sdk.finish=Finish
python.sdk.interpreter.field.is.empty=Interpreter field is empty
python.sdk.setting.up.pipenv.title=Setting Up Pipenv Environment
python.sdk.install.requirements.from.pipenv.lock=Install requirements from Pipfile.lock
python.sdk.pipenv.executable.not.found=Pipenv executable is not found
python.sdk.pipenv.executable=Pipenv executable:
python.sdk.pipenv.associated.object=Associated {0}:
python.sdk.file.not.found=File {0} is not found
python.sdk.cannot.execute=Cannot execute {0}
python.sdk.pipenv.has.been.selected=Pipenv interpreter has been already added, select ''{0}'' in your interpreters list
python.sdk.there.is.no.interpreter=No interpreter
python.sdk.no.interpreter.configured.warning=No Python interpreter configured for the project
python.sdk.no.interpreter.configured.owner=No Python interpreter configured for the {0}
python.sdk.no.interpreter.selection=No Python interpreter selected
python.sdk.choose.valid.interpreter=Choose valid Python interpreter
python.sdk.common.options.environment=Environment
python.sdk.rendering.project.default=Project Default
python.sdk.rendering.project.default.0=Project Default ({0})
python.sdk.failed.to.install.title=Failed To Install {0}
python.sdk.installation.has.been.cancelled.title={0} Installation Has Been Cancelled
python.sdk.failed.to.create.interpreter.title=Failed To Create Interpreter

# SDK / skeletons
sdk.some.skeletons.failed=Some skeletons failed to generate
sdk.error.dialog.problems=Skeleton Generation Problems
sdk.gen.cleaning.up=Cleaning up skeletons...
sdk.gen.launching.generator=Launching skeleton generator...
sdk.gen.reloading=Reloading generated skeletons...
sdk.gen.unpacking.prebuilt=Unpacking prebuilt skeletons...
sdk.gen.updating.interpreter=Updating Python Interpreter
sdk.scanning.installed.packages=Scanning Installed Packages
sdk.gen.stubs.for.binary.modules=Generate stubs for binary module {0}
sdk.gen.failed.notification.title=Couldn't refresh skeletons for remote interpreter

# Active SDK configurable and related dialogs
active.sdk.dialog.show.all.item=Show All...
active.sdk.dialog.project.interpreter=Project Interpreter:
active.sdk.dialog.project.interpreter.path.mappings=Path mappings:
active.sdk.dialog.project.interpreter.path.mappings.default.project.error=Open or create project to configure mappings

sdk.details.step.add=Add...
sdk.details.step.create.virtual.env=Create VirtualEnv
sdk.details.step.create.conda.env=Create Conda Env
sdk.details.step.show.all=Show All...

sdk.details.dialog.title=Project Interpreters
sdk.details.dialog.hide.all.virtual.envs=Hide virtual environments associated with other projects
sdk.details.dialog.show.interpreter.paths=Show paths for the selected interpreter
sdk.details.dialog.error.duplicate.name=Please specify a unique name for the interpreter

sdk.edit.dialog.title=Edit Python Interpreter
sdk.edit.dialog.associate.virtual.env.with.path=Associate this virtual environment with {0}
sdk.edit.dialog.associate.virtual.env.current.project=Associate this environment with current project
sdk.edit.dialog.specify.interpreter.path=Specify Interpreter Path

sdk.paths.dialog.title=Interpreter Paths
sdk.paths.dialog.reload.paths=Reload List of Paths
sdk.paths.dialog.added.by.user.suffix=(added by user)
sdk.paths.dialog.removed.by.user.suffix=(removed by user)

sdk.create.venv.dialog.creating.venv=Creating virtual environment
sdk.create.venv.dialog.make.available.to.all.projects=Make available to all projects
sdk.create.venv.dialog.select.venv.location=Select Location for Virtual Environment
sdk.create.venv.dialog.error.not.empty.directory=Directory is not empty
sdk.create.venv.dialog.error.empty.venv.name=VirtualEnv name can't be empty
sdk.create.venv.dialog.error.empty.venv.location=Destination directory path can't be empty
sdk.create.venv.dialog.error.invalid.directory.name=Invalid directory name
sdk.create.venv.dialog.error.failed.to.create.venv=Failed to Create Virtual Environment

sdk.create.venv.dialog.title=Create Virtual Environment
sdk.create.venv.dialog.label.name=Name:
sdk.create.venv.dialog.label.location=Location:
sdk.create.venv.dialog.label.base.interpreter=Base interpreter:
sdk.create.venv.dialog.label.inherit.global.site.packages=Inherit global site-packages
sdk.create.venv.dialog.error.no.base.interpreter=Select base interpreter

sdk.create.venv.conda.dialog.title=Create Conda Environment
sdk.create.venv.conda.dialog.error.no.python.version=Select python version
sdk.create.venv.conda.dialog.label.location=Location:
sdk.create.venv.conda.dialog.label.python.version=Python version:

# remote interpreters
remote.interpreter.add.title=Add Remote Interpreter
remote.interpreter.configure.title=Configure Remote Python Interpreter
remote.interpreter.configure.path.title=Select Python Interpreter
remote.interpreter.configure.temp.files.path.title=Select Folder for PyCharm Helpers
remote.interpreter.default.interpreter.path=/usr/bin/python
remote.interpreter.docker.default.interpreter.path=python
remote.interpreter.unspecified.interpreter.path=Specify Python interpreter path
remote.interpreter.unspecified.temp.files.path=Specify path for PyCharm helpers
remote.interpreter.configure.path.label=Python interpreter path:
remote.interpreter.configure.temp.files.path.label=PyCharm helpers path:
remote.interpreter.error.plugin.missing=The Remote Hosts Access plugin is missing. Please enable the plugin in {0}.
remote.interpreter.configure.ssh.run_as_root_via_sudo.checkbox=Execute code using this interpreter with root privileges via sudo
remote.interpreter.configure.ssh.run_as_root_via_sudo.help=Sudo will be invoked only for launching remote interpreters through SSH connections. Files will be copied to the remote server with user's privileges.
remote.interpreter.unsupported.python.sdk.type=Unsupported Python SDK type
remote.interpreter.support.is.not.available=Support for {0} is not available.\nPlease check the corresponding plugin.
remote.interpreter.remote.server.permissions=Failed to browse remote server. Make sure you have permissions.

# CommandLine
commandLine.inspection.name=Command-line inspection
commandLine.inspection.badCommand=Bad or unknown command. make sure this command really exists.
commandLine.inspection.badOption=Bad or unknown option. make sure this option really exists.
commandLine.inspection.badArgument=Argument can't have this value. use autocompletion to check list of possible values.
commandLine.inspection.excessArgument=Excess argument or argument is not possible here
# What to display if argument is available here, but no name provided
commandLine.argumentHint.defaultName=arguments
# What to display of user entered junk
commandLine.commandNotFound={0}: command not found

# Window with actions
# "X" button title
windowWithActions.closeWindow=Close window
# "Stop" button title
windowWithActions.stopProcess=Stop currently running process

formatter.imports.panel.title=Imports
formatter.imports.panel.optimize.imports=Optimize Imports
formatter.imports.panel.sort.imports=Sort import statements
formatter.imports.panel.sort.names.in.from.imports=Sort imported names in "from" imports
formatter.imports.panel.from.imports.structure.title=Structure of "from" imports
formatter.imports.panel.from.imports.leave.as.is=Leave as is
formatter.imports.panel.from.imports.join.with.same.source=Join imports with the same source
formatter.imports.panel.from.imports.always.split=Always split imports
formatter.imports.panel.sort.by.type=Sort plain and "from" imports separately within a group
formatter.imports.panel.sort.case.insensitively=Sort case-insensitively

formatter.panel.dict.alignment.label=Dict alignment:
formatter.panel.add.trailing.line.feed=Add line feed at the end of file

formatter.panel.use.continuation.indent.for.title=Use continuation indent for
formatter.panel.use.continuation.indent.for.arguments=Method call arguments
formatter.panel.use.continuation.indent.for.collection.literals=Collections and comprehensions

formatter.left.bracket = Left bracket
formatter.around.eq.in.named.parameter = Around = in named parameter
formatter.around.eq.in.keyword.argument = Around = in keyword argument
formatter.braces = Braces
formatter.before.backslash = Before '\\'
formatter.before.hash = Before '#'
formatter.after.hash = After '#'
formatter.around.top.level.imports = After top-level imports:
formatter.after.local.imports=After local imports:
formatter.before.first.method=Before the first method:
formatter.around.top.level.classes.and.function=Around top-level classes and functions:
formatter.around.multiplicative.operators=Multiplicative operators (*, @, /, %)
formatter.around.power.operator=Power operator (**)
formatter.single.clause.statements=Single-clause statements
formatter.multi.clause.statements=Multi-clause statements
formatter.force.new.line.after.colon=Force new line after colon
formatter.align.when.multiline=Align when multiline
formatter.collections.and.comprehensions=Collections and Comprehensions
formatter.from.import.statements="From" Import Statements
formatter.from.import.statements.force.parentheses.if.multiline=Force parentheses if multiline
formatter.from.import.statements.force.comma.if.multline=Force trailing comma if multiline
formatter.dictionary.literals=Dictionary literals
formatter.hang.closing.brackets=Hang closing brackets

smartKeys.insert.backslash.in.statement.on.enter=Insert backslash when pressing Enter inside a statement
smartKeys.insert.self.in.method=Insert 'self' when defining a method
smartKeys.insert.type.placeholder.in.docstring.stub=Insert type placeholders in the documentation comment stub

show.expression.type.no.expression.found=No expression found
runcfg.labels.module=Module:
remote.interpreter.wsl.default.interpreter.path=/usr/bin/python
remote.interpreter.failed.to.obtain.credentials=Failed to obtain connection credentials for Python SDK {0}

action.SetNextStatement.text=&Jump To Cursor
action.SetNextStatement.description=Jump to the line where the caret is
action.StepIntoMyCode.text=Step Into My Code
action.StepIntoMyCode.description=Step to the next line executed ignoring libraries
action.PyConvertPackageToModuleAction.text=Convert to Python Module
action.PyConvertPackageToModuleAction.description=Create module with the same name and move content of __init__.py to that module
action.PyConvertModuleToPackage.text=Convert to Python Package
action.PyConvertModuleToPackage.description=Create package with the same name and move content of the module to its __init__.py
action.PyDebugger.ViewAsGroup.text=View as
action.PyDebugger.ViewArray.text=View as Array
action.PythonGenerateDictionaries.text=Generate Python Spellchecker Dictionaries
group.PyPackagingMenu.text=Packaging
action.CleanPyc.text=Clean Python Compiled Files
action.CleanPyc.description=Delete compiled bytecode files in selected directory and its subdirectories
action.PySyncPythonRequirements.text=Sync Python Requirements...
action.PySyncPythonRequirements.description=Synchronize Python requirements file with the packages that are used in project
action.CompuleQrc.text=Compile .qrc file
action.NewPythonPackage.text=Python Package
action.NewPythonPackage.description=Create a new directory and __init__.py inside it
action.PyConsoleRenameAction.text=Rename Console
action.ExecuteInPyConsoleAction.text=Execute selection in console
action.ExecuteInPyConsoleAction.description=Executes selected code fragment in Python/Django console
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.text=Python or Debug Console
action.com.jetbrains.python.console.RunPythonOrDebugConsoleAction.description=Allows to quickly run Python Console or Debug Console if debug session is running
action.ForceStepInto.text=Fo_rce Step Into
action.ForceStepInto.description=Step into, ignore stepping filters for libraries, constructors, etc.
configurable.Tab.display.name=Buildout
configurable.PyConsoleOptionsConfigurable.display.name=Console
configurable.PyConsoleOptionsConfigurable.child.display.name=Python Console
configurable.BuildoutConfigurable.display.name=Buildout
configurable.BuildoutModulesConfigurable.display.name=Buildout Support
configurable.PySmartKeysOptions.display.name=Python
configurable.PyContentEntriesModuleConfigurable.display.name=Project Structure
configurable.PythonContentEntriesConfigurable.display.name=Project Structure
configurable.PyActiveSdkModuleConfigurable.display.name=Project Interpreter
configurable.PyDependenciesConfigurable.display.name=Project Dependencies
configurable.PyIntegratedToolsConfigurable.display.name=Python Integrated Tools
configurable.PyIntegratedToolsModulesConfigurable.display.name=Python Integrated Tools
configurable.PyScientificConfigurable.display.name=Python Scientific
configurable.PythonSdkEditorTab.display.name=Python SDK
configurable.PyDebuggerConfigurable.display.name=Python Debugger
configurable.PyActiveSdkModuleConfigurable.python.interpreter.display.name=Python Interpreter
configurable.PyTemplateLanguageModulesConfigurable.template.languages.display.name=Template Languages
configurable.PyTemplateLanguageModulesConfigurable.python.template.languages.display.name=Python Template Languages
flask.name=Flask
settings.default.remote.interpreter=Default Python Remote Interpreter
action.DumbAware.PydevConsoleRunnerImpl.text.stop.console=Stop Console
action.DumbAware.PydevConsoleRunnerImpl.description.stop.python.console=Stop Python Console
action.DumbAware.ConcurrencyToolWindowPanel.text.stop.process=Stop process
action.DumbAware.ConcurrencyToolWindowPanel.description.stop.process=Stop process
action.AnActionButton.text.use.conda.package.manager=Use Conda Package Manager
action.AnActionButton.text.show.early.releases=Show Early Releases
action.PyManagePackages.text=Manage Python Packages...
action.RunPythonToolwindowAction.text=Python Console

# qt actions
qt.error.failed.run.qt.designer=Failed to run Qt Designer: {0}
qt.qrc.compiler.select.output.path=Select Output Path:
qt.qrc.compile.files=Compile {0} .Qrc Files
qt.qrc.compile=Compile {0}
qt.compile.qrc.file=Compile .Qrc File
qt.run.error=Error running {0}: {1}
qt.cannot.find.pyrcc4.or.pysidercc=Could not find pyrcc4 or pyside-rcc for selected Python interpreter
qt.run.designer.error=Error

python.module.name=Python Module
python.module.description=Python modules are used for developing <b>Python</b> applications.
python.module.description.extended=Supported technologies include <b>Django, Google App Engine, Mako, Jinja2</b> and others.

action.create.python.file.title=Python File
action.create.python.file.description=Creates a Python file from the specified template
acton.run.file.in.python.console.title=Run File in Python Console
action.run.file.in.python.console.description=Run current file in Python console
action.cleaning.up.pyc.files=Cleaning up .Pyc Files...

buildout.facet.title=Buildout Support
buildout.configurable.choose.a.buildout.script=Choose a Buildout Script
buildout.configurable.select.the.target.script=Select the target script that will invoke your code
buildout.color.comment=Comment
buildout.color.key.value.separator=Key value separator
buildout.color.value=Value
buildout.color.key=Key
buildout.color.section.name=Section name
buildout.config=Buildout config
buildout.config.language=Buildout config
buildout.config.script.name.validation.error.message=Please specify buildout script
buildout.config.script.file.invalid.message=Invalid script file ''{0}''

code.insight.select.methods.to.override=Select Methods to Override
code.insight.select.methods.to.implement=Select Methods to Implement
code.insight.create.test=Create test
code.insight.select.target.directory=Select target directory
code.insight.encoding.comment.format=Encoding comment format:
code.insight.select.default.encoding=Select default encoding: 
code.insight.type.hints.are.not.installed=Type hints are not installed
code.insight.install.type.hints.content=They could make code insight better.
code.insight.install.type.hints.action=Install stub packages
code.insight.ignore.type.hints=Ignore
code.insight.ignore.packages.qfix=Ignore {0,choice, 1#package|2#packages}
configurable.pipenv.auto.detected=Auto-detected: {0}
configurable.choose.path.to.the.package.requirements.file=Choose path to the package requirements file:
configurable.choose.working.directory=Please choose working directory:
configurable.select.working.directory=Select Working Directory

console.waiting.for.repl.response.with.timeout=Waiting for REPL response with {0}s timeout
console.waiting.for.repl.response=Waiting for REPL Response
console.repl.communication=REPL Communication
console.getting.description=Getting Description
console.close.console.communication=Close Console Communication
console.executing.code.in.console=Executing Code in Console...
console.new.console.description=Creates new python console
console.new.console=New Console
console.error.connecting.debugger=Error Connecting Debugger
console.cannot.connect.to.debugger=Can't connect to debugger
console.attach.debugger.description=Enables tracing of code executed in console
console.attach.debugger=Attach Debugger
console.restarting.console=Restarting Console
console.command.executor=Python Console Command Executor
connecting.to.console.progress=Connecting to console...
connecting.to.console.title=Connecting to Console
console.show.variables.title=Show Variables
console.show.variables.description=Shows active console variables

compile.cython.extensions.title=Compile Cython Extensions
compile.cython.extensions.help=How does it work
compile.cython.extensions.install=Install
compile.cython.extensions.notification=Python Debugger Extension Available

create.python.file.action.new.python.file=New Python file
create.python.file.action.python.file=Python file
create.python.file.action.python.unit.test=Python unit test
create.python.file.action.python.stub=Python stub
create.python.file.script.action=Create Python script {0}

debugger.attach.to.process.filter.names=<html>For <b>Attach To Process</b> show processes with names containing:</html>
debugger.watch.return.values.description=Enables watching executed functions return values
debugger.exception.breakpoint.ignore.library.files=Ignore library files
debugger.exception.breakpoint.on.raise=On raise
debugger.exception.breakpoint.on.termination=On termination
debugger.exception.breakpoint.type=Python Exception Breakpoint
debugger.exception.breakpoint.activation.policy=Activation policy
debugger.delete.signature.cache=Delete Cache
debugger.cleaning.signature.cache=Cleaning the Cache of Dynamically Collected Types
debugger.simplified.view.description=Disables watching classes, functions and modules objects
debugger.simplified.view.text=Simplified Variables View
debugger.data.view.colored=Colored
debugger.data.view.close.selected.viewer=Close selected viewer
debugger.data.view.close.viewer=Close Viewer
debugger.data.view.open.new.container.viewer=Open new container viewer
debugger.data.view.view.new.container=View New Container
debugger.data.view.data=Data
debugger.data.view.close=Close
debugger.data.view.resize.automatically=Resize Automatically
debugger.data.view.colored.cells=Colored cells
debugger.numeric.view.as.dataframe=View as DataFrame
debugger.numeric.view.as.array=View as Array
debugger.stepping.filter=Stepping Filter
debugger.stepping.filter.specify.pattern=Specify glob pattern ('*', '?' and '[seq]' allowed, semicolon ';' as name separator):
debugger.stepping.no.script.filters=No script filters configured
debugger.sending.close.message=Sending close message to Python Console...
debugger.waiting.to.finish=Waiting for Python Console process to finish...
debugger.variables.loading.policy=Variables Loading Policy
debugger.variables.loading.synchronously.text=Synchronously
debugger.variables.loading.synchronously.description=Load variable values synchronously
debugger.variables.loading.asynchronously.text=Asynchronously
debugger.variables.loading.asynchronously.description=Load variable values asynchronously
debugger.variables.loading.on.demand.text=On demand
debugger.variables.loading.on.demand.description=Load variable values on demand
debugger.variables.view.loading.timed.out=Loading timed out
debugger.variables.view.switch.to.loading.on.demand=Switch to loading on demand
debugger.variables.view.warning.message=The values of several variables couldn't be loaded  
debugger.exception.breakpoint.select.exception.class=Select Exception Class
debugger.watch.show.return.values=Show Return Values
debugger.data.view.connected.to.python.console=Connected to Python Console
debugger.data.view.connected.to.debug.session=Connected to debug session ''{0}''
debugger.data.view.empty.text=Run Python Console or Debugger to view available data

pydev.console.runner.settings=Settings
pydev.console.runner.error.running.console=Error running console
pydev.console.runner.python.console.debugger=Python Console Debugger
pydev.console.runner.unknown.error=Unknown error
pydev.console.console.process.terminated.with.error=Console process terminated with error:\n{0}{1}
pydev.console.console.process.terminated.with.exit.code=Console process terminated with exit code {0}, output:{1}
pydev.console.couldnt.connect.to.console.process=Couldn't connect to console process.
pydev.console.debugger.connected=\nDebugger connected.\n
pydev.console.couldnt.read.integer.value.from.stream=Couldn't read integer value from stream
pydev.console.python.interpreter.is.not.selected=Python interpreter is not selected. Please setup Python interpreter first.

external.documentation.python.plugin=Python External Documentation
external.documentation.pycharm=External Documentation
external.documentation.edit.documentation.url=Edit Documentation URL
external.documentation.title=Python External Documentation
external.documentation.configure.description=No external documentation URL configured for module {0}.\nWould you like to configure it now?


python.colors.python=Python
python.colors.type.annotation=Type annotation
python.colors.class.definition=Class definition
python.colors.decorator=Decorator
python.colors.built.in.name=Built-in name
python.colors.special.names.usage=Special Names//Usage
python.colors.special.names.definition=Special Names//Definition
python.colors.keyword.argument=Keyword argument
python.colors.parameters.self.parameter=Parameters//'self' parameter
python.colors.parameters.parameter=Parameters//Parameter
python.colors.functions.method.call=Functions//Method call
python.colors.functions.function.call=Functions//Function call
python.colors.functions.function.definition=Functions//Function definition
python.colors.braces.and.operators.dot=Braces and Operators//Dot
python.colors.braces.and.operators.comma=Braces and Operators//Comma
python.colors.braces.and.operators.braces=Braces and Operators//Braces
python.colors.braces.and.operators.brackets=Braces and Operators//Brackets
python.colors.braces.and.operators.parentheses=Braces and Operators//Parentheses
python.colors.braces.and.operators.operation.sign=Braces and Operators//Operation sign
python.colors.docstring.tag=Docstring//Tag
python.colors.docstring.text=Docstring//Text
python.colors.string.f.string.format.specifier.start=String//f-string//Format specifier start
python.colors.string.f.string.type.conversion=String//f-string//Type conversion
python.colors.string.f.string.expression.braces=String//f-string//Expression braces
python.colors.string.escape.sequence.invalid=String//Escape sequence//Invalid
python.colors.string.escape.sequence.valid=String//Escape sequence//Valid
python.colors.string.text.unicode=String//Text (unicode)
python.colors.string.binary.bytes=String//Binary (bytes)
python.colors.line.comment=Line Comment
python.colors.keyword=Keyword
python.colors.number=Number

python.new.project.synchronization.not.configured=Synchronization not Configured
python.new.project.remote.path.not.provided=Remote path not provided
python.new.project.more.settings=Mor&e Settings
python.new.project.install.failed.title=Install {0} Failed

python.project.view.remote.libraries=Remote Libraries
python.project.view.py.skeletons=Binary Skeletons
python.project.view.typeshed.stubs=Typeshed Stubs
python.project.view.user.skeletons.node=Extended Definitions

python.packaging.installing.packaging.tools=Installing packaging tools...
python.packaging.installing.packages=Installing packages...
python.packaging.warning=Warning
python.packaging.create.setup.py=Create setup.py
python.packaging.failed.to.run.task=Failed to run task: {0}
python.packaging.run.setup.py.task=Run setup.py Task...
python.packaging.expand.options=Expand Options >>
python.packaging.collapse.options=<< Collapse Options
python.packaging.run.setup.task.0=Run Setup Task {0}
python.packaging.command.line=Command Line
python.packaging.install=Install
python.packaging.choose.packages.to.install=Choose Packages to Install
python.packaging.removing.conda.channel=Removing Conda Channel
python.packaging.adding.conda.channel=Adding Conda Channel
python.packaging.failed.to.install.packaging.tools.title=Failed to Install Python Packaging Tools

# UI forms

form.qt.compile.qrc.output.file=Output file:
form.buildout.config.set.to.buildout.dir.bin.django.py.for.proper.django.support=Set to <buildout-dir>/bin/django.py for proper Django support 
form.buildout.config.use.paths.from.script=Use paths from &script: 
form.auto.import.from.module.import.name=from <module> import <name>
form.auto.import.import.module.name=import <module>.<name>
form.auto.import.preferred.import.style=Preferred import style:
form.auto.import.python=Python
form.auto.import.auto.import.show.popup=Show import popup
form.create.test.target.directory=Target directory
form.create.test.test.class.name=Test class name
form.create.test.test.file.name=Test file name
form.edit.sdk.associate.this.virtual.environment.with.current.project=&Associate this virtual environment with current project
form.edit.sdk.interpreter.path=&Interpreter path:
form.edit.sdk.label.create.connection.pool.options.name=&Name:
form.edit.sdk.html.href.remove.association=<html><a href=\\"#\\">Remove association</a>
form.integrated.tools.analyze.python.code.in.docstrings=Analyze Python code in docstrings
form.integrated.tools.default.test.runner=Default test runner:
form.integrated.tools.docstring.format=Docstring format:
form.integrated.tools.package.requirements.file=Package requirements file:
form.integrated.tools.path.to.pipenv.executable=Path to Pipenv executable:
form.integrated.tools.render.external.documentation.for.stdlib=Render external documentation for stdlib
form.integrated.tools.sphinx.working.directory=Sphinx working directory:
form.integrated.tools.treat.txt.files.as.restructuredtext=Treat *.txt files as reStructuredText 
form.console.options.always.show.debug.console=Always show debug console
form.console.options.settings.title.system.settings=General settings
form.console.options.show.console.variables.by.default=Show console variables by default
form.console.options.use.existing.console.for.run.with.python.console=Use existing console for "Run with Python Console"
form.console.options.use.ipython.if.available=Use IPython if available
form.console.specific.options.starting.script=Starting script
form.debugger.for.attach.to.process.show.processes.with.names.containing=\ For Attach To Process show processes with names containing:
form.debugger.attach.to.subprocess.automatically.while.debugging=Attach to subprocess automatically while debugging
form.debugger.clear.caches=Clear caches
form.debugger.clear.caches.action=Clear Caches
form.debugger.collect.run.time.types.information.for.code.insight=Collect run-time types information for code insight
form.debugger.gevent.compatible=Gevent compatible
form.debugger.pyqt.compatible=PyQt compatible
form.debugger.remote.interpreter.docker.default.interpreter.path=python
form.data.viewer.current.slice=Current slice.
form.data.viewer.dialog.show.svn.map.table.header.column.format.title=Format
form.data.viewer.format=Format:
form.debugger.stepping.checkbox.text.do.not.step.into.library.scripts=Do not step into library scripts
form.debugger.stepping.do.not.step.into.scripts=Do not step into scripts:
form.debugger.stepping.always.do.smart.step.into=Always do smart step into
form.documentation.entry.insert=&Insert
form.documentation.entry.module.name=&Module Name:
form.documentation.entry.url.path.pattern=&URL/Path Pattern:
form.documentation.entry.available.macros=Available Macros
form.remote.path.remote.project.location=Remote project location:
form.introduce.name=&Name:
form.introduce.field.initialize.in=&Initialize in
form.move.module.members.from=From:
form.move.module.members.to=To:
form.python.run.configuration.emulate.terminal.in.output.console=Emulate terminal in output console
form.python.run.configuration.redirect.input.from=Redirect input from:
form.python.run.configuration.run.with.python.console=Run with Python Console
form.test.shared.target=Target:
form.test.shared.test=Test
form.test.run.configuration.params=Params:
form.test.run.configuration.specify.nosetests.command.line.options=Specify nosetests command line options
form.test.run.configuration.unittest=Unittest
form.pytest.legacy.path.to.a.file.or.directory.that.contains.the.tests.to.be.executed=Path to a file or directory that contains the tests to be executed
form.pytest.legacy.py.tests=py.tests
form.pytest.legacy.specify.py.tests.command.line.options=Specify py.tests command line options
form.pytest.legacy.specify.the.keywords.to.search.for.the.required.tests.k.command.line.option.in.py.tests=Specify the keywords to search for the required tests. -k command line option in py.tests
form.tox.configuration.arguments=Arguments
form.tox.configuration.run.only.environment=Run only environment
form.tox.configuration.runcfg.tox=tox
py.module.dependencies.configurable.list.title=Project depends on these projects:
py.sdk.editor.python.interpreter.label.text=Python Interpreter:
# Python reStructuredText forms
rest.configuration.editor.open.output.file.in.browser.label.text=Open output file in browser
sphinx.ask.for.working.directory.label.text=Sphinx working directory



pure.python.project=Pure Python
project.cannot.be.generated=Project can not be generated
error.in.project.generation=Error in Project Generation

sdk.has.been.configured.as.the.project.interpreter={0} has been configured as the project interpreter
configure.python.interpreter=Configure a Python Interpreter...
configuring.python.interpreter=Configuring a Python Interpreter
configuring.interpreters.link=<html><a href="#">Configure Interpreters
looking.for.previous.interpreter=Looking for the previously used interpreter
looking.for.related.venv=Looking for a virtual environment related to the project
looking.for.pipfile=Looking for a Pipfile
install.packages.from.pipfile=Install packages from Pipfile
looking.for.default.interpreter=Looking for the default interpreter setting for a new project
looking.for.previous.system.interpreter=Looking for the previously used system-wide interpreter
looking.for.system.interpreter=Looking for a system-wide interpreter
current.interpreter=Current Interpreter: {0}
python.facet.name=Python
enable.in.python.3=Enable in Python 3+
ignore.overridden.functions=Ignore overridden functions
choose.packages.to.install=Choose packages to install:
manage.python.packages=Manage Python Packages
interpreter=Interpreter:
base.interpreter=Base interpreter:
available.to.all.projects=Make available to all projects


framework.support.python.sdk.combobox.label=Python SDK:
integrated.tools.configurable.docstrings=Docstrings
integrated.tools.configurable.restructuredtext=reStructuredText
integrated.tools.configurable.packaging=Packaging
integrated.tools.configurable.testing=Testing
integrated.tools.configurable.pipenv=Pipenv
command.line.parser.error.message=Space between argument is its value is unexpected

python.package.installation.notification.message={0} will be installed on the selected interpreter
python.package.and.packaging.tools.installation.notification.message=Python packaging tools and {0} will be installed on the selected interpreter

python.execute.selection.action.execute.selection.in.console=Execute Selection in Python Console
python.execute.selection.action.execute.line.in.console=Execute Line in Python Console

python.add.sdk.panel.name.conda.environment=Conda environment
python.add.sdk.panel.name.existing.environment=Existing environment
python.add.sdk.panel.name.existing.interpreter=Existing interpreter
python.add.sdk.panel.name.new.environment.using=New environment using
python.add.sdk.panel.name.new.environment=New environment
python.add.sdk.panel.name.new.project.interpreter=New project interpreter
python.add.sdk.panel.name.pipenv.environment=Pipenv Environment
python.add.sdk.panel.name.system.interpreter=System interpreter
python.add.sdk.panel.name.virtualenv.environment=Virtualenv environment

python.requirements.version.label=Version in requirements:
python.requirements.version.separator.no.version=Don't specify version
python.requirements.version.separator.strong.eq=Strong equality
python.requirements.version.separator.gte=Greater or equal
python.requirements.version.separator.compatible=Compatible version
python.requirements.remove.unused=Remove unused requirements
python.requirements.modify.base.files=Modify base files (defined with -r or --requirement)
python.requirements.keep.matching.specifier=Keep existing version specifier if it matches the current version
python.requirements.quickfix.family.name=Add imported packages to requirements...
python.requirements.analyzing.imports.title=Analyzing imports in project
python.requirements.action.name=Sync Python requirements
python.requirements.error.ends.with.slash=Error parsing requirements: file ends with '/' symbol.
python.requirements.error.no.packages=Error retrieving the list of packages.
python.requirements.error.no.interpreter=Configured interpreter required to synchronize requirements.
python.requirements.warning.unhandled.lines=Could not analyze entries in requirements fie: {0}
python.requirements.info.file.ref.dropped=Some requirements from base files were not updated: {0}
python.requirements.balloon=Sync Python requirements
python.requirements.file.empty=Requirements file is empty

toolwindow.stripe.SciView=SciView
toolwindow.stripe.Python_Console=Python Console