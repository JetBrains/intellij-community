# Stubs for cStringIO (Python 2.7)
# See https://docs.python.org/2/library/stringio.html

from typing import overload, IO, List, Iterable, Iterator, Optional, Union
from types import TracebackType

# TODO the typing.IO[] generics should be split into input and output.

class InputType(IO[str], Iterator[str]):
    def getvalue(self) -> str: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    def read(self, size: int = ...) -> str: ...
    def readline(self, size: int = ...) -> str: ...
    def readlines(self, hint: int = ...) -> List[str]: ...
    def seek(self, offset: int, whence: int = ...) -> None: ...
    def tell(self) -> int: ...
    def truncate(self, size: int = ...) -> Optional[int]: ...
    def __iter__(self) -> 'InputType': ...
    def next(self) -> str: ...
    def reset(self) -> None: ...

class OutputType(IO[str], Iterator[str]):
    @property
    def softspace(self) -> int: ...
    def getvalue(self) -> str: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    def read(self, size: int = ...) -> str: ...
    def readline(self, size: int = ...) -> str: ...
    def readlines(self, hint: int = ...) -> List[str]: ...
    def seek(self, offset: int, whence: int = ...) -> None: ...
    def tell(self) -> int: ...
    def truncate(self, size: int = ...) -> Optional[int]: ...
    def __iter__(self) -> 'OutputType': ...
    def next(self) -> str: ...
    def reset(self) -> None: ...
    def write(self, b: Union[str, unicode]) -> None: ...
    def writelines(self, lines: Iterable[Union[str, unicode]]) -> None: ...

@overload
def StringIO() -> OutputType: ...
@overload
def StringIO(s: str) -> InputType: ...
