from _typeshed import Incomplete
from asyncio import AbstractEventLoop
from collections.abc import Generator
from types import coroutine as coroutine
from typing import TypeVar

from ..base import AsyncBase as AsyncBase
from ..threadpool.utils import (
    cond_delegate_to_executor as cond_delegate_to_executor,
    delegate_to_executor as delegate_to_executor,
    proxy_property_directly as proxy_property_directly,
)

_T = TypeVar("_T")

class AsyncSpooledTemporaryFile(AsyncBase[_T]):
    def fileno(self) -> Generator[Incomplete, Incomplete, Incomplete]: ...
    def rollover(self) -> Generator[Incomplete, Incomplete, Incomplete]: ...
    async def flush(self) -> None: ...
    async def isatty(self) -> bool: ...
    async def read(self, __n: int = ...): ...
    async def readline(self, __limit: int | None = ...): ...
    async def readlines(self, __hint: int = ...): ...
    async def seek(self, offset: int, whence: int = ...) -> int: ...
    async def tell(self) -> int: ...
    async def truncate(self, size: int | None = ...) -> None: ...
    @property
    def closed(self): ...
    @property
    def encoding(self): ...
    @property
    def mode(self): ...
    @property
    def name(self): ...
    async def newlines(self): ...
    @property
    def softspace(self): ...
    async def write(self, s): ...
    async def writelines(self, iterable): ...

class AsyncTemporaryDirectory:
    async def cleanup(self) -> None: ...
    @property
    def name(self): ...
    def __init__(self, file, loop: AbstractEventLoop | None, executor: Incomplete | None) -> None: ...
    async def close(self) -> None: ...
