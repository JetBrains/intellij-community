# Some methods are dynamically patched onto to instances as they
# may depend on whether code is executed in graph/eager/v1/v2/etc.
# Tensorflow supports multiple modes of execution which changes some
# of the attributes/methods/even class hierarchies.
tensorflow.Tensor.__int__
tensorflow.Tensor.numpy
tensorflow.Tensor.__index__
# Incomplete
tensorflow.sparse.SparseTensor.__getattr__
tensorflow.SparseTensor.__getattr__
tensorflow.TensorShape.__getattr__
tensorflow.dtypes.DType.__getattr__
tensorflow.RaggedTensor.__getattr__
tensorflow.DType.__getattr__
tensorflow.Graph.__getattr__
tensorflow.Operation.__getattr__
tensorflow.Variable.__getattr__
tensorflow.keras.layers.Layer.__getattr__
tensorflow.python.feature_column.feature_column_v2.SharedEmbeddingColumnCreator.__getattr__
tensorflow.GradientTape.__getattr__
tensorflow.data.Dataset.__getattr__
tensorflow.experimental.Optional.__getattr__

# Internal undocumented API
tensorflow.RaggedTensor.__init__
tensorflow.data.Dataset.__init__

# Has an undocumented extra argument that tf.Variable which acts like subclass
# (by dynamically patching tf.Tensor methods) does not preserve.
tensorflow.Tensor.__getitem__
# stub internal utilities
tensorflow._aliases

# Tensorflow imports are cursed.
# import tensorflow.initializers
# import tensorflow as tf
# tf.initializers
# Usually these two ways are same module, but for tensorflow the first way
# often does not work and the second way does. The documentation describes
# tf.initializers as module and has that type if accessed the second way,
# but the real module file is completely different name (even package) and dynamically handled.
# tf.initializers at runtime is <module 'keras.api._v2.keras.initializers' from '...'>
tensorflow.initializers

# Layer constructor's always have **kwargs, but only allow a few specific values. PEP 692
# would allow us to specify this with **kwargs and remove the need for these exceptions.
tensorflow.keras.layers.*.__init__

# __call__ in tensorflow classes often allow keyword usage, but
# when you subclass those classes it is not expected to handle keyword case. As an example,
# class MyLayer(tf.keras.layers.Layer):
#   def call(self, x):
#      ...
# is common even though Layer.call is defined like def call(self, inputs). Treating inputs as
# a keyword argument would lead to many false positives with typical subclass usage.
# Additional awkwardness for Layer's is call may optionally have training/mask as keyword arguments and some
# layers do while others do not. At runtime call is not intended to be used directly by users,
# but instead through __call__ which extracts out the training/mask arguments. Trying to describe
# this better in stubs would similarly add many false positive Liskov violations.
tensorflow.keras.layers.*.call
tensorflow.keras.regularizers.Regularizer.__call__
tensorflow.keras.constraints.Constraint.__call__

# Layer class does good deal of __new__ magic and actually returns one of two different internal
# types depending on tensorflow execution mode. This feels like implementation internal.
tensorflow.keras.layers.Layer.__new__

# build/compute_output_shape are marked positional only in stubs
# as argument name is inconsistent across layer's and looks like
# an implementation detail as documentation never mentions the
# disagreements.
tensorflow.keras.layers.*.build
tensorflow.keras.layers.*.compute_output_shape

# pb2.pyi generated by mypy-protobuf diverge with runtime in many ways. These stubs
# are mainly tested in mypy-protobuf.
.*_pb2.*

# Uses namedtuple at runtime, but NamedTuple in stubs and the two disagree about the name of
# __new__ first argument (cls vs cls_).
tensorflow.io.RaggedFeature.__new__
tensorflow.io.FixedLenSequenceFeature.__new__
tensorflow.io.FixedLenFeature.__new__
tensorflow.io.SparseFeature.__new__

# Metaclass inconsistency. The runtime metaclass is defined from c++ extension and is undocumented.
tensorflow.io.TFRecordWriter
