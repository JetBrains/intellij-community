from collections.abc import Awaitable
from typing import Any

from redis.asyncio import Redis

class Lock:
    lua_release: Any
    lua_extend: Any
    lua_reacquire: Any
    LUA_RELEASE_SCRIPT: str
    LUA_EXTEND_SCRIPT: str
    LUA_REACQUIRE_SCRIPT: str
    redis: Any
    name: Any
    timeout: Any
    sleep: Any
    blocking: Any
    blocking_timeout: Any
    thread_local: Any
    local: Any
    def __init__(
        self,
        redis: Redis[Any],
        name: str | bytes | memoryview,
        timeout: float | None = ...,
        sleep: float = ...,
        blocking: bool = ...,
        blocking_timeout: float | None = ...,
        thread_local: bool = ...,
    ) -> None: ...
    def register_scripts(self) -> None: ...
    async def __aenter__(self): ...
    async def __aexit__(self, exc_type, exc_value, traceback) -> None: ...
    async def acquire(
        self, blocking: bool | None = ..., blocking_timeout: float | None = ..., token: str | bytes | None = ...
    ): ...
    async def do_acquire(self, token: str | bytes) -> bool: ...
    async def locked(self) -> bool: ...
    async def owned(self) -> bool: ...
    def release(self) -> Awaitable[None]: ...
    async def do_release(self, expected_token: bytes): ...
    def extend(self, additional_time: float, replace_ttl: bool = ...) -> Awaitable[bool]: ...
    async def do_extend(self, additional_time, replace_ttl) -> bool: ...
    def reacquire(self) -> Awaitable[bool]: ...
    async def do_reacquire(self) -> bool: ...
