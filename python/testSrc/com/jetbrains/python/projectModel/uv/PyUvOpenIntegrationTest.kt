// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.jetbrains.python.projectModel.uv

import com.intellij.openapi.components.service
import com.intellij.openapi.externalSystem.testFramework.fixtures.multiProjectFixture
import com.intellij.platform.testFramework.assertion.collectionAssertion.CollectionAssertions
import com.intellij.platform.testFramework.assertion.moduleAssertion.ContentRootAssertions
import com.intellij.platform.testFramework.assertion.moduleAssertion.DependencyAssertions
import com.intellij.platform.testFramework.assertion.moduleAssertion.ModuleAssertions
import com.intellij.testFramework.common.timeoutRunBlocking
import com.intellij.testFramework.junit5.RegistryKey
import com.intellij.testFramework.junit5.TestApplication
import com.intellij.testFramework.junit5.fixture.tempPathFixture
import com.intellij.testFramework.useProjectAsync
import com.intellij.testFramework.utils.io.createFile
import org.junit.jupiter.api.Test
import kotlin.io.path.writeText
import kotlin.time.Duration.Companion.seconds

@RegistryKey("python.project.model.uv", "true")
@TestApplication
class PyUvOpenIntegrationTest {
  private val testRoot by tempPathFixture()
  private val multiprojectFixture by multiProjectFixture()

  @Test
  fun `project with top-level uv-lock is automatically linked`() = timeoutRunBlocking(timeout = 20.seconds) {
    val projectPath = testRoot.resolve("project")

    projectPath.createFile("uv.lock").writeText("""
      # This file is automatically generated by uv.
    """.trimIndent())

    projectPath.createFile("pyproject.toml").writeText("""
      [project]
      name = "project"
    """.trimIndent())

    multiprojectFixture.openProject(projectPath).useProjectAsync {
      ModuleAssertions.assertModules(it, "project")
      CollectionAssertions.assertEqualsUnordered(listOf(projectPath), it.service<UvSettings>().getLinkedProjects())
    }
  }

  @Test
  fun `project with top-level pyproject-toml containing uv-tool table is automatically linked`() = timeoutRunBlocking(timeout = 20.seconds) {
    val projectPath = testRoot.resolve("project")

    projectPath.createFile("pyproject.toml").writeText("""
      [project]
      name = "project"

      [tool.uv.workspace]
      members = ["packages/*"]
    """.trimIndent())

    multiprojectFixture.openProject(projectPath).useProjectAsync { project ->
      ModuleAssertions.assertModules(project, "project")
      CollectionAssertions.assertEqualsUnordered(listOf(projectPath), project.service<UvSettings>().getLinkedProjects())
    }
  }

  @Test
  fun `project with top-level pyproject-toml without uv-tool table is not automatically linked`() = timeoutRunBlocking(timeout = 20.seconds) {
    val projectPath = testRoot.resolve("project")

    projectPath.createFile("pyproject.toml").writeText("""
      [project]
      name = "project"
    """.trimIndent())

    multiprojectFixture.openProject(projectPath).useProjectAsync { project ->
      ModuleAssertions.assertModules(project, "project")
      CollectionAssertions.assertEqualsUnordered(emptyList(), project.service<UvSettings>().getLinkedProjects())
    }
  }

  @Test
  fun `manually syncing a not recognized project removes its fake top-level module`() = timeoutRunBlocking(timeout = 20.seconds) {
    val projectPath = testRoot.resolve("project")

    projectPath.createFile("pyproject.toml").writeText("""
      [project]
      name = "myproject"
    """.trimIndent())

    multiprojectFixture.openProject(projectPath).useProjectAsync { project ->
      // Nothing was linked automatically. There is only the module created by PlatformProjectConfigurator.
      ModuleAssertions.assertModules(project, "project")
      ContentRootAssertions.assertContentRoots(project, "project", listOf(projectPath))
      CollectionAssertions.assertEqualsUnordered(emptyList(), project.service<UvSettings>().getLinkedProjects())

      multiprojectFixture.awaitProjectConfiguration(project) {
        UvProjectModelService.linkAllProjectModelRoots(project, project.basePath!!)
        UvProjectModelService.syncAllProjectModelRoots(project)
      }

      // Now there is only the module owned by Uv
      ModuleAssertions.assertModules(project, "myproject")
      CollectionAssertions.assertEqualsUnordered(listOf(projectPath), project.service<UvSettings>().getLinkedProjects())
      ContentRootAssertions.assertContentRoots(project, "myproject", listOf(projectPath))
    }
  }

  @Test
  fun `test monorepo without top-level pyproject-toml and with sibling path dependency`() = timeoutRunBlocking(timeout = 20.seconds) {
    val projectPath = testRoot.resolve("project")

    projectPath.createFile("libs/project1/pyproject.toml").writeText("""
      [project]
      name = "project1"

      [tool.uv.sources]
      project2 = { path = "../project2", editable = true }
    """.trimIndent())

    projectPath.createFile("libs/project2/pyproject.toml").writeText("""
      [project]
      name = "project2"
    """.trimIndent())

    multiprojectFixture.openProject(projectPath).useProjectAsync { project ->
      val uvSettings = project.service<UvSettings>()
      // Such projects without uv.lock or pyproject.toml with tool.uv in the root cannot be recognized automatically
      CollectionAssertions.assertEmpty(uvSettings.getLinkedProjects())
      ModuleAssertions.assertModules(project, "project")

      multiprojectFixture.awaitProjectConfiguration(project) {
        UvProjectModelService.linkAllProjectModelRoots(project, project.basePath!!)
        UvProjectModelService.syncAllProjectModelRoots(project)
      }

      ModuleAssertions.assertModules(project, "project", "project1", "project2")
      CollectionAssertions.assertEqualsUnordered(
        listOf(projectPath.resolve("libs/")),
        uvSettings.getLinkedProjects()
      )

      ModuleAssertions.assertModuleEntity(project, "project1") { module ->
        DependencyAssertions.assertDependencies(module, DependencyAssertions.INHERITED_SDK, DependencyAssertions.MODULE_SOURCE, "project2")
      }

      ModuleAssertions.assertModuleEntity(project, "project2") { module ->
        DependencyAssertions.assertDependencies(module, DependencyAssertions.INHERITED_SDK, DependencyAssertions.MODULE_SOURCE)
      }
    }
  }

  @Test
  fun `test monorepo with two independent workspaces`() = timeoutRunBlocking(timeout = 20.seconds) {
    val projectPath = testRoot.resolve("project")

    projectPath.createFile("workspace1/pyproject.toml").writeText("""
      [project]
      name = "workspace1"
      
      [tool.uv.workspace]
      members = [
          "lib1",
      ]
      
      [tool.uv.sources]
      lib1 = { workspace = true }
    """.trimIndent())

    projectPath.createFile("workspace1/lib1/pyproject.toml").writeText("""
      [project]
      name = "lib1"
    """.trimIndent())

    projectPath.createFile("workspace2/pyproject.toml").writeText("""
      [project]
      name = "workspace2"
      
      [tool.uv.workspace]
      members = [
          "lib2",
      ]
      
      [tool.uv.sources]
      lib2 = { workspace = true }
    """.trimIndent())

    projectPath.createFile("workspace2/lib2/pyproject.toml").writeText("""
      [project]
      name = "lib2"
    """.trimIndent())

    multiprojectFixture.openProject(projectPath).useProjectAsync { project ->
      val uvSettings = project.service<UvSettings>()
      // Such projects without uv.lock or pyproject.toml with tool.uv in the root cannot be recognized automatically
      CollectionAssertions.assertEmpty(uvSettings.getLinkedProjects())
      ModuleAssertions.assertModules(project, "project")

      multiprojectFixture.awaitProjectConfiguration(project) {
        UvProjectModelService.linkAllProjectModelRoots(project, project.basePath!!)
        UvProjectModelService.syncAllProjectModelRoots(project)
      }

      ModuleAssertions.assertModules(project, "project", "workspace1", "workspace2", "lib1", "lib2")
      CollectionAssertions.assertEqualsUnordered(
        listOf(
          projectPath.resolve("workspace1"),
          projectPath.resolve("workspace2")
        ),
        uvSettings.getLinkedProjects()
      )

      ModuleAssertions.assertModuleEntity(project, "workspace1") { module ->
        DependencyAssertions.assertDependencies(module, DependencyAssertions.INHERITED_SDK, DependencyAssertions.MODULE_SOURCE, "lib1")
      }

      ModuleAssertions.assertModuleEntity(project, "workspace2") { module ->
        DependencyAssertions.assertDependencies(module, DependencyAssertions.INHERITED_SDK, DependencyAssertions.MODULE_SOURCE, "lib2")
      }

      ModuleAssertions.assertModuleEntity(project, "lib1") { module ->
        DependencyAssertions.assertDependencies(module, DependencyAssertions.INHERITED_SDK, DependencyAssertions.MODULE_SOURCE)
      }

      ModuleAssertions.assertModuleEntity(project, "lib2") { module ->
        DependencyAssertions.assertDependencies(module, DependencyAssertions.INHERITED_SDK, DependencyAssertions.MODULE_SOURCE)
      }
    }
  }
}
