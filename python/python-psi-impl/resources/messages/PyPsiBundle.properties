# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Dynamic class based on {0}

### Refactoring

refactoring.extract.method.error.interrupted.execution.flow=Cannot perform refactoring when execution flow is interrupted
refactoring.extract.method.error.star.import=Cannot perform refactoring with star import statement inside code block
refactoring.extract.method.error.yield=Cannot perform refactoring with 'yield' statement inside code block

### Annotators ###
ANN.deleting.none=Deleting None
ANN.assign.to.none=Assignment to None
ANN.cant.assign.to.call=Can't assign to function call
ANN.cant.delete.call=Can't delete function call
ANN.cant.aug.assign.to.generator=Augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=Augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=Assign to generator expression not possible
ANN.cant.assign.to.operator=Can't assign to operator
ANN.cant.assign.to.parens=Can't assign to ()
ANN.cant.aug.assign.to.list.or.comprh=Augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=Can't assign to list comprehension
ANN.cant.assign.to.dict.comprh=Can't assign to dict comprehension
ANN.cant.assign.to.set.comprh=Can't assign to set comprehension
ANN.cant.aug.assign.to.comprh=Augmented assign to list comprehension not possible
ANN.cant.aug.assign.to.dict.comprh=Augmented assign to dict comprehension not possible
ANN.cant.aug.assign.to.set.comprh=Augmented assign to set comprehension not possible
ANN.cant.assign.to.literal=Can't assign to literal
ANN.cant.delete.literal=Can't delete literal
ANN.cant.assign.to.lambda=Can't assign to lambda

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop

ANN.$0.assigned.before.global.decl=Name ''{0}'' is assigned before global declaration

ANN.duplicate.param.name=duplicate parameter name
ANN.starred.param.after.kwparam=* parameter after ** parameter
ANN.regular.param.after.vararg=regular parameter after * parameter
ANN.regular.param.after.keyword=regular parameter after ** parameter
ANN.non.default.param.after.default=non-default parameter follows default parameter
ANN.named.parameters.after.star=named parameters must follow bare *
ANN.named.parameters.before.slash=named parameters must precede bare /
ANN.tuple.py3=tuple parameter unpacking is not supported in Python 3
ANN.multiple.args=multiple * parameters are not allowed
ANN.multiple.kwargs=multiple ** parameters are not allowed
ANN.multiple.slash=multiple / parameters are not allowed
ANN.slash.param.after.vararg=/ parameter must precede * parameter
ANN.slash.param.after.keyword=/ parameter must precede ** parameter

ANN.star.import.at.top.only='import *' only allowed at module level

ANN.missing.closing.quote=Missing closing quote [{0}]
ANN.missing.closing.triple.quotes=Missing closing triple quotes

ANN.method.$0.removed.use.$1=Method ''{0}'' has been removed, use ''{1}'' instead
ANN.method.$0.removed=Method ''{0}'' removed

### parsing
PARSE.expected.expression=expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.rbrace='}' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.identifier=Identifier expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=formal parameter name expected
PARSE.0.expected={0} expected
PARSE.expected.ellipsis='...' expected
PARSE.string.literal.expected=string literal expected
PARSE.expected.symbols={0} or {1} expected
PARSE.declarator.should.be.empty=declarator should be empty
PARSE.string.literal=string literal
PARSE.newline.expected=newline expected
PARSE.eq.expected='=' expected
PARSE.from.expected='from' expected
PARSE.gt.expected='>' expected

statement.expected.found.0=Statement expected, found {0}
unexpected.indent=Unexpected indent
unindent.does.not.match.any.outer.indent=Unindent does not match any outer indentation level
except.or.finally.expected='except' or 'finally' expected
expected.statement=Statement expected
dedent.expected=Dedent expected
indent.expected=Indent expected
indented.block.expected=Indented block expected
cannot.assign.to.yield.expression=Cannot assign to 'yield' expression
end.of.statement.expected=End of statement expected
import.expected='import' expected
def.or.with.or.for.expected='def' or 'with' or 'for' expected
rbracket.or.comma.expected=']' or ',' expected
unexpected.expression.syntax=Unexpected expression syntax
tuple.expression.expected=tuple expression expected
value.expression.expected=value expression expected
unexpected.expression.part=unexpected expression part
unexpected.f.string.token=unexpected f-string token
can.t.assign.to.await.expression=can't assign to await expression
for.expected='for' expected
rarrow.expected='->' expected
unexpected.tokens=unexpected tokens
enable.in.python.3=Enable in Python 3+

PARSE.function.type.annotations.py2=Type annotations are unsupported in Python 2
PARSE.function.return.type.annotations.py2=Return type annotations are unsupported in Python 2

PARSE.console.multiline.magic.warn=Multiline magic can't be used as an expression
PARSE.console.identifier.expected=Identifier expected.
PARSE.console.help.request.warn=Help request must follow the name

### quick doc generator
QDOC.module.path.unknown=(Module path is unknown)
QDOC.epydoc.python2.sdk.not.found=You need configured Python 2 SDK to render <a href='http://epydoc.sourceforge.net/'>Epydoc</a> docstrings
QDOC.local.sdk.not.found=You need a configured local Python SDK to render docstrings.
QDOC.assigned.to=Assigned to:
QDOC.documentation.is.copied.from=Documentation is copied from:
QDOC.accessor.kind=Accessor kind:
QDOC.raises=Raises:
QDOC.keyword.args=Keyword args:
QDOC.returns=Returns:
QDOC.params=Params:

### Formatter
formatter.panel.dict.alignment.do.not.align=Do not align
formatter.panel.dict.alignment.align.on.colon=Align on colon
formatter.panel.dict.alignment.align.on.value=Align on value

ignore.overridden.functions=Ignore overridden functions

### Intentions ###

INTN.replace.octal.numeric.literal=Convert octal numeric literal to supported form
INTN.convert.builtin.import=Convert builtin module import to supported form

INTN.Family.convert.except.part=Convert except part to supported form
INTN.Family.convert.set.literal=Convert set literal two supported forms
INTN.Family.convert.builtin=Convert builtin module import
INTN.Family.convert.dict.comp.expression=Convert dictionary comprehension expression
INTN.Family.convert.string=Convert single-quoted string to double-quoted


INTN.convert.to.from.$0.import.$1=Convert to ''from {0} import {1}''
INTN.convert.to.import.$0=Convert to ''import {0}''
INTN.convert.except.to=Convert 'except exceptClass, Target' to 'except exceptClass as Target'
INTN.convert.set.literal.to=Convert set literal to 'set' method call


INTN.alias.for.$0.dialog.title=Alias for ''{0}'':
INTN.add.alias.for.import.$0=Add alias to ''{0}''
INTN.remove.alias.for.import.$0=Remove alias ''{0}''

INTN.Family.migration.to.python3=Migration to Python 3

INTN.replace.noteq.operator=Replace not equal operator
INTN.convert.dict.comp.to=Convert dictionary comprehension to 'dict' method call

INTN.remove.leading.$0=Remove leading {0}
INTN.remove.leading.prefix=Remove prefix

INTN.replace.backquote.expression=Replace backquote expression
INTN.replace.raise.statement=Convert raise statement to supported form

INTN.replace.list.comprehensions=Convert list comprehensions to supported form

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=Convert to f-string literal
INTN.replace.with.method=Replace with str.format method call

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=Convert format operator usage to str.format method call

INTN.Family.convert.import.unqualify=Convert 'import module' to 'from module import'
INTN.Family.convert.import.qualify=Convert 'from module import' to 'import module'
INTN.Family.toggle.import.alias=Toggle import alias

INTN.replace.list.comprehensions.with.for=Convert list comprehensions to for loop

INTN.replace.method=Replace method which is not supported in current Python version

INTN.split.if=Split if
INTN.split.if.text=Split into 2 if's

INTN.negate.comparison=Negate comparison
INTN.negate.$0.to.$1=Negate ''{0}'' to ''{1}''

INTN.string.concatenation.to.format=Replace string concatenation with format operator
INTN.replace.plus.with.format.operator=Replace + with string formatting operator
INTN.replace.plus.with.str.format=Replace + with str.format method call


INTN.flip.comparison=Flip comparison
INTN.flip.$0=Flip ''{0}''
INTN.flip.$0.to.$1=Flip ''{0}'' to ''{1}''

INTN.convert.string=Convert single-quoted string to double-quoted

INTN.join.if=Join if's
INTN.join.if.text=Join two if's

INTN.convert.dict.constructor.to.dict.literal=Convert dict constructor to dict literal form
INTN.convert.dict.literal.to.dict.constructor=Convert dict literal to dict constructor

INTN.quoted.string=Convert between single-quoted and double-quoted strings
INTN.quoted.string.single.to.double=Convert single-quoted string to double-quoted string
INTN.quoted.string.double.to.single=Convert double-quoted string to single-quoted string

INTN.convert.lambda.to.function=Convert lambda to function

INTN.convert.variadic.param=Convert from variadic to normal parameter(s)

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=Convert triple-quoted string to single-quoted string

# PyBaseConvertCollectionLiteralIntention
INTN.convert.collection.literal.family=Convert collection to {0}
INTN.convert.collection.literal.text=Convert {0} to {1}

# PyConvertTypeCommentToVariableAnnotation
INTN.convert.type.comment.to.variable.annotation.family=Convert type comment to variable annotation
INTN.convert.type.comment.to.variable.annotation.text=Convert to variable annotation


INTN.demorgan.law=DeMorgan law

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=Transform conditional expression into if/else statement

# PyConvertTripleQuotedStringIntention
INTN.doc.string.stub=Insert documentation string stub

#SpecifyTypeInDocstringIntention
INTN.specify.type=Specify type for reference in docstring
INTN.specify.return.type=Specify return type in docstring
INTN.add.parameters.to.docstring=Add parameters to docstring

#SpecifyTypeInPy3AnnotationsIntention
INTN.specify.type.in.annotation=Specify type for reference using annotation
INTN.specify.return.type.in.annotation=Specify return type using annotation

#PyAnnotateTypesIntention/PyAnnotateVariableTypeIntention
INTN.add.type.hints.for.function.family=Add type hints for function
INTN.add.type.hints.for.function=Add type hints for function ''{0}''
INTN.add.type.hint.for.variable.family=Add type hint for variable
INTN.add.type.hint.for.variable=Add type hint for variable ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=Type ''{0}'' cannot be expressed inline in PEP 484 format

#TypeAssertionIntention
INTN.insert.assertion=Insert type assertion

#PyYieldFromIntention
INTN.yield.from=Transform explicit iteration with 'yield' into 'yield from' expression

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=Convert static method to function

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=Convert method to property

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=Convert relative import to absolute
INTN.convert.absolute.to.relative=Convert absolute import to relative

INTN.add.alias.title=Add Alias

### Quick fixes ###
QFIX.auto.import.family=Import
QFIX.auto.import.import.this.name=Import this name
QFIX.auto.import.import.name=Import ''{0}''
QFIX.local.auto.import.family=Import locally
QFIX.local.auto.import.import.locally={0} locally
QFIX.augment.assignment=Replace assignment with augmented assignment
QFIX.NAME.remove.call=Remove call
QFIX.replace.equality=Replace equality
QFIX.dict.creation=Replace dictionary creation
QFIX.NAME.remove.dict.key=Remove this key
QFIX.NAME.move.except.up=Move except clause up
QFIX.add.field.to.class=Add field to class
QFIX.added.constructor.$0.for.field.$1=Added a __init__ to class <code>{0}</code><br/>to accommodate new field <code>{1}</code>
QFIX.NAME.remove.parameter=Remove parameter
QFIX.rename.parameter.to.$0=Rename to ''{0}''
QFIX.NAME.add.field.$0.to.class.$1=Add field ''{0}'' to class {1}
QFIX.NAME.remove.statement=Remove statement
QFIX.failed.to.add.field=<br/>Failed to add a field!<br/><br/>
QFIX.redundant.parentheses=Remove redundant parentheses
QFIX.simplify.boolean.expression=Simplify boolean expression
QFIX.simplify.$0=Replace boolean expression with ''{0}''
QFIX.chained.comparison=Simplify chained comparison
QFIX.move.from.future.import=Move 'from __future__ import' to a correct place
QFIX.list.creation=Replace list creation
QFIX.add.super=Add super class call
QFIX.NAME.remove.assignment=Remove assignment
QFIX.NAME.remove.argument=Remove argument
QFIX.add.parameter.self=Add parameter ''{0}''
QFIX.statement.effect=Replace with function call
QFIX.remove.trailing.semicolon=Remove trailing semicolon
QFIX.introduce.variable=Introduce variable for statement
QFIX.NAME.make.list=Replace tuple with list
QFIX.NAME.add.specifier=Add format specifier character
QFIX.NAME.wrap.in.exception=Wrap with Exception call
QFIX.add.global=Add global statement
QFIX.create.property=Create property
QFIX.replace.with.type.name=Replace with type name
QFIX.remove.function.annotations=Remove function annotations
QFIX.replace.with.target.name=Replace with target name
QFIX.remove.generic.parameters=Remove generic parameter(s)
QFIX.replace.with.square.brackets=Replace with square brackets
QFIX.surround.with.square.brackets=Surround with square brackets
QFIX.remove.square.brackets=Remove square brackets
QFIX.add.property=Add property for the field
QFIX.use.property=Use property for the field
QFIX.make.public=Make public
QFIX.NAME.update.parameters=Update parameters
QFIX.rename.parameter=Rename parameter
QFIX.convert.to.new.style=Convert to New-style class
QFIX.change.base.class=Change base class
QFIX.classic.class.transform=Inherit from object
QFIX.NAME.rename.argument=Rename argument
QFIX.NAME.add.exception.base=Add Exception base class
QFIX.add.encoding=Add encoding declaration
QFIX.remove.trailing.suffix=Remove trailing suffix
QFIX.action.failed=Action failed


#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=Remove underscores in numeric literals

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=Replace function call with set literal

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=Remove arguments equal to default

#PyDefaultArgumentQuickFix
QFIX.default.argument=Replace mutable default argument

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=Move attribute to __init__ method

#DocstringQuickFix
QFIX.docstring.add.$0=Add docstring parameter ''{0}''
QFIX.docstring.remove.$0=Remove docstring parameter ''{0}''
QFIX.docstring.insert.stub=Insert docstring
QFIX.fix.docstring=Fix docstring

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=Make method static

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=Make function from method

#ConvertIndents
QFIX.convert.indents=Convert indents
QFIX.convert.indents.to.tabs=Convert indents to tabs
QFIX.convert.indents.to.spaces=Convert indents to spaces

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=Convert docstring to the triple double-quoted string form

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=Remove unnecessary backslash in expression

#RemoveDecoratorQuickFix
QFIX.remove.decorator=Remove decorator

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.$0.return.$1=Make ''{0}'' return ''{1}''

# Add method quick fix
QFIX.NAME.add.method.$0.to.class.$1=Add method {0}() to class {1}
QFIX.failed.to.add.method=<br/>Failed to add a method!<br/><br/>
QFIX.NAME.add.function.$0.to.module.$1=Create function {0}() in module {1}
QFIX.failed.to.add.function=<br/>Failed to add a function!<br/><br/>
QFIX.add.method.to.class=Add method to class

# InstallAndImportQuickFix
QFIX.install.and.import.package=Install and import package
QFIX.NAME.install.and.import.package=Install and import package ''{0}''


# Actions and associated commands
ACT.CMD.use.import=Use an imported module
ACT.qualify.with.module=Qualify with an imported module
ACT.from.some.module.import=Import from ...


python.docstring.file.type=python docstring
python.function.type.annotation.file.type.description=Python PEP-484 function type comment
python.docstring.format=Docstring format:
python.docstring.select.type=Select Docstring Type

### Inspections: INSP ###
INSP.GROUP.python=Python

INSP.compatibility.this.syntax.available.only.since.py3=This syntax available only since py3
INSP.compatibility.check.for.compatibility.with.python.versions=Check for compatibility with python versions:
INSP.abstract.class.set.as.metaclass=Set ''{0}'' as metaclass
INSP.abstract.class.add.to.superclasses=Add ''{0}'' to superclasses
INSP.pep8.naming=PEP 8 naming convention violation
INSP.shadowing.builtins=Shadowing built-ins
INSP.calling.non.callable=Trying to call a non-callable object
INSP.dataclass.definition.and.usages=Dataclass definition and usages
INSP.dunder.slots=Definition of __slots__ in a class
INSP.final.classes.methods.and.variables=Final classes, methods and variables
INSP.global.undefined=Global variable is undefined at the module level
INSP.inconsistent.indentation=Inconsistent indentation
INSP.named.tuple=Namedtuple definition
INSP.shadows.name.from.outer.scope=Shadows name ''{0}'' from outer scope
INSP.trailing.semicolon=Trailing semicolon in the statement
INSP.raising.string.exception=Raising a string exception
INSP.protected.member.ignore.annotations=Ignore annotations
INSP.protected.member.ignore.test.functions=Ignore test functions
INSP.docstring.types.fix.docstring=Fix docstring
INSP.docstring.types.change.type=Change {0} type from {1} to {2}
INSP.interpreter.configure.python.interpreter=Configure Python interpreter
INSP.interpreter.interpreter.settings=Interpreter settings
INSP.interpreter.use.interpreter=Use {0}
INSP.interpreter.use.suggested.interpreter=Use suggested interpreter
INSP.mandatory.encoding.encoding.comment.format=Encoding comment format:
INSP.mandatory.encoding.select.default.encoding=Select default encoding: 
INSP.mandatory.encoding.no.encoding.specified.for.file=No encoding specified for file
INSP.method.parameters.metaclass.method.first.argument.name=Metaclass method first argument name
INSP.missing.type.hints.add.type.hints=Add type hints
INSP.missing.type.hints.add.type.hints.for=Add type hints for ''{0}''
INSP.missing.type.hints.only.when.types.are.known.collected.from.run.time.or.inferred=Only when types are known(collected from run-time or inferred)

INSP.package.requirements.requirements.have.been.ignored=Requirements have been ignored
INSP.package.requirements.requirement.has.been.ignored=''{0}'' has been ignored
INSP.package.requirements.add.import=Add import
INSP.package.requirements.administrator.privileges.required=Administrator Privileges Required
INSP.package.requirements.administrator.privileges.required.description=\
  Installing packages into ''{0}'' requires administrator privileges.\n\n\
  Configure a per-project virtual environment as your project interpreter\n\
  to avoid installing packages to a protected area of the file system.
INSP.package.requirements.administrator.privileges.required.button.configure=Configure
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Install Anyway
INSP.package.requirements.requirements.file.empty=Requirements file is empty
INSP.package.requirements.quickfix.family.name=Add imported packages to requirements...
INSP.pep8.ignore.base.class=Ignore base class
INSP.pep8.ignore.method.names.for.descendants.of.class=Ignore method names for descendants of class
INSP.shadowing.builtins.ignore.shadowed.built.in.name=Ignore shadowed built-in name
INSP.stub.packages.compatibility.ignore=Ignore ''{0}'' compatibility
INSP.arguments.not.declared.but.provided.by.decorator=Following arguments are not declared but provided by decorator: {0}
INSP.abstract.class=Class must implement all abstract methods
INSP.assigning.function.call.that.doesnt.return.anything=Assigning function call that doesn't return anything
INSP.deprecated.function.class.or.module=Deprecated function, class or module
INSP.mandatory.encoding=No encoding specified for file
INSP.missing.type.hints=Missing type hinting for function definition
INSP.overloads.in.regular.python.files=Overloads in regular Python files
INSP.pep8.coding.style.violation=PEP 8 coding style violation
INSP.protected.member=Access to a protected member of a class or a module
INSP.protocol.definition.and.usages=Protocol definition and usages
INSP.shadowing.names=Shadowing names from outer scopes
INSP.stub.packages.compatibility=Stub packages compatibility inspection
INSP.stub.packages=Stub packages advertiser
INSP.type.checker=Type checker
INSP.type.hints=Type hints definitions and usages
INSP.typed.dict=TypedDict definition and usages

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.cannot.appear.past.keyword.arg=Cannot appear past keyword arguments or *arg or **kwarg
INSP.unexpected.arg=Unexpected argument
INSP.unexpected.arg(s)=Unexpected argument(s)
INSP.parameter.$0.unfilled=Parameter ''{0}'' unfilled
INSP.parameter(s).unfilled=Parameter(s) unfilled
INSP.possible.callees=Possible callees
INSP.func.$0.lacks.first.arg=Function ''{0}'' lacks a positional argument
INSP.expected.dict.got.$0=Expected a dictionary, got {0}
INSP.expected.iter.got.$0=Expected an iterable, got {0}
INSP.more.args.that.pos.params=Multiple values resolve to one positional parameter
INSP.multiple.values.resolve.to.positional.$0=Multiple values resolve to positional parameter ''{0}''
INSP.cannot.analyze=This argument list cannot be analyzed

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Methods having troubles with first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called ''{0}''
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'
INSP.usually.named.$0=Usually first parameter of such methods is named ''{0}''
INSP.first.param.must.not.be.tuple=First parameter of a non-static method must not be a tuple

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=Problematic nesting of decorators
INSP.decorator.receives.unexpected.builtin=This decorator will not receive a callable it may expect; the built-in decorator returns a special object

# PyRedeclarationInspection
INSP.NAME.redeclaration=Redeclared names without usage
INSP.redeclared.name=Redeclared ''{0}'' defined above without usage

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=''{0}'' in try block with ''except ImportError'' should also be defined in except block
INSP.unused.import.statement=Unused import statement <code>#ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=Invalid interpreter configured

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ method that returns a value
INSP.cant.return.value.from.init=Cannot return a value from __init__

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=Unreachable code
INSP.unreachable.code=This code is unreachable

# PyStringFormatInspection
INSP.NAME.str.format=Errors in string formatting operations
INSP.format.requires.no.mapping=Format doesn't require a mapping
INSP.key.$0.has.no.arg=Key ''{0}'' has no corresponding argument
INSP.unexpected.type.$0=Unexpected type {0}
INSP.too.few.keys=Too few mapping keys
INSP.no.format.specifier.char=Format specifier character missing
INSP.format.requires.mapping=Format requires a mapping
INSP.too.many.args.for.fmt.string=Too many arguments for format string
INSP.too.few.args.for.fmt.string=Too few arguments for format string
INSP.incompatible.options=The format options in chunk "{0}" are incompatible
INSP.unused.mapping = Mapping key "{0}" is unused
INSP.unsupported.format.character=Unsupported format character ''{0}''
INSP.manual.to.auto.field.numbering=Cannot switch from manual field specification to automatic field numbering
INSP.auto.to.manual.field.numbering=Cannot switch from automatic field numbering to manual field specification

# PyMethodOverridingInspection
INSP.NAME.method.over=Method signature does not match signature of overridden method
INSP.signature.mismatch=Signature of method ''{0}'' does not match signature of base method in class ''{1}''

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=Incompatible signatures of __new__ and __init__
INSP.new.incompatible.to.init=Signature is not compatible to __init__
INSP.init.incompatible.to.new=Signature is not compatible to __new__

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=Trailing semicolon in statement


# PyUnboundLocalVariableInspection
INSP.NAME.unbound=Unbound local variable
INSP.unbound.local.variable=Local variable ''{0}'' might be referenced before assignment
INSP.unbound.nonlocal.variable=Nonlocal variable ''{0}'' must be bound in an outer function scope
INSP.unbound.name.undefined=Name ''{0}'' can be undefined
INSP.unbound.function.too.large=Function ''{0}'' is too large to analyse

# PyListCreationInspection
INSP.NAME.list.creation=List creation could be rewritten by list literal

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=Tuple assignment balance is incorrect

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=Classic style class usage
INSP.classic.class.usage.old.style.class=Old-style class
INSP.classic.class.usage.old.style.class.ancestors=Old-style class, because all classes from whom it inherits are old-style


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=Exception doesn't inherit from standard ''Exception'' class

# PyDefaultArgumentInspection
INSP.NAME.default.argument=Default argument is mutable

# PyDocstringTypesInspection
INSP.NAME.docstring.types=Type in docstring doesn't match inferred type

# PyStatementEffectInspection
INSP.NAME.statement.effect=Statement has no effect
INSP.NAME.statement.message=Statement seems to have no effect

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=Raising a string exception

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=Wrong arguments to call super
INSP.$0.is.not.superclass.of.$1=''{0}'' is not an instance or a subclass of ''{1}''

# PynonAsciiCharInspection
INSP.NAME.non.ascii=File contains non-ASCII character

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=No encoding specified for file

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=Tuple item assignment
INSP.tuples.never.assign.items=Tuples don't support item assignment

# PyPropertyAccessInspection
INSP.NAME.property.access=Access to properties
INSP.property.$0.cant.be.set=Property ''{0}'' cannot be set
INSP.property.$0.cant.be.read=Property ''{0}'' cannot be read
INSP.property.$0.cant.be.deleted=Property ''{0}'' cannot be deleted

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=Property definitions
INSP.doc.param.should.be.str=The doc parameter should be a string
INSP.strange.arg.want.callable=Strange argument; a callable is expected
INSP.func.property.name.mismatch=Names of function and decorator don't match; property accessor is not created
INSP.getter.return.smth=Getter should return or yield something
INSP.setter.should.not.return=Setter should not return a value
INSP.deleter.should.not.return=Deleter should not return a value
INSP.getter.signature.advice=Getter signature should be (self)
INSP.setter.signature.advice=Setter signature should be (self, value)
INSP.deleter.signature.advice=Deleter signature should be (self)
INSP.accessor.first.param.is.$0=First parameter of an accessor is usually called ''{0}''

# PyProtectedMemberInspection
INSP.protected.member.$0.access=Access to a protected member {0} of a class
INSP.protected.member.$0.access.module=Access to a protected member {0} of a module

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=Old-style class contains new-style class features
INSP.oldstyle.class.slots=Old-style class contains __slots__ definition
INSP.oldstyle.class.getattribute=Old-style class contains __getattribute__ definition
INSP.oldstyle.class.super=Old-style class contains call for super method

# PyCompatibilityInspection
INSP.NAME.compatibility=Code compatibility inspection

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=Unnecessary backslash

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=Single quoted docstring
INSP.message.single.quoted.docstring=Triple double-quoted strings should be used for docstrings.

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=Missed call to __init__ of super class
INSP.missing.super.constructor.message=Call to __init__ of super class is missed

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=Function call can be replaced with set literal

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=Class specific decorator on method outside class

# PyPackageRequirementsInspection
INSP.NAME.requirements=Package requirements

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=Class has no __init__ method
INSP.class.has.no.init=Class has no __init__ method
INSP.parent.$0.has.no.init=Parent ''{0}'' has no __init__ method

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=Assigning function call that doesn't return anything (None)
INSP.none.function.assignment=Function ''{0}'' doesn''t return anything

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=Checks that functions decorated by pytest parametrize have correct arguments

# PyUnusedLocalInspection
INSP.NAME.unused=Unused local
INSP.unused.locals.parameter.isnot.used=Parameter ''{0}'' value is not used
INSP.unused.locals.local.variable.isnot.used=Local variable ''{0}'' value is not used
INSP.unused.locals.replace.with.wildcard=Replace with _
INSP.unused.locals.local.function.isnot.used=Local function ''{0}'' is not used
INSP.unused.locals.local.class.isnot.used=Local class ''{0}'' is not used

INSP.unused.locals.ignore.variables.starting.with=Ignore variables starting with '_'
INSP.unused.locals.ignore.range.iteration.variables=Ignore range iteration variables
INSP.unused.locals.ignore.lambda.parameters=Ignore lambda parameters
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ignore variables used in tuple unpacking

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=Chained comparisons can be simplified

# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=Assignment can be replaced with augmented assignment

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=Too broad exception clauses

# PyByteLiteralInspection
INSP.NAME.byte.literal=Byte literal contains characters > 255

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=Comparison with None performed with equality operators

# PyDictCreationInspection
INSP.NAME.dict.creation=Dictionary creation could be rewritten by dictionary literal

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=Dictionary contains duplicate keys

# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__ import must be the first executable statement

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=Reassignment of method's first argument
INSP.first.arg.$0.assigned=Method''s parameter ''{0}'' reassigned

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=Method may be static
INSP.method.may.be.static=Method <code>#ref</code> may be 'static'

# PyAbstractClassInspection
INSP.NAME.abstract.class=Class must implement all abstract methods
INSP.NAME.abstract.class.$0.must.implement=Class {0} must implement all abstract methods

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter.display.name=Assignment to 'for' loop or 'with' statement parameter
INSP.NAME.assignment.to.loop.or.with.parameter.display.message=Variable ''{0}'' already declared in ''for'' loop or ''with'' statement above
INSP.assignment.to.loop.or.with.parameter=Assignment to 'for' loop or 'with' statement parameter

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=Argument passed to function is equal to default parameter value
INSP.argument.equals.to.default=Argument equals to default parameter value

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=Coroutine ''{0}'' is not awaited
INSP.async.call=Coroutine is not awaited

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=Instance attribute defined outside __init__
INSP.attribute.$0.outside.init=Instance attribute {0} defined outside __init__
INSP.attribute.outside.init=Instance attribute defined outside __init__

# PyCallByClassInspection
INSP.NAME.different.class.call=Calling a method by class using an instance of a different class
INSP.instance.of.$0.excpected=An instance of {0} expected, not the class itself
INSP.passing.$0.instead.of.$1=Passing {0} instead of {1}. Is this intentional?

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=Missing or empty docstring
INSP.no.docstring=Missing docstring
INSP.empty.docstring=Empty docstring

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.module.$0.not.found=Module ''{0}'' not found
INSP.unresolved.ref.$0=Unresolved reference ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Unresolved attribute reference ''{0}'' for class ''{1}''
INSP.cannot.find.$0.in.$1=Cannot find reference ''{0}'' in ''{1}''
INSP.unresolved.operator.ref=Class ''{0}'' does not define ''{1}'', so the ''{2}'' operator cannot be used on its instances
python.stub=Python stub

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=Redundant parentheses
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ignore empty lists of base classes
INSP.redundant.parens.ignore.tuples=Ignore tuples
INSP.redundant.parens.ignore.argument.of.operator=Ignore argument of % operator

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=Boolean variable check can be simplified
INSP.expression.can.be.simplified=Expression can be simplified
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ignore comparison to zero

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=Incorrect docstring
INSP.missing.parameter.in.docstring=Missing parameter {0} in docstring
INSP.unexpected.parameter.in.docstring=Unexpected parameter {0} in docstring

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=Bad except clauses order
INSP.class.$0.already.caught=Exception class ''{0}'' has already been caught
INSP.class.$0.superclass.$1.already.caught=''{0}'', superclass of exception class ''{1}'', has already been caught

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=Global variable is undefined at the module level
INSP.NAME.global.$0.undefined=Global variable ''{0}'' is undefined at the module level

# PyHighlightingAnnotator
INSP.python.trailing.suffix.not.support=Python does not support a trailing ''{0}''

# PyInterpreterInspection
python.sdk.no.interpreter.configured.owner=No Python interpreter configured for the {0}

find.usages.unnamed=<unnamed>
find.usages.keyword.argument=keyword argument
find.usages.variable=variable
find.usages.imported.module.alias=imported module alias
find.usages.class=class
find.usages.function=function
find.usages.method=method
find.usages.parameter=parameter

python.find.usages=Find Usages
python.find.usages.base.method.question=Method {0} overrides method of class {1}.\nDo you want to find usages of the base method?
python.find.usages.usage.in.superclass.list=Usage in superclass list
python.find.usages.usage.in.isinstance=Usage in isinstance()
python.find.usages.untyped.probable.usage=Untyped (probable) usage
python.find.usages.usage.in.import.statement=Usage in import statement
