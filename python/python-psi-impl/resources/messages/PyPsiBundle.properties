# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Dynamic class based on {0}

### Refactoring

refactoring.extract.method.error.interrupted.execution.flow=Cannot perform refactoring when execution flow is interrupted
refactoring.extract.method.error.star.import=Cannot perform refactoring with a star import statement inside a code block
refactoring.extract.method.error.yield=Cannot perform refactoring with a 'yield' statement inside a code block

refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=Cannot place elements into a non-Python file

# introduce
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.selection.error=Cannot perform refactoring using the selected elements

# introduce variable
refactoring.introduce.variable.dialog.title=Extract Variable
refactoring.introduce.variable.scope.error=The name conflicts with an existing variable or parameter

# introduce constant
refactoring.introduce.constant.dialog.title=Extract Constant
refactoring.introduce.constant.scope.error=The name is already declared in the scope
refactoring.introduce.constant.cannot.extract.selected.expression=Selected expression cannot be extracted into a constant

# extract method
refactoring.extract.method=Extract method
refactoring.extract.method.error.bad.selection=Cannot perform the Extract Method refactoring using the selected elements
refactoring.extract.method.error.name.clash=The method name clashes with an already existing name
refactoring.extract.method.error.returns=Cannot extract a method with return instructions inside a code fragment
refactoring.extract.method.error.local.variable.modifications=Cannot perform refactoring from the expression with local variable modifications inside a code fragment.
refactoring.extract.method.error.local.variable.modifications.and.returns=Cannot perform refactoring from the expression with local variables modifications and return instructions inside a code fragment
refactoring.extract.method.error.empty.fragment=Cannot perform refactoring from an empty code fragment

refactoring.extract.method.error.class.level=Cannot perform refactoring at a class level

# inline
refactoring.inline.local.multiassignment=Definition is in multi-assign

# inline function
refactoring.inline.function.title=Inline Function
refactoring.inline.this.only=Inline this invocation only and keep the declaration
refactoring.inline.function=Inline the function {0}
refactoring.inline.method=Inline the method {0}
refactoring.inline.all.keep.declaration=Inline all invocations and keep the declaration
refactoring.inline.all.remove.declaration=Inline all invocations and remove the declaration
refactoring.inline.all.border.title=Inline
refactoring.inline.label.function=Function {0}
refactoring.inline.label.method=Method {0}
refactoring.name.label.text={0} has {1} occurrence{2, choice, 0#|1#s}
refactoring.inline.function.command.name=Inlining {0}
refactoring.inline.function.function.to.inline=Function to inline
refactoring.inline.function.invocations.to.be.inlined=Invocations to be inlined in {0} files
refactoring.inline.function.is.decorator=The function {0} is used as a decorator and cannot be inlined. The function definition will not be removed
refactoring.inline.function.is.reference=The function {0} is used as a reference and cannot be inlined. The function definition will not be removed
refactoring.inline.function.uses.unpacking=The function {0} uses argument unpacking and cannot be inlined. The function definition will not be removed
refactoring.inline.function.generator=Cannot inline generators
refactoring.inline.function.async=Cannot inline async functions
refactoring.inline.function.constructor=Cannot inline constructor calls
refactoring.inline.function.builtin=Cannot inline builtin functions
refactoring.inline.function.special.method=Cannot inline special methods
refactoring.inline.function.skeleton.only=Cannot inline a function from the binary module
refactoring.inline.function.decorator=Cannot inline functions with decorators
refactoring.inline.function.self.referrent=Cannot inline functions that reference themselves
refactoring.inline.function.star=Cannot inline functions with * arguments
refactoring.inline.function.overrides.method=Cannot inline methods that override other methods
refactoring.inline.function.is.overridden=Cannot inline overridden methods
refactoring.inline.function.global=Cannot inline functions with global variables
refactoring.inline.function.nonlocal=Cannot inline functions with nonlocal variables
refactoring.inline.function.nested=Cannot inline functions with another function declaration
refactoring.inline.function.interrupts.flow=Cannot inline functions that interrupt control flow
refactoring.inline.can.not.string.with.backslashes.or.quotes.to.f.string=Cannot inline string with backslashes and quotes to f-string
refactoring.inline.can.not.string.to.nested.f.string=Cannot inline string to nested f-string
refactoring.inline.can.not.multiline.string.to.f.string=Cannot inline multiline string to f-string

refactoring.progress.title.updating.existing.usages=Updating existing usages...

### Annotators ###
ANN.deleting.none=Deleting None
ANN.assign.to.none=Assignment to None
ANN.cant.assign.to.call=Cannot assign to function call
ANN.cant.delete.call=Cannot delete function call
ANN.cant.aug.assign.to.generator=Augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=Augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=Assign to generator expression not possible
ANN.cant.assign.to.operator=Cannot assign to operator
ANN.cant.assign.to.parens=Cannot assign to ()
ANN.cant.aug.assign.to.list.or.comprh=Augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=Cannot assign to list comprehension
ANN.cant.assign.to.dict.comprh=Cannot assign to dict comprehension
ANN.cant.assign.to.set.comprh=Cannot assign to set comprehension
ANN.cant.aug.assign.to.comprh=Augmented assign to list comprehension not possible
ANN.cant.aug.assign.to.dict.comprh=Augmented assign to dict comprehension not possible
ANN.cant.aug.assign.to.set.comprh=Augmented assign to set comprehension not possible
ANN.cant.aug.assign.starred.assignment.target.must.be.in.list.or.tuple=Starred assignment target must be in a list or tuple
ANN.cant.assign.to.literal=Cannot assign to literal
ANN.cant.delete.literal=Cannot delete literal
ANN.cant.assign.to.lambda=Cannot assign to lambda
ANN.cant.assign.to.await.expr=Cannot assign to await expression

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop

ANN.duplicate.param.name=duplicate parameter name
ANN.starred.param.after.kwparam=* parameter after ** parameter
ANN.regular.param.after.vararg=regular parameter after * parameter
ANN.regular.param.after.keyword=regular parameter after ** parameter
ANN.non.default.param.after.default=non-default parameter follows default parameter
ANN.named.parameters.after.star=named parameters must follow bare *
ANN.named.parameters.before.slash=named parameters must precede bare /
ANN.tuple.py3=tuple parameter unpacking is not supported in Python 3
ANN.multiple.args=multiple * parameters are not allowed
ANN.multiple.kwargs=multiple ** parameters are not allowed
ANN.multiple.slash=multiple / parameters are not allowed
ANN.slash.param.after.vararg=/ parameter must precede * parameter
ANN.slash.param.after.keyword=/ parameter must precede ** parameter

ANN.star.import.at.top.only='import *' only allowed at module level

ANN.missing.closing.quote=Missing closing quote [{0}]
ANN.missing.closing.triple.quotes=Missing closing triple quotes

ANN.default.except.must.be.last=default 'except:' must be last
ANN.no.exception.to.reraise=No exception to reraise

ANN.name.used.both.as.global.and.param=Name ''{0}'' is used both as a parameter and as a global

ANN.assignment.to.keyword=Assignment to keyword
ANN.cannot.assign.to.debug=Cannot assign to __debug__
ANN.unparenthesized.assignment.expression.statement=Unparenthesized assignment expressions are prohibited at the top level of an expression statement
ANN.unparenthesized.assignment.expression.value=Unparenthesized assignment expressions are prohibited at the top level of the right hand side of an assignment statement
ANN.assignment.expressions.within.a.comprehension.cannot.be.used.in.a.class.body=Assignment expressions within a comprehension cannot be used in a class body
ANN.assignment.expression.as.a.target=Assignment expression cannot be used as a target here
ANN.assignment.expression.in.an.iterable=Assignment expression cannot be used in a comprehension iterable
ANN.ignore.errors.like.this=Ignore errors like this
ANN.python.does.not.support.yield.from.inside.async.functions=Python does not support 'yield from' inside async functions
ANN.yield.outside.of.function='yield' outside of function
ANN.non.empty.return.inside.asynchronous.generator=non-empty 'return' inside asynchronous generator
ANN.return.outside.of.function='return' outside of function
ANN.can.t.use.starred.expression.here=Can't use starred expression here
ANN.illegal.target.for.variable.annotation=An illegal target for a variable annotation
ANN.variable.annotation.cannot.be.combined.with.tuple.unpacking=A variable annotation cannot be combined with tuple unpacking
ANN.variable.annotation.cannot.be.used.in.assignment.with.multiple.targets=A variable annotation cannot be used in assignment with multiple targets
ANN.generator.expression.must.be.parenthesized.if.not.sole.argument=Generator expression must be parenthesized if not sole argument

ANN.fstrings.missing.conversion.character=A conversion character is expected: should be one of 's', 'r', 'a'
ANN.fstrings.illegal.conversion.character=An illegal conversion character ''{0}'': should be one of ''s'', ''r'', ''a''
ANN.fstrings.single.right.brace.not.allowed.inside.fstrings=A single '}' is not allowed inside f-strings

ANN.patterns.single.star.pattern.cannot.be.used.outside.sequence.patterns=Single star pattern cannot be used outside sequence patterns
ANN.patterns.double.star.pattern.cannot.be.used.outside.mapping.patterns=Double star pattern cannot be used outside mapping patterns
ANN.patterns.invalid.complex.number.literal=Invalid complex number literal
ANN.patterns.key.pattern.can.only.be.value.or.literal.pattern=Key pattern can only be a value pattern or a literal pattern
ANN.patterns.pattern.makes.remaining.alternatives.unreachable=Pattern makes remaining alternatives unreachable
ANN.patterns.pattern.makes.remaining.case.clauses.unreachable=Pattern makes remaining case clauses unreachable
ANN.patterns.pattern.does.not.bind.names=Pattern does not bind {0,choice,1#name|2#names} {1}
ANN.patterns.attribute.name.is.repeated=Attribute name ''{0}'' is repeated
ANN.patterns.name.already.bound=Name ''{0}'' is already bound

ANN.try.except.can.not.have.except.and.star.except=Try statement cannot contain both except and except*
ANN.exception.group.in.star.except=ExceptionGroup cannot be used in except*
ANN.continue.break.or.return.in.star.except='break', 'continue' and 'return' cannot appear in an except* block

ANN.await.outside.async.function='await' outside async function

### quick doc generator
QDOC.module.path.unknown=(Module path is unknown)
QDOC.epydoc.python2.sdk.not.found=You need a configured Python 2 SDK to render <a href='http://epydoc.sourceforge.net/'>Epydoc</a> docstrings
QDOC.local.sdk.not.found=You need a configured local Python SDK to render docstrings.
QDOC.assigned.to=Assigned to:
QDOC.copied.from=Copied from:
QDOC.accessor.kind=Accessor kind:
QDOC.raises=Raises:
QDOC.keyword.args=Keyword args:
QDOC.returns=Returns:
QDOC.params=Params:
QDOC.attributes=Attributes:
QDOC.class=class
QDOC.parameter.name.of.link=Parameter {0} of {1}
QDOC.property.name.of.link=Property {0} of {1}
QDOC.property.getter=property getter
QDOC.not.defined.in.parentheses=(not defined)
QDOC.instance.attribute=Instance attribute {0} of {1}
QDOC.class.attribute=Class attribute {0} of {1}
QDOC.built.in.description=built-in description
QDOC.package.name=Package {0}
QDOC.module.name=Module {0}
QDOC.inferred.type.name=Inferred type: {0}
QDOC.variable.name=Variable "{0}"
QDOC.parameter.of.function.name=Parameter "{0}" of function "{1}"
QDOC.parameter.of.method.name=Parameter "{0}" of method "{1}"
QDOC.parameter.name=Parameter "{0}"
QDOC.type.parameter.name.of.link=Type parameter {0} of {1}
QDOC.type.parameter.name=Type parameter {0}
QDOC.type.parameter.kind=kind:
QDOC.type.alias.statement.name.of.link=Type alias statement {0} of {1}

ignore.overridden.functions=Ignore overridden functions

### Intentions ###

INTN.category.python=Python

INTN.replace.octal.numeric.literal=Convert octal numeric literal to supported form
INTN.convert.builtin.import=Convert builtin module import to supported form

QFIX.NAME.convert.builtin=Convert builtin module import

INTN.NAME.convert.import.unqualify=Convert 'import module' to 'from module import'
INTN.convert.to.from.import=Convert to ''from {0} import {1}''

INTN.NAME.convert.import.qualify=Convert 'from module import' to 'import module'
INTN.convert.to.plain.import=Convert to ''import {0}''

INTN.add.qualifier=Add ''{0}'' qualifier
INTN.remove.qualifier=Remove ''{0}'' qualifier
INTN.multiple.usages.of.import.found=Multiple Usages of the Import Found
INTN.remove.qualifier.from.this.name=Remove qualifier from this name
INTN.remove.qualifier.from.all.usages=Remove qualifier from all usages

INTN.convert.except.to=Convert 'except exceptClass, Target' to 'except exceptClass as Target'

INTN.NAME.toggle.import.alias=Switch using import aliases
INTN.add.import.alias=Add alias
INTN.add.import.alias.to.name=Add alias to ''{0}''
INTN.add.import.alias.dialog.message=Alias for ''{0}'':
INTN.add.import.alias.title=Add Alias
INTN.remove.import.alias=Remove alias ''{0}''

INTN.replace.noteq.operator=Replace not equal operator

QFIX.NAME.remove.string.prefix=Remove prefix
QFIX.remove.string.prefix=Remove leading {0}

INTN.replace.backquote.expression=Replace backquote expression
INTN.replace.raise.statement=Convert raise statement to supported form

INTN.replace.list.comprehensions=Convert list comprehensions to supported form

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=Convert to f-string literal
INTN.replace.with.method=Replace with str.format method call

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=Convert format operator to 'str.format' method call

INTN.replace.list.comprehensions.with.for=Convert list comprehensions to 'for' loop

INTN.NAME.split.if=Split 'if' statement
INTN.split.if=Split into 2 'if' statements

INTN.NAME.negate.comparison=Negate comparison
INTN.negate.comparison=Negate ''{0}'' to ''{1}''

INTN.string.concatenation.to.format=Replace string concatenation with 'str.format'
INTN.replace.plus.with.format.operator=Replace + with string formatting operator
INTN.replace.plus.with.str.format=Replace + with str.format method call


INTN.NAME.flip.comparison=Flip comparison
INTN.flip.comparison=Flip ''{0}''
INTN.flip.comparison.to.operator=Flip ''{0}'' to ''{1}''

INTN.NAME.join.if=Join 'if' statements
INTN.join.if=Join two 'if' statements

INTN.convert.dict.constructor.to.dict.literal=Convert dict constructor to dict literal
INTN.convert.dict.literal.to.dict.constructor=Convert dict literal to dict constructor

INTN.quoted.string=Convert single-quoted to double-quoted strings and vice versa
INTN.quoted.string.single.to.double=Convert single-quoted string to double-quoted string
INTN.quoted.string.double.to.single=Convert double-quoted string to single-quoted string

INTN.convert.lambda.to.function=Convert lambda to function

INTN.convert.variadic.param=Convert variadic parameters to normal

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=Convert triple-quoted string to single-quoted string

# PyBaseConvertCollectionLiteralIntention
INTN.NAME.convert.collection.literal=Convert collection to {0}
INTN.convert.collection.literal=Convert {0} to {1}

# PyConvertTypeCommentToVariableAnnotation
INTN.NAME.convert.type.comment.to.variable.annotation=Convert type comment to variable annotation
INTN.convert.type.comment.to.variable.annotation=Convert to a variable annotation

INTN.NAME.demorgan.law=De Morgan's law

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=Transform conditional expressions into 'if/else' statements

# PyGenerateDocstringIntention
INTN.NAME.insert.docstring.stub=Insert docstring stub
INTN.insert.docstring.stub=Insert a documentation string stub
INTN.add.parameters.to.docstring=Add parameters to docstring

#SpecifyTypeInDocstringIntention
INTN.NAME.specify.type.in.docstring=Specify type for reference in docstring
INTN.specify.type.in.docstring=Specify type for the reference in docstring
INTN.specify.return.type.in.docstring=Specify return type in docstring

#HideTypeAnnotationsIntention
INTN.NAME.hide.type.annotations=Hide type annotations
INTN.hide.type.annotations=Hide type annotations

#SpecifyTypeInPy3AnnotationsIntention
INTN.NAME.specify.type.in.annotation=Specify type for reference using annotation
INTN.specify.type.in.annotation=Specify type for the reference using annotation
INTN.specify.return.type.in.annotation=Specify return type using annotation

#PyAnnotateTypesIntention
INTN.NAME.add.type.hints.for.function=Add type hints for function
INTN.add.type.hints.for.function=Add type hints for function ''{0}''

# PyAnnotateVariableTypeIntention
INTN.NAME.add.type.hint.for.variable=Add type hint for variable
INTN.add.type.hint.for.variable=Add type hint for variable ''{0}''
INTN.add.type.hint.for.variable.PEP484.incompatible.type=Type ''{0}'' cannot be expressed inline in PEP 484 format

#TypeAssertionIntention
INTN.insert.assertion=Insert type assertion

#PyYieldFromIntention
INTN.yield.from=Transform explicit iterations with 'yield' into 'yield from' expressions

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=Convert static method to function

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=Convert method to property

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=Convert relative import to absolute
INTN.convert.absolute.to.relative=Convert absolute import to relative

#PyInvertIfConditionIntention
INTN.invert.if.condition=Invert 'if' condition

### Quick-fixes ###
QFIX.add.qualifier=Add qualifier

QFIX.NAME.auto.import=Import
QFIX.auto.import.import.this.name=Import this name
QFIX.auto.import.import.name=Import ''{0}''

QFIX.NAME.local.auto.import=Import locally
QFIX.local.auto.import.import.locally={0} locally

QFIX.augment.assignment=Replace assignment with augmented assignment
QFIX.NAME.remove.call=Remove call
QFIX.replace.equality=Replace equality
QFIX.dict.creation=Replace dictionary creation
QFIX.NAME.remove.dict.key=Remove this key
QFIX.NAME.move.except.up=Move except clause up
QFIX.NAME.add.field.to.class=Add field to class
QFIX.add.field.to.class=Add field ''{0}'' to class {1}
QFIX.add.field.to.class.popup.content.added.init=Added a __init__ to class <code>{0}</code><br/>to accommodate new field <code>{1}</code>
QFIX.NAME.remove.parameter=Remove parameter
QFIX.NAME.rename.parameter=Rename parameter
QFIX.rename.parameter=Rename to ''{0}''
QFIX.NAME.remove.statement=Remove statement
QFIX.NAME.remove.with.target=Remove 'with' target
QFIX.NAME.remove.exception.target=Remove exception target
QFIX.NAME.remove.assignment.target=Remove assignment target
QFIX.failed.to.add.field=<br/>Failed to add a field!<br/><br/>
QFIX.redundant.parentheses=Remove redundant parentheses
QFIX.NAME.simplify.boolean.expression=Simplify boolean expression
QFIX.simplify.boolean.expression=Replace boolean expression with ''{0}''
QFIX.chained.comparison=Simplify chained comparison
QFIX.move.from.future.import=Move 'from __future__ import' to a correct place
QFIX.list.creation=Replace with a list literal
QFIX.add.super=Add super class call
QFIX.NAME.remove.assignment=Remove assignment
QFIX.NAME.remove.argument=Remove argument
QFIX.add.parameter.self=Add parameter ''{0}''
QFIX.statement.effect=Replace with function call
QFIX.remove.trailing.semicolon=Remove trailing semicolon
QFIX.introduce.variable=Introduce variable for statement
QFIX.NAME.make.list=Replace tuple with list
QFIX.NAME.add.specifier=Add format specifier character
QFIX.add.global=Add global statement
QFIX.create.property=Create property
QFIX.add.property=Add property for the field
QFIX.use.property=Use property for the field
QFIX.make.public=Make public
QFIX.NAME.update.parameters=Update parameters
QFIX.convert.to.new.style=Convert to New-style class
QFIX.change.base.class=Change base class
QFIX.classic.class.transform=Inherit from object
QFIX.NAME.rename.argument=Rename argument
QFIX.NAME.add.exception.base=Add Exception base class
QFIX.add.encoding=Add encoding declaration
QFIX.remove.trailing.suffix=Remove trailing suffix
QFIX.action.failed=Action failed
QFIX.create.class=Create class
QFIX.create.class.0=Create class ''{0}''
QFIX.create.class.in.module=Create class ''{0}'' in module {1}

QFIX.optimize.imports=Optimize imports
QFIX.unresolved.reference=Replace ''{0}'' with ''{1}.{0}''

QFIX.NAME.unresolved.reference.add.param=Create parameter for reference
QFIX.unresolved.reference.add.param=Create parameter ''{0}''

#PyRenameUnresolvedRefQuickFix
QFIX.rename.unresolved.reference=Rename reference

# UnresolvedRefCreateFunctionQuickFix
QFIX.unresolved.reference.create.function=Create function
QFIX.NAME.unresolved.reference.create.function=Create function ''{0}''

#UnresolvedRefTrueFalseQuickFix
QFIX.NAME.replace.with.true.or.false=Replace with True or False
QFIX.replace.with.true.or.false=Replace with {0}

#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=Remove underscores in numeric literals

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=Replace function call with set literal

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=Remove arguments equal to default

#PyDefaultArgumentQuickFix
QFIX.default.argument=Replace mutable default argument

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=Move attribute to __init__ method

#DocstringQuickFix
QFIX.NAME.docstring=Fix docstring
QFIX.docstring.add.parameter=Add docstring parameter ''{0}''
QFIX.docstring.remove.parameter=Remove docstring parameter ''{0}''
QFIX.docstring.insert.stub=Insert docstring

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=Make method static

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=Make function from method

#ConvertIndents
QFIX.convert.indents=Convert indents
QFIX.convert.indents.to.tabs=Convert indents to tabs
QFIX.convert.indents.to.spaces=Convert indents to spaces

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=Convert docstring to the triple double-quoted string form

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=Remove unnecessary backslash in expression

#RemoveDecoratorQuickFix
QFIX.remove.decorator=Remove decorator

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.function.return.type=Make function return inferred type
QFIX.make.function.return.type=Make ''{0}'' return ''{1}''

# Add method quick-fix
QFIX.NAME.add.method.to.class=Add method to class
QFIX.add.method.to.class=Add method {0}() to class {1}
QFIX.failed.to.add.method=<br/>Failed to add a method!<br/><br/>

QFIX.NAME.create.function.in.module=Create function in module
QFIX.create.function.in.module=Create function {0}() in module {1}
QFIX.failed.to.add.function=<br/>Failed to add a function!<br/><br/>

# InstallAndImportQuickFix
QFIX.install.and.import.package=Install and import package
QFIX.NAME.install.and.import.package=Install and import package ''{0}''

# PyAsyncCallInspection
QFIX.coroutine.is.not.awaited=Coroutine is not awaited

# PyTestUnpassedFixtureInspection
INSP.NAME.pytest.unpassed.fixture=Fixture is not requested by test functions
INSP.use.fixture.without.declaration.in.test.function=Fixture ''{0}'' is not requested by test functions or '@pytest.mark.usefixtures' marker
QFIX.add.fixture.to.test.function.parameters.list=Add fixture to test function parameters

# PyReplaceStarByUnpackQuickFix
QFIX.replace.star.by.unpack=Replace by typing_extensions.Unpack


# Actions and associated commands
ACT.CMD.use.import=Use an imported module
ACT.qualify.with.module=Qualify with an imported module
ACT.from.some.module.import=Import from\u2026


filetype.python.docstring.description=Python docstring
filetype.python.function.type.annotation.description=Python PEP-484 function type comment
filetype.python.type.hint.description=Python PEP-484 type hint
python.docstring.format=Docstring format:
python.docstring.select.type=Select Docstring Type

### Inspections: INSP ###
INSP.GROUP.python=Python

INSP.abstract.class.set.as.metaclass=Set ''{0}'' as metaclass
INSP.abstract.class.add.to.superclasses=Add ''{0}'' to superclasses
INSP.named.tuple=Invalid definition of 'typing.NamedTuple'
INSP.shadows.name.from.outer.scope=Shadows name ''{0}'' from outer scope
INSP.trailing.semicolon=Trailing semicolon in the statement
INSP.protected.member.ignore.annotations=Ignore annotations
INSP.protected.member.ignore.test.functions=Ignore test functions
INSP.docstring.types.fix.docstring=Fix docstring
INSP.docstring.types.change.type=Change {0} type from {1} to {2}
INSP.interpreter.configure.python.interpreter=Configure Python interpreter
INSP.interpreter.interpreter.settings=Interpreter settings
INSP.interpreter.use.interpreter=Use {0}
INSP.interpreter.use.suggested.interpreter=Use suggested interpreter
INSP.method.parameters.metaclass.method.first.argument.name=Metaclass method first argument name

INSP.package.requirements.requirements.have.been.ignored=Requirements have been ignored
INSP.package.requirements.requirement.has.been.ignored=''{0}'' has been ignored
INSP.package.requirements.add.import=Add Import
INSP.package.requirements.administrator.privileges.required=Administrator Privileges Required
INSP.package.requirements.administrator.privileges.required.description=\
  Installing packages into ''{0}'' requires administrator privileges.\n\n\
  Configure a per-project virtual environment as your project interpreter\n\
  to avoid installing packages to a protected area of the file system.
INSP.package.requirements.administrator.privileges.required.button.configure=Configure
INSP.package.requirements.administrator.privileges.required.button.install.anyway=Install Anyway
INSP.package.requirements.requirements.file.empty=Requirements file is empty
QFIX.add.imported.packages.to.requirements=Add imported packages to requirements\u2026

INSP.pep8.ignore.base.class=Ignore Base Class
INSP.pep8.ignore.method.names.for.descendants.of.class=Ignore method names for descendants of class
INSP.stub.packages.compatibility.ignore=Ignore ''{0}'' compatibility
INSP.stub.packages.compatibility.ignored.packages.label=Ignored stub packages:
INSP.stub.packages.compatibility.incompatible.packages.message=''{0}{1}{2}'' is incompatible with ''{3}{4}{5}''. Expected ''{6}'' version: [{7}]
INSP.arguments.not.declared.but.provided.by.decorator=Following arguments are not declared but provided by decorator: {0}
INSP.pep8.coding.style.violation=PEP 8 coding style violation
INSP.shadowing.names=Shadowing names from outer scopes
INSP.stub.packages.compatibility=Incompatible stub packages
INSP.stub.packages=Stub packages advertiser

# PyCallingNonCallableInspection
INSP.NAME.calling.non.callable=Attempt to call a non-callable object
INSP.class.object.is.not.callable=''{0}'' object is not callable
INSP.symbol.is.not.callable=''{0}'' is not callable
INSP.expression.is.not.callable=Expression is not callable

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.unexpected.arg=Unexpected argument
INSP.unexpected.arg(s)=Unexpected argument(s)
INSP.parameter.unfilled=Parameter ''{0}'' unfilled
INSP.parameter(s).unfilled=Parameter(s) unfilled
INSP.possible.callees=Possible callees
INSP.function.lacks.positional.argument=Function ''{0}'' lacks a positional argument
INSP.expected.dict.got.type=Expected a dictionary, got {0}
INSP.expected.iterable.got.type=Expected an iterable, got {0}

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Improper first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called ''{0}''
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'
INSP.usually.named=Usually first parameter of such methods is named ''{0}''
INSP.first.param.must.not.be.tuple=First parameter of a non-static method must not be a tuple

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=Problematic nesting of decorators
INSP.decorator.receives.unexpected.builtin=This decorator will not receive a callable it may expect; the built-in decorator returns a special object

# PyRedeclarationInspection
INSP.NAME.redeclaration=Redeclared names without usages
INSP.redeclared.name=Redeclared ''{0}'' defined above without usage

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=''{0}'' in the try block with ''except ImportError'' should also be defined in the except block
INSP.unused.import.statement=Unused import statement <code>#ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=An invalid interpreter
INSP.interpreter.pipenv.interpreter.associated.with.another.project=Pipenv interpreter is associated with another project: ''{0}''
INSP.interpreter.pipenv.interpreter.associated.with.another.module=Pipenv interpreter is associated with another module: ''{0}''
INSP.interpreter.pipenv.interpreter.not.associated.with.any.project=Pipenv interpreter is not associated with any project
INSP.interpreter.pipenv.interpreter.not.associated.with.any.module=Pipenv interpreter is not associated with any module
INSP.interpreter.invalid.python.interpreter.selected.for.project=Invalid Python interpreter selected for the project
INSP.interpreter.invalid.python.interpreter.selected.for.module=Invalid Python interpreter selected for the module
INSP.interpreter.python.has.reached.its.end.of.life.and.is.no.longer.supported.in.pycharm=Python {0} has reached its end-of-life date and it is no longer supported in PyCharm
INSP.interpreter.python.has.reached.its.end.life.and.is.no.longer.supported.in.python.plugin=Python {0} has reached its end-of-life date and it is no longer supported in the Python plugin
INSP.interpreter.no.python.interpreter.configured.for.project=No Python interpreter configured for the project
INSP.interpreter.no.python.interpreter.configured.for.module=No Python interpreter configured for the module

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ method that returns a value
INSP.cant.return.value.from.init=Cannot return a value from __init__

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=Unreachable code
INSP.unreachable.code=This code is unreachable

# PyStringFormatInspection
INSP.NAME.str.format=Errors in string formatting operations
INSP.format.requires.no.mapping=Format does not require a mapping
INSP.str.format.key.has.no.argument=Key ''{0}'' has no corresponding argument
INSP.str.format.unexpected.argument.type=Unexpected type {0}
INSP.too.few.keys=Too few mapping keys
INSP.no.format.specifier.char=Format specifier character missing
INSP.format.requires.mapping=Format requires a mapping
INSP.too.many.args.for.fmt.string=Too many arguments for format string
INSP.too.few.args.for.fmt.string=Too few arguments for format string
INSP.incompatible.options=The format options in chunk "{0}" are incompatible
INSP.unsupported.format.character=Unsupported format character ''{0}''
INSP.manual.to.auto.field.numbering=Cannot switch from manual field specification to automatic field numbering
INSP.auto.to.manual.field.numbering=Cannot switch from automatic field numbering to manual field specification
INSP.str.format.unsupported.format.character.b=Unsupported format character 'b'
INSP.str.format.can.not.use.star.in.formats.when.using.mapping=Cannot use '*' in formats when using a mapping

# PyMethodOverridingInspection
INSP.NAME.method.over=Method signature does not match signature of overridden method
INSP.signature.mismatch=Signature of method ''{0}'' does not match signature of the base method in class ''{1}''

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=Incompatible signatures of __new__ and __init__
INSP.new.incompatible.to.init=Signature is not compatible to __init__
INSP.init.incompatible.to.new=Signature is not compatible to __new__

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=Prohibited trailing semicolon in a statement


# PyUnboundLocalVariableInspection
INSP.NAME.unbound=Unbound local variables
INSP.unbound.local.variable=Local variable ''{0}'' might be referenced before assignment
INSP.unbound.nonlocal.variable=Nonlocal variable ''{0}'' must be bound in an outer function scope
INSP.unbound.name.undefined=Name ''{0}'' can be undefined
INSP.unbound.function.too.large=Function ''{0}'' is too large to analyse

# PyListCreationInspection
INSP.NAME.list.creation=Non-optimal list declaration
INSP.list.creation.this.list.creation.could.be.rewritten.as.list.literal=Multi-step list initialization can be replaced with a list literal

# PyTupleAssignmentBalanceInspection
INSP.NAME.tuple.assignment.balance=Tuple assignment balance is incorrect
INSP.tuple.assignment.balance.only.one.starred.expression.allowed.in.assignment=Only one starred expression allowed in assignment
INSP.tuple.assignment.balance.need.more.values.to.unpack=Need more values to unpack
INSP.tuple.assignment.balance.too.many.values.to.unpack=Too many values to unpack

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=Classic style class usage
INSP.classic.class.usage.old.style.class=Old-style class
INSP.classic.class.usage.old.style.class.ancestors=Old-style class, because all classes from whom it inherits are old-style


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=Exceptions do not inherit from standard 'Exception' class
INSP.exception.inheritance.exception.does.not.inherit.from.base.exception.class=Exception doesn't inherit from base 'Exception' class

# PyDefaultArgumentInspection
INSP.NAME.default.argument=The default argument is mutable
INSP.default.arguments.default.argument.value.mutable=Default argument value is mutable

# PyDocstringTypesInspection
INSP.NAME.docstring.types=Type in docstring does not match inferred type
INSP.docstring.types.dynamically.inferred.type.does.not.match.specified.type=Dynamically inferred type ''{0}'' doesn''t match specified type ''{1}''

# PyStatementEffectInspection
INSP.NAME.statement.effect=Statement has no effect
INSP.statement.effect.statement.seems.to.have.no.effect=Statement seems to have no effect
INSP.statement.effect.statement.having.no.effect.can.be.replaced.with.function.call=Statement seems to have no effect and can be replaced with a function call to have effect

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=Wrong arguments to call super
INSP.class.is.not.subtype.of.class=''{0}'' is not an instance or a subclass of ''{1}''

# PyNonAsciiCharInspection
INSP.NAME.non.ascii=File contains non-ASCII character
INSP.non.ascii.char.non.ascii.character.in.file.but.no.encoding.declared=Non-ASCII character ''{0}'' in the file, but no encoding declared

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=No encoding specified for file
INSP.mandatory.encoding.label.encoding.comment.format=Encoding comment format:
INSP.mandatory.encoding.label.select.default.encoding=Select default encoding:
INSP.mandatory.encoding.checkbox.enable.in.python.3=Enable in Python 3+
INSP.mandatory.encoding.no.encoding.specified.for.file=No encoding specified for file

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=Tuple item assignment is prohibited
INSP.tuples.never.assign.items=Tuples don't support item assignment

# PyPropertyAccessInspection
INSP.NAME.property.access=Inappropriate access to properties
INSP.property.cannot.be.set=Property ''{0}'' cannot be set
INSP.property.cannot.be.read=Property ''{0}'' cannot be read
INSP.property.cannot.be.deleted=Property ''{0}'' cannot be deleted

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=Incorrect property definition
INSP.doc.param.should.be.str=The doc parameter should be a string
INSP.strange.arg.want.callable=Strange argument; a callable is expected
INSP.func.property.name.mismatch=Names of function and decorator don't match; property accessor is not created
INSP.getter.return.smth=Getter should return or yield something
INSP.setter.should.not.return=Setter should not return a value
INSP.deleter.should.not.return=Deleter should not return a value
INSP.getter.signature.advice=Getter signature should be (self)
INSP.setter.signature.advice=Setter signature should be (self, value)
INSP.deleter.signature.advice=Deleter signature should be (self)

# PyProtectedMemberInspection
INSP.NAME.protected.member=Accessing a protected member of a class or a module
INSP.protected.member.access.to.protected.member.of.class=Access to a protected member {0} of a class
INSP.protected.member.access.to.protected.member.of.module=Access to a protected member {0} of a module
INSP.protected.member.name.not.declared.in.all=''{0}'' is not declared in __all__

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=Old-style class contains new-style class features
INSP.oldstyle.class.slots=Old-style class contains __slots__ definition
INSP.oldstyle.class.getattribute=Old-style class contains __getattribute__ definition
INSP.oldstyle.class.super=Old-style class contains call for super method

# PyCompatibilityInspection
INSP.NAME.compatibility=Code is incompatible with specific Python versions
INSP.compatibility.this.syntax.available.only.since.py3=This syntax available only since Python 3
INSP.compatibility.check.for.compatibility.with.python.versions=Check for compatibility with python versions:
INSP.compatibility.inspection.unsupported.feature.prefix=Python {0,choice,1#version|2#versions} {1} {0,choice,1#does|2#do} not {2}
INSP.compatibility.feature.support.variable.annotations=support variable annotations
INSP.compatibility.feature.support.this.syntax=support this syntax
INSP.compatibility.feature.support.type.alias.statements=support type alias statements
INSP.compatibility.feature.have.module.builtins=have module builtins
INSP.compatibility.feature.have.module.builtin=have module __builtin__
INSP.compatibility.feature.support.starred.expressions.as.assignment.targets=support starred expressions as assignment targets
INSP.compatibility.feature.support.starred.expressions.in.tuples.lists.and.sets=support starred expressions in tuples, lists, and sets
INSP.compatibility.feature.support.unpacking.without.parentheses.in.return.statements=support unpacking without parentheses in return statements
INSP.compatibility.feature.support.unpacking.without.parentheses.in.yield.statements=support unpacking without parentheses in yield statements
INSP.compatibility.feature.support.starred.expressions.in.dicts=support starred expressions in dicts
INSP.compatibility.feature.support.starred.expressions.in.subscriptions=support starred expressions in subscriptions
INSP.compatibility.feature.support.starred.expressions.in.type.annotations=support starred expressions in type annotations
INSP.compatibility.feature.support.diamond.operator=support <>, use != instead
INSP.compatibility.feature.support.matrix.multiplication.operators=support matrix multiplication operators
INSP.compatibility.feature.support.long.integer.literal.suffix=support a trailing ''{0}''
INSP.compatibility.feature.support.old.style.octal.literals=support this syntax. It requires '0o' prefix for octal literals
INSP.compatibility.feature.support.underscores.in.numeric.literals=support underscores in numeric literals
INSP.compatibility.feature.support.string.literal.prefix=support a ''{0}'' prefix
INSP.compatibility.feature.allow.to.mix.bytes.and.non.bytes.literals=allow to mix bytes and non-bytes literals
INSP.compatibility.feature.support.this.syntax.in.list.comprehensions=support this syntax in list comprehensions
INSP.compatibility.feature.support.raise.with.no.arguments.outside.except.block=support this syntax. Raise with no arguments can only be used in an except block
INSP.compatibility.feature.support.backquotes=support backquotes, use repr() instead
INSP.compatibility.feature.support.print.statement=support this syntax. The print statement has been replaced with a print() function
INSP.compatibility.feature.support.super.without.arguments=support this syntax. super() should have arguments in Python 2
INSP.compatibility.feature.allow.quote.reuse.in.f-strings=allow nesting of string literals with the same quote type inside f-strings
INSP.compatibility.feature.allow.new.lines.in.f-strings=allow new lines in expression parts of non-triple-quoted f-strings
INSP.compatibility.feature.allow.deep.expression.nesting.in.f-strings=allow nesting expressions in format specifiers this deep
INSP.compatibility.feature.allow.backslashes.in.f-strings=allow backslashes inside expression parts of f-strings
INSP.compatibility.feature.line.comments.in.f-strings=allow comments inside expression parts of f-strings
INSP.compatibility.feature.support.yield.from=support this syntax. Delegating to a subgenerator is available since Python 3.3; use explicit iteration over subgenerator instead.
INSP.compatibility.pre35.versions.do.not.allow.return.with.argument.inside.generator=Python versions < 3.3 do not allow 'return' with argument inside generator.
INSP.compatibility.feature.support.ellipsis.outside.slices=support '...' outside of sequence slicings
INSP.compatibility.feature.have.nonlocal.keyword=have nonlocal keyword
INSP.compatibility.keyword.argument.repeated=Keyword argument repeated
INSP.compatibility.feature.allow.keyword.arguments.after.kwargs=allow keyword arguments after **expression
INSP.compatibility.feature.allow.duplicate.kwargs=allow duplicate **expressions
INSP.compatibility.feature.allow.duplicate.positional.varargs=allow duplicate *expressions
INSP.compatibility.feature.allow.positional.arguments.after.expression=allow positional arguments after *expression
INSP.compatibility.positional.argument.after.keyword.argument=Positional argument after keyword argument
INSP.compatibility.positional.argument.after.kwargs=Positional argument after **expression
INSP.compatibility.feature.allow.trailing.comma.after.kwargs=allow a trailing comma after **expression
INSP.compatibility.feature.allow.trailing.comma.after.positional.vararg=allow a trailing comma after *expression
INSP.compatibility.feature.support.positional.only.parameters=support positional-only parameters
INSP.compatibility.support.equality.signs.in.fstrings=support equality signs in f-strings
INSP.compatibility.feature.support.assignment.expressions=support assignment expressions
INSP.compatibility.feature.support.continue.inside.finally.clause=support 'continue' inside 'finally' clause
INSP.compatibility.feature.support.arbitrary.expressions.as.decorator=support arbitrary expressions as a decorator
INSP.compatibility.feature.have.type.long=have type long. Use int instead.
INSP.compatibility.feature.have.method=have method {0}
INSP.compatibility.feature.have.module=have module {0}
INSP.compatibility.feature.allow.async.and.await.as.names=allow 'async' and 'await' as names
INSP.compatibility.old.dict.methods.not.available.in.py3=dict.iterkeys(), dict.iteritems(), and dict.itervalues() methods are not available in Python 3
INSP.compatibility.basestring.type.not.available.in.py3=basestring type is not available in Python 3
INSP.compatibility.new.union.syntax.not.available.in.earlier.version=allow writing union types as X | Y
INSP.compatibility.feature.support.match.statements=support match statements
INSP.compatibility.feature.support.parenthesized.context.expressions=support parenthesized context expressions
INSP.compatibility.feature.support.starred.except.part=support except* part

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=Unnecessary backslash
INSP.unnecessary.backslash.unnecessary.backslash.in.expression=Unnecessary backslash in the expression

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=Single quoted docstring
INSP.message.single.quoted.docstring=Triple double-quoted strings should be used for docstrings.

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=Missed call to '__init__' of the super class
INSP.missing.super.constructor.message=Call to __init__ of super class is missed

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=Function call can be replaced with set literal

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=Class-specific decorator is used outside the class
INSP.decorators.method.only.decorator.on.method.outside.class=Decorator {0} on a method outside the class

# PyPackageRequirementsInspection
INSP.NAME.requirements=Unsatisfied package requirements
INSP.requirements.ignore.packages.label=Ignored packages:
INSP.requirements.package.requirements.not.satisfied=Package {1,choice,1#requirement|2#requirements} {0} {1,choice,1#is|2#are} not satisfied
INSP.requirements.package.containing.module.not.listed.in.project.requirements=Package containing module ''{0}'' is not listed in the project requirements
QFIX.NAME.install.requirements=Install {0,choice,1#requirement|2#requirements}
QFIX.NAME.ignore.requirements=Ignore {0,choice,1#requirement|2#requirements}

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=Class has no `__init__` method
INSP.class.has.no.init=Class has no __init__ method

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=Assigning function calls that don't return anything
INSP.none.function.assignment=Function ''{0}'' doesn''t return anything

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=Incorrect arguments in @pytest.mark.parametrize

# PyUnusedLocalInspection
INSP.NAME.unused=Unused local symbols
INSP.unused.locals.parameter.isnot.used=Parameter ''{0}'' value is not used
INSP.unused.locals.local.variable.isnot.used=Local variable ''{0}'' value is not used
INSP.unused.locals.replace.with.wildcard=Replace with _
INSP.unused.locals.local.function.isnot.used=Local function ''{0}'' is not used
INSP.unused.locals.local.class.isnot.used=Local class ''{0}'' is not used

INSP.unused.locals.ignore.variables.starting.with=Ignore variables starting with '_'
INSP.unused.locals.ignore.range.iteration.variables=Ignore range iteration variables
INSP.unused.locals.ignore.lambda.parameters=Ignore lambda parameters
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=Ignore variables used in tuple unpacking

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=Too complex chained comparisons
INSP.chained.comparisons.ignore.statements.with.constant.in.the.middle=Ignore statements with a constant in the middle
INSP.simplify.chained.comparison=Simplify chained comparison

# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=Assignment can be replaced with augmented assignment
INSP.assignment.can.be.replaced.with.augmented.assignment=Assignment can be replaced with an augmented assignment

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=Unclear exception clauses
INSP.too.broad.exception.clause=Too broad exception clause

# PyByteLiteralInspection
INSP.NAME.byte.literal=A byte literal contains a non-ASCII character
INSP.byte.literal.contains.illegal.characters=Byte literal contains characters > 255

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=Using equality operators to compare with None
INSP.comparison.with.none.performed.with.equality.operators=Comparison with None performed with equality operators

# PyDictCreationInspection
INSP.NAME.dict.creation=Dictionary creation can be rewritten by dictionary literal
INSP.dict.creation.this.dictionary.creation.could.be.rewritten.as.dictionary.literal=This dictionary creation could be rewritten as a dictionary literal

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=Dictionary contains duplicate keys
INSP.duplicate.keys.dictionary.contains.duplicate.keys=Dictionary contains duplicate keys ''{0}''

# PyFromFutureImportInspection
INSP.NAME.from.future.import=Improper position of from __future__ import
INSP.from.future.import.from.future.imports.must.occur.at.beginning.file=from __future__ imports must occur at the beginning of the file

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=First argument of the method is reassigned
INSP.first.arg.assign.method.parameter.reassigned=Method''s parameter ''{0}'' reassigned

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=Method is not declared static
INSP.method.may.be.static=Method <code>#ref</code> may be 'static'

# PyAbstractClassInspection
INSP.NAME.abstract.class=Class must implement all abstract methods
INSP.abstract.class.class.must.implement.all.abstract.methods=Class {0} must implement all abstract methods

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter=Assignments to 'for' loop or 'with' statement parameter
INSP.assignment.to.loop.or.with.parameter=Variable ''{0}'' is already declared in ''for'' loop or ''with'' statement above

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=The function argument is equal to the default parameter value
INSP.argument.equals.to.default=Argument equals to the default parameter value

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=Coroutine ''{0}'' is not awaited
INSP.async.call=Missing `await` syntax in coroutine calls

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=An instance attribute is defined outside `__init__`
INSP.attribute.outside.init=Instance attribute {0} defined outside __init__

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=Missing or empty docstring
INSP.no.docstring=Missing docstring
INSP.empty.docstring=Empty docstring

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.unresolved.refs.module.not.found=Module ''{0}'' not found
INSP.unresolved.refs.unresolved.reference=Unresolved reference ''{0}''
INSP.unresolved.refs.unresolved.attribute.for.class=Unresolved attribute reference ''{0}'' for class ''{1}''
INSP.unresolved.refs.cannot.find.reference.in.type=Cannot find reference ''{0}'' in ''{1}''
INSP.unresolved.refs.class.object.has.no.attribute=''{0}'' object has no attribute ''{1}''
INSP.unresolved.refs.import.resolves.to.its.containing.file=Import resolves to its containing file
INSP.unresolved.refs.class.does.not.define.operator=Class ''{0}'' does not define ''{1}'', so the ''{2}'' operator cannot be used on its instances
INSP.unresolved.refs.ignore.references.label=Ignored references:
unresolved.docstring.param.reference=Function ''{0}'' does not have a parameter ''{1}''
unresolved.import.reference=No module named ''{0}''

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=Redundant parentheses
INSP.redundant.parens.ignore.empty.lists.of.base.classes=Ignore empty lists of base classes
INSP.redundant.parens.ignore.tuples=Ignore tuples
INSP.redundant.parens.ignore.argument.of.operator=Ignore argument of % operator

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=Redundant boolean variable check
INSP.expression.can.be.simplified=Expression can be simplified
INSP.simplify.boolean.check.ignore.comparison.to.zero=Ignore comparison to zero

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=Incorrect docstring
INSP.missing.parameter.in.docstring=Missing parameter {0} in docstring
INSP.unexpected.parameter.in.docstring=Unexpected parameter {0} in docstring

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=Wrong order of 'except' clauses
INSP.bad.except.exception.class.already.caught=Exception class ''{0}'' has already been caught
INSP.bad.except.superclass.of.exception.class.already.caught=''{0}'', superclass of the exception class ''{1}'', has already been caught

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=Global variable is not defined at the module level
INSP.global.variable.undefined=Global variable ''{0}'' is undefined at the module level

#PyDataclassInspection
INSP.NAME.dataclass.definition.and.usages=Invalid definition and usage of Data Classes
INSP.dataclasses.operator.not.supported.between.instances.of.class=''{0}'' not supported between instances of ''{1}''
INSP.dataclasses.operator.not.supported.between.instances.of.classes=''{0}'' not supported between instances of ''{1}'' and ''{2}''
INSP.dataclasses.object.could.have.no.attribute.because.it.declared.as.init.only=''{0}'' object could have no attribute ''{1}'' because it is declared as init-only
INSP.dataclasses.object.attribute.read.only=''{0}'' object attribute ''{1}'' is read-only
INSP.dataclasses.eq.must.be.true.if.order.true='eq' must be true if 'order' is true
INSP.dataclasses.argument.ignored.if.class.already.defines.method=''{0}'' is ignored if the class already defines ''{1}'' method
INSP.dataclasses.order.argument.should.be.false.if.class.defines.one.of.order.methods='order' should be False if the class defines one of order methods
INSP.dataclasses.frozen.attribute.should.be.false.if.class.defines.setattr.or.delattr='frozen' should be False if the class defines '__setattr__' or '__delattr__'
INSP.dataclasses.unsafe.hash.attribute.should.be.false.if.class.defines.hash='unsafe_hash' should be False if the class defines '__hash__'
INSP.dataclasses.frozen.dataclasses.can.not.inherit.non.frozen.one=Frozen dataclasses can not inherit non-frozen one and vice versa
INSP.dataclasses.method.is.ignored.if.class.already.defines.parameter=''{0}'' is ignored if the class already defines ''{1}'' parameter
INSP.dataclasses.hash.ignored.if.class.already.defines.cmp.or.order.or.frozen.parameters='__hash__' is ignored if the class already defines 'cmp/order' and 'frozen' parameters
INSP.dataclasses.mutable.attribute.default.not.allowed.use.default.factory=Mutable default ''{0}'' is not allowed. Use ''default_factory''
INSP.dataclasses.attribute.default.set.using.method=A default is set using ''{0}''
INSP.dataclasses.method.should.take.only.n.parameter=''{0}'' should take only {1} {1,choice,1#parameter|2#parameters}
INSP.dataclasses.attribute.lacks.type.annotation=Attribute ''{0}'' lacks a type annotation
INSP.dataclasses.cannot.specify.both.default.and.factory=Cannot specify both 'default' and 'factory'
INSP.dataclasses.attribute.useless.until.post.init.declared=Attribute ''{0}'' is useless until ''__post_init__'' is declared
INSP.dataclasses.field.cannot.have.default.factory=Field cannot have a default factory
INSP.dataclasses.cannot.specify.both.default.and.default.factory=Cannot specify both 'default' and 'default_factory'
INSP.dataclasses.post.init.would.not.be.called.until.init.parameter.set.to.true='__post_init__' would not be called until 'init' parameter is set to True
INSP.dataclasses.post.init.should.take.all.init.only.variables.including.inherited.in.same.order.they.defined='__post_init__' should take all init-only variables (incl. inherited) in the same order as they are defined
INSP.dataclasses.post.init.should.take.all.init.only.variables.in.same.order.they.defined='__post_init__' should take all init-only variables in the same order as they are defined
INSP.dataclasses.attrs.post.init.would.not.be.called.until.init.parameter.set.to.true='__attrs_post_init__' would not be called until 'init' parameter is set to True
INSP.dataclasses.attrs.post.init.should.not.take.any.parameters.except.self='__attrs_post_init__' should not take any parameters except 'self'
INSP.dataclasses.method.should.be.called.on.dataclass.instances.or.types=''{0}'' method should be called on dataclass instances or types
INSP.dataclasses.method.should.be.called.on.dataclass.instances=''{0}'' method should be called on dataclass instances
INSP.dataclasses.method.should.be.called.on.attrs.instances=''{0}'' method should be called on attrs instances
INSP.dataclasses.method.should.be.called.on.attrs.types=''{0}'' method should be called on attrs types

# PyDeprecationInspection
INSP.NAME.deprecated.function.class.or.module=Deprecated function, class, or module
INSP.deprecation.abc.decorator.deprecated.use.alternative=''{0}'' is deprecated since Python 3.3. Use ''{1}'' with ''{2}'' instead

# PyDunderSlotsInspection
INSP.NAME.dunder.slots=Invalid usages of classes with  '__slots__' definitions
INSP.dunder.slots.name.in.slots.conflicts.with.class.variable=''{0}'' in __slots__ conflicts with a class variable
INSP.dunder.slots.class.object.attribute.read.only=''{0}'' object attribute ''{1}'' is read-only

# PyFinalInspection
INSP.NAME.final.classes.methods.and.variables=Invalid usages of final classes, methods, and variables
INSP.final.super.classes.are.marked.as.final.and.should.not.be.subclassed={0} {1,choice,1#is|2#are} marked as ''@final'' and should not be subclassed
INSP.final.final.should.be.placed.on.first.overload='@final' should be placed on the first overload
INSP.final.method.marked.as.final.should.not.be.overridden=''{0}'' is marked as ''@final'' and should not be overridden
INSP.final.final.should.be.placed.on.implementation='@final' should be placed on the implementation
INSP.final.final.could.not.be.mixed.with.abstract.decorators='Final' could not be mixed with abstract decorators
INSP.final.final.class.could.not.contain.abstract.methods='Final' class could not contain abstract methods
INSP.final.no.need.to.mark.method.in.final.class.as.final=No need to mark method in 'Final' class as '@final'
INSP.final.non.method.function.could.not.be.marked.as.final=Non-method function could not be marked as '@final'
INSP.final.final.could.not.be.used.in.annotations.for.function.parameters='Final' could not be used in annotations for function parameters
INSP.final.final.could.not.be.used.in.annotation.for.function.return.value='Final' could not be used in annotation for a function return value
INSP.final.if.assigned.value.omitted.there.should.be.explicit.type.argument.to.final=If assigned value is omitted, there should be an explicit type argument to 'Final'
INSP.final.final.name.should.be.initialized.with.value='Final' name should be initialized with a value
INSP.final.already.declared.name.could.not.be.redefined.as.final=Already declared name could not be redefined as 'Final'
INSP.final.either.instance.attribute.or.class.attribute.could.be.type.hinted.as.final=Either instance attribute or class attribute could be type hinted as 'Final'
INSP.final.final.attribute.could.not.be.overridden=''{0}'' is ''Final'' and could not be overridden
INSP.final.final.attribute.should.be.declared.in.class.body.or.init='Final' attribute should be declared in class body or '__init__'
INSP.final.final.target.could.not.be.reassigned=''{0}'' is ''Final'' and could not be reassigned
INSP.final.final.could.only.be.used.as.outermost.type='Final' could only be used as the outermost type
INSP.final.final.could.not.be.used.inside.loop='Final' could not be used inside a loop

# PyInconsistentIndentationInspection
INSP.NAME.inconsistent.indentation=Inconsistent indentation
INSP.inconsistent.indentation.mix.tabs.spaces=Inconsistent indentation: mix of tabs and spaces
INSP.inconsistent.indentation.previous.line.used.tabs.this.line.uses.spaces=Inconsistent indentation: previous line used tabs, this line uses spaces
INSP.inconsistent.indentation.previous.line.used.spaces.this.line.uses.tabs=Inconsistent indentation: previous line used spaces, this line uses tabs

# PyMissingTypeHintsInspection
INSP.NAME.missing.type.hints=Missing type hinting for function definition
INSP.missing.type.hints.type.hinting.missing.for.function.definition=Type hinting is missing for a function definition
INSP.missing.type.hints.add.type.hints=Add type hints
INSP.missing.type.hints.add.type.hints.for=Add type hints for ''{0}''
INSP.missing.type.hints.checkbox.only.when.types.are.known=Only when types are known (collected from run-time or inferred)

# PyOverloadsInspection
INSP.NAME.overloads.in.regular.python.files=Overloads in regular Python files
INSP.overloads.series.overload.decorated.methods.should.always.be.followed.by.implementation=A series of @overload-decorated methods should always be followed by an implementation that is not @overload-ed
INSP.overloads.series.overload.decorated.functions.should.always.be.followed.by.implementation=A series of @overload-decorated functions should always be followed by an implementation that is not @overload-ed
INSP.overloads.this.method.overload.signature.not.compatible.with.implementation=Signature of this @overload-decorated method is not compatible with the implementation
INSP.overloads.this.function.overload.signature.not.compatible.with.implementation=Signature of this @overload-decorated function is not compatible with the implementation

# PyOverridesInspection
INSP.NAME.invalid.usages.of.override.decorator=Invalid usages of @override decorator
INSP.override.missing.super.method=Missing super method for override

# PyPep8NamingInspection
INSP.NAME.pep8.naming=PEP 8 naming convention violation
INSP.pep8.naming.column.name.excluded.base.classes=Excluded base classes:
INSP.pep8.naming.column.name.ignored.errors=Ignored errors:
QFIX.NAME.ignore.errors.like.this=Ignore errors like this
INSP.pep8.naming.class.names.should.use.capwords.convention=Class names should use CapWords convention
INSP.pep8.naming.function.name.should.be.lowercase=Function name should be lowercase
INSP.pep8.naming.argument.name.should.be.lowercase=Argument name should be lowercase
INSP.pep8.naming.variable.in.function.should.be.lowercase=Variable in function should be lowercase
INSP.pep8.naming.constant.variable.imported.as.non.constant=Constant variable imported as non-constant
INSP.pep8.naming.lowercase.variable.imported.as.non.lowercase=Lowercase variable imported as non-lowercase
INSP.pep8.naming.camelcase.variable.imported.as.lowercase=CamelCase variable imported as lowercase
INSP.pep8.naming.camelcase.variable.imported.as.constant=CamelCase variable imported as constant

# PyProtocolInspection
INSP.NAME.protocol.definition.and.usages=Invalid protocol definitions and usages
INSP.protocol.all.bases.protocol.must.be.protocols=All bases of a protocol must be protocols
INSP.protocol.only.runtime.checkable.protocols.can.be.used.with.instance.class.checks=Only @runtime_checkable protocols can be used with instance and class checks
INSP.protocol.newtype.cannot.be.used.with.protocol.classes=NewType cannot be used with protocol classes
INSP.protocol.element.type.incompatible.with.protocol=Type of ''{0}'' is incompatible with ''{1}''

# PyShadowingBuiltinsInspection
INSP.NAME.shadowing.builtins=Shadowing built-in names
INSP.shadowing.builtins.shadows.built.in.name=Shadows built-in name ''{0}''
INSP.shadowing.builtins.ignore.built.ins.label=Ignored built-ins:
QFIX.NAME.ignore.shadowed.built.in.name=Ignore shadowed built-in name
QFIX.ignore.shadowed.built.in.name=Ignore shadowed built-in name "{0}"

# PyTypeCheckerInspection
INSP.NAME.type.checker=Incorrect type
INSP.type.checker.expected.type.got.type.instead=Expected type ''{0}'', got ''{1}'' instead
INSP.type.checker.typed.dict.extra.key=Extra key ''{0}'' for TypedDict ''{1}''
INSP.type.checker.typed.dict.missing.keys=TypedDict ''{0}'' has missing {1,choice,1#key|2#keys}: {2}
INSP.type.checker.expected.to.return.type.got.no.return=Expected to return ''{0}'', got no return
INSP.type.checker.init.should.return.none=__init__ should return None
INSP.type.checker.type.does.not.have.expected.attribute=Type ''{0}'' doesn''t have expected {1,choice,1#attribute|2#attributes} {2}
INSP.type.checker.only.concrete.class.can.be.used.where.matched.protocol.expected=Only a concrete class can be used where ''{0}'' (matched generic type ''{1}'') protocol is expected
INSP.type.checker.only.concrete.class.can.be.used.where.protocol.expected=Only a concrete class can be used where ''{0}'' protocol is expected
INSP.type.checker.expected.matched.type.got.type.instead=Expected type ''{0}'' (matched generic type ''{1}''), got ''{2}'' instead
INSP.type.checker.unexpected.types.prefix=Unexpected type(s):
INSP.type.checker.expected.types.prefix=Possible type(s):
INSP.type.checker.unexpected.argument.from.paramspec=Unexpected argument (from ParamSpec ''{0}'')
INSP.type.checker.unfilled.parameter.for.paramspec=Parameter ''{0}'' unfilled (from ParamSpec ''{1}'')
INSP.type.checker.unfilled.vararg=Parameter ''{0}'' unfilled, expected ''{1}''

# PyTypedDictInspection
INSP.NAME.typed.dict=Invalid TypedDict definition and usages
INSP.typeddict.typeddict.key.must.be.string.literal.expected.one=TypedDict key must be a string literal; expected one of ({0})
INSP.typeddict.typeddict.has.no.key=TypedDict "{0}" has no key ''{1}''
INSP.typeddict.typeddict.has.no.keys=TypedDict "{0}" has no keys ({1})
INSP.typeddict.typeddict.field.is.readonly=TypedDict key "{0}" is ReadOnly
INSP.typeddict.first.argument.has.to.match.variable.name=First argument has to match the variable name
INSP.typeddict.typeddict.cannot.inherit.from.non.typeddict.base.class=TypedDict cannot inherit from a non-TypedDict base class
INSP.typeddict.specifying.metaclass.not.allowed.in.typeddict=Specifying a metaclass is not allowed in TypedDict
INSP.typeddict.cannot.overwrite.typeddict.field.while.merging=Cannot overwrite TypedDict field ''{0}'' while merging
INSP.typeddict.invalid.statement.in.typeddict.definition.expected.field.name.field.type=Invalid statement in TypedDict definition; expected 'field_name: field_type'
INSP.typeddict.right.hand.side.values.are.not.supported.in.typeddict=Right-hand side values are not supported in TypedDict
INSP.typeddict.cannot.overwrite.typeddict.field=Cannot overwrite TypedDict field
INSP.typeddict.key.cannot.be.deleted=Key ''{0}'' of TypedDict ''{1}'' cannot be deleted
INSP.typeddict.this.operation.might.break.typeddict.consistency=This operation might break TypedDict consistency
INSP.typeddict.key.should.be.string=Key should be string
INSP.typeddict.value.must.be.type=Value must be a type
INSP.typeddict.total.value.must.be.true.or.false=Value of 'total' must be True or False
INSP.typeddict.typeddict.cannot.have.key=TypedDict "{0}" cannot have key ''{1}''
INSP.typeddict.cannot.add.non.string.key.to.typeddict=Cannot add a non-string key to TypedDict "{0}"
INSP.typeddict.qualifiers.cannot.be.used.outside.typeddict.definition=''{0}'' can be used only in a TypedDict definition
INSP.typeddict.cannot.be.required.and.not.required.at.the.same.time=Key cannot be required and not required at the same time
INSP.typeddict.required.notrequired.must.have.exactly.one.type.argument=''{0}'' must have exactly one type argument

# PyTypeHintsInspection
INSP.NAME.type.hints=Invalid type hints definitions and usages
INSP.type.hints.builtin.cannot.be.parameterized.directly=Builtin ''{0}'' cannot be parameterized directly
INSP.type.hints.typing.self.cannot.be.parameterized='Self' cannot be parameterized
INSP.type.hints.invalid.type.self=Invalid type 'self'
INSP.type.hints.literal.must.have.at.least.one.parameter='Literal' must have at least one parameter
INSP.type.hints.annotated.must.be.called.with.at.least.two.arguments='Annotated' must be called with at least two arguments
INSP.type.hints.type.specified.both.in.type.comment.and.annotation=Types specified both in a type comment and annotation
INSP.type.hints.typevar.expression.must.be.always.directly.assigned.to.variable=A 'TypeVar()' expression must always directly be assigned to a variable
INSP.type.hints.type.variables.must.not.be.redefined=Type variables must not be redefined
INSP.type.hints.typevar.expects.string.literal.as.first.argument='TypeVar()' expects a string literal as first argument
INSP.type.hints.typevar.tuple.expects.string.literal.as.first.argument='TypeVarTuple()' expects a string literal as first argument
INSP.type.hints.paramspec.expects.string.literal.as.first.argument='ParamSpec()' expects a string literal as first argument
INSP.type.hints.argument.to.typevar.must.be.string.equal.to.variable.name=The argument to 'TypeVar()' must be a string equal to the variable name to which it is assigned
INSP.type.hints.argument.to.typevar.tuple.must.be.string.equal.to.variable.name=The argument to 'TypeVarTuple()' must be a string equal to the variable name to which it is assigned
INSP.type.hints.argument.to.paramspec.must.be.string.equal.to.variable.name=The argument to 'ParamSpec()' must be a string equal to the variable name to which it is assigned
INSP.type.hints.bivariant.type.variables.are.not.supported=Bivariant type variables are not supported
INSP.type.hints.typevar.constraints.cannot.be.combined.with.bound=Constraints cannot be combined with bound=\u2026
INSP.type.hints.single.typevar.constraint.not.allowed=A single constraint is not allowed
INSP.type.hints.typevar.constraints.cannot.be.parametrized.by.type.variables=Constraints cannot be parametrized by type variables
INSP.type.hints.type.variables.cannot.be.used.with.instance.class.checks=Type variables cannot be used with instance and class checks
INSP.type.hints.type.cannot.be.used.with.instance.class.checks=''{0}'' cannot be used with instance and class checks
INSP.type.hints.parameterized.generics.cannot.be.used.with.instance.class.checks=Parameterized generics cannot be used with instance and class checks
INSP.type.hints.generics.should.be.specified.through.square.brackets=Generics should be specified through square brackets
INSP.type.hints.cannot.inherit.from.plain.generic=Cannot inherit from plain 'Generic'
INSP.type.hints.cannot.inherit.from.generic.multiple.times=Cannot inherit from 'Generic[...]' multiple times
INSP.type.hints.some.type.variables.are.not.listed.in.generic=Some type variables ({0}) are not listed in ''Generic[{1}]''
INSP.type.hints.illegal.literal.parameter='Literal' may be parameterized with literal ints, byte and unicode strings, bools, Enum values, None, other literal types, or type aliases to other literal types
INSP.type.hints.parameters.to.generic.must.all.be.type.variables=Parameters to 'Generic[...]' must all be type variables
INSP.type.hints.parameters.to.generic.must.all.be.unique=Parameters to 'Generic[...]' must all be unique
INSP.type.hints.illegal.callable.format='Callable' must be used as 'Callable[[arg, ...], result]'
INSP.type.hints.illegal.first.parameter='Callable' first parameter must be a parameter expression
INSP.type.hints.parameters.to.generic.types.must.be.types=Parameters to generic types must be types
INSP.type.hints.parameters.to.generic.types.cannot.contain.more.than.one.unpacking=Parameters to generic cannot contain more than one unpacking
INSP.type.hints.type.comment.cannot.be.matched.with.unpacked.variables=Type comment cannot be matched with unpacked variables
INSP.type.hints.type.signature.has.too.few.arguments=Type signature has too few arguments
INSP.type.hints.type.signature.has.too.many.arguments=Type signature has too many arguments
INSP.type.hints.type.self.not.supertype.its.class=The type of self ''{0}'' is not a supertype of its class ''{1}''
INSP.type.hints.non.self.attribute.could.not.be.type.hinted=Non-self attribute could not be type hinted
INSP.type.hints.type.alias.must.be.used.as.standalone.type.hint='TypeAlias' must be used as standalone type hint
INSP.type.hints.type.alias.must.be.immediately.initialized=Type alias must be immediately initialized
INSP.type.hints.type.alias.must.be.top.level.declaration=Type alias must be top-level declaration
INSP.type.hints.type.alias.cannot.be.parameterized='TypeAlias' cannot be parameterized
INSP.type.hints.self.use.in.staticmethod=Cannot use 'Self' in staticmethod
INSP.type.hints.self.use.outside.class=Cannot use 'Self' outside class
INSP.type.hints.self.use.for.self.parameter.with.self.annotation=Cannot use 'Self' if 'self' parameter is not 'Self' annotated
INSP.type.hints.self.use.for.cls.parameter.with.self.annotation=Cannot use 'Self' if 'cls' parameter is not 'Self' annotated
INSP.type.hints.type.var.tuple.must.always.be.unpacked=TypeVarTuple must always be unpacked
QFIX.remove.function.annotations=Remove function annotations
QFIX.replace.with.target.name=Replace with the target name
QFIX.remove.generic.parameters=Remove generic parameters
QFIX.replace.with.square.brackets=Replace with square brackets
QFIX.surround.with.square.brackets=Surround with square brackets
QFIX.remove.square.brackets=Remove square brackets
QFIX.replace.with.typing.alias=Replace with typing alias
QFIX.remove.type.comment=Remove the type comment
QFIX.remove.annotation=Remove the annotation
QFIX.replace.with.type.name=Replace with the type name
QFIX.replace.with.old.union.style=Replace with an old-style Union
QFIX.add.from.future.import.annotations=Add 'from __future__ import annotations'
QFIX.NAME.unpack.type.var.tuple=Unpack the TypeVarTuple

# PyInspectionsSuppressor
INSP.python.suppressor.suppress.for.function=Suppress for a function
INSP.python.suppressor.suppress.for.class=Suppress for a class
INSP.python.suppressor.suppress.for.statement=Suppress for a statement

find.usages.unnamed=<unnamed>
find.usages.keyword.argument=keyword argument
find.usages.variable=variable
find.usages.imported.module.alias=imported module alias
find.usages.class=class
find.usages.function=function
find.usages.method=method
find.usages.parameter=parameter

python.find.usages=Find Usages
python.find.usages.base.method.question=Method {0} overrides method of class {1}.\nDo you want to find usages of the base method?
python.find.usages.usage.in.superclass.list=Usage in the superclass list
python.find.usages.usage.in.isinstance=Usage in isinstance()
python.find.usages.untyped.probable.usage=Untyped (probable) usage
python.find.usages.usage.in.import.statement=Usage in an import statement
python.find.usages.usage.in.type.hint=Usage in a type hint

# PyPackagesInspection
INSP.NAME.relative.import=Suspicious relative imports
INSP.relative.import.relative.import.outside.package=Relative import outside of a package

debugger.cleaning.signature.cache=Cleaning the Cache of Dynamically Collected Types
ANN.patterns.repeated.star.pattern=Repeated star pattern

# PyElementPresentation
element.presentation.location.string.in.class=({0} in {1})
element.presentation.location.string.in.class.stub=({0} in {1} stub)
element.presentation.location.string.module=({0})
element.presentation.location.string.module.stub=({0} stub)

# PyClassVarInspection
INSP.NAME.class.var.variables=Invalid usage of ClassVar variables
INSP.class.var.can.not.be.assigned.to.instance=Cannot assign to class variable ''{0}'' via instance
INSP.class.var.can.be.used.only.in.class.body='ClassVar' can only be used for assignments in class body
INSP.class.var.can.not.be.used.in.function.body='ClassVar' cannot be used in annotations for local variables
INSP.class.var.can.not.override.class.variable=Cannot override class variable ''{0}'' (previously declared on base class ''{1}'') with instance variable
INSP.class.var.can.not.override.instance.variable=Cannot override instance variable ''{0}'' (previously declared on base class ''{1}'') with class variable
INSP.class.var.can.not.be.used.in.annotations.for.function.parameters='ClassVar' cannot be used in annotations for function parameters
INSP.class.var.can.not.be.used.in.annotation.for.function.return.value='ClassVar' cannot be used in annotation for a function return value
INSP.class.var.can.not.include.type.variables='ClassVar' parameter cannot include type variables

# Pandas-Specific inspections and quick fixes
INSP.pandas.series.values.replace.with.tolist=Method Series.to_list() is recommended
QFIX.pandas.series.values.replace.with.tolist=Replace list(Series.values) with Series.to_list()

# PyTypeParameterListAnnotator
type.param.list.annotator.type.parameter.already.defined=Type parameter with name ''{0}'' is already defined in this type parameter list
type.param.list.annotator.two.or.more.types.required=Two or more types required
type.param.list.annotator.type.var.tuple.and.param.spec.can.not.have.bounds=ParamSpec and TypeVarTuple cannot have constraints and upper bounds

# PyNewStyleGenericSyntaxInspection
INSP.NAME.new.style.generics.type.param.syntax=Invalid usage of new-style type parameters and type aliases
INSP.new.style.generics.are.not.allowed.inside.type.param.bounds=Generic types are not allowed inside constraints and bounds of type parameters
INSP.new.style.generics.old.style.type.vars.not.allowed.in.new.style.type.aliases=Traditional TypeVars are not allowed inside new-style type alias statements
INSP.new.style.generics.classes.with.type.param.list.should.not.extend.generic=Classes with an explicit type parameter list should not extend 'Generic'
INSP.new.style.generics.extending.protocol.does.not.need.parameterization=Extending 'Protocol' does not need parameterization in classes with a type parameter list
INSP.new.style.generics.mixing.old.style.and.new.style.type.vars.not.allowed=Mixing traditional and new-style type variables is not allowed
INSP.new.style.generics.assignment.expressions.not.allowed=Assignment expressions are not allowed inside declarations of classes, functions and type aliases having type parameter list 
