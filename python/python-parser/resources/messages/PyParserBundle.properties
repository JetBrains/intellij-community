# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Dynamic class based on {0}

### parsing
PARSE.expected.expression=Expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=Expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.rbrace='}' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=Name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.identifier=Identifier expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=Formal parameter name expected
PARSE.0.expected=''{0}'' expected
PARSE.expected.ellipsis='...' expected
PARSE.string.literal.expected=string literal expected
PARSE.expected.symbols=''{0}'' or ''{1}'' expected
PARSE.expected.symbols.first.quotation=''{0}'' or {1} expected
PARSE.expected.symbols.second.quotation={0} or ''{1}'' expected
PARSE.declarator.should.be.empty=declarator should be empty
PARSE.string.literal=string literal
PARSE.newline.expected=newline expected
PARSE.eq.expected='=' expected
PARSE.from.expected='from' expected
PARSE.gt.expected='>' expected
PARSE.expected.fstring.quote={0} expected
PARSE.expected.fstring.rbrace='}' expected
PARSE.expected.fstring.colon.or.rbrace=: or '}' expected
PARSE.expected.fstring.type.conversion.or.colon.or.rbrace=Type conversion, ':' or '}' expected
PARSE.single.star.parameter.not.supported.py2=Single star parameter is not supported in Python 2
PARSE.async.keyword.not.expected.here='async' keyword is not expected here
PARSE.keyword.cannot.be.used.as.identifier.py2=''{0}'' keyword can''t be used as an identifier in Python 2
PARSE.expected.number=Number expected
PARSE.expected.case.clause=Case clause expected
PARSE.expected.pattern=Pattern expected
PARSE.expected.name.or.wildcard=Name or '_' expected
PARSE.expected.type.parameter=Type parameter expected

statement.expected.found.0=Statement expected, found {0}
unexpected.indent=Unexpected indent
unindent.does.not.match.any.outer.indent=Unindent does not match any outer indentation level
except.or.finally.expected='except' or 'finally' expected
expected.statement=Statement expected
indent.expected=Indent expected
cannot.assign.to.yield.expression=Cannot assign to 'yield' expression
end.of.statement.expected=End of statement expected
import.expected='import' expected
def.or.with.or.for.expected='def' or 'with' or 'for' expected
rbracket.or.comma.expected=']' or ',' expected
unexpected.expression.syntax=Unexpected expression syntax
tuple.expression.expected=Tuple expression expected
value.expression.expected=Value expression expected
unexpected.expression.part=Unexpected expression part
unexpected.f.string.token=Unexpected f-string token
can.t.assign.to.await.expression=Cannot assign to await expression
for.expected='for' expected
rarrow.expected='->' expected
unexpected.tokens=Unexpected tokens

PARSE.function.type.annotations.py2=Type annotations are unsupported in Python 2
PARSE.function.return.type.annotations.py2=Return type annotations are unsupported in Python 2

PARSE.console.multiline.magic.warn=Multiline magic cannot be used as an expression
PARSE.console.help.request.warn=IPython introspection syntax error