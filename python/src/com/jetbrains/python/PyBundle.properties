f###=Generic words ###
GNAME.function=function
GNAME.class=class
GNAME.var=variable
GNAME.item=item

# Actions and associated commands
ACT.CMD.use.import=Use an imported module
ACT.qualify.with.module=Qualify with an imported module
ACT.from.some.module.import=Import from ...

### Quick fixes ###
QFIX.auto.import.family=Import
QFIX.auto.import.import.this.name=Import this name
QFIX.auto.import.import.name=Import ''{0}''

QFIX.local.auto.import.family=Import locally
QFIX.local.auto.import.import.locally={0} locally

QFIX.add.import.add.import=Add "''{0}''"

QFIX.add.parameter.self=Add parameter ''{0}''
QFIX.add.super=Add super class call

QFIX.add.property=Add property for the field
QFIX.use.property=Use property for the field

QFIX.make.public=Make public

QFIX.convert.to.new.style=Convert to New-style class

QFIX.change.base.class=Change base class

QFIX.create.property=Create property

QFIX.add.encoding=Add encoding declaration

QFIX.NAME.parameters=Parameters of functions and methods
QFIX.rename.parameter.to.$0=Rename to ''{0}''

QFIX.NAME.add.field.$0.to.class.$1=Add field ''{0}'' to class {1}
QFIX.added.constructor.$0.for.field.$1=Added a __init__ to class <code>{0}</code><br/>to accommodate new field <code>{1}</code>
QFIX.failed.to.add.field=<br/>Failed to add a field!<br/><br/>

QFIX.NAME.add.method.$0.to.class.$1=Add method {0}() to class {1}
QFIX.failed.to.add.method=<br/>Failed to add a method!<br/><br/>

QFIX.NAME.add.function.$0.to.module.$1=Create function {0}() in module {1}
QFIX.failed.to.add.function=<br/>Failed to add a function!<br/><br/>

QFIX.action.failed=Action failed

QFIX.remove.trailing.semicolon=Remove trailing semicolon

QFIX.dict.creation=Replace dictionary creation
QFIX.list.creation=Replace list creation

QFIX.classic.class.transform=Inherit from object

QFIX.add.global=Add global statement

QFIX.simplify.$0=Replace boolean expression with ''{0}''

QFIX.move.from.future.import=Move 'from __future__ import' to a correct place

QFIX.replace.equality=Replace equality

QFIX.redundant.parentheses=Remove redundant parentheses

QFIX.augment.assignment=Replace assignment with augmented assignment

QFIX.chained.comparison=Simplify chained comparison

QFIX.statement.effect=Replace with function call
QFIX.statement.effect.move.docstring=Move docstring to the proper place

QFIX.statement.effect.introduce.variable=Introduce variable

QFIX.unresolved.reference=Replace ''{0}'' with ''{1}.{0}''

QFIX.unresolved.reference.add.param.$0=Create parameter ''{0}''
QFIX.unresolved.reference.add.param=Create parameter for reference

QFIX.unresolved.reference.create.function.$0=Create function ''{0}''

QFIX.introduce.variable=Introduce variable for statement

QFIX.unresolved.reference.add.future=Add 'from __future__ import with_statement''

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=Remove unnecessary backslash in expression

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=Convert docstring to the triple double-quoted string form

#UnresolvedRefTrueFalseQuickFix
QFIX.unresolved.reference.replace.$0=Replace with {0}

#PyDefaultArgumentQuickFix
QFIX.default.argument=Replace mutable default argument

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=Remove arguments equal to default

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=Replace function call with set literal

#DocstringQuickFix
QFIX.docstring.add.$0=Add docstring parameter ''{0}''
QFIX.docstring.remove.$0=Remove docstring parameter ''{0}''
QFIX.docstring.insert.stub=Insert docstring

#RemoveDecoratorQuickFix
QFIX.remove.decorator=Remove decorator

#PyRenameUnresolvedRefQuickFix
QFIX.rename.unresolved.reference=Rename reference

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=Move attribute to __init__ method

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=Make method static

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=Make function from method

#PyImplementMethodsQuickFix
QFIX.NAME.implement.methods=Implement abstract methods

QFIX.NAME.remove.assignment=Remove assignment

QFIX.NAME.remove.statement=Remove statement

QFIX.NAME.update.parameters=Update parameters

QFIX.NAME.remove.call=Remove call

QFIX.NAME.move.except.up=Move except clause up

QFIX.NAME.remove.dict.key=Remove this key

QFIX.NAME.add.specifier=Add format specifier character

QFIX.NAME.add.exception.base=Add Exception base class

QFIX.NAME.change.signature=Change signature

QFIX.NAME.remove.argument=Remove argument

QFIX.NAME.remove.parameter=Remove parameter

QFIX.NAME.rename.argument=Rename argument

QFIX.NAME.wrap.in.exception=Wrap with Exception call

QFIX.NAME.make.list=Replace tuple with list

# Intentions: INTN
INTN.Family.convert.import.unqualify=Convert 'import module' to 'from module import'
INTN.Family.convert.import.qualify=Convert 'from module import' to 'import module'
INTN.Family.toggle.import.alias=Toggle import alias
INTN.Family.convert.except.part=Convert except part to supported form
INTN.Family.convert.set.literal=Convert set literal two supported forms
INTN.Family.convert.builtin=Convert builtin module import
INTN.Family.convert.dict.comp.expression=Convert dictionary comprehension expression
INTN.Family.convert.string=Convert single-quoted string to double-quoted

INTN.convert.to.from.$0.import.$1=Convert to ''from {0} import {1}''
INTN.convert.to.import.$0=Convert to ''import {0}''

INTN.alias.for.$0.dialog.title=Alias for ''{0}'':
INTN.add.alias.for.import.$0=Add alias to ''{0}''
INTN.remove.alias.for.import.$0=Remove alias ''{0}''

INTN.Family.migration.to.python3=Migration to Python 3

INTN.convert.except.to=Convert 'except exceptClass, Target' to 'except exceptClass as Target'

INTN.convert.set.literal.to=Convert set literal to 'set' method call

INTN.convert.builtin.import=Convert builtin module import to supported form

INTN.convert.dict.comp.to=Convert dictionary comprehension to 'dict' method call

INTN.replace.noteq.operator=Replace not equal operator

INTN.remove.leading.$0=Remove leading {0}
INTN.remove.leading.prefix=Remove prefix

INTN.remove.trailing.l=Remove trailing L

INTN.replace.list.comprehensions=Convert list comprehensions to supported form

INTN.replace.list.comprehensions.with.for=Convert list comprehensions to for loop

INTN.replace.octal.numeric.literal=Convert octal numeric literal to supported form

INTN.replace.raise.statement=Convert raise statement to supported form

INTN.replace.backquote.expression=Replace backquote expression

INTN.replace.method=Replace method which is not supported in current Python version

INTN.split.if=Split if
INTN.split.if.text=Split into 2 if's

INTN.negate.comparison=Negate comparison
INTN.negate.$0.to.$1=Negate ''{0}'' to ''{1}''

INTN.string.concatenation.to.format=Replace string concatenation with format operator
INTN.replace.plus.with.format.operator=Replace + with string formatting operator
INTN.replace.plus.with.str.format=Replace + with str.format method call

INTN.format.operator.to.method=Convert format operator usage to str.format method call
INTN.replace.with.method=Replace with str.format method call

INTN.flip.comparison=Flip comparison
INTN.flip.$0=Flip ''{0}''
INTN.flip.$0.to.$1=Flip ''{0}'' to ''{1}''

INTN.convert.string=Convert single-quoted string to double-quoted

INTN.join.if=Join if's
INTN.join.if.text=Join two if's

INTN.convert.dict.constructor.to.dict.literal=Convert dict constructor to dict literal form
INTN.convert.dict.literal.to.dict.constructor=Convert dict literal to dict constructor

INTN.quoted.string=Convert between single-quoted and double-quoted strings
INTN.quoted.string.single.to.double=Convert single-quoted string to double-quoted string
INTN.quoted.string.double.to.single=Convert double-quoted string to single-quoted string

INTN.convert.lambda.to.function=Convert lambda to function

INTN.convert.variadic.param=Convert from variadic to normal parameter(s)

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=Convert triple-quoted string to single-quoted string

INTN.convert.collection.literal.family=Convert collection to {0}
INTN.convert.collection.literal.text=Convert {0} to {1}

INTN.demorgan.law=DeMorgan law

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=Transform conditional expression into if/else statement

# PyConvertTripleQuotedStringIntention
INTN.doc.string.stub=Insert documentation string stub

#SpecifyTypeInDocstringIntention
INTN.specify.type=Specify type for reference in docstring
INTN.specify.return.type=Specify return type in docstring
INTN.add.parameters.to.docstring=Add parameters to docstring

#SpecifyTypeInPy3AnnotationsIntention
INTN.specify.type.in.annotation=Specify type for reference using annotation
INTN.specify.return.type.in.annotation=Specify return type using annotation

#PyAnnotateTypesIntention
INTN.annotate.types=Annotate types

#TypeAssertionIntention
INTN.insert.assertion=Insert type assertion

#PyYieldFromIntention
INTN.yield.from=Transform explicit iteration with 'yield' into 'yield from' expression

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=Convert static method to function

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=Convert method to property

# Conflict checker
CONFLICT.name.$0.obscured=Name ''{0}'' obscured by local definitions
CONFLICT.name.$0.obscured.cannot.convert=Name ''{0}'' obscured. Cannot convert.
CONFLICT.occurrence.sing=occurrence
CONFLICT.occurrence.pl=occurrences

### Surround with templates ###
surround.with.whileelse.template=while / else
surround.with.return.template=return
surround.with.try.except.template=try / except

##########################################################################################################################
# Unwrap
##########################################################################################################################
unwrap.if=Unwrap if...
unwrap.while=Unwrap while...
unwrap.for=Unwrap for...
unwrap.with=Unwrap with...
unwrap.try=Unwrap try...
unwrap.else=Unwrap else...
unwrap.elif=Unwrap elif...
remove.else=Remove else...
remove.elif=Remove elif...

### Inspections: INSP ###
INSP.GROUP.python=Python
INSP.GROUP.mako=Mako

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=Incorrect call arguments
INSP.cannot.appear.past.keyword.arg=Cannot appear past keyword arguments or *arg or **kwarg
INSP.unexpected.arg=Unexpected argument
INSP.parameter.$0.unfilled=Parameter ''{0}'' unfilled
INSP.func.$0.lacks.first.arg=Function ''{0}'' lacks a positional argument
INSP.expected.dict.got.$0=Expected a dictionary, got {0}
INSP.expected.iter.got.$0=Expected an iterable, got {0}
INSP.more.args.that.pos.params=Multiple values resolve to one positional parameter
INSP.multiple.values.resolve.to.positional.$0=Multiple values resolve to positional parameter ''{0}''
INSP.cannot.analyze=This argument list cannot be analyzed

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=Methods having troubles with first parameter
INSP.must.have.first.parameter=Method must have a first parameter, usually called ''{0}''
INSP.probably.mistyped.self=Did not you mean 'self'?
INSP.usually.named.self=Usually first parameter of a method is named 'self'
INSP.usually.named.$0=Usually first parameter of such methods is named ''{0}''
INSP.first.param.must.not.be.tuple=First parameter of a non-static method must not be a tuple

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=Problematic nesting of decorators
INSP.decorator.receives.unexpected.builtin=This decorator will not receive a callable it may expect; the built-in decorator returns a special object

# PyRedeclarationInspection
INSP.NAME.redeclaration=Redeclared names without usage
INSP.redeclared.name=Redeclared ''{0}'' defined above without usage

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=Unresolved references
INSP.module.$0.not.found=Module ''{0}'' not found
INSP.unresolved.ref.$0=Unresolved reference ''{0}''
INSP.unresolved.ref.$0.for.class.$1=Unresolved attribute reference ''{0}'' for class ''{1}''
INSP.cannot.find.$0.in.$1=Cannot find reference ''{0}'' in ''{1}''
INSP.try.except.import.error=''{0}'' in try block with ''except ImportError'' should also be defined in except block
INSP.unresolved.operator.ref=Class ''{0}'' does not define ''{1}'', so the ''{2}'' operator cannot be used on its instances

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=Invalid interpreter configured

# ReturnValueFromInitInspection
INSP.NAME.init.return=__init__ method that returns a value
INSP.cant.return.value.from.init=Cannot return a value from __init__

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=Unreachable code
INSP.unreachable.code=This code is unreachable

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=Reassignment of method's first argument
INSP.first.arg.$0.assigned=Method''s parameter ''{0}'' reassigned

# PyStringFormatInspection
INSP.NAME.str.format=Errors in string formatting operations
INSP.format.requires.no.mapping=Format doesn't require a mapping
INSP.key.$0.has.no.arg=Key ''{0}'' has no following argument
INSP.unexpected.type.$0=Unexpected type {0}
INSP.too.few.keys=Too few mapping keys
INSP.no.format.specifier.char=Format specifier character missing
INSP.format.requires.mapping=Format requires a mapping
INSP.too.many.args.for.fmt.string=Too many arguments for format string
INSP.too.few.args.for.fmt.string=Too few arguments for format string

# PyMethodOverridingInspection
INSP.NAME.method.over=Method signature does not match signature of overridden method
INSP.signature.mismatch=Signature of method ''{0}'' does not match signature of base method in class ''{1}''

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=Incompatible signatures of __new__ and __init__
INSP.new.incompatible.to.init=Signature is not compatible to __init__
INSP.init.incompatible.to.new=Signature is not compatible to __new__

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=Trailing semicolon in statement

# PyUnusedLocalInspection
INSP.NAME.unused=Unused local
INSP.unused.locals.parameter.isnot.used=Parameter ''{0}'' value is not used
INSP.unused.locals.local.variable.isnot.used=Local variable ''{0}'' value is not used
INSP.unused.locals.replace.with.wildcard=Replace with _
INSP.unused.locals.local.function.isnot.used=Local function ''{0}'' is not used
INSP.unused.locals.local.class.isnot.used=Local class ''{0}'' is not used

# PyUnboundLocalVariableInspection
INSP.NAME.unbound=Unbound local variable
INSP.unbound.local.variable=Local variable ''{0}'' might be referenced before assignment
INSP.unbound.nonlocal.variable=Nonlocal variable ''{0}'' must be bound in an outer function scope
INSP.unbound.name.not.defined=Name ''{0}'' can be not defined
INSP.unbound.function.too.large=Function ''{0}'' is too large to analyse

# PyDictCreationInspection
INSP.NAME.dict.creation=Dictionary creation could be rewritten by dictionary literal

# PyListCreationInspection
INSP.NAME.list.creation=List creation could be rewritten by list literal

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=Bad except clauses order
INSP.class.$0.already.caught=Exception class ''{0}'' has already been caught
INSP.class.$0.superclass.$1.already.caught=''{0}'', superclass of exception class ''{1}'', has already been caught

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=Tuple assignment balance is incorrect

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=Classic style class usage
INSP.classic.class.usage.old.style.class=Old-style class
INSP.classic.class.usage.old.style.class.ancestors=Old-style class, because all classes from whom it inherits are old-style


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=Exception doesn't inherit from standard ''Exception'' class

# PyDefaultArgumentInspection
INSP.NAME.default.argument=Default argument is mutable

# PyRaisingNewStyleClassInspection
INSP.NAME.raising.new.style.class=Raising a new style class

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=Incorrect docstring
INSP.missing.parameter.in.docstring=Missing parameter {0} in docstring
INSP.unexpected.parameter.in.docstring=Unexpected parameter {0} in docstring

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=Missing or empty docstring
INSP.no.docstring=Missing docstring
INSP.empty.docstring=Empty docstring

# PyDocstringTypesInspection
INSP.NAME.docstring.types=Type in docstring doesn't match inferred type

# PyStatementEffectInspection
INSP.NAME.statement.effect=Statement has no effect
INSP.NAME.statement.message=Statement seems to have no effect

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=Boolean variable check can be simplified
INSP.expression.can.be.simplified=Expression can be simplified

# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__ import must be the first executable statement

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=Comparison with None performed with equality operators

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=Raising a string exception

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=Wrong arguments to call super
INSP.$0.is.not.superclass.of.$1=''{0}'' is not an instance or a subclass of ''{1}''

# PyByteLiteralInspection
INSP.NAME.byte.literal=Byte literal contains characters > 255

# PynonAsciiCharInspection
INSP.NAME.non.ascii=File contains non-ASCII character

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=No encoding specified for file

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=Tuple item assignment
INSP.tuples.never.assign.items=Tuples don't support item assignment

# PyPropertyAccessInspection
INSP.NAME.property.access=Access to properties
INSP.property.$0.cant.be.set=Property ''{0}'' cannot be set
INSP.property.$0.cant.be.read=Property ''{0}'' cannot be read
INSP.property.$0.cant.be.deleted=Property ''{0}'' cannot be deleted

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=Property definitions
INSP.doc.param.should.be.str=The doc parameter should be a string
INSP.strange.arg.want.callable=Strange argument; a callable is expected
INSP.func.property.name.mismatch=Names of function and decorator don't match; property accessor is not created
INSP.getter.return.smth=Getter should return or yield something
INSP.setter.should.not.return=Setter should not return a value
INSP.deleter.should.not.return=Deleter should not return a value
INSP.getter.signature.advice=Getter signature should be (self)
INSP.setter.signature.advice=Setter signature should be (self, value)
INSP.deleter.signature.advice=Deleter signature should be (self)
INSP.accessor.first.param.is.$0=First parameter of an accessor is usually called ''{0}''

# PyCallByClassInspection
INSP.NAME.different.class.call=Calling a method by class using an instance of a different class
INSP.instance.of.$0.excpected=An instance of {0} expected, not the class itself
INSP.passing.$0.instead.of.$1=Passing {0} instead of {1}. Is this intentional?

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=Too broad exception clauses

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=Dictionary contains duplicate keys

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=Redundant parentheses

# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=Assignment can be replaced with augmented assignment

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=Chained comparisons can be simplified

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=Instance attribute defined outside __init__
INSP.attribute.$0.outside.init=Instance attribute {0} defined outside __init__

# PyProtectedMemberInspection
INSP.NAME.protected.member.access=Access to a protected member of a class
INSP.protected.member.$0.access=Access to a protected member {0} of a class
INSP.protected.member.$0.access.module=Access to a protected member {0} of a module

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=Argument passed to function is equal to default parameter value
INSP.argument.equals.to.default=Argument equals to default parameter value

# PyAbstractClassInspection
INSP.NAME.abstract.class=Class must implement all abstract methods
INSP.NAME.abstract.class.$0.must.implement=Class {0} must implement all abstract methods

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=Old-style class contains new-style class features
INSP.oldstyle.class.slots=Old-style class contains __slots__ definition
INSP.oldstyle.class.getattribute=Old-style class contains __getattribute__ definition
INSP.oldstyle.class.super=Old-style class contains call for super method

# PyCompatibilityInspection
INSP.NAME.compatibility=Code compatibility inspection

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=Unnecessary backslash

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=Single quoted docstring
INSP.message.single.quoted.docstring=Triple double-quoted strings should be used for docstrings.

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=Missed call to __init__ of super class
INSP.missing.super.constructor.message=Call to __init__ of super class is missed

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=Function call can be replaced with set literal

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=Class specific decorator on method outside class

# PyPackageRequirementsInspection
INSP.NAME.requirements=Package requirements

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=Method may be static
INSP.method.may.be.static=Method <code>#ref</code> may be 'static'

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=Class has no __init__ method
INSP.class.has.no.init=Class has no __init__ method
INSP.parent.$0.has.no.init=Parent ''{0}'' has no __init__ method

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=Assigning function call that doesn't return anything (None)
INSP.none.function.assignment=Function ''{0}'' doesn''t return anything

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=Global variable is undefined at the module level
INSP.NAME.global.$0.undefined=Global variable ''{0}'' is undefined at the module level

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter.display.name=Assignment to 'for' loop or 'with' statement parameter
INSP.NAME.assignment.to.loop.or.with.parameter.display.message=Variable ''{0}'' already declared in ''for'' loop or ''with'' statement above

# Refactoring
refactoring.will.not.be.accessible=Member, you are trying to move depends on ''{0}'' which will not be accessible after this refactoring
refactoring.error.file.exists=File "{0}" already exists
refactoring.error.directory.exists=Directory "{0}" already exists

# introduce
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)

# introduce variable
refactoring.introduce.variable.dialog.title=Extract Variable
refactoring.introduce.variable.scope.error=Name clashes with existing variable or parameter

# introduce constant
refactoring.introduce.constant.dialog.title=Extract Constant
refactoring.introduce.constant.scope.error=Name is already declared in scope

# introduce parameter
refactoring.introduce.parameter.dialog.title=Extract Parameter

# pull up
refactoring.pull.up.dialog.title=Pull members up to
refactoring.pull.up.dialog.move.members.to.class=Move members to class
refactoring.pull.up.dialog.members.to.be.moved=Following members would be moved
refactoring.pull.up.error.cannot.perform.refactoring.using.selected.elements=Cannot perform pull member up using selected element(s)
refactoring.pull.up.error.cannot.perform.refactoring.not.inside.class=Cannot perform pull member up: not inside the class
refactoring.pull.up.error.cannot.perform.refactoring.no.base.classes=Class {0} has no super classes or none of them could be used for refactoring

# push down
refactoring.push.down.dialog.title=Push members down from
refactoring.push.down.error.cannot.perform.refactoring.using.selected.elements=Cannot perform push member down using selected element(s)
refactoring.push.down.error.cannot.perform.refactoring.not.inside.class=Cannot perform pull member down: not inside the class

# inline
refactoring.inline.local.multiassignment=Definition is in multi-assign

# extract method
refactoring.extract.method=Extract method
refactoring.extract.method.error.interrupted.execution.flow=Cannot perform refactoring when execution flow is interrupted
refactoring.extract.method.error.star.import=Cannot perform refactoring with star import statement inside code block
refactoring.extract.method.error.bad.selection=Cannot perform extract method using selected element(s)
refactoring.extract.method.error.name.clash=Method name clashes with already existing name
refactoring.extract.method.error.returns=Cannot extract method with return instructions inside code fragment
refactoring.extract.method.error.local.variable.modifications=Cannot perform refactoring from expression with local variable modifications inside code fragment
refactoring.extract.method.error.local.variable.modifications.and.returns=Cannot perform refactoring from expression with local variables modifications and return instructions inside code fragment
refactoring.extract.method.error.empty.fragment=Cannot perform refactoring from empty code fragment
refactoring.extract.method.error.undetermined.execution.flow=Cannot determine execution flow for the code fragment
refactoring.extract.method.error.yield=Cannot perform refactoring with 'yield' statement inside code block
refactoring.extract.method.error.class.level=Cannot perform refactoring at class level


# extract superclass
refactoring.extract.super.target.path.outside.roots=Target directory is outside the project. Must be within content roots
refactoring.extract.super.target.class.already.exists=Class ''{0}'' already exists in this module
refactoring.extract.super.name.0.must.be.ident=Name ''{0}'' is invalid. Must be a valid Python identifier
refactoring.extract.super.class.no.members.allowed=None of members could be extracted

# move
refactoring.move.module.members=Move module members
refactoring.move.module.members.dialog.title=Move Module Members
refactoring.move.module.members.dialog.table.title=Bulk &move
refactoring.move.module.members.dialog.description.class.$0=Move class {0}
refactoring.move.module.members.dialog.description.function.$0=Move function {0}()
refactoring.move.module.members.dialog.description.variable.$0=Move global variable {0}
refactoring.move.module.members.dialog.description.selection=Move selected elements
refactoring.move.module.members.dialog.choose.destination.file.title=Choose Destination File
refactoring.move.module.members.error.cannot.place.elements.into.nonpython.file=Cannot place elements into a non-Python file
refactoring.move.module.members.error.destination.file.contains.class.$0=Destination file already contains class named ''{0}''
refactoring.move.module.members.error.destination.file.contains.function.$0=Destination file already contains function named ''{0}()''
refactoring.move.module.members.error.destination.file.contains.global.variable.$0=Destination file already contains global variable named ''{0}''
refactoring.move.module.members.error.cannot.use.module.name.$0=Cannot use module name ''{0}'' in imports
refactoring.move.module.members.error.selection=Cannot perform refactoring using selected element(s)

# Make function top-level
refactoring.make.function.top.level.function=Convert to top-level function
refactoring.make.method.top.level=Make method top-level
refactoring.make.local.function.top.level=Make local function top-level
refactoring.make.function.top.level.error.nonlocal.writes=Cannot move function with nonlocal writes
refactoring.make.function.top.level.error.self.reads=Cannot move function that contains usages of "self" parameter from outer scope
refactoring.make.function.top.level.error.outer.scope.reads=Cannon move method that references names from the outer scope
refactoring.make.function.top.level.error.private.attributes=Cannot move method that references private instance attributes
refactoring.make.function.top.level.error.attribute.writes=Cannot move method that writes to instance attributes
refactoring.make.function.top.level.error.method.calls=Cannot move method that calls other methods of the same class
refactoring.make.function.top.level.error.special.usage.of.self=Cannot move method that contains special usages of "self" parameter



#change signature
refactoring.change.signature.usage.view.declarations.header=Functions to be refactored
refactoring.change.signature.dialog.validation.name.defined=Name is already defined in scope
refactoring.change.signature.dialog.validation.function.name=Incorrect function name
refactoring.change.signature.dialog.validation.parameter.name=Incorrect parameter name
refactoring.change.signature.dialog.validation.multiple.star=Multiple * arguments are not allowed
refactoring.change.signature.dialog.validation.multiple.double.star=Multiple ** arguments are not allowed
refactoring.change.signature.dialog.validation.default.missing=Default value is missing
refactoring.change.signature.dialog.validation.parameter.missing=Parameter name is missing
refactoring.change.signature.dialog.default.value.checkbox=Use default value in signature:
refactoring.change.signature.dialog.default.value.label=Default value:
refactoring.change.signature.dialog.name.label=Name:
refactoring.change.signature.find.usages.of.base.class=Method {0} of class {1}\noverrides method of class {2}.\nDo you want to refactor the base method?
refactoring.change.signature.error.wrong.caret.position.method.name=The caret should be positioned at the name of the method to be refactored
refactoring.change.signature.error.lambda.call=Caret is positioned on lambda call
refactoring.change.signature.error.tuple.parameters=Function contains tuple parameters
refactoring.change.signature.error.not.under.source.root=Function is not under the source root

# convert module to package
refactoring.convert.module.to.package.title=Convert Module to Package

# convert module
refactoring.convert.package.to.module.title=Convert Module to Package
refactoring.convert.package.to.module.error.not.empty.package=Package "{0}" is not empty


### Annotators ###
ANN.deleting.none=Deleting None
ANN.assign.to.none=Assignment to None
ANN.cant.assign.to.call=Can't assign to function call
ANN.cant.delete.call=Can't delete function call
ANN.cant.aug.assign.to.generator=Augmented assign to generator expression not possible
ANN.cant.aug.assign.to.tuple.or.generator=Augmented assign to tuple literal or generator expression not possible
ANN.cant.assign.to.generator=Assign to generator expression not possible
ANN.cant.assign.to.operator=Can't assign to operator
ANN.cant.assign.to.parens=Can't assign to ()
ANN.cant.assign.to.brackets=Can't assign to []
ANN.cant.aug.assign.to.list.or.comprh=Augmented assign to list literal or comprehension not possible
ANN.cant.assign.to.comprh=Can't assign to list comprehension
ANN.cant.assign.to.dict.comprh=Can't assign to dict comprehension
ANN.cant.assign.to.set.comprh=Can't assign to set comprehension
ANN.cant.aug.assign.to.comprh=Augmented assign to list comprehension not possible
ANN.cant.aug.assign.to.dict.comprh=Augmented assign to dict comprehension not possible
ANN.cant.aug.assign.to.set.comprh=Augmented assign to set comprehension not possible
ANN.cant.assign.to.literal=Can't assign to literal
ANN.cant.delete.literal=Can't delete literal
ANN.cant.assign.to.lambda=Can't assign to lambda

ANN.break.outside.loop='break' outside loop
ANN.continue.outside.loop='continue' outside loop
ANN.cant.continue.in.finally='continue' not supported inside 'finally' clause
ANN.default.except.must.be.last=default 'except:' must be last

ANN.$0.both.global.and.param=Name ''{0}'' used both as a parameter and as a global
ANN.$0.assigned.before.global.decl=Name ''{0}'' is assigned before global declaration

ANN.duplicate.param.name=duplicate parameter name
ANN.starred.param.after.kwparam=* parameter after ** parameter
ANN.regular.param.after.vararg=regular parameter after * parameter
ANN.regular.param.after.keyword=regular parameter after ** parameter
ANN.non.default.param.after.default=non-default parameter follows default parameter
ANN.named.arguments.after.star=named arguments must follow bare *
ANN.tuple.py3=tuple parameter unpacking is not supported in Python 3

ANN.star.import.at.top.only='import *' only allowed at module level

ANN.missing.closing.quote=Missing closing quote [{0}]
ANN.missing.closing.triple.quotes=Missing closing triple quotes

ANN.method.$0.removed.use.$1=Method ''{0}'' has been removed, use ''{1}'' instead
ANN.method.$0.removed=Method ''{0}'' removed

### parsing
PARSE.expected.expression=expression expected
PARSE.expected.rbracket=']' expected
PARSE.expected.expr.or.comma.or.bracket=expected expression, ',' or ']'
PARSE.expected.in='in' expected
PARSE.expected.for.or.bracket=']' or 'for' expected
PARSE.expected.comma=',' expected
PARSE.expected.colon=':' expected
PARSE.expected.rpar=')' expected
PARSE.expected.lpar='(' expected
PARSE.expected.rbrace='}' expected
PARSE.expected.tick='`' (backtick) expected
PARSE.expected.name=name expected
PARSE.expected.colon.or.rbracket=':' or ']' expected
PARSE.expected.comma.or.rpar=',' or ')' expected
PARSE.expected.else='else' expected

PARSE.expected.identifier=Identifier expected
PARSE.expected.comma.lpar.rpar=',' or '(' or ')' expected
PARSE.expected.statement.break=Statement break expected
PARSE.expected.@.or.def='@' or 'def' expected
PARSE.expected.formal.param.name=formal parameter name expected

### qiuck doc generator
QDOC.copied.from.$0.$1=<i>Documentation is missing.</i> The following is copied from <code>{0}.{1}</code>.
QDOC.copied.from.builtin=<small>(copied from built-in description)</small>
QDOC.copied.from.class.$0=<i>Documentation is missing.</i> The following is copied from class <code>{0}</code>.
QDOC.assigned.to.$0=Assigned to <code>{0}</code>
QDOC.wrapped.in.$0=Wrapped in <code>{0}</code>
QDOC.module.path.unknown=(Module path is unknown)
QDOC.epydoc.python2.sdk.not.found=You need configured Python 2 SDK to render <a href='http://epydoc.sourceforge.net/'>Epydoc</a> docstrings
QDOC.sdk.not.found=You need configured Python SDK to render docstrings

### doctest run conf
runcfg.doctest.display_name=Doctests
runcfg.doctest.description=Python's doctests run configuration

### nosetests run conf
runcfg.nosetests.display_name=Nosetests
runcfg.nosetests.description=Python's nosetests run configuration

### pytest run conf
runcfg.pytest.display_name=py.test
runcfg.pytest.description=py.test run configuration
runcfg.pytest.target=&Target:
runcfg.pytest.parameters=&Options:
runcfg.pytest.keywords=&Keywords:

### attest run conf
runcfg.attest.display_name=Attests
runcfg.attest.description=Python's attests run configuration

### test run configuration
runcfg.test.display_name=Python tests
runcfg.test.description=Python frameworks supported by PyCharm

### unittest run configuration
runcfg.unittest.display_name=Unittests
runcfg.unittest.description=Python's unittest run configuration
runcfg.unittest.no_script_name=Please specify script name
runcfg.unittest.no_class_name=Please specify class name
runcfg.unittest.no_method_name=Please specify method name
runcfg.unittest.no_folder_name=Please specify folder with tests
runcfg.unittest.incorrect.script=Test script name should start with "test" prefix
runcfg.unittest.dlg.tests_group_title=Tests:
runcfg.unittest.dlg.test_script_label=Script:
runcfg.unittest.dlg.class_label=Class:
runcfg.unittest.dlg.method_label=Method:
runcfg.unittest.dlg.function_label=Function:
runcfg.unittest.dlg.folder_path=Folder:
runcfg.unittest.dlg.test_type_title=Test:
runcfg.unittest.dlg.all_in_folder_title=All in folder
runcfg.unittest.dlg.all_in_script_title=Script
runcfg.unittest.dlg.test_class_title=Class
runcfg.unittest.dlg.test_method_title=Method
runcfg.unittest.dlg.folder_title=Tests folder:
runcfg.unittest.no_valid_sdk=Please select a valid Python interpeter
runcfg.unittest.no_module_sdk=Please select a module with a valid Python SDK
runcfg.unittest.no_sdk=Please specify a Python SDK
runcfg.unittest.dlg.select.folder.path=Select folder path:
runcfg.unittest.dlg.select.script.path=Select script path:
runcfg.unittest.dlg.interpreter_options_title=Interpreter options:
runcfg.unittest.dlg.messages.working.dir=Working directory:
runcfg.labels.script_parameters=Script &parameters:
runcfg.labels.script=&Script:
runcfg.labels.environment_variables=&Environment variables:
runcfg.labels.interpreter=&Use specified interpreter:
runcfg.labels.interpreter_options=Interpreter &options:
runcfg.labels.working_directory=&Working directory:
runcfg.captions.script_parameters_dialog=Enter script parameters
runcfg.captions.interpreter_options_dialog=Enter interpreter options
sdk.error.invalid.interpreter.name.$0=Invalid Python interpeter name ''{0}''!
sdk.select.path=Select Python Interpreter
runcfg.unittest.dlg.pattern=Pattern:

runcfg.testing.no.test.framework=No {0} runner found in selected interpreter

# Consoles messages
python.console=Python Console


# UI messages
MSG.title.bad.sdk=Invalid Python SDK
MSG.cant.setup.sdk.$0=Cannot set up a python SDK \nat {0}.\nThe SDK seems invalid.


#Buildout
buildout=Buildout
buildout.unresolved.part.inspection=Buildout config unresolved part inspection
buildout.unresolved.part.inspection.msg=Unresolved part reference
runcfg.unittest.dlg.test_function_title=Function
runcfg.unittest.dlg.keywords=Keywords:
run.configuration.remote.debug.name=Python Remote Debug
run.configuration.type.description=Starts server for remote debug
run.configuration.show.command.line.action.name=Show Python Prompt

unable.to.stop=Currently running process can't be stopped. Kill it manually first.

#Debug

debug.popup.title.step.into.function=Step Into Function

remote.debug.info=Info
remote.debug.server.hint=Launch this debug configuration to start the debug server.
remote.debug.server.hint1.5=Update your script:
remote.debug.server.hint2=1. Add pycharm-debug.egg from the PyCharm installation to the Python path.
remote.debug.server.hint2.5=2. Add the following import statement:
remote.debug.server.hint3=3. Add the following command to connect to the debug server:
remote.debug.settings=Settings
remote.debug.remote.host=Remote host
remote.debug.port=Port:
remote.debug.use.path.mapping=Use path mapping
remote.debug.remote.root.folder=Remote paths prefix:
remote.debug.local.root.folder=Local paths prefix:
remote.debug.server.hint4=If you want to enable stdout and stderr redirection to PyCharm console, use following command in your script:
remote.debug.local.host=Local host name:
remote.debug.redirect.output=Redirect output to console
remote.debug.suspend.on.connect=Suspend after connect

# SDK / skeletons
sdk.errorlog.$0.mods.fail.in.$1.sdks={0,choice,|1#1 module|2#{0,number} modules} failed in {1,choice, |1#1 interpreter|2#{1,number} interpreters}. <a href=\"#\">Details...</a>
sdk.errorlog.$0.mods.fail.in.$1.sdks.$2.completely={0,choice,|1#1 module|2#{0,number} modules} failed in {1,choice, |1#1 interpreter|2#{1,number} interpreters}, {2,choice, |1#1 interpreter|2#{2,number} interpreters} failed <i>completely</i>. <a href=\"#\">Details...</a>
sdk.some.skeletons.failed=Some skeletons failed to generate
sdk.error.dialog.problems=Skeleton Generation Problems
sdk.error.dialog.failed.sdks=Failed interpreters
sdk.error.dialog.failed.modules=Failed modules
sdk.error.dialog.were.blacklisted=Generation of skeletons for the modules above will be tried again when the modules are updated or a new version of generator is available.
sdk.gen.querying.$0=Querying skeleton generator for {0}...
sdk.gen.updating.builtins.$0=Updating skeletons of builtins for {0}...
sdk.gen.updating.$0=Updating skeletons for {0}...
sdk.gen.cleaning.$0=Cleaning up skeletons for {0}...
sdk.gen.reloading=Reloading generated skeletons...
sdk.gen.reading.versions.file=Reading versions file...
sdk.gen.notify.converting.old.skels=Converting old skeletons
sdk.gen.notify.converting.text=Skeletons of binary modules seem to be from an older version.<br/>These will be fully re-generated, which will take some time, but will happen <i>only once</i>.<br/>Next time you open the project, only skeletons of new or updated binary modules will be re-generated.
sdk.gen.updating.skeletons=Updating Skeletons
sdk.gen.stubs.for.binary.modules=Generate stubs for binary module {0}

# Active SDK configurable and related dialogs
active.sdk.dialog.show.all.item=Show All
active.sdk.dialog.project.interpreter=Project Interpreter:
active.sdk.dialog.project.interpreter.path.mappings=Path mappings:
active.sdk.dialog.project.interpreter.path.mappings.default.project.error=Open or create project to configure mappings

sdk.details.step.add.local=Add Local
sdk.details.step.add.remote=Add Remote
sdk.details.step.create.virtual.env=Create VirtualEnv
sdk.details.step.create.conda.env=Create Conda Env
sdk.details.step.show.more=More...

sdk.details.dialog.title=Project Interpreters
sdk.details.dialog.show.all.virtual.envs=Show virtual environments associated with other projects
sdk.details.dialog.show.interpreter.paths=Show paths for the selected interpreter
sdk.details.dialog.error.duplicate.name=Please specify a unique name for the interpreter

sdk.edit.dialog.title=Edit Python Interpreter
sdk.edit.dialog.associate.virtual.env.with.path=Associate this virtual environment with {0}
sdk.edit.dialog.associate.virtual.env.current.project=Associate this environment with current project
sdk.edit.dialog.specify.interpreter.path=Specify Interpreter Path

sdk.paths.dialog.title=Interpreter Paths
sdk.paths.dialog.reload.paths=Reload list of paths
sdk.paths.dialog.added.by.user.suffix=(added by user)
sdk.paths.dialog.removed.by.user.suffix=(removed by user)

sdk.create.venv.dialog.creating.venv=Creating virtual environment
sdk.create.venv.dialog.make.available.to.all.projects=Make available to all projects
sdk.create.venv.dialog.select.venv.location=Select Location for Virtual Environment
sdk.create.venv.dialog.error.not.empty.directory=Directory is not empty
sdk.create.venv.dialog.error.empty.venv.name=VirtualEnv name can't be empty
sdk.create.venv.dialog.error.empty.venv.location=Destination directory path can't be empty
sdk.create.venv.dialog.error.invalid.directory.name=Invalid directory name
sdk.create.venv.dialog.error.failed.to.create.venv=Failed to Create Virtual Environment

sdk.create.venv.dialog.title=Create Virtual Environment
sdk.create.venv.dialog.label.name=Name:
sdk.create.venv.dialog.label.location=Location:
sdk.create.venv.dialog.label.base.interpreter=Base interpreter:
sdk.create.venv.dialog.label.inherit.global.site.packages=Inherit global site-packages
sdk.create.venv.dialog.error.no.base.interpreter=Select base interpreter

sdk.create.venv.conda.dialog.title=Create Conda Environment
sdk.create.venv.conda.dialog.error.no.python.version=Select python version
sdk.create.venv.conda.dialog.label.python.version=Python version:

# remote interpreters
remote.interpreter.add.title=Add Remote Interpreter
remote.interpreter.configure.title=Configure Remote Python Interpreter
remote.interpreter.configure.path.title=Select Python Interpreter
remote.interpreter.configure.temp.files.path.title=Select Folder for PyCharm Helpers
remote.interpreter.default.interpreter.path=/usr/bin/python
remote.interpreter.docker.default.interpreter.path=python
remote.interpreter.unspecified.interpreter.path=Specify Python interpreter path
remote.interpreter.unspecified.temp.files.path=Specify path for PyCharm helpers
remote.interpreter.configure.path.label=Python interpreter path:
remote.interpreter.configure.temp.files.path.label=PyCharm helpers path:
remote.interpreter.error.plugin.missing=The Remote Hosts Access plugin is missing. Please enable the plugin in {0}.

# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name=Dynamic class based on {0}


# CommandLine
commandLine.inspection.name=Command-line inspection
commandLine.inspection.badCommand=Bad or unknown command. make sure this command really exists.
commandLine.inspection.badOption=Bad or unknown option. make sure this option really exists.
commandLine.inspection.badArgument=Argument can't have this value. use autocompletion to check list of possible values.
commandLine.inspection.excessArgument=Excess argument or argument is not possible here
# What to display if argument is available here, but no name provided
commandLine.argumentHint.defaultName=arguments
# What to display of user entered junk
commandLine.commandNotFound={0}: command not found

# Window with actions
# "X" button title
windowWithActions.closeWindow=Close window
# "Stop" button title
windowWithActions.stopProcess=Stop currently running process

formatter.panel.dict.alignment.do.not.align=Do not align
formatter.panel.dict.alignment.align.on.colon=Align on colon
formatter.panel.dict.alignment.align.on.value=Align on value
formatter.panel.dict.alignment.label=Dict alignment:
formatter.panel.add.trailing.line.feed=Add line feed at the end of file
formatter.panel.use.continuation.indent.for.arguments=Use continuation indent for arguments

formatter.left.bracket = Left bracket
formatter.around.eq.in.named.parameter = Around = in named parameter
formatter.around.eq.in.keyword.argument = Around = in keyword argument
formatter.braces = Braces
formatter.before.backslash = Before '\\'
formatter.before.hash = Before '#'
formatter.after.hash = After '#'
formatter.around.top.level.imports = After top-level imports:
formatter.after.local.imports=After local imports:
formatter.around.top.level.classes.and.function=Around top-level classes and functions:
formatter.around.multiplicative.operators=Multiplicative operators (*, @, /, %)
formatter.around.power.operator=Power operator (**)
formatter.single.clause.statements=Single-clause statements
formatter.multi.clause.statements=Multi-clause statements
formatter.force.new.line.after.colon=Force new line after colon
formatter.align.when.multiline=Align when multiline
formatter.collections.and.comprehensions=Collections and Comprehensions
formatter.import.statements=Import Statements
formatter.dictionary.literals=Dictionary literals

smartKeys.insert.backslash.in.statement.on.enter=Insert backslash when pressing Enter inside a statement
smartKeys.insert.self.in.method=Insert 'self' when defining a method
smartKeys.insert.type.placeholder.in.docstring.stub=Insert type placeholders in the documentation comment stub
