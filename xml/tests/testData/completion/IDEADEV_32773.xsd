<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xsd:schema xmlns="http://www.mulesource.org/schema/mule/core/2.1"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            xmlns:spring="http://www.springframework.org/schema/beans"
            xmlns:spring-context="http://www.springframework.org/schema/context"
            targetNamespace="http://www.mulesource.org/schema/mule/core/2.1"
            attributeFormDefault="unqualified"
            elementFormDefault="qualified">

    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:import namespace="http://www.springframework.org/schema/beans"
                schemaLocation="http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"/>
    <xsd:import namespace="http://www.springframework.org/schema/context"
                schemaLocation="http://www.springframework.org/schema/context/spring-context-2.5.xsd"/>

    <!--==============================================================-->
    <!--   Structure                                                  -->
    <!--==============================================================-->

    <!-- This defines the structure in abstract terms (except for a few simple/unique things like
         global properties).  We then provide some implementations below.  Other modules
         can provide other implementations. -->

    <xsd:element name="mule" type="muleType">
        <xsd:annotation>
            <xsd:documentation>
                Either the root element of a Mule configuration, or a "top-level" element in a Spring configuration, that contains further Mule elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="muleType">
        <xsd:sequence>
            <xsd:element name="description" type="descriptionType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        This can hold any kind of documentation consistent with the overall XML format). It is intended to be "human readable" only and is not used by the system.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:group ref="springRootElements"/>
                <xsd:group ref="muleRootElements"/>
            </xsd:choice>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:group name="springRootElements">
        <xsd:choice>
            <xsd:element ref="spring:beans">
                <xsd:annotation>
                    <xsd:documentation>
                        Allow embedding of further spring documents.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="spring:bean">
                <xsd:annotation>
                    <xsd:documentation>
                        We support direct use of spring beans via this tag.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="spring-context:property-placeholder">
                <xsd:annotation>
                    <xsd:documentation>
                        We support direct use of property placeholders via this tag.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:choice>
    </xsd:group>

    <xsd:group name="muleRootElements">
        <xsd:choice>
            <xsd:element name="global-property" type="globalPropertyType">
                <xsd:annotation>
                    <xsd:documentation>
                        A global property is a named string. It can be inserted in most attribute values using the #\[...\] syntax. So the attribute value "#\[foo\]" would be replaced by the value associated with the property named "foo".
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="configuration" type="configurationType">
                <xsd:annotation>
                    <xsd:documentation>
                        Defaults and general settings for the entire Mule system.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="notifications" type="notificationManagerType">
                <xsd:annotation>
                    <xsd:documentation>
                        Register listeners for notifications and associate interfaces with particular events.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-extension"/>
            <xsd:element ref="abstract-security-manager"/>
            <xsd:element ref="abstract-transaction-manager"/>
            <xsd:element ref="abstract-connector"/>
            <xsd:element ref="abstract-global-endpoint"/>
            <xsd:element ref="abstract-transformer"/>
            <xsd:element ref="abstract-filter"/>
            <xsd:element ref="abstract-model"/>
            <xsd:element ref="abstract-interceptor-stack"/>
        </xsd:choice>
    </xsd:group>

    <xsd:complexType name="descriptionType">
        <xsd:complexContent mixed="true">
            <xsd:extension base="xsd:anyType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-extension" abstract="true" type="abstractExtensionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for arbitrary extensions as children of the mule element. Other transports and modules may extend this if they need to add global elements to the configuration (but consider the more specific elements like abstract-connector first).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractExtensionType"/>

    <xsd:element name="abstract-connector" abstract="true" type="abstractConnectorType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for connector elements. Connector elements allow properties to be configured across all endpoints that use the same transport. If multiple connectors are defined for the same transport then each endpoint must name which connector is being used.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractConnectorType">
        <xsd:attribute name="name" type="substitutableName" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    Identifies the connector so that other elements can reference it.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-global-endpoint" abstract="true" type="abstractGlobalEndpointType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for global endpoint elements. Global endpoints are named templates that allow us to define an endpoint once and refer to it in several places. Currently the same template is used for both inbound and outbound endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractGlobalEndpointType">
        <xsd:attribute name="name" type="substitutableName" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    Identifies the endpoint so that other elements can reference it. This name can also be referenced in MuleClient.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-inbound-endpoint" abstract="true" type="abstractInboundEndpointType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for inbound endpoint elements. Inbound endpoints receive messages from the underlying transport. The message payload is then delivered to the component for processing.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInboundEndpointType">
        <xsd:attribute name="name" type="substitutableName">
            <xsd:annotation>
                <xsd:documentation>
                    Identifies the inbound endpoint in the registry, but is of relatively little use - it cannot be referred to from MuleClient, for example. For more useful aliases, use global endpoints.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-outbound-endpoint" abstract="true" type="abstractOutboundEndpointType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for outbound endpoint elements. Outbound endpoints dispatch messages to the underlying transport.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractOutboundEndpointType">
        <xsd:attribute name="name" type="substitutableName">
            <xsd:annotation>
                <xsd:documentation>
                    Identifies the outbound endpoint in the registry, but is of relatively little use - it cannot be referred to from MuleClient, for example. For more useful aliases, use global endpoints.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-transformer" abstract="true" type="abstractTransformerType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for transformer elements. Transformers convert message payloads.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractTransformerType">
        <xsd:attribute name="name" type="substitutableName">
            <xsd:annotation>
                <xsd:documentation>
                    Identifies the transformer so that other elements can reference it. Required if the transformer is defined at the global level.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="returnClass" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The class of the message generated by the transformer. This is used if transformers are auto-selected (which is somewhat incomplete at the moment).
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="ignoreBadInput" type="substitutableBoolean">
            <xsd:annotation>
                <xsd:documentation>
                    Many transformers only accept certain classes. Such transformers are never called with inappropriate input (whatever the value of this attribute). If a transformer forms part of a chain and cannot accept the current message class, then this flag controls whether the remaining part of the chain is evaluated. If true, the next transformer is called. If false the chain ends, keeping the result generated up to that point.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="globalPropertyType">
        <xsd:attribute name="name" type="substitutableName" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The name of the property. This is used inside #[...].
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="value" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The value of the property. This replaces each occurence of #[...].
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- seemed pointless making these simple container types abstract -->
    <xsd:complexType name="inboundCollectionType">
        <xsd:sequence>
            <xsd:element ref="abstract-inbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element ref="abstract-inbound-router" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element ref="abstract-catch-all-strategy" minOccurs="0"/>
        </xsd:sequence>
        <xsd:attribute name="matchAll" type="substitutableBoolean" default="true">
            <xsd:annotation>
                <xsd:documentation>
                    If true, the input message will be passed through inbound routers, otherwise only the first matching router is used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-catch-all-strategy" abstract="true" type="abstractCatchAllStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for catch-all strategy elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractCatchAllStrategyType"/>

    <xsd:element name="abstract-inbound-router" abstract="true" type="abstractInboundRouterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for inbound router elements. Inbound routers control how incoming messages are handled.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInboundRouterType"/>

    <xsd:element name="abstract-filter" abstract="true" type="abstractFilterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for filter elements. Filters are used to make decisions within the Mule framework.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractFilterType">
        <xsd:attribute name="name" type="substitutableName">
            <xsd:annotation>
                <xsd:documentation>
                    Identifies the filter so that other elements can reference it. Required if the filter is defined at the global level.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="not" type="substitutableBoolean">
            <xsd:annotation>
                <xsd:documentation>
                    Inverts the filter condition.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="outboundCollectionType">
        <xsd:sequence>
            <xsd:element ref="abstract-outbound-router" maxOccurs="unbounded"/>
            <xsd:element ref="abstract-catch-all-strategy" minOccurs="0"/>
        </xsd:sequence>
        <xsd:attribute name="matchAll" type="substitutableBoolean" default="false">
            <xsd:annotation>
                <xsd:documentation>
                    If true, the output message will be sent to all routers, otherwise only the first matching router is used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-outbound-router" abstract="true" type="abstractOutboundRouterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for outbound router elements. Outbound routers control how outgoing messages are delivered to the outbound endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractOutboundRouterType"/>

    <xsd:element name="abstract-transaction-manager" abstract="true" type="abstractTransactionManagerType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for transaction manager elements. Transaction managers are used to co-ordinate transactions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractTransactionManagerType"/>

    <xsd:complexType name="configurationType">
        <xsd:sequence>
            <xsd:element name="default-threading-profile" type="threadingProfileType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        The default threading profile, used by components and by endpoints for dispatching and receiving if no more specific configuration is given.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="default-dispatcher-threading-profile" type="threadingProfileType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        The default dispatching threading profile, modifies the default-threading-profile values and is used by endpoints for dispatching if no more specific configuration is given.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="default-receiver-threading-profile" type="threadingProfileType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        The default receiving threading profile, modifies the default-threading-profile values and is used by endpoints for receiving if no more specific configuration is given.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="default-service-threading-profile" type="threadingProfileType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        The default service threading profile, modifies the default-threading-profile values and is used if no more specific configuration is given.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-retry-policy" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        The default retry policy, used by connectors and endpoints if no more specific policy is configured for them.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="defaultSynchronousEndpoints" type="substitutableBoolean" default="false">
            <xsd:annotation>
                <xsd:documentation>
                    If true then connections to endpoints will wait for a response.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="defaultRemoteSync" type="substitutableBoolean" default="false">
            <xsd:annotation>
                <xsd:documentation>
                    If true then connections to endpoints will wait for a response from the remote service.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="defaultSynchronousEventTimeout" type="xsd:string" default="3000">
            <xsd:annotation>
                <xsd:documentation>
                    The default period (ms) to wait for a synchronous response.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="defaultTransactionTimeout" type="xsd:string" default="5000">
            <xsd:annotation>
                <xsd:documentation>
                    The default timeout for transactions, used if no more specific configuration is given.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="notificationManagerType">
        <xsd:sequence>
            <xsd:element name="notification" type="defineNotificationType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Associate an event with an interface. Listeners which implement the interface will receive instances of the event.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="disable-notification" type="disableNotificationType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Block the association of an event with a particular interface. This filters events after the association with a particular interface (and so takes precedence).
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="notification-listener" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Register a bean as a listener with the notification system. Events are dispatched by reflection - the listener will receive all events associated with any interfaces it implements. The relationship between interfaces and events is configured by the notification and disable-notification elements.
                    </xsd:documentation>
                </xsd:annotation>
                <xsd:complexType>
                    <xsd:attribute name="ref" type="xsd:NMTOKEN" use="required">
                        <xsd:annotation>
                            <xsd:documentation>
                                The bean that will receive notifications.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="subscription" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                An optional string that is compared with the event resource identifier. Only events with matching identifiers will be sent. If no value is given, all events are sent.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:complexType>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="dynamic" type="substitutableBoolean">
            <xsd:annotation>
                <xsd:documentation>
                    If the notification manager is dynamic then programatic updates to the manager (ie via Java code) will affect all messages. Otherwise, some parts of the system may cache state for efficiency and so not generate newly enabled notifications. The default value is false.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="defineNotificationType">
        <xsd:attribute name="event-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The class associated with a notification event that will be delivered to the interface. This can be used instead of the event attribute to specify a custom class.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="event" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The notification event to deliver.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The interface (class name) that will receive the notification event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The interface that will receive the notification event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="disableNotificationType">
        <xsd:attribute name="event-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The class associated with an event that will no longer be delivered to any interface. This can be used instead of the event attribute to specify a custom class.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="event" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The event to not deliver.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface-class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The interface (class name) that will no longer receive an event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="interface" type="notificationTypes">
            <xsd:annotation>
                <xsd:documentation>
                    The interface that will no longer receive an event.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>


    <xsd:simpleType name="notificationTypes">
        <xsd:restriction base="xsd:NMTOKEN">
            <xsd:enumeration value="CONTEXT"/>
            <xsd:enumeration value="MODEL"/>
            <xsd:enumeration value="SERVICE"/>
            <xsd:enumeration value="SECURITY"/>
            <xsd:enumeration value="ENDPOINT-MESSAGE"/>
            <xsd:enumeration value="COMPONENT-MESSAGE"/>
            <xsd:enumeration value="MANAGEMENT"/>
            <xsd:enumeration value="CONNECTION"/>
            <xsd:enumeration value="REGISTRY"/>
            <xsd:enumeration value="CUSTOM"/>
            <xsd:enumeration value="EXCEPTION"/>
            <xsd:enumeration value="TRANSACTION"/>
            <xsd:enumeration value="ROUTING"/>
            <!-- DEPRECATED -->
            <xsd:enumeration value="MESSAGE"/>
        </xsd:restriction>
    </xsd:simpleType>
    <!--==============================================================-->
    <!-- Models                                                       -->
    <!--==============================================================-->

    <xsd:element name="abstract-model" abstract="true" type="abstractModelType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for model elements. A model provides basic settings and processing for all the services it contains.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractModelType">
        <xsd:sequence>
            <xsd:element ref="abstract-exception-strategy" minOccurs="0"/>
            <xsd:group ref="entryPointResolvers"/>
            <xsd:element ref="abstract-service" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
        <xsd:attribute name="name" type="nonBlankString">
            <xsd:annotation>
                <xsd:documentation>
                    The name used to identify this model.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="seda-model" type="sedaModelType" substitutionGroup="abstract-model">
        <xsd:annotation>
            <xsd:documentation>
                A SEDA (Staged Event Drivern Architecture) model has separate threads and queues for each component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="sedaModelType">
        <xsd:complexContent>
            <xsd:extension base="abstractModelType">
                <xsd:sequence>
                    <xsd:element ref="abstract-queue-profile" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="inherit" type="xsd:boolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            If true then this model element is an extension of a previous model element with the same name.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="model" type="defaultModelType" substitutionGroup="abstract-model">
        <xsd:annotation>
            <xsd:documentation>
                The default model is a SEDA model.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="defaultModelType">
        <xsd:complexContent>
            <xsd:extension base="sedaModelType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Model elements -->

    <xsd:element name="abstract-queue-profile" abstract="true" type="abstractQueueProfileType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for queue profile elements. A queue profile controls how messages are queued before being processed.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractQueueProfileType"/>

    <!-- to give a cleaner config we allow either a set or an individual entry (but not both).-->
    <xsd:group name="entryPointResolvers">
        <xsd:choice>
            <xsd:element ref="abstract-entry-point-resolver-set" minOccurs="0"/>
            <!-- we could allow many of these, but it looks ugly -->
            <xsd:element ref="abstract-entry-point-resolver" minOccurs="0"/>
        </xsd:choice>
    </xsd:group>

    <xsd:element name="abstract-entry-point-resolver-set" abstract="true" type="abstractEntryPointResolverSetType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for entry point resolver set elements. These combine a group of entry point resolvers, trying them in turn until one succeeds.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractEntryPointResolverSetType"/>

    <xsd:element name="legacy-entry-point-resolver-set" type="extensibleEntryPointResolverSet"
                 substitutionGroup="abstract-entry-point-resolver-set">
        <xsd:annotation>
            <xsd:documentation>
                An extensible set of entry point resolvers (which determine how a message is passed to a component in Java) that already contains resolvers to implement the standard logic. This is already provided by default and is only needed explicitly if it will be extended with other entry point resolvers. This element can be set on the model or component; the model value provides a default which individual component values can override.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="entry-point-resolver-set" type="extensibleEntryPointResolverSet"
                 substitutionGroup="abstract-entry-point-resolver-set">
        <xsd:annotation>
            <xsd:documentation>
                An extensible set of entry point resolvers. These determine how a message is passed to a component in Java. Each entry point resolver is tried in turn until one succeeds in delivering the messge to the component. This element can be set on the model or component; the model value provides a default which individual component values can override.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="extensibleEntryPointResolverSet">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverSetType">
                <xsd:sequence>
                    <xsd:element ref="abstract-entry-point-resolver" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-entry-point-resolver-set" type="customEntryPointResolverSetType"
                 substitutionGroup="abstract-entry-point-resolver-set">
        <xsd:annotation>
            <xsd:documentation>
                A custom entry point resolver set. This allows user-supplied code to determine how a message is passed to a component in Java. This element can be set on the model or component; the model value provides a default which individual component values can override.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customEntryPointResolverSetType">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverSetType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the EntryPointResolverSet interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-entry-point-resolver" abstract="true" type="abstractEntryPointResolverType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an entry point resolver element. Entry point resolvers define how payloads are delivered to Java code by choosing the method to call.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="callable-entry-point-resolver" type="abstractEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                An entry point resolver for components that implement the Callable interface. This passes a MuleEventContext to the component. This element can be set on the model or component; the model value provides a default which individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractEntryPointResolverType"/>

    <xsd:element name="custom-entry-point-resolver" type="customEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                A custom entry point resolver. This allows user-supplied code to determine how a message is passed to a component in Java. This element can be set on the model or component; the model value provides a default which individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the EntryPointResolver interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="abstractEntryPointResolverType">
                <xsd:attribute name="transformFirst" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether the message should be transformed before being delivered to the component. By default, messages are transformed.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="acceptVoidMethods" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether the resolver should call void methods. By default, void methods are not considered as possible candidates for message delivery.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="property-entry-point-resolver" type="propertyEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Use a message property to select the component method to be called. This element can be set on the model or component; the model value provides a default which individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="propertyEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="baseEntryPointResolverType">
                <xsd:attribute name="property" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the message property used to select a method on the component.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="method-entry-point-resolver" type="methodEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Deliver the message to a named method. This element can be set on the model or component; the model value provides a default which individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="methodEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="baseEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element ref="include-entry-point" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="reflection-entry-point-resolver" type="reflectionEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Generate a list of candidate methods from the component via reflections. This element can be set on the model or component; the model value provides a default which individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="reflectionEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="baseEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element name="exclude-object-methods" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                If specified, methods in the Java Object interface are not included in the list of possible methods that can receive the message.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="exclude-entry-point" type="methodType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Explicitly exclude a named method from receiving the message.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="array-entry-point-resolver" type="complexEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Deliver the message to a method which takes a single array as argument. This element can be set on the model or component; the model value provides a default which individual component values can override. This element can also be used directly or as part of a set of resolvers; the resolvers in a set are used in turn until one is successful.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="no-arguments-entry-point-resolver" type="complexEntryPointResolverType"
                 substitutionGroup="abstract-entry-point-resolver">
        <xsd:annotation>
            <xsd:documentation>
                Call a method without arguments (the message is not passed to the component).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="complexEntryPointResolverType">
        <xsd:complexContent>
            <xsd:extension base="reflectionEntryPointResolverType">
                <xsd:sequence>
                    <xsd:element ref="include-entry-point" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="enableDiscovery" type="substitutableBoolean"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="include-entry-point" type="methodType">
        <xsd:annotation>
            <xsd:documentation>
                A possible method for delivery.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="methodType">
        <xsd:attribute name="method" type="nonBlankString">
            <xsd:annotation>
                <xsd:documentation>
                    The name of the method.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>


    <!--==============================================================-->
    <!--  Services                                                    -->
    <!--==============================================================-->

    <xsd:element name="abstract-service" abstract="true" type="abstractServiceType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a service element. Services combine message routing with a Java (typically) component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractServiceType">
        <xsd:attribute name="name" type="nonBlankString" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The name used to identify this service.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="baseServiceType">
        <xsd:annotation>
            <xsd:documentation>
                Base support for a model-based wrapper around the POJO service (SEDA, Streaming, etc.)
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractServiceType">
                <xsd:sequence>
                    <xsd:element name="description" type="descriptionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                This can hold any kind of documentation consistent with the overall XML format). It is intended to be "human readable" only and is not used by the system.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="inbound" type="inboundCollectionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The elements within "inbound" describe how a service receives messages.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <!-- minOccurs="0" to allow for <forwarding-router/> and/or default component -->
                    <xsd:element ref="abstract-component" minOccurs="0"/>
                    <xsd:element name="outbound" type="outboundCollectionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The elements within "outbound" describe how a services sends or dispatches messages.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="async-reply" type="asyncReplyCollectionType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                The elements within "async-reply" describe how asynchronous replies are handled.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element ref="abstract-exception-strategy" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="initialState" default="started">
                    <xsd:annotation>
                        <xsd:documentation>
                            The initial state of the service. Usually a service is started automatically, but this attribute can block any initial startup ("stopped") or stop the service immediately after initial startup ("paused").
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="started"/>
                            <xsd:enumeration value="stopped"/>
                            <xsd:enumeration value="paused"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-exception-strategy" abstract="true" type="abstractExceptionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an exception strategy element. Exception strategies define how Mule should react to errors.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="abstractExceptionStrategyType">
        <xsd:sequence>
            <xsd:element name="commit-transaction" type="exceptionPatternType" maxOccurs="1" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>Defines when a current transaction gets rolled-back depending on the name of the exception caught. Users can set a comma delimited list of wildcard patterns that wil be matched angainst the fully qualified classname of the current exception. Patterns defined for this element will leave the current transaction (if any) untouched and llow it to be committed.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element name="rollback-transaction" type="exceptionPatternType" maxOccurs="1" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>Defines when a current transaction gets rolled-back depending on the name of the exception caught. Users can set a comma delimited list of wildcard patterns that wil be matched angainst the fully qualified classname of the current exception. Patterns defined for this element will rollback the current transaction (if any).
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="enableNotifications" type="xsd:boolean">
            <xsd:annotation>
                <xsd:documentation>Determines whether ExceptionNotifications wil be fired from this strategy when an exception occurs.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="exceptionPatternType">
        <xsd:attribute name="exception-pattern" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>A comma-separate list of wildcard expressions that will be matched against the fully qualified cassname of the current exception received by the ExceptionStrategy.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-retry-policy" abstract="true" type="abstractRetryPolicyType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a retry policy element. Retry policies define how Mule should retry a failed message send/dispatch/request.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractRetryPolicyType">
        <xsd:sequence>
            <xsd:element ref="abstract-retry-notifier" minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:element name="abstract-retry-notifier" abstract="true" type="abstractRetryNotifierType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for a retry notifier element. The RetryNotifier interface is a callback that allows actions to be performed after each retry. For example, when retrying connections Mule will fire server notification events on success or failure.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractRetryNotifierType"/>

    <xsd:complexType name="asyncReplyCollectionType">
        <xsd:sequence>
            <xsd:element ref="abstract-inbound-endpoint" minOccurs="1" maxOccurs="unbounded"/>
            <xsd:element ref="abstract-async-reply-router" minOccurs="0" maxOccurs="1"/>
            <!-- TODO leaving this commented here, but I do not think there should be a transformer here -->
            <!--<xsd:element ref="abstract-transformer" minOccurs="0" maxOccurs="unbounded"/>-->
        </xsd:sequence>
        <xsd:attribute name="timeout" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    The timeout (ms) to wait for a reply.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="failOnTimeout" type="substitutableBoolean">
            <xsd:annotation>
                <xsd:documentation>
                    If the router times out before all expected events have been received should an exception be thrown or should the current events be returned for processing. The default is false.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="abstract-async-reply-router" abstract="true" type="abstractAsyncReplyRouterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an async reply router element. Asynchronous replies are handled via this router.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractAsyncReplyRouterType"/>

    <xsd:element name="service" type="sedaServiceType" substitutionGroup="abstract-service">
        <xsd:annotation>
            <xsd:documentation>
                The standard SEDA service. A service describes how to receive messages, deliver them to a component, and handle the results (if any).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="sedaServiceType">
        <xsd:complexContent>
            <xsd:extension base="baseServiceType">
                <xsd:sequence>
                    <xsd:element ref="abstract-service-threading-profile" minOccurs="0"/>
                    <xsd:element ref="abstract-queue-profile" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="queueTimeout" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The timeout used when taking messages from the SEDA queue.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-service" type="customServiceType" substitutionGroup="abstract-service">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemeted service (typically used only in testing).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customServiceType">
        <xsd:complexContent>
            <xsd:extension base="baseServiceType">
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The class to use for the service.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-service-threading-profile" abstract="true"
                 type="abstractServiceThreadingProfileType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for service threading profile element. Threading profiles define how thread pools interact with the component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractServiceThreadingProfileType"/>

    <!--==============================================================-->
    <!-- Components                                              -->
    <!--==============================================================-->

    <xsd:element name="abstract-component" abstract="true" type="abstractComponentType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for component element. A component processes data. Typically it is a Java object.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractComponentType">
        <xsd:group ref="interceptorGroup" minOccurs="0"/>
    </xsd:complexType>

    <xsd:element name="component" type="defaultJavaComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                A simple POJO (Plain Old Java Object) component that will be invoked by Mule when a message is received. The instance can be specified via a factory, or via a class.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="defaultJavaComponentType">
        <xsd:complexContent>
            <xsd:extension base="abstractComponentType">
                <xsd:sequence>
                    <xsd:group ref="entryPointResolvers"/>
                    <xsd:element ref="abstract-object-factory" minOccurs="0"/>
                    <xsd:element ref="abstract-lifecycle-adapter-factory" minOccurs="0"/>
                    <xsd:element name="binding" type="pojoBindingType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                A binding associates a Mule endpoint with an injected Java interface. This is like using Spring to inject a bean, but instead of calling a method on the bean a message is sent to an endpoint.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            Specify a component class. This is a shortcut that is equivalent to providing a prototype-object element.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="pooled-component" type="pooledJavaComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                A pooled POJO (Plain Old Java Object) component that will be invoked by Mule when a message is received. The instance can be specified via a factory, or via a class.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="pooledJavaComponentType">
        <xsd:complexContent>
            <xsd:extension base="defaultJavaComponentType">
                <xsd:sequence>
                    <xsd:element ref="abstract-pooling-profile" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>Characteristics of the object pool</xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="pojoBindingType">
        <xsd:sequence>
            <xsd:element ref="abstract-outbound-endpoint" minOccurs="1" maxOccurs="unbounded"/>
        </xsd:sequence>
        <xsd:attribute name="interface" use="required" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The interface to be injected. A proxy will be created that implements this interface by calling out to the endpoint.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="method" use="optional">
            <xsd:annotation>
                <xsd:documentation>
                    The method on the interface that should be used. This can be omitted if the interface has a single method.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="defaultComponentType">
        <xsd:complexContent>
            <xsd:extension base="abstractComponentType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="bridge-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                This transfers a message from inbound to outbound endpoints. This name is provided for backwards compatability - it is equivalent to not specifying any component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!-- don't expose this, it's not needed -->
    <!-- xsd:element name="pass-through-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                The default, "do nothing" component.
                The message is simply transferred from inbound to outbound endpoints.
                This is the default and need not be specified.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element -->

    <xsd:element name="echo-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                This logs the message and returns the payload back as the result.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="log-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                This logs the message content (or content length if it is a large message).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="null-component" type="defaultComponentType" substitutionGroup="abstract-component">
        <xsd:annotation>
            <xsd:documentation>
                This will throw an exception if it receives a message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>


    <!--==============================================================-->
    <!--   Transactions                                               -->
    <!--==============================================================-->

    <xsd:element name="abstract-transaction" abstract="true" type="abstractTransactionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for transaction elements. Transactions allow a series of operations to be grouped together.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="abstract-xa-transaction" abstract="true" type="abstractTransactionType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for XA transaction elements. XA Transactions allow a series of operations to be grouped together spanning different transports, e.g. JMS and JDBC.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractTransactionType">
        <xsd:attribute name="action">
            <xsd:annotation>
                <xsd:documentation>
                    NONE - Never participate in a transaction;
                    ALWAYS_BEGIN - Always start a new transaction when receiving an event. An exception will be thrown
                    if a transaction already exists;
                    BEGIN_OR_JOIN - If a transaction is already in progress when an event is received, join the
                    transaction, otherwise start a new transaction;
                    ALWAYS_JOIN - Always expects a transaction to be in progress when an event is received, if there is
                    no transaction an exception is thrown;
                    JOIN_IF_POSSIBLE - Will join the current transaction if one is available otherwise no transaction is
                    created.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="NONE"/>
                    <xsd:enumeration value="ALWAYS_BEGIN"/>
                    <xsd:enumeration value="BEGIN_OR_JOIN"/>
                    <xsd:enumeration value="ALWAYS_JOIN"/>
                    <xsd:enumeration value="JOIN_IF_POSSIBLE"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute name="timeout" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    Timeout for transaction (ms).
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:complexType name="baseTransactionType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransactionType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-transaction" type="customTransactionType" substitutionGroup="abstract-transaction">
        <xsd:annotation>
            <xsd:documentation>
                Allow access to user-defined or otherwise unsupported third-party transactions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customTransactionType">
        <xsd:complexContent>
            <xsd:extension base="baseTransactionType">
                <xsd:attribute name="factory-class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            A class that implements the TransactionFactory interface that will be instantiated and used to generate a transaction. This attribute and the "factory-ref" attribute are mutually exclusive; one of the two is required.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="factory-ref" type="xsd:NMTOKEN">
                    <xsd:annotation>
                        <xsd:documentation>
                            A bean that implements the TransactionFactory interface that will be used to generate a transaction. This attribute and the "factory-class" attribute are mutually exclusive; one of the two is required.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="xa-transaction" type="xaTransactionType" substitutionGroup="abstract-transaction">
        <xsd:annotation>
            <xsd:documentation>
                Allow access to XA transactions.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="xaTransactionType">
        <xsd:complexContent>
            <xsd:extension base="baseTransactionType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="transactionManagerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransactionManagerType">
                <xsd:attribute name="name" type="substitutableName" default="transactionManager" use="optional">
                    <xsd:annotation>
                        <xsd:documentation>
                            An optional name for the transaction manager. The default value is "transactionManager".
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="websphere-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The WebSphere transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="jboss-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The JBoss transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="jndiTransactionManagerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransactionManagerType">
                <xsd:sequence>
                    <xsd:element name="environment" type="mapType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                The JNDI environment.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="weblogic-transaction-manager" type="jndiTransactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The WebLogic transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="jrun-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The JRun transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="resin-transaction-manager" type="transactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                The Resin transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="jndi-transaction-manager" substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                Retrieve a named transaction manager factory from JNDI.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="jndiTransactionManagerType">
                    <xsd:attribute name="jndiName" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                The name of the manager factory to retrieve (eg java:/TransactionManager).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="custom-transaction-manager" type="customTransactionManagerType"
                 substitutionGroup="abstract-transaction-manager">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented transaction manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customTransactionManagerType">
        <xsd:complexContent>
            <xsd:extension base="jndiTransactionManagerType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The class to instantiate to create a transaction manager.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--==============================================================-->
    <!--   Endpoint elements                                          -->
    <!--==============================================================-->

    <xsd:element name="endpoint" type="globalEndpointType" substitutionGroup="abstract-global-endpoint">
        <xsd:annotation>
            <xsd:documentation>
                An endpoint "template" that can be used to construct an inbound or outbound endpoint elsewhere in the configuration by referencing the endpoint name. Each transport implements its own endpoint element, with a more friendly syntax, but this generic element can be used with any transport by supplying the correct address URI. For example, "vm://foo" describes a VM transport endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="globalEndpointType">
        <xsd:complexContent>
            <xsd:extension base="abstractGlobalEndpointType">
                <xsd:group ref="defaultEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <!-- extend this type for endpoints that support XA transactions -->
    <xsd:complexType name="globalEndpointWithXaType">
        <xsd:complexContent>
            <xsd:extension base="abstractGlobalEndpointType">
                <xsd:group ref="defaultXaEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="inbound-endpoint" type="inboundEndpointType" substitutionGroup="abstract-inbound-endpoint">
        <xsd:annotation>
            <xsd:documentation>
                An inbound endpoint receives messages from the associated transport. Each transport implements its own inbound endpoint element, with a more friendly syntax, but this generic element can be used with any transport by supplying the correct address URI. For example, "vm://foo" describes a VM transport endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="inboundEndpointType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundEndpointType">
                <xsd:group ref="defaultEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <!-- extend this type for endpoints that support XA transactions -->
    <xsd:complexType name="inboundEndpointWithXaType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundEndpointType">
                <xsd:group ref="defaultXaEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="outbound-endpoint" type="outboundEndpointType" substitutionGroup="abstract-outbound-endpoint">
        <xsd:annotation>
            <xsd:documentation>
                An outbound endpoint sends messages to the associated transport. Each transport implements its own outbound endpoint element, with a more friendly syntax, but this generic element can be used with any transport by supplying the correct address URI. For example, "vm://foo" describes a VM transport endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="outboundEndpointType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundEndpointType">
                <xsd:group ref="defaultEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="outboundEndpointWithXaType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundEndpointType">
                <xsd:group ref="defaultXaEndpointElements"/>
                <xsd:attributeGroup ref="defaultEndpointAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- these include option/repeats - should be embedded once -->
    <xsd:group name="defaultEndpointElements">
        <xsd:sequence>
            <xsd:sequence minOccurs="0" maxOccurs="unbounded">
                <xsd:group ref="endpointTransformers"/>
                <xsd:element ref="abstract-transaction" minOccurs="0"/>
                <xsd:element ref="abstract-filter" minOccurs="0"/>
                <xsd:element ref="abstract-security-filter" minOccurs="0"/>
                <xsd:element ref="abstract-retry-policy" minOccurs="0"/>
                <xsd:group ref="propertiesGroup"/>
            </xsd:sequence>
        </xsd:sequence>
    </xsd:group>
    <xsd:group name="defaultXaEndpointElements">
        <xsd:sequence>
            <xsd:sequence minOccurs="0" maxOccurs="unbounded">
                <xsd:group ref="endpointTransformers"/>
                <xsd:element ref="abstract-transaction" minOccurs="0"/>
                <xsd:element ref="abstract-xa-transaction" minOccurs="0"/>
                <xsd:element ref="abstract-filter" minOccurs="0"/>
                <xsd:element ref="abstract-security-filter" minOccurs="0"/>
                <xsd:group ref="propertiesGroup"/>
            </xsd:sequence>
        </xsd:sequence>
    </xsd:group>

    <xsd:element name="abstract-security-filter" abstract="true" type="abstractSecurityFilterType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for security filter elements. Security filters can control access to the system, etc.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractSecurityFilterType"/>

    <xsd:attributeGroup name="defaultEndpointAttributes">
        <xsd:attributeGroup ref="restrictedEndpointAttributes"/>
        <!-- these next two attributes are mutually exclusive and one is required.
             but there is no way to define this in a schema... -->
        <!-- endpoint references - dynamically checked to make sure not top level -->
        <xsd:attribute name="ref" type="xsd:NMTOKEN">
            <xsd:annotation>
                <xsd:documentation>
                    A reference to a global endpoint. If this attribute is used then the endpoint is used as a template to construct this endpoint. A template fixes the address (protocol, path, host, etc.), and may specify initial values for various properties, but further properties can be defined locally (as long as they do not change the address in any way).
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <!-- explicit or global endpoints -->
        <xsd:attribute name="address" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The generic address for this endpoint. If this attribute is used, the protocol must be specified as part of the URI. Alternatively, most transports provide their own attributes for specifying the address (path, host, etc.). Note that the address attribute cannot be combined with "ref" or with the transport-provided alternative attributes.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="restrictedEndpointAttributes">
        <xsd:attribute name="synchronous" type="substitutableBoolean">
            <xsd:annotation>
                <xsd:documentation>
                    If true, the result from the component processing the incoming message will be returned as a response.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="remoteSync" type="substitutableBoolean">
            <xsd:annotation>
                <xsd:documentation>
                    If true, the component will wait for a response to the outgoing message before replying to the incoming message.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="remoteSyncTimeout" type="substitutableInt">
            <xsd:annotation>
                <xsd:documentation>
                    The timeout for the remoteSync wait (ms).
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="encoding" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    String encoding used for messages.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="connector-ref" type="xsd:NMTOKEN">
            <xsd:annotation>
                <xsd:documentation>
                    The name of the connector associated with this endpoint. This must be specified if more than one connector is defined for this transport.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="transformer-refs" type="xsd:NMTOKENS">
            <xsd:annotation>
                <xsd:documentation>
                    A list of the transformers that will be applied to the message in order before it is delivered to the component.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="responseTransformer-refs" type="xsd:NMTOKENS">
            <xsd:annotation>
                <xsd:documentation>
                    A list of the transformers that will be applied to the synchronous response in order before it is returned via the transport.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:complexType name="endpointRefType">
        <xsd:attribute name="address" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The destination address for a reply message.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="ref" type="xsd:NMTOKEN">
            <xsd:annotation>
                <xsd:documentation>
                    The reference name of a global endpoint to use. If this EndpointRef will be associated to a message such as a Reply-To address, this endpoint ref has to be available on the remote Mule instance that reads the Reply-To address.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:group name="endpointTransformers">
        <xsd:annotation>
            <xsd:documentation>
                Allows the user to specify either a simple list of (normal) transformers or separate bracketed lists of normal and response transformers.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:choice>
            <xsd:group ref="transformersList"/>
            <xsd:sequence>
                <xsd:element name="transformers" minOccurs="0">
                    <xsd:annotation>
                        <xsd:documentation>
                            A list of transformer elements that will be applied to the message before it is delivered to the component. Note that a list of transformers can also be specified directly (without the "transformers" element), but then it is not possible to also specify response transformers (using the "response-transformers" element).
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:complexType>
                        <xsd:group ref="transformersList"/>
                    </xsd:complexType>
                </xsd:element>
                <xsd:element name="response-transformers" minOccurs="0">
                    <xsd:annotation>
                        <xsd:documentation>
                            A list of transformer elements that will be applied to the response message returned from the component.
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:complexType>
                        <xsd:group ref="transformersList"/>
                    </xsd:complexType>
                </xsd:element>
            </xsd:sequence>
        </xsd:choice>
    </xsd:group>

    <xsd:group name="transformersList">
        <xsd:annotation>
            <xsd:documentation>
                A list of transformers - normal or response, depending on context.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:element ref="abstract-transformer" minOccurs="0" maxOccurs="unbounded"/>
        </xsd:sequence>
    </xsd:group>

    <!--==============================================================-->
    <!--   Filter elements                                            -->
    <!--==============================================================-->

    <xsd:element name="filter" type="refFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that is defined elsewhere (at the global level, or as a Spring bean).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="refFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:attribute name="ref" type="xsd:NMTOKEN" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the filter to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="not-filter" type="unitaryFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                Invert the enclosed filter (so if it returns true for some message, this will return false, and vice-versa).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="unitaryFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-filter"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="and-filter" type="collectionFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                Return true only if all the enclosed filters return true.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="or-filter" type="collectionFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                Return true if any of the enclosed filters returns true.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="collectionFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-filter" minOccurs="2" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="wildcard-filter" type="wildcardFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches string messages against wildcards. It performs matches with "*", for example, "jms.events.*" would catch "jms.events.customer" and "jms.events.receipts". This filter accepts a comma-separated list of patterns, so more than one filter pattern can be matched for a given argument: "jms.events.*, jms.actions.*" will match "jms.events.system" and "jms.actions" but not "jms.queue".
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="wildcardFilterType">
        <xsd:complexContent>
            <xsd:extension base="caseSensitivePatternFilterType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="expression-filter" type="expressionFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that can evaluate a range of expressions. It supports some base expression types such as header, payload (payload type), regex, and wildcard.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="expressionFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:attribute name="evaluator" use="required">
                    <xsd:annotation>
                        <xsd:documentation>The expression evaluator to use. The expression filter supports some types such as header, payload, exception, wildcard and regex, that are in-built filters not registered with the ExpressionEvaluatorManager. All others are registered with the ExpressionEvaluatorManager. Where XPath, bean, and ONGL are used, the expression should be a boolean expression.
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="substitutableName">
                            <xsd:enumeration value="header"/>
                            <xsd:enumeration value="payload-type"/>
                            <xsd:enumeration value="exception-type"/>
                            <xsd:enumeration value="wildcard"/>
                            <xsd:enumeration value="regex"/>
                            <xsd:enumeration value="ognl"/>
                            <xsd:enumeration value="xpath"/>
                            <xsd:enumeration value="jxpath"/>
                            <xsd:enumeration value="groovy"/>
                            <xsd:enumeration value="bean"/>
                            <xsd:enumeration value="custom"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="expression" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>The expression that will be evaluated. This should always be a boolean expression. The syntax of the expression will be determined by the expression language being used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="customEvaluator" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>Must be set if the evaluator is set to custom. The custom evaluator must be registered with the ExpressionEvaluatorManager if it is to be used here.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="nullReturnsTrue" type="substitutableBoolean">
                    <xsd:annotation>
                        <xsd:documentation>Whether the filter should return true if the specified expression returns null.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="regex-filter" type="patternFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches string messages against a regular expression. The Java regular expression engine (java.util.regex.Pattern) is used.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="patternFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:attribute name="pattern" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The property name and possibly value to use when matching. If the expression is just a property name, the filter will check that the property exists. Users can also uses '=' and '!=' to determine a specific value for a property.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="message-property-filter" type="caseSensitivePatternFilterType"
                 substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches properties on a message. This can be very useful as the message properties represent all the meta information about the message from the underlying transport, so for a message received over HTTP, you can check for HTTP headers and so forth. The pattern should be expressed as a key/value pair, such as "propertyName=value". If you want to compare more than one property, you can use the logic filters for And, Or, and Not expressions. By default the comparison is case sensitive, which you can override with the caseSensitive property.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="caseSensitivePatternFilterType">
        <xsd:complexContent>
            <xsd:extension base="patternFilterType">
                <xsd:attribute name="caseSensitive" type="substitutableBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            If false, the comparison ignores case.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="exception-type-filter" type="typeFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches the type of an exception.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="payload-type-filter" type="typeFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that matches the type of the payload.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="typeFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:attribute name="expectedType" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The expected class used in the comparison.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-filter" type="customFilterType" substitutionGroup="abstract-filter">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented filter.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractFilterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the Filter interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   Interceptor elements                                       -->
    <!--==============================================================-->
    <xsd:element name="abstract-interceptor-stack" abstract="true" type="abstractInterceptorStackType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for interceptor stack elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInterceptorStackType">
        <xsd:sequence maxOccurs="unbounded">
            <xsd:element ref="abstract-interceptor"/>
        </xsd:sequence>
        <xsd:attribute name="name" type="nonBlankString" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The name used to identify this interceptor stack.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>
    <xsd:element name="interceptor-stack" type="abstractInterceptorStackType" substitutionGroup="abstract-interceptor-stack"/>


    <xsd:element name="abstract-interceptor" abstract="true" type="abstractInterceptorType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for an interceptor element.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractInterceptorType"/>

    <xsd:group name="interceptorGroup">
        <xsd:sequence>
            <xsd:choice maxOccurs="unbounded">
                <xsd:element ref="abstract-interceptor"/>
                <xsd:element name="interceptor-stack" type="refInterceptorStackType"/>
            </xsd:choice>
        </xsd:sequence>
    </xsd:group>

    <xsd:complexType name="refInterceptorStackType">
        <xsd:attribute name="ref" type="xsd:NMTOKEN" use="required">
            <xsd:annotation>
                <xsd:documentation>
                    The name of the interceptor stack to use.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:element name="timer-interceptor" type="abstractInterceptorType" substitutionGroup="abstract-interceptor">
        <xsd:annotation>
            <xsd:documentation>
                The timer interceptor (ported from 1.x).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="logging-interceptor" type="abstractInterceptorType" substitutionGroup="abstract-interceptor">
        <xsd:annotation>
            <xsd:documentation>
                The logging interceptor (ported from 1.x).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="custom-interceptor" type="customInterceptorType" substitutionGroup="abstract-interceptor">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented interceptor.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customInterceptorType">
        <xsd:complexContent>
            <xsd:extension base="abstractInterceptorType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the Interceptor interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- security filters -->

    <xsd:element name="encryption-security-filter" type="encryptionSecurityFilterType"
                 substitutionGroup="abstract-security-filter">
        <xsd:annotation>
            <xsd:documentation>
                A filter that provides password-based encyption.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="encryptionSecurityFilterType">
        <xsd:complexContent>
            <xsd:extension base="abstractSecurityFilterType">
                <xsd:attribute name="strategy-ref" type="xsd:NMTOKEN">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the encryption strategy to use. This should be configured using the password-encryption-strategy element, inside a security-manager element at the top level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--==============================================================-->
    <!--   Transformer elements                                       -->
    <!--==============================================================-->

    <xsd:element name="transformer" type="refTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A reference to a transformer defined elsewhere.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="refTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:attribute name="ref" type="xsd:NMTOKEN" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the transformer to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="auto-transformer" type="abstractTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that uses the transform discovery mechanism to convert the message payload. This transformer works much better when transforming custom object types rather than Java types, because there is less chance for ambiguity.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="custom-transformer" type="customTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A user-implemented transformer.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the Transformer interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="message-properties-transformer" type="messagePropertiesTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that can add or delete message properties.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="messagePropertiesTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="delete-message-property" type="keyType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Delete a message property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="add-message-property" type="keyValueType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Add a message property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="rename-message-property" type="keyValueType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Rename a message property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="add-message-properties" type="mapType" minOccurs="0" maxOccurs="1">
                        <xsd:annotation>
                            <xsd:documentation>
                                Add a set of message properties.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:choice>
                <xsd:attribute name="overwrite" type="substitutableBoolean" use="optional" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            If false, a property is not added if the message already contains a property with that name.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="no-action-transformer" type="abstractTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that has no effect.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="base64-encoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that base64 encodes a string or byte array message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="base64-decoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that base64 decodes a message to give an array of bytes.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="xml-entity-encoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that encodes a string using XML entities.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="xml-entity-decoder-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that decodes a string containing XML entities.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="gzip-compress-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that compresses a byte array using gzip.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="gzip-uncompress-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that uncompresses a byte array using gzip.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-hex-string-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to a string of hexadecimal digits.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="hex-string-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a string of hexadecimal digits to a byte array.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-object-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to an object (either deserializing or converting to a string).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="object-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that serializes all objects except strings (which are converted using getBytes()).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="object-to-string-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that gives a human-readable description of various types (useful for debugging).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-serializable-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to an object (deserializing the object).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="serializable-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts an object to a byte array (serializing the object).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="byte-array-to-string-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a byte array to a string.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="string-to-byte-array-transformer" type="abstractTransformerType"
                 substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that converts a string to a byte array.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="append-string-transformer" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that appends a string to a string payload.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractTransformerType">
                    <xsd:attribute name="message" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>
                                The string to append.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:element name="encrypt-transformer" type="encryptionTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that encrypts a message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="decrypt-transformer" type="encryptionTransformerType" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that decrypts a message.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="encryptionTransformerType">
        <xsd:complexContent>
            <xsd:extension base="abstractTransformerType">
                <xsd:attribute name="strategy-ref" type="xsd:NMTOKEN">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the encryption strategy to use. This should be configured using the password-encryption-strategy element, inside a security-manager element at the top level.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="expression-transformer" substitutionGroup="abstract-transformer">
        <xsd:annotation>
            <xsd:documentation>
                A transformer that evaluates one or more expressions on the current event. Each expression equates to a parameter in the return message. The return message for two or more expressions will be an Object[].
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="abstractTransformerType">
                    <xsd:sequence minOccurs="1" maxOccurs="unbounded">
                        <xsd:element name="return-argument">
                            <xsd:complexType>
                                <xsd:attributeGroup ref="expressionAttributes"/>
                                <xsd:attribute name="optional" type="substitutableBoolean" use="optional">
                                    <xsd:annotation>
                                        <xsd:documentation>If the expression evaluates to null, whether to continue to the next expression without error.
                                        </xsd:documentation>
                                    </xsd:annotation>
                                </xsd:attribute>
                            </xsd:complexType>
                        </xsd:element>
                    </xsd:sequence>
                    <xsd:attribute name="returnSourceIfNull" type="xsd:boolean" use="optional">
                        <xsd:annotation>
                            <xsd:documentation>If all expressions return null on this transformer, this flag will cause the source payload to be returned without modification.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>

    <xsd:attributeGroup name="expressionAttributes">
        <xsd:attribute name="evaluator" use="required">
            <xsd:annotation>
                <xsd:documentation>The expression evaluator to use. Expression Evaluators must be registered with the ExpressionEvaluatrManager before thay can be used. Using the custom evaluator allows the developer to define their own in the 'custom-evaluator' attribute. Note that some evaluators such as xpath, groovy, and bean are loaded from other Mule modules (XML and Scripting, respectively). These modules must be on your classpath before the evaluator can be used.
                </xsd:documentation>
            </xsd:annotation>
            <xsd:simpleType>
                <xsd:restriction base="substitutableName">
                    <xsd:enumeration value="groovy"/>
                    <xsd:enumeration value="header"/>
                    <xsd:enumeration value="headers"/>
                    <xsd:enumeration value="headers-list"/>
                    <xsd:enumeration value="attachment"/>
                    <xsd:enumeration value="attachments"/>
                    <xsd:enumeration value="attachments-list"/>
                    <xsd:enumeration value="message"/>
                    <xsd:enumeration value="map-payload"/>
                    <xsd:enumeration value="payload"/>
                    <xsd:enumeration value="xpath"/>
                    <xsd:enumeration value="jxpath"/>
                    <xsd:enumeration value="bean"/>
                    <xsd:enumeration value="ognl"/>
                    <xsd:enumeration value="function"/>
                    <xsd:enumeration value="custom"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
        <xsd:attribute name="expression" type="xsd:string" use="required">
            <xsd:annotation>
                <xsd:documentation>The expression to evaluate. The syntax of this attribute will change depending on the evaluator being used.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="custom-evaluator" type="substitutableName" use="optional">
            <xsd:annotation>
                <xsd:documentation>The name of the custom evaluator to use. This attribute is only used when the evaluator attribute is set to custom. You can plug in your own expression evaluators by registering them with the ExpressionEvaluatorManager.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:attributeGroup>

    <!--==============================================================-->
    <!--   Shared elements                                             -->
    <!--==============================================================-->

    <xsd:element name="queue-profile" type="queueProfileType" substitutionGroup="abstract-queue-profile">
        <xsd:annotation>
            <xsd:documentation>
                Specifies the properties of an internal Mule queue. Internal queues are used to queue messages for each component managed by Mule.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="queueProfileType">
        <xsd:complexContent>
            <xsd:extension base="abstractQueueProfileType">
                <xsd:attribute name="maxOutstandingMessages" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines the maximum number of messages that can be queued.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="persistent" type="substitutableBoolean" default="false">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether Mule messages are persisted to a store. Primarily, this is used for persisting queued messages to disk so that the internal state of the server is mirrored on disk in case the server fails and needs to be restarted. Default is false.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-security-manager" type="abstractSecurityManagerType" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                A security manager is a container for security providers. More than one security manager may be configured; each contains providers from a particular module and has that module type. This element is abstract - a security-related module or transport will provide a suitable implementation.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="abstractSecurityManagerType">
        <xsd:annotation>
            <xsd:documentation>
                An empty holder that can be extended by modules that want to provide security managers. Typically it will contain elements called module:type-security-provider, which extend securityProviderType where "module" might be "acegi" and "type" might de "delegate", for example. It can also contain encryption strategies, which should follow a similar scheme and extend encryptionStrategyType.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="id" fixed="_muleSecurityManager"/>
        <xsd:attribute name="name" fixed="_muleSecurityManager"/>
    </xsd:complexType>

    <xsd:element name="security-manager" type="securityManagerType" substitutionGroup="abstract-security-manager">
        <xsd:annotation>
            <xsd:documentation>
                The default security manager.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="securityManagerType">
        <xsd:annotation>
            <xsd:documentation>
                The default security manager (type mule:defaultSecurityManagerType) provides basic support for security functions. Other modules (Acegi, JAAS, PGP) provide more advanced functionality.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractSecurityManagerType">
                <xsd:sequence>
                    <xsd:element name="custom-security-provider" type="customSecurityProviderType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Allow any implementation of SecurityProvider to be used.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="custom-encryption-strategy" type="customEncryptionStrategyType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Allow any implementation of EncryptionStrategy to be used.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="secret-key-encryption-strategy" type="secretKeyEncryptionStrategyType"
                                 minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Provides secret key-based encryption using JCE.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="password-encryption-strategy" type="passwordEncryptionStrategyType"
                                 minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Provides password-based encryption using JCE. Users must specify a password and optionally a salt and iteration count as well. The default algorithm is PBEWithMD5AndDES, but users can specify any valid algorithm supported by JCE.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="securityProviderType">
        <xsd:annotation>
            <xsd:documentation>
                A security provider is a source of specific security-related functionality.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="name" type="substitutableName" use="required"/>
    </xsd:complexType>

    <xsd:complexType name="encryptionStrategyType">
        <xsd:annotation>
            <xsd:documentation>
                An encryption strategy provides support for a specific encryption algorithm.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="name" type="substitutableName" use="required"/>
    </xsd:complexType>

    <xsd:complexType name="customSecurityProviderType">
        <xsd:complexContent>
            <xsd:extension base="securityProviderType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="provider-ref" type="xsd:NMTOKEN" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the security provider to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="customEncryptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="encryptionStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="strategy-ref" type="xsd:NMTOKEN" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            A reference to the encryption strategy (which may be a Spring bean that implements the EncryptionStrategy interface).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="passwordEncryptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="encryptionStrategyType">
                <xsd:attribute name="password" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            The password to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="salt" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The salt to use (this helps prevent dictionary attacks).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="iterationCount" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The number of itreations to use.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="secretKeyEncryptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="encryptionStrategyType">
                <xsd:attribute name="key" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The key to use. This and the keyFactory-ref attribute are mutually exclusive.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="keyFactory-ref" type="xsd:NMTOKEN">
                    <xsd:annotation>
                        <xsd:documentation>
                            The name of the key factory to use. This should implement the ObjectFactory interface and return a byte array. This and the key attribute are mutually exclusive.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="threading-profile" type="threadingProfileType"
                 substitutionGroup="abstract-service-threading-profile">
        <xsd:annotation>
            <xsd:documentation>
                The threading profile to use for the service.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <!-- this is a general threading type used by various elements here -->
    <xsd:complexType name="threadingProfileType">
        <xsd:complexContent>
            <!-- this is a hack that allows us to use this general threading profile as a component threading profile
                 without retyping everything -->
            <xsd:extension base="abstractServiceThreadingProfileType">
                <xsd:attribute name="maxThreadsActive" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The maximum number of threads that will be used.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxThreadsIdle" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            The maximum number of idle or inactive threads that can be in the pool before they are destroyed.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="threadTTL" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Detemines how long an inactive thread is kept in the pool before being discarded.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="poolExhaustedAction">
                    <xsd:annotation>
                        <xsd:documentation>
                            When the maximum pool size or queue size is bounded, this value determines how to handle incoming tasks. Possible values are: WAIT (wait until a thread becomes available. This policy should, in general, not be used if the minimum number of threads is zero, in which case a thread may never become available.), DISCARD (throw away the current request and return), DISCARD_OLDEST (throw away the oldest request and return), ABORT (throw a RuntimeException), and RUN (the thread making the execute request runs the task itself. This policy helps guard against lockup.)
                        </xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="WAIT"/>
                            <xsd:enumeration value="DISCARD"/>
                            <xsd:enumeration value="DISCARD_OLDEST"/>
                            <xsd:enumeration value="ABORT"/>
                            <xsd:enumeration value="RUN"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="threadWaitTimeout" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            How long to wait in milliseconds when the pool exhausted action is WAIT. If the value is negative, it will wait indefinitely.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="doThreading" type="substitutableBoolean" default="true">
                    <xsd:annotation>
                        <xsd:documentation>
                            Whether threading should be used (default is true).
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxBufferSize" type="substitutableInt">
                    <xsd:annotation>
                        <xsd:documentation>
                            Determines how many requests are queued when the pool is at maximum usage capacity and the pool exhausted action is WAIT. The buffer is used as an overflow.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   Exception strategies                                       -->
    <!--==============================================================-->

    <xsd:element name="default-service-exception-strategy" type="endpointExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Provide default exception handling via an endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:element name="default-connector-exception-strategy" type="endpointExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Provide default exception handling via an endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="endpointExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractExceptionStrategyType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-exception-strategy" type="customExceptionStrategyType"
                 substitutionGroup="abstract-exception-strategy">
        <xsd:annotation>
            <xsd:documentation>
                A user-defined exception stratgey.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customExceptionStrategyType">
        <xsd:complexContent>
            <xsd:extension base="endpointExceptionStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            A class that implements the ExceptionListener interface. In addition, if an outbound-endpoint element is specified, it is set as an "endpoint" bean property.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Custom connector element -->

    <xsd:element name="custom-connector" type="customConnectorType" substitutionGroup="abstract-connector">
        <xsd:annotation>
            <xsd:documentation>
                A user-defined connector.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customConnectorType">
        <xsd:complexContent>
            <xsd:extension base="connectorType">
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            A class that implements the Connector interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--  Object stores                                                     -->
    <!--==============================================================-->


    <xsd:complexType name="abstractObjectStoreType"/>

        <xsd:element name="abstract-object-store" abstract="true" type="abstractObjectStoreType">
            <xsd:annotation>
                <xsd:documentation>
                    A placeholder for an object store that can be used by routers to maintain state.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:element>

        <xsd:element name="in-memory-store" type="abstractMonitoredObjectStoreType"
                     substitutionGroup="abstract-object-store">
            <xsd:annotation>
                <xsd:documentation>
                    An optionally bounded in-memory store for message IDs with periodic expiry of old entries. The bounded size is a soft limit and is only enforced periodically by the expiry process; this means that the store may temporarily exceed its maximum size between expiry runs but will eventually shrink to its configured size.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:element>

        <xsd:element name="simple-text-file-store" type="textFileObjectStoreType" substitutionGroup="abstract-object-store">
            <xsd:annotation>
                <xsd:documentation>
                    A Simple object store that stores String objects by key to a text file. This store is only suitable for storing simple key value pair strings. This store is backed by an in-memory store and supports the ability to expire and apply TTL to objects in the store.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:element>

        <xsd:complexType name="textFileObjectStoreType">
            <xsd:complexContent>
                <xsd:extension base="abstractMonitoredObjectStoreType">
                    <xsd:attribute name="directory" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                The file location (directory) where the object store will be saved. If this value is not set, Mule defaults to using the {{mule.working.dir/objectstore}}.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>

        <xsd:complexType name="abstractMonitoredObjectStoreType">
            <xsd:complexContent>
                <xsd:extension base="abstractObjectStoreType">
                    <xsd:attribute name="name" type="xsd:string">
                        <xsd:annotation>
                            <xsd:documentation>
                                An ID for this store that can be used for logging and identification purposes.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="maxEntries" type="substitutableInt">
                        <xsd:annotation>
                            <xsd:documentation>
                                The maximum number of entries that this store keeps around. Specify {{-1}} if the store is supposed to be "unbounded".
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="entryTTL" type="substitutableInt">
                        <xsd:annotation>
                            <xsd:documentation>
                                The time-to-live for each message ID, specified in seconds, or {{-1}} for entries that should never expire. DO NOT combine this with an unbounded store!
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="expirationInterval" type="substitutableInt">
                        <xsd:annotation>
                            <xsd:documentation>
                                The interval for periodic bounded size enforcement and entry expiration, specified in seconds. Arbitrary positive values between one second and several hours or days are possible, but should be chosen carefully according to the expected message rate to prevent OutOfMemory conditions.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>

    <!--==============================================================-->
    <!--  Routers                                                     -->
    <!--==============================================================-->

    <xsd:element name="abstract-message-info-mapping" abstract="true" type="abstractMessageInfoMappingType">
        <xsd:annotation>
            <xsd:documentation>Maps the attributes of the current message to known message elements in Mule; namely, Message ID, CorrrelationID.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="abstractMessageInfoMappingType"/>

    <!-- Inbound Router implementations -->

    <xsd:complexType name="filteredInboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-filter" minOccurs="0"/>
                    <!-- TODO this does not make sense here, need to re-visit <xsd:element ref="abstract-message-info-mapping" minOccurs="0"/>-->
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="idempotent-receiver-router" type="idempotentReceiverType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Ensures that only unique messages are received by a service by checking the unique ID of the incoming message. Note that the ID used can be generated from the message using an expression defined in the {{idExpression}} attribute. By default, the expression used is #\[message:id\], which means the underlying endpoint must support unique message IDs for this to work. Otherwise, a {{UniqueIdNotSupportedException}} is thrown.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="idempotent-secure-hash-receiver-router" type="idempotentSecureHashReceiverType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Ensures that only unique messages are received by a service by calculating the hash of the message itself using a message digest algorithm. This provides a value with an infinitesimally small chance of a collision. This can be used to filter message duplicates. Keep in mind that the hash is calculated over the entire byte array representing the message, so any leading or trailing spaces or extraneous bytes (like padding) can produce different hash values for the same semantic message content. Care should be taken to ensure that messages do not contain extraneous bytes. This class is useful when the message does not support unique identifiers.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="idempotentReceiverType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-object-store" maxOccurs="1" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="idExpression" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            Defines one or more expressions to use when extrating the ID from the message. For example, it would be possible to combine to headers as the ID of the message to provide idempotency: "#\[headers:foo,bar\]". Or, you could combine the message ID with a header: "#\[message:id\]-#[header:foo]". If this property is not set, "#\[message:id\]" will be used by default.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="idempotentSecureHashReceiverType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-object-store" maxOccurs="1" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="messageDigestAlgorithm" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The secure hashing algorithm to use. If not set, the default is SHA-256.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:element name="wire-tap-router" type="wireTapRouterType" substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                The WireTap inbound router allows you to route certain messages to a different endpoint as well as to the component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="wireTapRouterType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="1" maxOccurs="1"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="forwarding-router" type="selectiveConsumerRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows messages to be forwarded to the outbound routers without first being processed by a component.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="selective-consumer-router" type="selectiveConsumerRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Applies one or more filters to the incoming message. If the filters match, the message is forwarded to the component. Otherwise, the message is forwarded to the catch-all strategy on the router. If no catch-all strategy is configured, the message is ignored and a warning is logged.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="correlation-resequencer-router" type="baseAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Holds back a group of messages and resequences them using each message's correlation sequence property.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="selectiveConsumerRouterType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-transformer" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="transformer-refs" type="xsd:NMTOKENS"/>
                <xsd:attribute name="transformFirst" type="substitutableBoolean"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="message-chunking-aggregator-router" type="messageChunkingAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Combines two or more messages into a single message by matching messages with a given Correlation ID. Correlation IDs are set on messages when they are dispatched by certain outbound routers, such as the Recipient List and Message Splitter routers. These messages can be aggregated back together again using this router.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="messageChunkingAggregatorRouterType">
        <xsd:complexContent>
            <xsd:extension base="baseAggregatorRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-message-info-mapping" minOccurs="0"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-correlation-aggregator-router" type="customCorrelationAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a custom message aggregator. Mule provides an abstract implementation that has a template method that performs the message aggregation. A common use of the aggregator router is to combine the results of multiple requests such as "ask this set of vendors for the best price of X".
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customCorrelationAggregatorRouterType">
        <xsd:complexContent>
            <xsd:extension base="messageChunkingAggregatorRouterType">
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="collection-aggregator-router" type="baseAggregatorRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a Collection Response Router. This will return a MuleMessageCollection message type that will contain all events received for a each correlation group.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="custom-inbound-router" type="customInboundRouterType"
                 substitutionGroup="abstract-inbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows for custom inbound routers to be configured.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="customInboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of InboundRouter (fully qualified Java class name)
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="baseAggregatorRouterType">
        <xsd:complexContent>
            <xsd:extension base="filteredInboundRouterType">
                <xsd:attribute name="timeout" type="substitutableInt"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- ResponseRouters -->

    <xsd:element name="single-async-reply-router" type="asyncReplyRouterType"
                 substitutionGroup="abstract-async-reply-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a Single Response Router. This will return the first message it receives on a reply endpoint and will discard the rest.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="collection-async-reply-router" type="asyncReplyRouterType"
                 substitutionGroup="abstract-async-reply-router">
        <xsd:annotation>
            <xsd:documentation>
                Configures a Collection Response Router. This will return a MuleMessageCollection message type that will contain all messages received for the current correlation.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="asyncReplyRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractAsyncReplyRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-inbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element ref="abstract-message-info-mapping" minOccurs="0"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-async-reply-router" type="customAsyncReplyRouterType"
                 substitutionGroup="abstract-async-reply-router"/>
    <xsd:complexType name="customAsyncReplyRouterType">
        <xsd:complexContent>
            <xsd:extension base="asyncReplyRouterType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- Outbound Router implementations -->

    <!-- Outbound router element and attribute groups -->

    <xsd:group name="defaultOutboundRouterElements">
        <xsd:sequence>
            <xsd:element name="reply-to" type="endpointRefType" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Defines where the message should be routed after the recipient of the message this service dispatches to has finished with it.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-transaction" minOccurs="0" />
            <xsd:element ref="abstract-message-info-mapping" minOccurs="0" />
        </xsd:sequence>
    </xsd:group>

    <xsd:group name="defaultFilteredOutboundRouterElements">
        <xsd:sequence>
            <xsd:group ref="defaultOutboundRouterElements" />
            <xsd:element ref="abstract-filter" minOccurs="0">
                <xsd:annotation>
                    <xsd:documentation>
                        Filters the messages to be processed by this router.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="abstract-transformer" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Filters are applied before message transformations. A transformer can be configured here to transform messages before they are filtered.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
        </xsd:sequence>
    </xsd:group>

    <xsd:attributeGroup name="defaultOutboundRouterAttributes">
        <xsd:attribute name="enableCorrelation" default="IF_NOT_SET">
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN">
                    <xsd:enumeration value="ALWAYS" />
                    <xsd:enumeration value="NEVER" />
                    <xsd:enumeration value="IF_NOT_SET" />
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="defaultFilteredOutboundRouterAttributes">
        <xsd:attributeGroup ref="defaultOutboundRouterAttributes"/>
        <xsd:attribute name="transformer-refs" type="xsd:NMTOKENS"/>
    </xsd:attributeGroup>

    <!-- Default Outbound Router Types -->
    <xsd:complexType name="outboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint"/>
                    <xsd:group ref="defaultOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultOutboundRouterAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="filteringOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint"/>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

     <xsd:complexType name="multipleEndpointFilteringOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" maxOccurs="unbounded"/>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--  Concrete Outbound Routers -->

    <xsd:element name="pass-through-router" type="outboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                This router always matches and simply sends or dispatches message via the endpoint that is configured.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--  FilteringOutboundRouter only uses a single endpoint. For now this needs to support multiple endpoints for MessageBuilderComponent usage only. -->
    <xsd:element name="filtering-router" type="multipleEndpointFilteringOutboundRouterType" substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Uses filters to determine whether the message matches a particular criteria and if so will route the message to the endpoint configured on the router.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="template-endpoint-router" type="filteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows endpoints to be altered at runtime based on properties set on the current message or fallback values set on the endpoint properties. Templated values are expressed using square braces around a property name.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="chaining-router" type="multipleEndpointFilteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the message through multiple endpoints using the result of the first invocation as the input for the next.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="exception-based-router" type="multipleEndpointFilteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends a message over an endpoint by selecting the first endpoint that can connect to the transport.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="multicasting-router" type="multipleEndpointFilteringOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message over multiple endpoints.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="endpoint-selector-router" type="endpointSelectorRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                // TODO
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="endpointSelectorRouterType">
        <xsd:complexContent>
            <xsd:extension base="multipleEndpointFilteringOutboundRouterType">
                <xsd:attributeGroup ref="expressionAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Splitter routers -->
    <xsd:element name="list-message-splitter-router" type="messageSplitterOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Accepts a list of objects that will be routed to different endpoints. The actual endpoint used for each object in the list is determined by a filter configured on the endpoint itself.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="messageSplitterOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="multipleEndpointFilteringOutboundRouterType">
                <!-- this is not exposed to the user afaict? -->
                <!-- xsd:attribute name="multimatch" type="substitutableBoolean"/ -->
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="expression-splitter-router" type="expressionSplitterOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Splits the message based on an expression. The expression must return one or more message parts in order to be effective.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>


    <xsd:complexType name="expressionSplitterOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="messageSplitterOutboundRouterType">
                <xsd:attributeGroup ref="expressionAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="message-chunking-router" type="chunkingRouterType" substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows you to split a single message into a number of fixed-length messages that will all be routed to the same endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="chunkingRouterType">
        <xsd:complexContent>
            <xsd:extension base="multipleEndpointFilteringOutboundRouterType">
                <xsd:attribute name="messageSize" type="substitutableInt"/>
                <xsd:attribute name="numberOfMessages" type="substitutableInt"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="static-recipient-list-router" type="staticRecipientListRouterType" substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple endpoints over the same endpoint or to implement routing-slip behaviour where the next destination for the message is determined from message properties or the payload. It uses a static list of recipient endpoints, which are specified via the attribute recipientsProperty and delimited by the attribute recipientsDelimieter.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="staticRecipientListRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                    <xsd:element name="recipients" type="listOrSetType" minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
                <xsd:attribute name="recipientsProperty" type="xsd:string"/>
                <xsd:attribute name="recipientsDelimiter" type="xsd:string"/>
                <xsd:attribute name="synchronous" type="xsd:boolean"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="expression-recipient-list-router" type="expressionRecipientListRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Sends the same message to multiple endpoints over the same endpoint or implements routing-slip behaviour where the next destination for the message is determined from message properties or the payload. It uses a list of recipients endpoints, which are extracted from the message using an expression. (As of 2.1)
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="expressionRecipientListRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                    <xsd:element name="recipients" type="listOrSetType" minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
                <xsd:attributeGroup ref="expressionAttributes"/>
                <xsd:attribute name="synchronous" type="xsd:boolean"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-outbound-router" type="customOutboundRouterType"
                 substitutionGroup="abstract-outbound-router">
        <xsd:annotation>
            <xsd:documentation>
                Allows you to configure a custom outbound router by specifying the custom router class and by using Spring properties.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customOutboundRouterType">
        <xsd:complexContent>
            <xsd:extension base="abstractOutboundRouterType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:group ref="defaultFilteredOutboundRouterElements"/>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attributeGroup ref="defaultFilteredOutboundRouterAttributes"/>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of OutboundRouter (fully qualified Java class name)
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!-- Catch all strategy implementations -->
    <xsd:element name="logging-catch-all-strategy" type="loggingCatchAllStrategyType" substitutionGroup="abstract-catch-all-strategy">
        <xsd:annotation>
            <xsd:documentation>
                 Does nothing with the message but simply logs (using the WARN log level) the fact that the message was not dispatched because no routing path was defined.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="loggingCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractCatchAllStrategyType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-catch-all-strategy" type="customCatchAllStrategyType"
                 substitutionGroup="abstract-catch-all-strategy"/>
    <xsd:complexType name="customCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractCatchAllStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="forwarding-catch-all-strategy" type="forwardingCatchAllStrategyType"
                 substitutionGroup="abstract-catch-all-strategy">
        <xsd:annotation>
            <xsd:documentation>
                Forwards the message to the specified endpoint if no outbound routers match.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="forwardingCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="abstractCatchAllStrategyType">
                <xsd:sequence>
                    <xsd:element ref="abstract-outbound-endpoint" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-forwarding-catch-all-strategy" type="customForwardingCatchAllStrategyType"
                 substitutionGroup="abstract-catch-all-strategy"/>
    <xsd:complexType name="customForwardingCatchAllStrategyType">
        <xsd:complexContent>
            <xsd:extension base="forwardingCatchAllStrategyType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- Message Info Mappers -->

    <xsd:element name="expression-message-info-mapping" type="expressionMessageInfoMappingType"
                 substitutionGroup="abstract-message-info-mapping">
        <xsd:annotation>
            <xsd:documentation>
                Allows expressions to be configured to extract the message information.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="expressionMessageInfoMappingType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageInfoMappingType">
                <xsd:attribute name="messageIdExpression" type="xsd:string" use="required"/>
                <xsd:attribute name="correlationIdExpression" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="custom-message-info-mapping" type="customMessageInfoMappingType"
                 substitutionGroup="abstract-message-info-mapping">
        <xsd:annotation>
            <xsd:documentation>
                Allows configuraton of a custom implementation of MessageInfoMapping.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="customMessageInfoMappingType">
        <xsd:complexContent>
            <xsd:extension base="abstractMessageInfoMappingType">
                <xsd:sequence>
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                </xsd:sequence>
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the MessageInfoMapping interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <!--==============================================================-->
    <!--  Lifecycle Adapters                                            -->
    <!--==============================================================-->

    <xsd:element name="abstract-lifecycle-adapter-factory" abstract="true" type="abstractLifecycleAdapterFactory"/>
    <xsd:complexType name="abstractLifecycleAdapterFactory">
        <xsd:annotation>
            <xsd:documentation>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:complexType>
    <xsd:complexType name="customLifecycleAdapterFactory">
        <xsd:complexContent>
            <xsd:extension base="abstractLifecycleAdapterFactory">
                <xsd:attribute name="class" type="substitutableClass" use="required">
                    <xsd:annotation>
                        <xsd:documentation>
                            An implementation of the LifecycleAdapter interface.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="custom-lifecycle-adapter-factory" type="customLifecycleAdapterFactory"
                 substitutionGroup="abstract-lifecycle-adapter-factory">
        <xsd:annotation>
            <xsd:documentation>
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--==============================================================-->
    <!--  Object Factories                                            -->
    <!--==============================================================-->

    <xsd:element name="abstract-object-factory" abstract="true" type="abstractObjectFactoryType"/>
    <xsd:complexType name="abstractObjectFactoryType">
        <xsd:annotation>
            <xsd:documentation>
                A factory that will be used by Mule to create new instances of this object.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
            <xsd:group ref="propertiesGroup">
                <xsd:annotation>
                    <xsd:documentation>
                        Properties to be set on the created object.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:group>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:complexType name="genericObjectFactoryType">
        <xsd:sequence>
            <xsd:element ref="abstract-object-factory"/>
        </xsd:sequence>
    </xsd:complexType>

    <xsd:element name="spring-object" type="springBeanLookupType" substitutionGroup="abstract-object-factory"/>
    <xsd:complexType name="springBeanLookupType">
        <xsd:complexContent>
            <xsd:extension base="abstractObjectFactoryType">
                <xsd:attribute name="bean" type="substitutableName">
                    <xsd:annotation>
                        <xsd:documentation>Name of Spring bean to look up.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="singleton-object" type="singletonObjectFactoryType" substitutionGroup="abstract-object-factory"/>
    <xsd:complexType name="singletonObjectFactoryType">
        <xsd:complexContent>
            <xsd:extension base="abstractObjectFactoryType">
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>Class name</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="prototype-object" type="prototypeObjectFactoryType" substitutionGroup="abstract-object-factory"/>
    <xsd:complexType name="prototypeObjectFactoryType">
        <xsd:complexContent>
            <xsd:extension base="abstractObjectFactoryType">
                <xsd:attribute name="class" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>Class name</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="abstract-pooling-profile" abstract="true" type="abstractPoolingProfileType"/>
    <xsd:complexType name="abstractPoolingProfileType"/>

    <xsd:element name="pooling-profile" type="poolingProfileType" substitutionGroup="abstract-pooling-profile"/>
    <xsd:complexType name="poolingProfileType">
        <xsd:annotation>
            <xsd:documentation>
                A pooling profile is used to configure the pooling behaviour of Mule components. Each service sets its own pooling profile. The org.mule.config.PoolingProfile class contains all the necessary values to create a pool of component proxies.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractPoolingProfileType">
                <xsd:attribute name="maxActive" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Controls the maximum number of Mule components that can be borrowed from a session at one time. When set to a negative value, there is no limit to the number of components that may be active at one time. When maxActive is exceeded, the pool is said to be exhausted.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="maxIdle" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Controls the maximum number of Mule components that can sit idle in the pool at any time. When set to a negative value, there is no limit to the number of Mule components that may be idle at one time.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="initialisationPolicy" default="INITIALISE_ONE">
                    <xsd:annotation>
                        <xsd:documentation>Determines how components in a pool should be initialized. The possible values are: INITIALISE_NONE (will not load any components into the pool on startup), INITIALISE_ONE (will load one initial component into the pool on startup), or INITIALISE_ALL (will load all components in the pool on startup)</xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="INITIALISE_NONE"/>
                            <xsd:enumeration value="INITIALISE_ONE"/>
                            <xsd:enumeration value="INITIALISE_ALL"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="exhaustedAction" default="WHEN_EXHAUSTED_GROW">
                    <xsd:annotation>
                        <xsd:documentation>Specifies the behavior of the Mule component pool when the pool is exhausted. Possible values are: "WHEN_EXHAUSTED_FAIL", which will throw a NoSuchElementException, "WHEN_EXHAUSTED_WAIT", which will block (invoke Object.wait(long)) until a new or idle object is available, or WHEN_EXHAUSTED_GROW, which will create a new Mule and return it, essentially making maxActive meaningless. If a positive maxWait value is supplied, it will block for at most that many milliseconds, after which a NoSuchElementException will be thrown. If maxThreadWait is a negative value, it will block indefinitely.</xsd:documentation>
                    </xsd:annotation>
                    <xsd:simpleType>
                        <xsd:restriction base="xsd:NMTOKEN">
                            <xsd:enumeration value="WHEN_EXHAUSTED_GROW"/>
                            <xsd:enumeration value="WHEN_EXHAUSTED_WAIT"/>
                            <xsd:enumeration value="WHEN_EXHAUSTED_FAIL"/>
                        </xsd:restriction>
                    </xsd:simpleType>
                </xsd:attribute>
                <xsd:attribute name="maxWait" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>Specifies the number of milliseconds to wait for a pooled component to become available when the pool is exhausted and the exhaustedAction is set to WHEN_EXHAUSTED_BLOCK.</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <!-- <xsd:attribute name="factory" type="xsd:string" default="org.mule.config.pool.CommonsPoolFactory"/> -->
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <!--==============================================================-->
    <!--  Utils / Standard Types                                      -->
    <!--==============================================================-->


    <xsd:complexType name="abstractAgentType">
        <xsd:annotation>
            <xsd:documentation>
                A placeholder for agents. Not used in core, but common to several modules.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="abstractExtensionType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- corresponds to TlsIndirectKeyStore, named as tls-client in transport namespace -->
    <xsd:complexType name="tlsClientKeyStoreType">
        <xsd:annotation>
            <xsd:documentation>
                Configure client key stores. TLS/SSL connections are made on behalf of an entity, which can be anonymous or identified by a certificate - this interface specifies how a keystore can be used to provide the certificates (and associated private keys) necessary for identification. This is also used as the trust store if no other trust store is specified and the explicitTrustStoreOnly parameter in the server trust store configuration is false. WARNING - due to restrictions in library implementations the values specified here typically apply to all connectors using this transport.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="path" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The location (which will be resolved relative to the current classpath and file system, if possible) of the keystore that contains public certificates and private keys for identification.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="storePassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protect the keystore.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The type of keystore used (a Java class name).
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- corresponds to TlsDirectKeyStore, named as tls-key-store in transport namespace -->
    <xsd:complexType name="tlsKeyStoreType">
        <xsd:annotation>
            <xsd:documentation>
                Configures key stores. TLS/SSL connections are made on behalf of an entity, which can be anonymous or identified by a certificate - this interface specifies how a keystore can be used to provide the certificates (and associated private keys) necessary for identification.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="path" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The location (which will be resolved relative to the current classpath and file system, if possible) of the keystore that contains public certificates and private keys for identification.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="class" type="substitutableClass">
            <xsd:annotation>
                <xsd:documentation>
                    The type of keystore used (a Java class name).
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="keyPassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protect the private key.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="storePassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protect the keystore.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="algorithm" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The algorithm used by the key store.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- corresponds to TlsIndirectTrustStore, named as tls-trust-store in transport namespace -->
    <xsd:complexType name="tlsTrustStoreType">
        <xsd:annotation>
            <xsd:documentation>
                Configures a trust store. TLS/SSL connections are made to trusted systems - the public certificates of trusted systems are store in a keystore (called a trust store) and used to verify that the connection made to a remote system "really is" the expected identity.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="path" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The location (which will be resolved relative to the current classpath and file system, if possible) of the keystore that contains public certificates of trusted servers.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="storePassword" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    The password used to protected the trust store.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <!-- corresponds to TlsDirectTrustStore, named as tls-server in transport namespace
         note that this extends tlsTrustStoreType, so only one of the two is needed -->
    <xsd:complexType name="tlsServerTrustStoreType">
        <xsd:complexContent>
            <xsd:extension base="tlsTrustStoreType">
                <xsd:attribute name="class" type="substitutableClass"/>
                <xsd:attribute name="algorithm" type="xsd:string"/>
                <!-- should be of type TrustManagerFactory -->
                <xsd:attribute name="factory-ref" type="xsd:NMTOKEN"/>
                <xsd:attribute name="explicitOnly" type="substitutableBoolean"/>
                <xsd:attribute name="requireClientAuthentication" type="substitutableBoolean"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!-- corresponds to TlsProtocolHandler, named as tls-protocol-handler -->
    <xsd:complexType name="tlsProtocolHandler">
        <xsd:annotation>
            <xsd:documentation>
                Configures the global Java protocol handler. WARNING - Untested.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="property" type="xsd:string">
            <xsd:annotation>
                <xsd:documentation>
                    Sets the java.protocol.handler.pkgs system property.
                </xsd:documentation>
            </xsd:annotation>
        </xsd:attribute>
    </xsd:complexType>

    <xsd:simpleType name="propertyPlaceholderType">
        <xsd:annotation>
            <xsd:documentation>
                A type that defines a Mule-style property placeholder
            </xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:string">
            <xsd:pattern value="(\#\[[^\]]+\]|\$\{[^\}]+\})"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableClass">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:NMTOKEN-like type that also allows for Ant-style property placeholders and a leading [
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:pattern value="\[?[A-Za-z0-9_\.$]+"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="nonBlankString">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:string-like type that cannot be empty.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:pattern value=".*[^ ]+.*"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableName">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:NMTOKEN type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:NMTOKEN"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutablePortNumber">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:int type that also allows for Ant-style property placeholders and restricts the int value to a valid port number.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:int">
                    <xsd:minInclusive value="0"/>
                    <xsd:maxInclusive value="65536"/>
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableInt">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:int type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:int"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableLong">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:long type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:long"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <xsd:simpleType name="substitutableBoolean">
        <xsd:annotation>
            <xsd:documentation>
                A custom xsd:boolean type that also allows for Ant-style property placeholders.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:union>
            <xsd:simpleType>
                <xsd:restriction base="propertyPlaceholderType"/>
            </xsd:simpleType>
            <xsd:simpleType>
                <xsd:restriction base="xsd:boolean"/>
            </xsd:simpleType>
        </xsd:union>
    </xsd:simpleType>

    <!-- i found this a bit confusing, so here is some background...
         this type is typically called from something like
           <xsd:element name="properties" type="mapType/>
         and the "properties" element generates a ChildMapDefinitionParser that
         can "receive" the map entries generated by the embedded spring <entry..>
         elements and which is then set via "setProperties" on the parent.
         in other words, it's a map, and despite the name "properties" has
         nothing to do with the spring <property ...> element.
         spring elements like <entry...> are handled by
         MuleHierarchicalBeanDefinitionParserDelegate which punts them to
         the spring handler -->
    <xsd:element name="properties" type="mapType">
        <xsd:annotation>
            <xsd:documentation>
                Sets Mule properties. These are name/value pairs that can be set on components, services, etc., and which provide a generic way of configuring the system. In Mule 2.x, you shouldn't need to use generic properties like this, since almost all functionality is exposed via dedicated elements. However, they can be useful in configuring obscure or overlooked options and in configuring transports from the generic endpoint elements.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>
    <xsd:complexType name="mapType">
        <xsd:complexContent>
            <xsd:extension base="spring:mapType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:group name="propertiesGroup">
        <xsd:sequence>
            <xsd:element name="property" type="keyValueType" minOccurs="0" maxOccurs="unbounded">
                <xsd:annotation>
                    <xsd:documentation>
                        Sets a Mule property. This is a name/value pair that can be set on components, services, etc., and which provide a generic way of configuring the system. In Mule 2.x, you shouldn't need to use a generic property like this, since almost all functionality is exposed via dedicated elements. However, it can be useful in configuring obscure or overlooked options and in configuring transports from the generic endpoint elements.
                    </xsd:documentation>
                </xsd:annotation>
            </xsd:element>
            <xsd:element ref="properties" minOccurs="0"/>
        </xsd:sequence>
    </xsd:group>

    <xsd:complexType name="listOrSetType">
        <xsd:complexContent>
            <xsd:extension base="spring:listOrSetType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="referenceType">
        <xsd:attribute name="ref" type="xsd:NMTOKEN"/>
    </xsd:complexType>

    <xsd:complexType name="keyType">
        <xsd:attribute name="key" type="xsd:string"/>
    </xsd:complexType>

    <xsd:complexType name="valueType">
        <xsd:attribute name="value" type="xsd:string"/>
        <xsd:attribute name="value-ref" type="xsd:NMTOKEN"/>
    </xsd:complexType>

    <xsd:complexType name="keyValueType">
        <xsd:complexContent>
            <xsd:extension base="keyType">
                <xsd:attribute name="value" type="xsd:string"/>
                <xsd:attribute name="value-ref" type="xsd:NMTOKEN"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   Connector support                                          -->
    <!--==============================================================-->

    <xsd:complexType name="connectorType">
        <xsd:complexContent>
            <xsd:extension base="abstractConnectorType">
                <xsd:sequence>
                    <!-- for normal connectors, this is for emergency use only, but it is
                         critical for custom connector -->
                    <xsd:element ref="spring:property" minOccurs="0" maxOccurs="unbounded"/>
                    <xsd:element name="receiver-threading-profile" type="threadingProfileType" minOccurs="0"/>
                    <xsd:element name="dispatcher-threading-profile" type="threadingProfileType" minOccurs="0"/>
                    <xsd:element ref="abstract-exception-strategy" minOccurs="0"/>
                    <xsd:element ref="abstract-retry-policy" minOccurs="0"/>
                    <xsd:element name="service-overrides" type="serviceOverridesType" minOccurs="0"/>
                </xsd:sequence>
                <xsd:attribute name="createMultipleTransactedReceivers" type="substitutableBoolean"/>
                <xsd:attribute name="numberOfConcurrentTransactedReceivers" type="substitutableInt"/>
                <xsd:attribute name="dynamicNotification" type="substitutableBoolean"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="serviceOverridesType">
        <xsd:attribute name="messageReceiver" type="xsd:NMTOKEN"/>
        <xsd:attribute name="transactedMessageReceiver" type="xsd:NMTOKEN"/>
        <xsd:attribute name="xaTransactedMessageReceiver" type="xsd:NMTOKEN"/>
        <xsd:attribute name="dispatcherFactory" type="xsd:NMTOKEN"/>
        <xsd:attribute name="inboundTransformer" type="xsd:NMTOKEN"/>
        <xsd:attribute name="outboundTransformer" type="xsd:NMTOKEN"/>
        <xsd:attribute name="responseTransformer" type="xsd:NMTOKEN"/>
        <xsd:attribute name="endpointBuilder" type="xsd:NMTOKEN"/>
        <xsd:attribute name="messageAdapter" type="xsd:NMTOKEN"/>
        <xsd:attribute name="streamMessageAdapter" type="xsd:NMTOKEN"/>
        <xsd:attribute name="serviceFinder" type="xsd:NMTOKEN"/>
        <xsd:attribute name="sessionHandler" type="xsd:NMTOKEN"/>
    </xsd:complexType>

    <!--==============================================================-->
    <!--   JNDI support                                               -->
    <!--==============================================================-->

    <xsd:complexType name="jndiConnectorType">
        <xsd:complexContent>
            <xsd:extension base="connectorType">
                <xsd:sequence>
                    <xsd:element name="jndi-provider-property" type="keyValueType" minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>
                                Direct setting of a JNDI property.
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                    <xsd:element name="jndi-provider-properties" type="mapType" minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>
                                Direct setting of JNDI properties (allows access to the full Spring map entry).
                            </xsd:documentation>
                        </xsd:annotation>
                    </xsd:element>
                </xsd:sequence>
                <xsd:attribute name="jndiContext-ref" type="xsd:NMTOKEN">
                    <xsd:annotation>
                        <xsd:documentation>
                            Set the complete context directly, via a bean reference.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="jndiInitialFactory" type="substitutableClass">
                    <xsd:annotation>
                        <xsd:documentation>
                            The initial context factory to use. The value of the property should be the fully qualified class name of the factory class that will create an initial context.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="jndiProviderUrl" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The service provider to use. The value of the property should contain a URL string (such as "ldap://somehost:389").
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="jndiUrlPkgPrefixes" type="xsd:string">
                    <xsd:annotation>
                        <xsd:documentation>
                            The list of package prefixes to use when loading in URL context factories. The value of the property should be a colon-separated list of package prefixes for the class name of the factory class that will create a URL context factory.
                        </xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="dataReferenceType" mixed="true">
        <xsd:attribute name="file" type="xsd:string"/>
        <xsd:attribute name="ref" type="xsd:string"/>
        <!--I don't like this flag, may be we could use content-type mappings... -->
        <xsd:attribute name="binary" type="substitutableBoolean"/>
    </xsd:complexType>

    <!-- these cannot be references (unless we use qualified attribute names, which are ugly),
         but serve as templates to cut+paste in individual transports

    <xsd:attribute name="path" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                A file location.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="user" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                A username.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="password" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                A password.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="host" type="xsd:string">
        <xsd:annotation>
            <xsd:documentation>
                An IP address (eg www.mulesource.com, localhost, 127.0.0.1).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    <xsd:attribute name="port" type="substitutablePortNumber">
        <xsd:annotation>
            <xsd:documentation>
                A port number.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:attribute>

    -->


</xsd:schema>
