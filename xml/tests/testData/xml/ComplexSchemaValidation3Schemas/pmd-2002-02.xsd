<?xml version="1.0"?>
<!--http://www.w3.org/2001/XMLSchema-->
<xsd:schema targetNamespace="http://schemas.niku.com/2002/pmd" xmlns="http://schemas.niku.com/2002/pmd" xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
  <xsd:include schemaLocation="common-2003-09.xsd"/>
  <xsd:element name="persistMetaData" type="PersistMetaDataType"/>
  <xsd:complexType name="PersistMetaDataType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Elements of type persistMetaData represents interactions with persistence mechanisms such as database servers and tries to solve two competing goals. 1. Use all the vendor specific capabilities of a given database vendor within the SQL text. 2. Appear to be portable to the application. Vendor specific functionality such as stored procedures, views and resultsets are allowed. Database portability is also facilitated by several notions. E.g. The ability to have different SQL texts per statement per database server vendor and the ability to have different SQL error codes per exception per database server vendor.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice maxOccurs="unbounded">
      <xsd:element name="statementSet" type="StatementSetType"/>
      <xsd:element name="statement" type="StatementType"/>
      <xsd:element name="sql" type="SqlType"/>
    </xsd:choice>
    <xsd:attribute name="schemaLocation" type="xsd:string" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="StatementSetType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">A statementSet describes a logical grouping of database statements. The sub statementRef elements serve as pointers to the statements in question and provides an indirection so that statements can be reused in different contexts and potetnially with different input sources and locations.</xsd:documentation>
    </xsd:annotation>
    <xsd:choice maxOccurs="unbounded">
      <xsd:element name="statementRef" type="StatementRefType"/>
      <xsd:element name="statement" type="StatementType"/>
    </xsd:choice>
    <xsd:attribute name="location" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">For internal use only.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="id" type="IdType" use="required">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">The id of the statementSet. Must be unique within the component in which it is specified and must be of the form &lt;component&gt;.ID.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="rootElementName" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">In case the statements defined in this statementSet returns data (e.g. one or more queries) and the client requested XML as output the output will be enclosed in an element specified with the rootElementName. If none is specified the output will not have this root element.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="databaseId" type="xsd:string" use="optional" default="Niku">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">The databaseId refers to the specific database instance as defined in the properties.xml file to use.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="requiresLinguisticSort" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If set to true, at least one statement expects to sort something in a linguistic manner. In Oracle this translates to setting the NLS_SORT variable to a value consistent with a users chosen Locale. (NOTE: This will probably change in the next version of the Persistence Implementation to handel both Oracle and SQL Server)</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="SqlRefType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">A sqlref is a reference to a sql element identified by it's id. There has to be one and only one sql element with the id of the sqlRef for a given database vendor.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="condition" type="ConditionType" minOccurs="0" maxOccurs="1"/>
    </xsd:sequence>
    <xsd:attribute name="id" type="IdType" use="required">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This is the reference to the sql element to be included.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="StatementRefType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">A statementRef is a reference to a statement element identified by it's id. There has to be one and only one statement with the id of the statementRef. There may be more than one statementRef pointing to a statement however.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="staticMap" type="StaticMapType" minOccurs="0"/>
      <xsd:element name="secondaryInput" type="SecondaryInputType" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="outputMapping" type="OutputMappingType" minOccurs="0"/>
    </xsd:sequence>
    <xsd:attribute name="id" type="IdType" use="required">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This is the reference to the statement to be executed.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="defaultSortColumn" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This value specifies the default sort column if none is passed in the data header.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="defaultSortDirection" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This value specifies the default sort direction if none is passed in the data header.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="InputAttributeGroup">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Determines the so-called driving input to the statement. Sometimes a statement requires no input in which case you specify "none" as the input source and the statement will be executed exactly once. Sometimes, e.g. in a simple query, you have input necessary to form the where-clause (e.g. an id) and the driving input will contain one node (in case of "xml" input) or one Map (in case of "map" input). While in the case of batch updates you will have more than one row of driving input and the statement will be executed once for every.</xsd:documentation>
      </xsd:annotation>
    </xsd:attributeGroup>
    <xsd:attributeGroup ref="SharedStatementAttributeGroup"/>
  </xsd:complexType>
  <xsd:attributeGroup name="SharedStatementAttributeGroup">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Specifies attributes shared between elements of type StatementRefType and StatementType when they appear inline.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="sortColumnPath" type="xsd:string" default="/data/header/sortInfo/@sortColumn">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This XPath value specifies the location of the column to sort on. Defaults to the Data XML defined position of the sort column.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="sortDirectionPath" type="xsd:string" default="/data/header/sortInfo/@sortDirection">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This XPath value specifies the location of the sort direction. Defaults to the Data XML defined position of the sort direction.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="slicePath" type="xsd:string" default="/data/header/pagination/sliceInfo/@slice">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This XPath value specifies the location of the slice (aka. page) to get. Defaults to the Data XML defined position of the slice.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="sliceSizePath" type="xsd:string" default="/data/header/pagination/sliceInfo/@sliceSize">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This XPath value specifies the location of the slice size (aka. rows per page) to use. Defaults to the Data XML defined position of the slice size.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="defaultSliceSize" type="xsd:integer" default="20">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This integer value specifies the default slice size (aka. rows per page) to use. Defaults to 20.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="ignoreIfError" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If the call to the persistence layer is done in error mode and this attribute is set to "true" on execution of the statementSet this particular statement will be ignored.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="hideResultSets" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If true, the potential result sets from this statement are only visible within the enclosing statement set. I.e. to be used as input (using inputSource="responseMap") but will not affect the number of result sets returned from executing the complete statement set.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:attributeGroup>
  <xsd:attributeGroup name="InputAttributeGroup">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Specifies information needed to identify a subset of input as either driving or secondary input.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="inputSource" type="InputSourceType" default="none">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">The source of input.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="inputLocation" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">XPath specifying a node set which serves as input. Required if inputSource="xml".</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="inputMapIndex" type="xsd:integer" default="0">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">The index of the array of Maps which serves as input. Required if inputSource="map" or inputSource="responseMap".</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:attributeGroup>
  <xsd:simpleType name="InputSourceType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">A call to a PMD statementSet can be issued with no input or one of three input sources. If "none" is specified the statement will be executed exactly once. If "xml" is specified an input document is expected and if "map" input is expected is the form of one or more arrays of maps. If "staticMap" is specified a subelement of type StaticMapType is expected to be provided as input. If "responseMap" is specified input is taken from the potentially partial result created by a statement preceding this statement in the current statementSet.</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="none"/>
      <xsd:enumeration value="xml"/>
      <xsd:enumeration value="map"/>
      <xsd:enumeration value="staticMap"/>
      <xsd:enumeration value="responseMap"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="StaticMapType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Defines a static map specified in a PMD file. I.e. one or more entry elements which map a name to a value.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="entry" type="StaticMapEntryType" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="StaticMapEntryType">
    <xsd:attribute name="name" type="xsd:string" use="required"/>
    <xsd:attribute name="value" type="xsd:string" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="SecondaryInputType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">A statement can require input both from the driving input and from some other source. An example could be a master-detail update. One statement would be the master update which would use input from one part of the total set of input data. This update would then be followed by the detail update which would use inout from both the detail (driving) input as well as the master (secondary) input (e.g. the primary key of the master record).</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="staticMap" type="StaticMapType" minOccurs="0"/>
    </xsd:sequence>
    <xsd:attribute name="id" type="IdType" use="required">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This id identifies the secondary input and must be unique within the statementRef. See also the secondaryInputId attribute of ParamType.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="mirrorDrivingInputRows" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Input from secondary input will be taken from the first row only unless this attribute is set to "true". If set to "true", the secondary input is assumed to have the same number of rows as the driving input and when row N from the driving input is processed secondary input will be taken from row N of the secondary input.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="InputAttributeGroup">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If the secondary input contains more than one row data will always be taken from the first.</xsd:documentation>
      </xsd:annotation>
    </xsd:attributeGroup>
  </xsd:complexType>
  <xsd:simpleType name="DatabaseVendorType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">The persistence implementation currently supports SQL Server 2000 (mssql) and Oracle 8.1.7 (oracle). If the construct specified is identical for both these databases specify "all".</xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="mssql"/>
      <xsd:enumeration value="oracle"/>
      <xsd:enumeration value="all"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="DataType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="string">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">Specifies Unicode strings of any length.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="searchString">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">Specifies Unicode strings that will be preprocessed to implement our search string functionality used in a SQL "like" clause. For example, a '*' will be replaced by a '%' and a '%' will be replaced by "\%". This means that all special characters are escaped by a '\' so in a statement the "like" clause will have to contain "ESCAPE '\'" to tell the database that '\' is the escape character.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="int">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">Signed integer with 9 digit precision.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="long">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">Signed integer with 18 digit precision.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="double">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">Signed floating point value with 15 digit precision.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="bigDecimal">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">Signed numeric value with aribitrary precision. Note that both SQL Server and Oracle supports at most 38 digits of precision.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="date">
        <xsd:annotation>
          <xsd:documentation>Date value including a time component.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="dateNoTime">
        <xsd:annotation>
          <xsd:documentation>Date value with no time component.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="blob">
        <xsd:annotation>
          <xsd:documentation>Binary large object of arbitrary size.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="clob">
        <xsd:annotation>
          <xsd:documentation>Character large object of arbitrary size.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="resultSet">
        <xsd:annotation>
          <xsd:documentation>ResultSet (Cursor). Only used for Oracle Stored Procs OUT parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="nullIndicator">
        <xsd:annotation>
          <xsd:documentation>An integer value that will evaluate to 1 if the data specified is NULL or 0 otherwise.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="valueIndicator">
        <xsd:annotation>
          <xsd:documentation>An integer value that will evaluate to 0 if the data specified is NULL but present (e.g. an empty attribute in "xml" input), 1 if the data specified is present and not NULL and 2 otherwise (i.e. it was not present in the input at all).</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="ReplaceType">
    <xsd:restriction base="MacroType">
      <xsd:enumeration value="normalized_timestamp">
        <xsd:annotation>
          <xsd:documentation>Will evaluate to the current date and time at runtime and use the normalizeDate method on it.  This allows us to get the full day.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="users_timestamp">
        <xsd:annotation>
          <xsd:documentation>Will evaluate to the current date and time at runtime in the users timezone.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="rowNum">
        <xsd:annotation>
          <xsd:documentation>Will evaluate to the current row number (0-based).</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="dbVendor">
        <xsd:annotation>
          <xsd:documentation>Will evaluate to the vendor string of the current statementSet.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="sessionId">
        <xsd:annotation>
          <xsd:documentation>Session Id from the SecurityIdentifier. Same as CMN_SESSION.ID</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="resourceId">
        <xsd:annotation>
          <xsd:documentation>Resource Id. Same as SRM_RESOURCES.ID</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="resourceCode">
        <xsd:annotation>
          <xsd:documentation>Resource Code. Same as SRM_RESOURCES.UNIQUE_NAME</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="DirectionType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="IN">
        <xsd:annotation>
          <xsd:documentation>Represents an IN parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="INOUT">
        <xsd:annotation>
          <xsd:documentation>Deprecated! Do not use!.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
      <xsd:enumeration value="OUT">
        <xsd:annotation>
          <xsd:documentation>Represents an OUT parameter.</xsd:documentation>
        </xsd:annotation>
      </xsd:enumeration>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="VariationType">
    <xsd:annotation>
      <xsd:documentation>Used to dynamically change the text of a statement base on input.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="includeIfNull" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation>Determines whether it's the NULLness or the non-NULLness that determines whether to include the variation text.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="includeIfPresent" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation>Determines if the presence of the input (rather than the NULLness) that determines whether to include the variation text.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="text" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>If the variation condition is evaluated to true this text will be appended to the current text of the statement.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:simpleType name="SequenceTypeType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="currentValue"/>
      <xsd:enumeration value="nextValue"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:attributeGroup name="SequenceGroup">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Used to mimic the behavior of Oracle Sequences. The attributes of the SequenceGroup will be passed to the CMN_ID_SP stored procedure for generation of new IDs. If inTransaction=true, the call to CMN_ID_SP will be part of the transaction in question (i.e. no new "System" conection will be used) and only one value will be grabbed. If inTransaction=false (default) CMN_ID_SP is not necessarily called at all since IDs will be cached and when it is called, it will be called outside the transaction of the actual statement (probably an insert statement...). Setting this flag to "true" can help solve some blocks on SQL Server.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="sequenceName" type="xsd:string"/>
    <xsd:attribute name="tableName" type="xsd:string"/>
    <xsd:attribute name="sequenceType" type="SequenceTypeType"/>
    <xsd:attribute name="inTransaction" type="xsd:boolean" default="false"/>
  </xsd:attributeGroup>
  <xsd:attributeGroup name="LookupGroup">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Used to improve usablity and performance of statements by removing need to join with lookup tables.  Instead only need to use the know lookup type and code to get the lookup id.  Also helps developers not hard code ids in their SQL.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="lookupCode" type="xsd:string"/>
    <xsd:attribute name="lookupType" type="xsd:string"/>
  </xsd:attributeGroup>
  <xsd:attributeGroup name="SecurityObjectGroup">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Used to improve usablity and performance of statements by removing need to join with CMN_SEC_OBJECT table.  Instead only need to use the know object type, object code, and component to get the object id.  Also helps developers not hard code ids in their SQL.</xsd:documentation>
    </xsd:annotation>
    <xsd:attribute name="objectCode" type="xsd:string"/>
    <xsd:attribute name="objectType" type="xsd:string"/>
    <xsd:attribute name="componentCode" type="xsd:string"/>
  </xsd:attributeGroup>
  <xsd:complexType name="ParamType">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">Used to specify a bind variable in the statement. The param elements match the bind variables by sequence. I.e. the first '?' must be matched by the first param element.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="variation" type="VariationType" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">The value specified by this parameter will determine if the statement text will be altered by this variation.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This is the key of the value in the input (driving or secondary) map. Will not be used in case of "xml" input.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="path" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">This is the relative XPath expression of the value in the input (driving or secondary) node set. Will not be used in case of "map" input.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="secondaryInputId" type="IdType">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If specified, must match a secondaryInput element of the statementRef and then the value specified by name/path will be used in this secondary input instead of the driving input.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="type" type="DataType">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">The type of the bind variable. Required unless the replace attribute or the SequenceGroup attributes or the LookupGroup attributes are specified.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="replace" type="ReplaceType">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">One of the possible replacements will be used to bind the variable.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="direction" type="DirectionType" default="IN">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Determines the direction of the bind variable.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="defaultValue" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Specifies a value to use in case the value otherwise specified turns out to be NULL (or not exist).</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="defaultReplace" type="ReplaceType">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Specifies a replacement macro to use in case the value otherwise specified turns out to be NULL (or not exist).</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="useDefaultIfNullButPresent" type="xsd:boolean" default="true">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Set to true if the defaultValue/defaultReplace should be used even if the value was passed but null. If set to false the defaultValue/defaultReplace will only be used if that value is not present in the input at all</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="constantValue" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Specifies a constant value to use irrespective of the value otherwise specified.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="constantNull" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Specifies that the value should be bound to NULL irrespective of the value otherwise specified.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="SequenceGroup"/>
    <xsd:attributeGroup ref="LookupGroup"/>
    <xsd:attributeGroup ref="SecurityObjectGroup"/>
    <xsd:attribute name="scale" type="xsd:integer" default="-1">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">In case of a non-integer numeric value this specifies the scale expected.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="sessionId" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If specified a value corresponding to it will be looked up in the current session and use to bind the variable.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="dynamicReplacement" type="ReplacementStringType">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If specified corresponds to a replacement of dynamic SQL. This parameter will be expanded to (or collapsed) based on the parameters passed with the dynamic SQL text passed with the given string.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="expressionListTag" type="ReplacementStringType">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">If specified the parameter is assumed to be an expression list to be used in a SQL in clause. Normal bind variables cannot be used for an expression list so an explicit string replacement will be used at runtime and the value of this attribute is the unique tag in the SQL text where the string replacement will happen. The elements of the list are expected to be of the data type specified. The list of can be passed as a java.lang.String (elements delimited by @expressionListDelimiter), an array of Objects (i.e. Object[]) or a java.util.Collection of Objects. The elements are not expected to be formatted for the list even if passed a string. I.e. string elements should not be enclosed in single quotes and no parentheses should be present. At runtime a proper SQL expression list will be constructed based on the input and the data type specified. Note that much like in the case with Variations only the first row in the driving input will be used to manipulate the SQL with the expression list.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="expressionListDelimiter" type="xsd:string" default=",">
      <xsd:annotation>
        <xsd:documentation xml:lang="en"/>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="arrayType" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">Specifies the type of the array parameter passed. This type must be a VARRAY or a nested table type. Array parameters are only supported for Oracle at this time.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="SqlBaseType">
    <xsd:annotation>
      <xsd:documentation>Specifies the structure of the actual SQL statement.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="text" type="xsd:string" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation>The base text of a segment of the actual SQL statement. This text can be altered by variations.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="param" type="ParamType" minOccurs="0" maxOccurs="unbounded">
        <xsd:annotation>
          <xsd:documentation>The parmeters to use for this segment's bind variables.</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SqlType">
    <xsd:annotation>
      <xsd:documentation>Specifies the structure of the actual SQL statement.</xsd:documentation>
    </xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="SqlBaseType">
        <xsd:sequence>
          <xsd:element name="condition" type="ConditionType" minOccurs="0" maxOccurs="1"/>
          <xsd:element name="dynamicDefault" type="DynamicDefaultType" minOccurs="0" maxOccurs="unbounded">
            <xsd:annotation>
              <xsd:documentation>Default for dynamic replace parameters.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
        <xsd:attribute name="location" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">For internal use only.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="id" type="IdType" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">The id of the sql element. Must be unique within the component in which it is specified and must be of the form &lt;component&gt;.ID. This is used to reference a sql element in a sqlRef.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="dbVendor" type="DatabaseVendorType" default="all">
          <xsd:annotation>
            <xsd:documentation>If the SQL specified is vendor specific specify the corresponding vendor here.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="dbVersion" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation>If the SQL specified is vendor version specific specify the corresponding version here.
            Can specify multiple versions using a comma-delimited list, and each version may be prefixed with a
            traditional operator: !, &gt;, &lt;, &gt;=, or &lt;=.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="xpathCondition" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation>An XPath expression that when applied to an input document is used to determine whether to include the SQL snippet or not. I.e. when the result is non-empty, the snippet will be included other it is not.</xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
			</xsd:extension>
		</xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DbErrorType">
    <xsd:attribute name="dbCode" type="xsd:integer" use="required">
      <xsd:annotation>
        <xsd:documentation>The database specific error code (e.g. Oracle unique key violation has an error code of 1) or the code returned from a user supplied excpetion raised in a stored procdure.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="dbVendor" type="DatabaseVendorType" use="required">
      <xsd:annotation>
        <xsd:documentation>The vendor for which this native error code is valid.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="ErrorMappingType">
    <xsd:annotation>
      <xsd:documentation>Elements of type errorMapping maps DB specific error codes to Application specific error codes. E.g. Oracle signals a unique key violation with an error code equal to 1 while SQL Server reports the same error with code 2601. To be able to give these errors context you specify mappings between these DB specific codes to something that makes sense in the application.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="dbError" type="DbErrorType" maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="applicationCode" type="xsd:string" use="required">
      <xsd:annotation>
        <xsd:documentation>The code you want to be passed to upper layers when the dbCode is returned from the DB of type dbVendor in one of the dbError elements. If the output of the PMD is XML then this application code will be returned in the header element. If the output is of Object type then a PersistenceApplicationException will be thrown with the appropriate information.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="StatementType">
    <xsd:annotation>
      <xsd:documentation>A statement element contains the actual SQL text. Statements can be reused across multiple statementSets.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="secondaryInput" type="SecondaryInputType" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:element name="errorMapping" type="ErrorMappingType" minOccurs="0" maxOccurs="unbounded"/>
      <xsd:choice maxOccurs="unbounded">
        <xsd:element name="sql" type="SqlType"/>
        <xsd:element name="sqlRef" type="SqlRefType"/>
      </xsd:choice>
      <xsd:element name="outputMapping" type="OutputMappingType" minOccurs="0"/>
      <xsd:element name="expectedResults" type="ExpectedResultsType" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="location" type="xsd:string" use="optional">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">For internal use only.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="id" type="IdType">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">The id of the statement. Must be unique within the component in which it is specified and must be of the form &lt;component&gt;.ID.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="subjectToSorting" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation>Set to true if this query is subject to sorting. I.e. an order by will be appended to it at runtime based on an input parameter (sortColum). Note that there must not be an order by clause in the sql text or this will fail.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="subjectToSlicing" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation>Set to true if one of the result sets in this statement is subject to slicing. I.e. a slice of a result set should be returned instead of all rows. If set to true the result set to be sliced is specified by the slicedResultSetIndex attribute.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="slicedResultSetIndex" type="xsd:integer" default="0">
      <xsd:annotation>
        <xsd:documentation>Specifies the index (0-based) of the result set that should be sliced. Note that only one result set in a statement can be sliced.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="batchable" type="xsd:boolean" default="false">
      <xsd:annotation>
        <xsd:documentation>Set to true if this statement can be executed in batch mode. This should include inserts, updates and calls to stored procedures without OUT parameters. Queries can never be batched.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attributeGroup ref="SharedStatementAttributeGroup"/>
    <xsd:attributeGroup ref="InputAttributeGroup"/>
    <xsd:attribute name="rowNumColumn" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>If the statement is supposed to be sliced and the analytic functions row_number() over (order by x) and count(*) over() are used this attribute specifies the alias of the row number column.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="totalRowsColumn" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>If the statement is supposed to be sliced and the analytic functions row_number() over (order by x) and count(*) over() are used this attribute specifies the alias of the total number of rows column (count(*)).</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute name="dynamicOrderByTag" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation>If the statement is supposed to be sliced and the analytic functions row_number() over (order by x) and count(*) over() are used this attribute specifies the dynamic SQL tag specifying the location of the order by clause for row_number() column.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="OutputMappingType">
    <xsd:annotation>
      <xsd:documentation>The outputMapping specifies how to structure or name the result set from the database.</xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="resultSetMap" type="ResultSetMapType" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="collectionElementName" type="xsd:string"/>
    <xsd:attribute name="rowElementName" type="xsd:string"/>
  </xsd:complexType>
  <xsd:complexType name="ResultSetMapType">
    <xsd:attribute name="resultSetId" type="xsd:integer" default="-1"/>
    <xsd:attribute name="collectionElementName" type="xsd:string"/>
    <xsd:attribute name="rowElementName" type="xsd:string"/>
  </xsd:complexType>
  <xsd:complexType name="ExpectedResultsType">
    <xsd:attribute name="count" type="xsd:integer" default="1"/>
    <xsd:attribute name="resultSetIndex" type="xsd:integer" default="0"/>
    <xsd:attribute name="errorCode" type="xsd:string" use="required"/>
  </xsd:complexType>
  <xsd:complexType name="ConditionType">
    <xsd:attributeGroup ref="InputAttributeGroup"/>
    <xsd:attribute name="not" type="xsd:boolean" use="optional" default="false"/>
    <xsd:attribute name="count" type="xsd:integer" use="optional"/>
  </xsd:complexType>
  <xsd:complexType name="DynamicDefaultType">
    <xsd:complexContent>
      <xsd:extension base="SqlBaseType">
        <xsd:sequence>
          <xsd:element name="condition" type="ConditionType" minOccurs="0" maxOccurs="1"/>
        </xsd:sequence>
        <xsd:attribute name="tag" type="xsd:string" use="required"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="ReplacementStringType">
    <xsd:restriction base="xsd:string">
      <xsd:pattern value="@[a-z,A-Z,0-9,_]+@"/>
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IdType">
    <xsd:restriction base="xsd:string">
      <xsd:pattern value="[a-z,A-Z,0-9,_,\.,-]+"/>
    </xsd:restriction>
  </xsd:simpleType>
</xsd:schema>
