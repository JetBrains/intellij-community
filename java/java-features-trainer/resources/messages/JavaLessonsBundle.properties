readme.shared.indexes.remark=You may notice a message prompting to download shared indexes. If you have a good internet connection, \
  you can accept the suggestion and speed up the project initialization.

java.surround.and.unwrap.help.unwrapping.and.removing.statements=Working with code statements

java.basic.completion.choose.first=You can choose the first item from the Lookup menu by pressing {0}.
java.basic.completion.activate=To activate Basic Completion, press {0} and you will see the lookup menu again.
java.basic.completion.choose.item=Select {0} inside the lookup menu and press {1}.
java.basic.completion.complete=Press {0} to complete this statement.
java.basic.completion.deeper.level=Sometimes, you need to see suggestions for static constants or methods. \
  Press {0} twice to get them in the lookup.
java.basic.completion.module.promotion=You will find more about refactorings in the {0} module.

java.run.configuration.lets.run=Any code marked with {0} can be run. Let''s run our simple example with {1}. \
  Alternatively, you can click {0} and select the {2} item.

java.postfix.completion.apply=Postfix Completion helps you reduce backward caret jumps as you write code. \
  It lets you transform an already typed expression into another one based on the postfix you add, the type of expression, and its context. \
  Type {0} after the parenthesis to see the list of postfix completion suggestions. \
  Select {1} from the list or type it in the editor and then press {2} to complete the statement.

java.smart.type.completion.lesson.name=Smart type completion
java.smart.type.completion.apply=Smart Type Completion filters the list of suggestions to include only the types applicable \
  within the current context. Press {0} to see the list of matching suggestions. Choose the first one by pressing {1}.
java.smart.type.completion.return=Smart Type Completion can also suggest code for a return statement. \
  Press {0} to see the Lookup menu for a return. Choose the first one by pressing {1}

java.statement.completion.lesson.name=Statement completion
java.statement.completion.complete.for=Press {0} to complete the {1} statement.
java.statement.completion.complete.if=Type {0} and press {1} to generate the statement.
java.statement.completion.complete.condition=Add a condition inside the parentheses {0} and press {1} to jump into the {2} statement.
java.statement.completion.complete.finish.body=Type a line of code: {0} and then press {1} to complete the statement and apply formatting.

java.rename.press.rename=Press {0} to rename field {1}.
java.rename.type.new.name=Type a new name for this field (for example, {0}) and press {1}.
java.rename.confirm.accessors.rename=<ide/> is detecting the corresponding getters/setters and suggests renaming them accordingly.\
  Now just press {0} or click {1}

java.refactoring.menu.inline.variable=Now let''s inline a variable {0} to reduce it to a single usage. You can press {1} and filter the refactoring menu by \
  <strong>iv</strong> (<strong>i</strong>nline <strong>v</strong>ariable). Choose this item or press {2}.
java.refactoring.menu.introduce.constant=Finally, let''s extract an extension from the file name. \
  Again, you can press {0} and filter by <strong>ic</strong> (<strong>i</strong>ntroduce <strong>c</strong>onstant) or press {1}.
java.refactoring.menu.confirm.constant=In this dialog, you can choose the new constant\u2019s type, name, parent class and visibility. \
  You can leave the defaults and press {0} or click {1}.

java.extract.method.edit.method.name=Edit the name of the new method or leave the one that IDE proposed. Then press {0}.

java.inheritance.hierarchy.lesson.name=Inheritance hierarchy
java.inheritance.hierarchy.goto.implementation=Press {0} to look for implementations of {1}.
java.inheritance.hierarchy.choose.any.implementation=Choose any implementation and press {0} or click it.
java.inheritance.hierarchy.navigate.to.base=You can navigate to a super method from derived. Press {0} or click the {1} icon in the editor gutter.
java.inheritance.hierarchy.invoke.implementations.again=The declaration of the base method has its own gutter icon {0}. \
  Click it or press {1} again.
java.inheritance.hierarchy.open.in.find.tool.window=For big hierarchies, you might want to look for implementations in the {0} tool window. \
  Click {1}.
java.inheritance.hierarchy.hide.find.tool.window=Press {0} to hide the {1} tool window.
java.inheritance.hierarchy.open.method.hierarchy=You might want to explore the whole hierarchy for this method. Press {0}.
java.inheritance.hierarchy.hide.method.hierarchy=Let''s (also) hide {0} too. Press {1} again.
java.inheritance.hierarchy.open.class.hierarchy=To view the class hierarchy, press {0}.
java.inheritance.hierarchy.last.note=<strong>Note:</strong> Actions {0} and {1} can be also applied to classes. \
  Actions {2} and {3} are rarely used, but you can always find them with {4} using the {5} filter.

java.find.occurrences.lesson.name=Next/previous occurrence
java.find.occurrences.invoke.find=In this lesson, you selected {0}. Press {1} to start a full-text search through the current file.
java.find.occurrences.find.previous=To jump to the previous occurrence, press {0}.
java.find.occurrences.search.closed.warning=Press {0} to open the search field again.
java.find.occurrences.find.next=<ide/> automatically copies the selected text into the search field. Let''s find the next occurrence. \
  Press {0} or {1}.
java.find.occurrences.close.search.tool=With the search panel closed, you can still use these shortcuts to navigate between \
  the recently found occurrences. Let''s close the search panel by pressing {0}.
java.find.occurrences.find.next.in.editor=Locate the next occurrence with {0}.
java.find.occurrences.find.previous.in.editor=And {0} to go backwards.
java.find.occurrences.note.about.cyclic=<strong>Note:</strong> The search is cyclic and pressing {0} twice at the last occurrence will set \
  the selection for the last occurrence. {1} is cyclic too.

java.debug.workflow.rebuild=For big programs, rerun can take a long time. When you find a mistake in a pure method, you can just rebuild \
  the project and apply the <strong>Hot Swap</strong> JVM feature. Let''s build the project: {0} or {1}.
java.debug.workflow.confirm.hot.swap=Confirm the <strong>Hot Swap</strong> replacement.
java.debug.workflow.drop.frame=We patched our method, but right now we are still executing obsolete {0}, and it will throw the \
  exception again. Let''s drop the frame and return to the state before the {1} call. Click {2} the debug panel or press {3}.
