abstract.class.not.allowed=Abstract class is not allowed
access.static.via.instance=Access static member via instance reference
action.analyzing.cyclic.dependencies.in.scope=Cyclic Dependencies of {0}
action.create.new.class=New Java Class
action.create.new.class.description=Create new Java class
action.create.new.module-info.description=Create new module-info.java
action.create.new.module-info.title=module-info.java
action.create.new.package-info.description=Create new package-info.java
action.create.new.package-info.title=package-info.java
action.cyclic.dependency.title=Cyclic Dependency Analysis
action.description.copy.whole.thread.dump.to.clipboard=Copy whole thread dump to clipboard
action.description.group.by.scope=Group by Scope Type (production, test, libraries)
action.description.group.threads.with.identical.stacktraces=Group threads with identical stacktraces
action.description.mark.directory.as.a.0.for.generated.files=Mark directory as a {0} for generated files
action.description.mark.directory.as.an.ordinary.0=Mark directory as an ordinary {0}
action.description.show.only.threads.containing.a.specific.string=Show only threads containing a specific string
action.group.by.package=Package
action.group.by.scope.type=Group by Scope Type
action.implement.method=Implement Method
action.implement.methods=Implement Methods
action.override.method=Override Method
action.override.methods=Override Methods
action.text.0.on.parameter.1={0} on parameter ''{1}''
action.text.choose.class.in.0=choose class in {0}...
action.text.copy.to.clipboard=Copy to Clipboard
action.text.edit.template=Edit Template
action.text.enter.class.name=enter class name...
action.text.generated.root.0=Generated {0}
action.text.merge.identical.stacktraces=Merge Identical Stacktraces
action.text.show.methods.to.implement=Show methods to implement
action.text.unmark.generated.0=Unmark Generated {0}
action.GotoSuperClass.text=Go to S_uper Class or Interface
action.GotoSuperClass.MainMenu.text=S_uper Class or Interface
action.GotoSuperClass.description=Navigate to the declaration of a class that the current class extends or implements
add.to.permits.list.family.name=Add class to permits list
add.to.permits.list=Add ''{0}'' to permits list of sealed class ''{1}''
annotate.intention.chooser.title=Choose Annotation to Add
assignment.to.declared.variable.problem.descriptor=Variable ''{0}'' is initialized with self assignment
assignment.to.itself.problem.descriptor=Variable ''{0}'' is assigned to itself
assignment.array.element.to.itself.problem.descriptor=Array element is assigned to itself
bean.property=Bean Property
boolean.method.is.always.inverted.display.name=Boolean method is always inverted
boolean.method.is.always.inverted.problem.descriptor=Calls to boolean method '#ref()' are always inverted
button.add.blank=Add Blank
button.add.class=Add Class...
button.add=Add...
button.add.package=Add Package...
button.add.pattern=Add Pattern...
button.annotations=Annotations...
button.base.method=&Base Method
button.code.patterns=Code patterns...
button.current.method=&Current Method
button.text.settings=Settings...
cast.expression=Insert cast expression
cast.to.0=Cast to ''{0}''
change.color.command.text=Change color
change.uid.action.name=Randomly change 'serialVersionUID' initializer
checkbox.after.description=After description
checkbox.after.parameter.descriptions=After parameter descriptions
checkbox.after.return.tag=After return tag
checkbox.align.parameter.descriptions=Align parameter descriptions
checkbox.align.thrown.exception.descriptions=Align thrown exception descriptions
checkbox.spaces.around.annotation.eq=Around '=' in annotation value pair
checkbox.annotate.local.variables=Annotate local variables
checkbox.collapse.annotations=Annotations
checkbox.collapse.anonymous.classes=Anonymous classes
checkbox.collapse.closures="Closures" (anonymous classes implementing one method, before Java 8)
checkbox.collapse.end.of.line.comments=End of line comments sequence
checkbox.collapse.generic.constructor.parameters=Generic constructor and method parameters
checkbox.collapse.i18n.messages=I18n strings
checkbox.collapse.inferred.type=Replace 'var' with inferred type
checkbox.collapse.inner.classes=Inner classes
checkbox.collapse.multiline.comments=Multiline comments
checkbox.collapse.one.line.methods=One-line methods
checkbox.collapse.simple.property.accessors=Simple property accessors
checkbox.collapse.suppress.warnings=@SuppressWarnings
checkbox.deprecated.members=Deprecated members
checkbox.do.not.indent.top.level.class.members=Do not indent top level class members
checkbox.do.not.wrap.after.single.annotation=Do not wrap after single annotation
checkbox.do.not.wrap.one.line.comments=Do not wrap one line comments
checkbox.enable.javadoc.formatting=Enable JavaDoc formatting
checkbox.enable.leading.asterisks=Enable leading asterisks
checkbox.generate.p.on.empty.lines=Generate "<p>" on empty lines
checkbox.html.report.inaccessible.symbols=<html>Report inaccessible symbols<br>(javadoc tool may be unable to create hyperlink)
disable.report.inaccessible.symbols.fix=Don't report inaccessible symbols
checkbox.ignore.fields.used.in.multiple.methods=Ignore fields used in multiple methods
checkbox.ignore.chains=Ignore chainable methods
checkbox.insert.imports.for.inner.classes=Insert imports for inner classes
checkbox.iterate.unknown.stream.sources.via.stream.iterator=Iterate unknown Stream sources via Stream.iterator()
checkbox.keep.empty.lines=Keep empty lines
checkbox.keep.empty.param.tags=Keep empty @param tags
checkbox.keep.empty.return.tags=Keep empty @return tags
checkbox.keep.empty.throws.tags=Keep empty @throws tags
checkbox.keep.invalid.tags=Keep invalid tags
checkbox.make.generated.local.variables.final=Make generated local variables final
checkbox.make.generated.parameters.final=Make generated parameters final
checkbox.declare.var.type=Use 'var' for local variable declaration
checkbox.param.description.on.new.line=Parameter descriptions on new line
checkbox.param.indent.on.continuation=Indent continuation lines
checkbox.prefer.longer.names=Prefer longer names
checkbox.preserve.line.feeds=Preserve line feeds
checkbox.spaces.record.header=Record header
checkbox.spaces.within.deconstruction.list=Deconstruction list
checkbox.spaces.inside.block.braces.when.body.is.present=Inside block braces when body is present
checkbox.spaces.before.colon.in.foreach=Before colon in foreach
checkbox.spaces.before.deconstruction.list=Deconstruction list
checkbox.spaces.inside.one.line.enum=Inside one line enum braces
checkbox.suggest.conversion.to.map.computeifabsent=Suggest conversion to Map.computeIfAbsent
checkbox.suggest.conversion.to.map.getordefault=Suggest conversion to Map.getOrDefault
checkbox.suggest.conversion.to.map.merge=Suggest conversion to Map.merge
checkbox.suggest.conversion.to.map.putifabsent=Suggest conversion to Map.putIfAbsent
checkbox.suggest.conversion.to.map.replaceall=Suggest conversion to Map.replaceAll
checkbox.suggest.replacement.even.if.lambda.may.have.side.effects=Suggest replacement even if lambda may have side effects
checkbox.don.t.warn.in.case.of.multiline.lambda=Don't warn if the parameter of 'List.replaceAll()' is multiline lambda
checkbox.suppress.with.suppresswarnings=Suppress with @SuppressWarnings
checkbox.treat.get.k.null.the.same.as.containskey.k.may.change.semantics=Treat 'get(k) != null' the same as 'containsKey(k)' (may change semantics)
checkbox.use.fully.qualified.class.names=Use fully qualified class names
checkbox.use.single.class.import=Use single class import
checkbox.use.throws.rather.than.exception=Use @throws rather than @exception
checkbox.warn.if.only.foreach.replacement.is.available=Warn if only 'forEach' replacement is available
checkbox.warn.if.the.loop.is.trivial=Warn if the loop is trivial
checkbox.wrap.at.right.margin=Wrap at right margin
choose.class=Choose Class
chooser.text.choose.where.to.save.0=Choose where to save ''{0}''
chooser.title.select.path.to.save.jar=Select Path to Save Jar
class.decorator.or.has.default.constructor=''{0}'' should have default constructor or implement ''Decorator'' pattern
class.filter.editor.add.dialog.title=New Filter
class.filter.editor.choose.class.title=Choose Class
class.has.no.default.constructor=''{0}'' has no default constructor
class.is.not.a.subclass=''{0}'' is not assignable to ''{1}''
class.is.not.concrete=''{0}'' is not a concrete class
class.is.not.public=''{0}'' is not public
class.not.found.error.message=Class ''{0}'' not found
code.style.generation.override.method.signature=Override Method Signature
code.style.generation.repeat.synchronized.modifier=Repeat &synchronized modifier
code.style.generation.replace.null.check=Replace null-check with Objects::nonNull or Objects::isNull
code.style.generation.use.class.isInstance=Use Class::isInstance and Class::cast when possible
code.style.generation.use.integer.sum=Use Integer::sum, etc. when possible
combobox.paste.insert.imports=&Insert imports on paste:
command.create.class.from.template=Create Class From Template
command.create.new.subdirectory=Create New Subdirectory
command.name.insert.block.statement=Insert Block Statement
command.name.updating.package.statement=Updating package statement
comment.the.class.will.be.created.in.the.package.0=The class will be created in the package ''{0}''
completion.class.name.hint.2=Press {0} once more to ignore module dependencies while searching
completion.no.suggestions.of.type=No suggestions of type {0}
completion.smart.aslist.hint=Press {0} once more to find arrays of {1}
completion.smart.chain.hint=Press {0} once more to search across chained method calls
completion.smart.hint=Press {0} to show only variants that are suitable by type
completion.smart.toar.hint=Press {0} once more to find collections of {1}
completion.smart.type.generate.anonymous.body=generate anonymous body
completion.unknown.type=Unknown type {0}
completion.provider.method.declaration.type=provider() method declaration
configurable.EqualsHashCodeTemplatesPanel.display.name=Templates
configurable.GenerateToStringConfigurable.display.name=Settings
configurable.TemplatesPanel.display.name=Templates
label.new.template.name=New template name:
dialog.title.create.new.template=Create New Template
dialog.title.copy.template=Copy Template
configure.annotations.option=Configure Annotations...
convert.compareto.expression.to.equals.call=Convert 'compareTo()' expression to 'equals()' call
convert.compareto.expression.to.equals.call.may.change.semantics=Convert 'compareTo()' expression to 'equals()' call (may change semantics)
copy.abstract.method.intention.name=Use existing implementation of ''{0}''
copy.abstract.method.no.existing.implementations.found=No existing implementations found
copy.abstract.method.popup.title=Choose implementation to copy
copy.abstract.method.title=Use Abstract Method Implementation
copy.paste.reference.notification=<html>{0} {0, choice, 1#import was|2#imports were} added<p><span><a href=''show''>Review Added Imports...</a></span></html>
cyclic.dependencies.progress.text=Building dependencies graph
cyclic.dependencies.scope.dialog.module.button={0} &module ''{1}''
cyclic.dependencies.scope.dialog.project.button={0} the whole &project
cyclic.dependencies.scope.dialog.title=Specify {0} Scope
cyclic.dependencies.scope.include.test.sources.option=Include &test sources
cyclic.dependencies.tree.cycle.node.text=cycle
cyclic.dependencies.usage.view.initial.text=Select package to analyze from the left tree
cyclic.dependencies.usage.view.root.node.text=Usages of package ''{0}'' in package ''{1}''
dataflow.from.here=Dataflow from Here
dataflow.to.here=Dataflow to Here
deannotate.intention.action.text=Deannotate {0}
deannotate.intention.action.several.text=Deannotate...
deannotate.intention.action.family.name=Deannotate
deannotate.intention.chooser.title=Choose Annotation to Delete
default.package.presentable.name=<default>
dependencies.libraries.node.text=Libraries
dependencies.tree.node.default.package.abbreviation=<default package>
dialog.create.class.destination.package.label=Destination package:
dialog.create.class.label=Create {0}:
dialog.create.class.name=Create {0} {1}
dialog.create.class.package.chooser.title=Choose Destination Package
dialog.edit.template.checkbox.smart.type.completion=Type-matching c&ompletion
dialog.edit.template.checkbox.use.static.import=Use static &import if possible
dialog.import.on.paste.title=Select Classes to Import
dialog.import.on.paste.title2=Select Elements to Import
dialog.import.on.paste.title3=Select Import to Remove
dialog.message.0.update.existing.class={0}. Update existing class?
dialog.message.create.test.in.the.same.source.root=Create test in the same source root?
dialog.message.infer.nullity.annotations.requires.the.project.language.level=Infer Nullity Annotations requires the project language level be set to 1.5 or greater.
dialog.message.jetbrains.annotations.library.is.missing=JetBrains annotations library is missing.\nWithout the library, IntelliJ IDEA cannot run the analysis. Would you like to add it?
dialog.message.no.places.found.to.infer.nullable.notnull=No places found to infer @Nullable/@NotNull
dialog.paste.on.import.text=<html>The code fragment which you have pasted uses classes that are not accessible by imports in the new context.<br/>Select classes that you want to import to the new file.</html>
dialog.paste.on.import.text2=<html>The code fragment which you have pasted uses elements that are not accessible by imports in the new context.<br/>Select elements that you want to import to the new file.</html>
dialog.paste.on.import.text3=<html>The code fragment which you have pasted introduced new imports in the current context.<br/>Select imports that you want to eliminate.</html>
dialog.title.choose.0.parameters=Choose {0} Parameters
dialog.title.choose.class=Choose Class
dialog.title.choose.logger = Choose Logger
dialog.title.configure.annotations=Configure Annotations
dialog.title.configure.code.patterns=Configure Code Patterns
dialog.title.create.class.in.package=Create Class in Package
dialog.title.create.missing.tests=Create Missing Tests
dialog.title.edit.method.contract=Edit Method Contract
dialog.title.edit.range=Edit Range of ''{0}''
dialog.title.infer.nullity=Infer Nullity
action.title.infer.nullity.annotations=Infer Nullity Annotations
action.description.infer.nullity.annotations=Infer nullity annotations
dialog.title.infer.nullity.results=Infer Nullity Results
dialog.title.no.test.roots.found=No Test Roots Found
dialog.title.process.duplicates=Process Duplicates
dialog.title.super.method.found=Super Method Found
dialog.title.testdatapath.method.generate=Generate methods from @TestDataPath
dialog.title.testdatapath.file.generate=Generate files from class to @TestDataPath
do.not.import.inner.classes.for=Exclude inner classes by short name:
do.not.import.inner.classes.no.classes=No inner classes defined
editbox.blanklines.around.initializer=Around initializer:
editbox.blank.lines.field.in.interface=Before field in interface
editbox.blank.lines.field.without.annotations=Before field without annotations:
editbox.blank.lines.field.with.annotations=Before field with annotations:
editbox.class.count.to.use.import.with.star=Class count to use import with '*':
editbox.names.count.to.use.static.import.with.star=Names count to use static import with '*':
enum.not.allowed=Enum is not allowed
error.attempt.to.generate.constructor.for.anonymous.class=Cannot add constructor to an anonymous class
error.attempt.to.generate.constructor.for.implicit.class=Cannot add constructor to an implicitly declared class
error.hint.no.expression.found=No expression found
error.package.already.contains.package-info=''package-info.java'' already exists for package ''{0}''
error.package.already.contains.package.html=Package ''{0}'' already has a ''package.html'' file. Create ''package-info.java'' anyway?
error.package.html.found.title=Found 'package.html'
error.text.this.is.not.a.valid.java.class.name=This is not a valid Java class name
exclude.0.from.completion=Exclude ''{0}'' from completion
exclude.accessors=&Exclude Accessors
exclude.from.completion.group=Exclude from auto-import and completion:
exclude.from.imports.no.exclusions=Add a class, package, or member
exclude.from.imports.no.exclusions.2=to exclude from auto-import and completion
exclude.table.mask=Class, package, or member
exclude.table.scope.column=Scope
export.to.html.generate.hyperlinks.checkbox=Generate &hyperlinks to classes
external.annotation.prompt=External Annotation Prompt
external.annotations.external.option=Add &Externally
external.annotations.in.code.option=Add in &Code
external.annotations.root.chooser.description=External annotations would be saved in appropriate folder
external.annotations.root.chooser.title=Select External Annotations Root for {0}
external.annotations.suggestion.message=<html><body>If you do not want annotations in your code you may use external storage.<br> \
  To configure external annotations please specify root directory where files with annotations would be placed</body></html>
find.field.accessors.prompt=Search for accessors of field ''{0}''?
find.field.accessors.title=Field Accessors Found
find.options.include.overloaded.methods.checkbox=O&verloaded methods
find.options.include.accessors.checkbox=Search for &accessors
find.options.include.accessors.base.checkbox=S&earch for base methods of accessors
find.options.include.accessors.base.checkbox.comment=Use top-level hierarchy methods as find usage targets by default
find.options.search.overriding.methods.checkbox=Search in &overriding methods
find.what.derived.classes.checkbox=&Derived classes
find.what.derived.interfaces.checkbox=&Derived interfaces
find.what.fields.usages.checkbox=Usages of &fields
find.what.search.for.base.methods.checkbox=S&earch for base method usages
find.what.search.for.base.methods.checkbox.comment=Use top-level hierarchy methods as find usage targets by default
find.what.implementing.classes.checkbox=&Implementing classes
find.what.implementing.methods.checkbox=&Implementing methods
find.what.implicit.to.string.checkbox=I&mplicit calls
find.what.methods.usages.checkbox=Usages of &methods
find.what.overriding.methods.checkbox=Over&riding methods
find.what.usages.checkbox=&Usages
find.what.usages.of.classes.and.interfaces=Usages of &classes and interfaces
generate.button.title=Generate
generate.constructor.fields.chooser.title=Choose Fields to Initialize by Constructor
generate.constructor.super.constructor.chooser.title=Choose Super Class Constructor
generate.delegate.target.chooser.title=Select Target to Generate Delegates for
generate.equals.and.hashcode.already.defined.title=Generate 'equals()' and 'hashCode()'
generate.equals.and.hashcode.already.defined.warning=Methods ''boolean equals(Object)'' and ''int hashCode()'' are already defined\nfor class {0}. Do you want to delete them and proceed?
generate.equals.and.hashcode.already.defined.warning.anonymous=Methods 'boolean equals(Object)' and 'int hashCode()' are already defined\nfor this anonymous class. Do you want to delete them and proceed?
generate.equals.hashcode.accept.sublcasses=Accept &subclasses as parameter to equals() method
generate.equals.hashcode.type.comparison.label=For class type comparison in equals() method generate:
generate.equals.hashcode.comparison.table=<html><table>\
  <tr><th><th>instanceof<th>getClass()\
  <tr><td>Allows instances of subclasses to equal instances of the superclass<td align=center>yes<td align=center>no\
  <tr><td>Allows instances of different subclasses to equal each other<td align=center>yes<td align=center>no\
  <tr><td>Overriding the generated equals() method does not break its contract<td align=center>no<td align=center>yes\
  <tr><td>Avoids extra null check<td align=center>yes<td align=center>no\
  <tr><td>Obeys\\&nbsp;the\\&nbsp;Liskov\\&nbsp;substitution\\&nbsp;principle<td align=center>yes<td align=center>no\
  </table></html>
generate.equals.hashcode.instanceof.type.comparison=&instanceof expression
generate.equals.hashcode.getclass.type.comparison=get&Class() comparison expression
generate.equals.hashcode.accept.sublcasses.explanation=<html><body>While generally incompliant to the contract of Object.equals(), accepting<br>\
  subclasses may be necessary for the generated method to work correctly<br>with frameworks which generate Proxy subclasses, like Hibernate.</body></html>
generate.equals.hashcode.equals.fields.chooser.title=Choose &fields to be included in equals()
generate.equals.hashcode.hashcode.fields.chooser.title=Choose &fields to be included in hashCode()
generate.equals.hashcode.internal.error=Internal error
generate.equals.hashcode.non.null.fields.chooser.title=Select all non-null &fields
generate.equals.hashcode.template=&Template:
generate.equals.hashcode.use.getters=Use &getters when available
generate.equals.hashcode.warning.hashcode.for.arrays.is.not.supported=hashCode () for arrays is not supported
generate.equals.hashcode.wizard.title=Generate equals() and hashCode()
generate.equals.template.title=Equals Template:
generate.equals.warning.equals.for.nested.arrays.not.supported=equals() for nested arrays is not supported
generate.equals.warning.generated.equals.could.be.incorrect=Generated equals() for Object[] can be incorrect
generate.getter.fields.chooser.title=Select Fields to Generate Getters
generate.getter.setter.title=Select Fields to Generate Getters and Setters
generate.getter.template=&Getter template:
generate.hashcode.template.title=HashCode Template:
generate.logger.no.place.found.dialog.title = No Places Found
generate.logger.no.place.found.dialog.message = Could not find places to insert logger
generate.logger.specify.place.popup.title=Choose Place
generate.record.constructor.title=Generate Records Constructor
generate.setter.fields.chooser.title=Select Fields to Generate Setters
generate.setter.template=&Setter template:
generate.tostring.already.exist.border=When method already exists
generate.tostring.available.implicit.variables.label=Available implicit variables:<br/>{0}
generate.tostring.exclude..transient=Exclude transient fields
generate.tostring.exclude.by.field.name=Exclude fields by name (reg exp)
generate.tostring.exclude.by.field.type=Exclude fields by type name (reg exp)
generate.tostring.exclude.by.name=Exclude methods by name (reg exp)
generate.tostring.exclude.by.return.type=Exclude methods by return type name (reg exp)
generate.tostring.exclude.constant.fields=Exclude constant fields
generate.tostring.exclude.enum.fields=Exclude enum fields
generate.tostring.exclude.logger=Exclude logger fields (Log4j, JDK Logging, Jakarta Commons Logging)
generate.tostring.exclude.static.fields=Exclude static fields
generate.tostring.fully.qualified.class.name=Use fully qualified class name in generated toString() ($classname)
generate.tostring.getters.in.generated.code=Use getters in generated toString() when available ($methods)
generate.tostring.handle.exception.error.message=An unrecoverable exception was thrown while performing the action - see IDEA log for details (stacktrace should be in idea.log):\n{0}
generate.tostring.handle.exception.plugin.warning.message=A PluginException was thrown while performing the action - see IDEA log for details (stacktrace should be in idea.log):\n{0}
generate.tostring.handle.exception.velocity.error.message=Velocity error generating code - see IDEA log for more details (stacktrace should be in idea.log):\n{0}
generate.tostring.insert.border=Where to insert?
generate.tostring.method.already.exists.dialog.me\=ssage=Replace existing {0} method
generate.tostring.method.already.exists.dialog.title=Method Already Exists
generate.tostring.move.to.generated.checkbox=Move caret to generated method
generate.tostring.settings=Settings
generate.tostring.sort.ascending=Ascending
generate.tostring.sort.checkbox=Sort elements
generate.tostring.sort.descending=Descending
generate.tostring.sort.super=Super class members first
generate.tostring.tab.title=toString() Generation Settings
generate.tostring.template.label=&Template:
generate.tostring.title=Generate toString()
generate.quickfix.files=Create QF scenarios(with '.after' suffix)
generate.select.default.modifier.text=Select modifier
generate.file.extension.text=Enter file extension: .php, .java, .kt, .cpp ....
generate.file.extension.validation.error=File extension ''{0}'' isn''t valid. It must start from ''.'', can''t contain space symbols or be blank
generate.method.nosuites.warn=No test suites were found in @TestDataPath("{0}")
generate.method.nofiles.warn=No test methods were found in class {0}
goto.super.class.chooser.title=Choose super class or interface
group.javadoc.alignment=Alignment
group.javadoc.blank.lines=Blank lines
group.javadoc.invalid.tags=Invalid tags
group.javadoc.other=Other
gutter.implemented.method=Implemented method
gutter.implementing.method=Implementing method
gutter.overridden.method=Overridden method
gutter.overriding.method=Overriding method
gutter.service=Service
gutter.sibling.inherited.method=Sibling inherited method
highlight.exceptions.thrown.chooser.title=Choose Exception Classes to Highlight
highlight.imported.classes.chooser.title=Choose Imported Classes to Highlight
highlight.imported.members.chooser.title=Choose Imported Members to Highlight
highlight.overridden.classes.chooser.title=Choose Classes to Highlight Overridden Methods from
icon.preview=Icon preview
ignore.imports.and.formatting=Ignore imports and formatting
illegal.name.validation.info=Illegal name: {0}
import.layout.static.imports.separately=Layout static imports separately
import.statically=Import statically
include.accessors=&Include Accessors
infer.nullity.progress=Post-processing results...
insert.override.annotation=Insert @&Override annotation
inspection.assert.quickfix=Assert ''{0}''
inspection.capturing.cleaner=Runnable passed to Cleaner.register() captures ''{0}'' reference
inspection.capturing.cleaner.description=Cleaner captures object reference
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Change variable type and remove cast
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Change type of ''{0}'' to ''{1}'' and remove cast
inspection.cast.can.be.removed.narrowing.variable.type.message=Cast may be removed by changing the type of ''{0}'' to ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.name=Too weak variable type leads to unnecessary cast
inspection.charset.object.can.be.used.display.name=Standard 'Charset' object can be used
inspection.charset.object.can.be.used.fix.family.name=Use Charset constant
inspection.charset.object.can.be.used.message={0} can be used instead
inspection.collection.factories.fix.family.name=Replace with collection factory call
inspection.collection.factories.fix.name=Replace with ''{0}.{1}()'' call
inspection.collection.factories.message=Can be replaced with ''{0}.{1}()'' call
inspection.collection.factories.option.ignore.non.constant=Only report when content is constant
inspection.collection.factories.option.suggest.ofentries=Suggest 'Map.ofEntries()'
inspection.collection.used.as.vararg.display.name=Iterable is used as vararg
inspection.collection.used.as.vararg.message=Iterable is passed as vararg: probably an array was intended
inspection.comparator.result.comparison.display.name=Suspicious usage of compare method
inspection.comparator.result.comparison.fix.family.name=Fix comparator result comparison
inspection.comparator.result.comparison.problem.display.name=Comparison of compare method result with specific constant
inspection.conditional.break.in.infinite.loop=Move condition to loop
inspection.conditional.break.in.infinite.loop.description=Conditional break inside loop
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=Don't suggest to replace with 'do while'
inspection.conditional.break.in.infinite.loop.allow.condition.fusion=Allow merging with existing loop condition
inspection.conditional.break.in.infinite.loop.suggest.conversion.when.if.is.single.stmt.in.loop=Suggest conversion when 'if' is a single statement in loop
inspection.convert.to.local.quickfix=Convert to local
inspection.data.flow.display.name=Nullability and data flow problems
inspection.data.flow.optional.of.nullable.misuse.display.name=Use of Optional.ofNullable with null or not-null argument
inspection.data.flow.constant.values.display.name=Constant values
inspection.data.flow.unreachable.code.display.name=Unreachable code
inspection.data.flow.unreachable.code.option.ignore.trivial.name=Ignore trivial exit statements
inspection.data.flow.unreachable.code.option.ignore.trivial.description=Do not report unreachable statements like <code>return 0</code>, <code>break</code>, etc., as they could be necessary to satisfy Java control flow rules.
inspection.data.flow.unreachable.code.option.respect.suppression.name=Respect 'Constant value' inspection suppressions
inspection.data.flow.unreachable.code.option.respect.suppression.description=Try to avoid reporting unreachable code if it caused by a constant condition, where a corresponding warning is suppressed.
inspection.data.flow.filter.notnull.quickfix=Insert 'filter(Objects::nonNull)' step
inspection.data.flow.nullable.quickfix.option=Suggest @Nullable annotation for methods/fields/parameters where nullable values are used
inspection.data.flow.true.asserts.option=Don't report assertions with condition statically proven to be always true
inspection.data.flow.ignore.assert.statements=Ignore assert statements
inspection.data.flow.treat.non.annotated.members.and.parameters.as.nullable=Treat non-annotated members and parameters as @Nullable
inspection.data.flow.report.not.null.required.parameter.with.null.literal.argument.usages=Report not-null required parameter with null-literal argument usages
inspection.data.flow.report.nullable.methods.that.always.return.a.non.null.value=Report nullable methods that always return a non-null value
inspection.data.flow.report.problems.that.happen.only.on.some.code.paths=Report problems that happen only on some code paths
inspection.data.flow.use.computeifpresent.quickfix=Replace 'compute' with 'computeIfPresent'
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.external=Classes with usages in non-Java files
inspection.dead.code.option.main=<html><code>void main(String args[])</code> methods</html>
inspection.dead.code.option.servlet=Servlets
inspection.default.annotation.param=Default annotation parameter value
inspection.duplicate.branches.in.switch.default.message=Branch in 'switch' is a duplicate of the default branch
inspection.duplicate.branches.in.switch.delete.fix.family.name=Delete redundant 'switch' branches
inspection.duplicate.branches.in.switch.delete.fix.name=Delete redundant 'switch' branch
inspection.duplicate.branches.in.switch.display.name=Duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.merge.fix.family.name=Merge duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Merge with ''{0}''
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Merge with the default 'switch' branch
inspection.duplicate.branches.in.switch.message=Duplicate branch in 'switch'
inspection.duplicate.expressions.complexity.threshold=Expression complexity threshold
inspection.duplicate.expressions.display.name=Multiple occurrences of the same expression
inspection.duplicate.expressions.introduce.variable.fix.family.name=Introduce variable
inspection.duplicate.expressions.introduce.variable.fix.name=Introduce variable for ''{0}''
inspection.duplicate.expressions.message=Multiple occurrences of <code>#ref</code> #loc
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Replace with variable other occurrences of expression
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Replace with ''{0}'' other occurrences of ''{1}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Reuse variable
inspection.duplicate.expressions.reuse.variable.fix.name=Reuse variable ''{0}'' for ''{1}''
inspection.endless.stream.description=Non-short-circuit operation consumes infinite stream
inspection.equals.hashcode.display.name='equals()' and 'hashCode()' not paired
inspection.equals.hashcode.generate.equals.quickfix=Generate 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=Generate 'hashCode()'
inspection.equals.hashcode.generate.equals.quickfix.preview=Opens a dialog to configure 'equals()' generation.
inspection.equals.hashcode.generate.hashcode.quickfix.preview=Opens a dialog to configure 'hashCode()' generation.
inspection.excessive.lambda.fix.family.name=Replace lambda with constant
inspection.excessive.lambda.fix.name=Use ''{0}'' method without lambda
inspection.excessive.lambda.message=Excessive lambda usage
inspection.explicit.argument.can.be.lambda.fix.family.name=Replace explicit argument with function
inspection.explicit.argument.can.be.lambda.fix.name=Use ''{0}'' method with functional argument
inspection.explicit.argument.can.be.lambda.message=Explicit argument can be converted to lambda
inspection.explicit.array.filling.description=Can be replaced with single ''Arrays.{0}()'' method call
inspection.explicit.array.filling.fix.family.name=Replace loop with ''Arrays.{0}()'' method call
inspection.explicit.array.filling.no.suggestion.for.set.all=Do not suggest to use 'Arrays.setAll()'
inspection.explicit.array.filling.redundant.loop.description=Redundant initialization of a newly created array
inspection.explicit.array.filling.suggest.set.all=Suggest 'Arrays.setAll()'
inspection.export.results.callees=Call chain
inspection.export.results.implicit.constructor=implicit constructor of
inspection.export.results.overrides.library.methods=Overrides library methods
inspection.export.results.package=package
inspection.export.results.type.references=The following uses this type
inspection.field.can.be.local.display.name=Field can be local
inspection.field.can.be.local.problem.descriptor=Field can be converted to a local variable
inspection.field.can.be.local.quickfix.constructor=Convert field to local variable in constructor
inspection.field.can.be.local.quickfix.initializer=Convert field to local variable in initializer section
inspection.field.can.be.local.quickfix.one.method=Convert field to local variable in method ''{0}''
inspection.fold.expression.fix.family.name=Fold expression
inspection.fold.expression.into.stream.display.name=Expression can be folded into Stream chain
inspection.fold.expression.into.stream.fix.name=Fold expression into Stream chain
inspection.fold.expression.into.string.display.name=Expression can be folded into 'String.join'
inspection.fold.expression.into.string.fix.name=Fold expression into 'String.join'
inspection.forward.compatibility.name=Forward compatibility
inspection.fuse.stream.operations.display.name=Subsequent steps can be fused into Stream API chain
inspection.fuse.stream.operations.fix.family.name=Fuse more statements to the Stream API chain
inspection.fuse.stream.operations.fix.name=Fuse {0} into the Stream API chain
inspection.fuse.stream.operations.message=Stream may be extended replacing {0}
inspection.fuse.stream.operations.option.strict.mode=Do not suggest 'toList()' or 'toSet()' collectors
inspection.handle.signature.change.type.fix.name=Change type to ''{0}''
inspection.handle.signature.field.cannot.resolve=Cannot resolve field ''{0}''
inspection.handle.signature.field.not.static=Field ''{0}'' is not static
inspection.handle.signature.field.static=Field ''{0}'' is static
inspection.handle.signature.field.type=The type of field ''{0}'' is ''{1}''
inspection.handle.signature.method.abstract=Method ''{0}'' is abstract in ''{1}''
inspection.handle.signature.method.not.static=Method ''{0}'' is not static
inspection.handle.signature.method.static=Method ''{0}'' is static
inspection.handle.signature.name=MethodHandle/VarHandle type mismatch
inspection.handle.signature.not.subclass=Caller class ''{0}'' must be a subclass of ''{1}''
inspection.handle.signature.use.constructor.fix.family.name=Use one of constructor overloads
inspection.handle.signature.use.constructor.fix.name=Use constructor ''{0}''
inspection.handle.signature.use.method.fix.family.name=Use one of method overloads
inspection.handle.signature.use.method.fix.name=Use method ''{0}''
inspection.idempotent.loop.body=Idempotent loop body
inspection.illegal.character=Illegal character
inspection.suspicious.ternary.in.varargs.display.name=Suspicious ternary operator in varargs method call
inspection.suspicious.ternary.in.varargs.description=Ternary operator in varargs call contains array and non-array branches
inspection.suspicious.ternary.in.varargs.quickfix=Wrap in array initializer
inspection.insert.literal.underscores.display.name=Unreadable numeric literal
inspection.insert.literal.underscores.family.name=Insert underscores into numeric literal
inspection.missingJavadoc.display.name=Missing Javadoc
inspection.replace.javadoc.display.name=Comment replaceable with Javadoc
inspection.missingJavadoc.label.minimalVisibility=Minimal visibility:
inspection.missingJavadoc.label.requiredTags=Required tags:
inspection.javadocDeclaration.display.name=Javadoc declaration problems
inspection.javadoc.label.text=Additional Javadoc tags:
inspection.javadoc.lint.display.name=HTML problems in Javadoc (DocLint)
inspection.javadoc.method.problem.missing.param.tag=Required tag <code>@param</code> is missing for parameter {0}
inspection.javadoc.method.problem.missing.tag.description={0} tag description is missing
inspection.javadoc.option.ignore.deprecated=Ignore elements marked as @deprecated
inspection.javadoc.option.ignore.period=Ignore period problems
inspection.javadoc.option.ignore.self.ref=Ignore Javadoc pointing to itself
inspection.javadoc.option.ignore.simple=Ignore simple property accessors
inspection.javadoc.option.ignore.throws=Ignore duplicate 'throws' tag
inspection.javadoc.option.tab.title=Class
inspection.javadoc.option.tab.title.field=Field
inspection.javadoc.option.tab.title.inner.class=Inner class
inspection.javadoc.option.tab.title.method=Method
inspection.javadoc.option.tab.title.module=Module
inspection.javadoc.option.tab.title.package=Package
inspection.javadoc.problem.add.param.tag=Add tag @param for parameter ''{0}''
inspection.javadoc.problem.add.param.tag.family=Add missing Javadoc param tag
inspection.javadoc.problem.add.tag=Add tag @{0} {1}
inspection.javadoc.problem.add.tag.family=Add missing Javadoc tag
inspection.javadoc.problem.cannot.resolve=Cannot resolve symbol {0}
inspection.javadoc.problem.descriptor=Required Javadoc is absent
inspection.javadoc.problem.descriptor1=Period in the documentation is missing. The period is used by the Javadoc tool to generate the comment for the overview page
inspection.javadoc.problem.disallowed.tag=Tag {0} is not allowed here
inspection.javadoc.problem.duplicate.param=Duplicate @param tag for parameter ''{0}''
inspection.javadoc.problem.duplicate.tag=Duplicate @{0} tag
inspection.javadoc.problem.duplicate.throws=Duplicate @throws or @exception tag for exception ''{0}''
inspection.javadoc.problem.inaccessible=Symbol {0} is inaccessible from here
inspection.javadoc.problem.missing.tag=Required tag {0} is missing
inspection.javadoc.problem.missing.tag.description={0} is missing after @{1} tag
inspection.javadoc.problem.name.expected=Name expected
inspection.javadoc.problem.pointing.to.itself=Javadoc pointing to itself
inspection.javadoc.problem.snippet.tag.is.not.available='@snippet' tag is not available at this language level
inspection.javadoc.problem.see.tag.expecting.ref=Class/method reference, quoted text, or HTML link are expected after @see tag
inspection.javadoc.problem.wrong.tag=Wrong tag {0}
inspection.javadoc.ref.display.name=Declaration has problems in Javadoc references
inspection.javadoc.blank.lines.display.name=Blank line should be replaced with <p> to break lines
inspection.javadoc.blank.lines.message=Blank line will be ignored
inspection.replace.with.javadoc=Replace with Javadoc comment
inspection.replace.with.javadoc.comment=Comment can be converted to Javadoc
inspection.javadoc.blank.lines.fix.name=Insert <p>
inspection.javadoc.blank.lines.fix.family.name=Replace blank lines with <p>
inspection.javadoc.link.as.plain.text.display.name=Link specified as plain text
inspection.javadoc.link.as.plain.text.message=Link specified as plain text
inspection.join.declaration.and.assignment.display.name=Assignment can be joined with declaration
inspection.join.declaration.and.assignment.fix.family.name=Join declaration and assignment
inspection.join.declaration.and.assignment.fix.title=Join Declaration and Assignment
inspection.join.declaration.and.assignment.message=Assignment can be joined with declaration of ''{0}''
inspection.labeled.switch.rule.redundant.code.block.display.name=Labeled switch rule has redundant code block
inspection.labeled.switch.rule.redundant.code.block.message=Labeled rule's code block is redundant
inspection.labeled.switch.rule.redundant.code.fix.name=Unwrap code block of labeled rule
inspection.lambda.to.method.call.fix.family.name=Replace lambda expression with method call
inspection.lambda.to.method.call.fix.name=Replace lambda expression with ''{0}''
inspection.manual.min.max.calculation.description=Can be replaced with ''Math.{0}()'' call
inspection.manual.min.max.calculation.disable.for.non.integral=Disable for float and double
inspection.map.foreach.display.name=Map.forEach() can be used
inspection.map.foreach.option.no.loops=Do not report loops
inspection.message.anonymous.ref.loc.can.be.replaced.with.method.reference=Anonymous #ref #loc can be replaced with method reference
inspection.message.can.be.replaced.with.0.constructor=Can be replaced with ''{0}'' constructor
inspection.message.can.be.replaced.with.files.readstring=Can be replaced with 'Files.readString()'
inspection.message.can.be.replaced.with.optional.of.nullable=Can be replaced with Optional.ofNullable()
inspection.message.can.be.replaced.with.single.expression.in.functional.style=Can be replaced with single expression in functional style
inspection.message.can.be.replaced.with.string.repeat=Can be replaced with 'String.repeat()'
inspection.message.lambda.parameter.type.is.redundant=Lambda parameter type is redundant
inspection.message.pseudo.functional.style.code=Pseudo functional style code
inspection.message.redundant.default.parameter.value.assignment=Redundant default parameter value assignment
inspection.message.replace.optional.with.if.statements=Replace Optional with if statements
inspection.no.jdk.error.message=The JDK is not configured properly for this project. Inspection cannot proceed.
inspection.no.modules.error.message=This project contains no modules. Inspection cannot proceed.
inspection.notnull.field.not.initialized.display.name=@NotNull field is not initialized
inspection.notnull.field.not.initialized.option.implicit=Ignore fields which could be initialized implicitly
inspection.notnull.field.not.initialized.option.implicit.description=When checked, fields that are known to be initialized implicitly (e.g. via dependency injection) will not be reported
inspection.notnull.field.not.initialized.option.setup=Ignore fields initialized in setUp() method
inspection.notnull.field.not.initialized.option.setup.description=When checked, fields in test case classes that are initialized in setup methods (e.g. annotated via <code>@Before</code> or <code>@BeforeEach</code>) will not be reported.
inspection.null.value.for.optional.assigned.ignore.fix.name=Do not warn when comparing Optional with null
inspection.null.value.for.optional.assigned.message=Optional value is compared with null
inspection.null.value.for.optional.context.assignment=assignment
inspection.null.value.for.optional.context.declaration=declaration
inspection.null.value.for.optional.context.lambda=lambda expression
inspection.null.value.for.optional.context.parameter=parameter
inspection.null.value.for.optional.context.return=return statement
inspection.null.value.for.optional.fix.family.name=Replace with empty Optional method
inspection.null.value.for.optional.message=Null is used for ''Optional'' type in {0}
inspection.null.value.for.optional.option.comparisons=Report comparison of Optional with null
inspection.nullable.problems.display.name=@NotNull/@Nullable problems
inspection.nullable.problems.ignore.external.notnull=&Ignore external @NotNull
inspection.nullable.problems.method.overrides.notnull.option=Report @NotNull &parameters overriding @Nullable and vice versa
inspection.nullable.problems.method.overrides.option=Report non-&annotated parameters or methods overriding @NotNull
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Report non-annotated &setter parameters or getters of annotated fields
inspection.nullable.problems.notnull.overrides.option=Report @NotNull &parameters overriding non-annotated
inspection.nullable.problems.notnull.parameters.with.null.literal.option=Report @NotNull parameters with null-literal argument usages
inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> without ''isPresent()'' check
inspection.optional.get.without.is.present.method.reference.message=<code>#ref</code> without 'isPresent()' check
inspection.overflowing.loop.index.inspection.description=Loop executes zero or billions of times
inspection.overflowing.loop.index.inspection.name=Loop executes zero or billions of times
inspection.overwritten.key.map.message=Duplicate Map key
inspection.overwritten.key.set.message=Duplicate Set element
inspection.overwritten.key.array.message=Overwritten array element
inspection.parameter.can.be.local.display.name=Value passed as parameter never read
inspection.parameter.can.be.local.problem.descriptor=Parameter can be converted to a local variable
inspection.quickfix.assert.family=Assert
inspection.raw.use.of.parameterized.type.problem.descriptor=Raw use of parameterized class <code>#ref</code> #loc
raw.variable.type.can.be.generic.family.quickfix=Add generic parameters to the type
raw.variable.type.can.be.generic.quickfix=Change type of {0} to {1}
raw.variable.type.can.be.generic.cast.quickfix=Change cast type to {0}
raw.variable.type.can.be.generic.cast.quickfix.family=Parameterize cast type
raw.use.of.parameterized.type.ignore.new.objects.option=Ignore construction of new objects
raw.use.of.parameterized.type.ignore.type.casts.option=Ignore type casts
raw.use.of.parameterized.type.ignore.uncompilable.option=Ignore where a type parameter would not compile
raw.use.of.parameterized.type.ignore.overridden.parameter.option=Ignore parameter types of overriding methods
raw.use.of.parameterized.type.ignore.quickfix.not.available.option=Ignore when automatic quick-fix is not available
inspection.redundant.array.creation.display.name=Redundant array creation
inspection.redundant.array.creation.for.varargs.call.descriptor=Redundant array creation for calling varargs method
inspection.redundant.array.creation.quickfix=Remove explicit array creation
inspection.redundant.explicit.close=Redundant 'close()'
inspection.redundant.file.creation.display.name=Redundant 'File' instance creation
inspection.redundant.file.creation.description=<code>#ref</code> is redundant #loc
inspection.redundant.file.creation.quickfix=Replace with file name
inspection.redundant.null.check.always.fail.message=Null-check will always fail: {0} is never null
inspection.redundant.null.check.fix.family.name=Remove redundant null-check
inspection.redundant.null.check.fix.notnull.family.name=Remove erroneous '!= null'
inspection.redundant.null.check.message=Redundant null-check: {0} is never null
inspection.redundant.operation.on.empty.array.message=Array <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.collection.message=Collection <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.container.display.name=Redundant operation on empty container
inspection.redundant.operation.on.empty.map.message=Map <code>#ref</code> is always empty
inspection.redundant.record.constructor.can.be.compact.message=Canonical constructor can be converted to compact form
inspection.redundant.record.constructor.canonical.message=Redundant canonical constructor
inspection.redundant.record.constructor.compact.message=Redundant compact constructor
inspection.redundant.record.constructor.description=Redundant record constructor
inspection.redundant.record.constructor.fix.family.name=Convert canonical constructor to compact form
inspection.redundant.record.constructor.statement.message=Redundant field assignment in compact constructor
inspection.redundant.stream.optional.call.explanation.at.most.one=stream contains at most one element
inspection.redundant.stream.optional.call.explanation.distinct=there is a previous 'distinct()' call in the chain
inspection.redundant.stream.optional.call.explanation.distinct.set=elements will be distinct anyway when collected to a Set
inspection.redundant.stream.optional.call.explanation.filter=predicate is always 'true'
inspection.redundant.stream.optional.call.explanation.map.flatMap=previous 'map()' call can replace the 'flatMap()' step
inspection.redundant.stream.optional.call.explanation.parallel=there is a subsequent ''{0}()'' call which overrides this call
inspection.redundant.stream.optional.call.explanation.parallel.source=the stream was created via 'parallelStream()', so it's already parallel
inspection.redundant.stream.optional.call.explanation.sequential.source=the stream was created via 'stream()', so it's already sequential
inspection.redundant.stream.optional.call.explanation.parallel.single=stream created from single element will not be parallelized
inspection.redundant.stream.optional.call.explanation.sorted=subsequent ''{0}()'' call doesn''t depend on the sort order
inspection.redundant.stream.optional.call.explanation.sorted.parallel=subsequent ''{0}()'' operation doesn''t depend on the sort order for parallel streams
inspection.redundant.stream.optional.call.explanation.sorted.twice=there is a subsequent 'sorted()' call in the chain
inspection.redundant.stream.optional.call.explanation.unordered=there is a previous 'unordered()' call in the chain
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Collect to 'LinkedHashSet'
inspection.redundant.stream.optional.call.fix.family.name=Remove redundant chain call
inspection.redundant.stream.optional.call.fix.bind.name=Merge the ''{0}()'' step with the previous ''{1}()'' step
inspection.redundant.stream.optional.call.fix.name=Remove ''{0}()'' call
inspection.redundant.stream.optional.call.fix.replace.terminal=Replace the terminal operation
inspection.redundant.stream.optional.call.fix.replace.terminal.text=Replace the terminal operation with ''{0}()''
inspection.redundant.stream.optional.call.message=Redundant ''{0}()'' call
inspection.redundant.stream.optional.call.message.with.explanation=Redundant ''{0}()'' call: {1}
inspection.redundant.stream.optional.call.option.streamboxing=Report redundant boxing in Stream.map()
inspection.reflect.handle.invocation.argument.not.array=Argument is not an array type
inspection.reflect.handle.invocation.argument.not.exact=Argument type should be exactly ''{0}''
inspection.reflect.handle.invocation.primitive.argument.null=Argument of type ''{0}'' cannot be ''null''
inspection.reflect.handle.invocation.receiver.incompatible=Call receiver type is incompatible: ''{0}'' is expected
inspection.reflect.handle.invocation.receiver.null=Call receiver is 'null'
inspection.reflect.handle.invocation.result.not.assignable=Should be cast to ''{0}'' or its superclass
inspection.reflect.handle.invocation.result.not.exact=Should be cast to ''{0}''
inspection.reflect.handle.invocation.result.null=Returned value is always 'null'
inspection.reflect.handle.invocation.result.void=Return type is 'void'
inspection.reflection.invocation.argument.count={0,choice,0#No arguments are|1#One argument is|1<{0} arguments are} expected
inspection.reflection.invocation.argument.not.assignable=Argument is not assignable to ''{0}''
inspection.reflection.invocation.array.not.assignable=Array {0,choice,1#item has|1<items have} incompatible {0,choice,1#type|1<types}
inspection.reflection.invocation.item.count={0,choice,0#Empty array is|1#Single-item array is|1<{0} array items are} expected
inspection.reflection.invocation.item.not.assignable=Array item is not assignable to ''{0}''
inspection.reflection.invocation.name=Reflective invocation arguments mismatch
inspection.reflection.member.access.cannot.resolve.constructor.arguments=Cannot resolve constructor with specified argument types
inspection.reflection.member.access.cannot.resolve.field=Cannot resolve field ''{0}''
inspection.reflection.member.access.cannot.resolve.method=Cannot resolve method ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=Cannot resolve method ''{0}'' with specified argument types
inspection.reflection.member.access.check.exists=Check that field/method exists in non-final classes
inspection.reflection.member.access.check.exists.exclude.label=Exclude classes:
inspection.reflection.member.access.check.exists.exclude.chooser=Class To Exclude
inspection.reflection.member.access.constructor.not.public=Constructor is not public
inspection.reflection.member.access.field.not.in.class=Field ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.field.not.public=Field ''{0}'' is not public
inspection.reflection.member.access.fix.family.name=Use appropriate reflection method
inspection.reflection.member.access.method.not.in.class=Method ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.method.not.public=Method ''{0}'' is not public
inspection.reflection.member.access.name=Reflective access to non-existent or not visible class member
inspection.reflection.visibility.name=Reflective access across modules issues
inspection.remove.literal.underscores.display.name=Underscores in numeric literal
inspection.remove.literal.underscores.family.name=Remove underscores from numeric literal
inspection.replace.methodref.ternary.quickfix=Replace with null-checking lambda
inspection.replace.ternary.quickfix=Replace with ''{0} != null ?:''
inspection.replace.with.bulk.fix.family.name=Replace with bulk method call
inspection.replace.with.bulk.fix.name=Replace iteration with bulk ''{0}()'' call
inspection.replace.with.bulk.message=Iteration can be replaced with bulk ''{0}()'' call
inspection.replace.with.bulk.wrap.arrays=Use 'Arrays.asList()' to wrap arrays
inspection.replace.with.enhanced.switch.statement.fix.name=Replace with enhanced 'switch' statement
inspection.replace.with.old.style.switch.statement.fix.name=Replace with old style 'switch' statement
inspection.replace.with.regular.string.literal.fix=Replace with regular string literal
inspection.replace.with.switch.expression.fix.name=Replace with 'switch' expression
inspection.replace.with.switch.expression.fix.family.name=Migrate to enhanced switch
inspection.replace.with.text.block.fix=Replace with text block
inspection.replace.with.string.template.fix=Replace with string template
inspection.replace.with.string.concatenation.fix=Replace with string concatenation
inspection.replace.with.trivial.lambda.fix.family.name=Replace with trivial lambda
inspection.replace.with.trivial.lambda.fix.name=Replace with lambda returning ''{0}''
inspection.require.non.null=Replace null check with Objects/Stream static call
inspection.require.non.null.description=Null check can be replaced with method call
inspection.require.non.null.message={0, choice, 1#''if'' statement|2#Conditional expression} can be replaced with call to ''{1}()''
inspection.require.non.null.quickfix=Replace {0, choice, 1#''if'' statement|2#conditional expression} with ''{1}()'' call
inspection.require.non.null.no.warning.replacement.bigger=Don't warn if the replacement is longer than the original
inspection.return.separated.from.computation.descriptor=Return separated from computation of value of ''{0}''
inspection.return.separated.from.computation.family.quickfix=Move 'return' closer to computation of the result
inspection.return.separated.from.computation.name='return' separated from the result computation
inspection.return.separated.from.computation.quickfix=Move ''return'' closer to computation of the value of ''{0}''
inspection.same.parameter.display.name=Method parameter always has the same value
inspection.same.parameter.fix.family.name=Inline parameter as constant value
inspection.same.parameter.fix.name=Inline value ''{1}'' for parameter ''{0}''
dialog.message.parameter.has.write.usages.inline.not.supported=Parameter has write usages. Inline is not supported
inspection.same.parameter.problem.descriptor=Value of parameter <code>#ref</code> is always ''{0}''
inspection.simplifiable.comparator.comparing.message=Unnecessary ''{0}()'' call
inspection.simplifiable.comparator.display.name=Comparator method can be simplified
inspection.simplifiable.comparator.entry.comparator.message=''{0}'' can be used instead
inspection.simplifiable.comparator.fix.comparing.family.name=Remove redundant call
inspection.simplifiable.comparator.fix.entry.comparator.family.name=Use predefined 'Map.Entry' comparator
inspection.simplifiable.comparator.fix.remove.name=Remove ''{0}()'' call
inspection.simplifiable.comparator.fix.replace.name=Remove ''{0}()'' call and use ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=Simplify comparator method replacing 'max' with 'min'
inspection.simplifiable.comparator.fix.reversed.name=Replace with ''{0}'' simplifying the comparator
inspection.simplifiable.comparator.reversed.message=Comparator method can be simplified if ''{0}()'' call is replaced with ''{1}()''
inspection.simplify.collector.fix.family.name=Simplify cascaded collector
inspection.simplify.collector.fix.name=Use ''Collectors.{0}()'' collector
inspection.simplify.collector.message=Can be simplified using ''{0}()'' collector
inspection.simplify.foreach.display.name=Simplifiable forEach() call
inspection.sorted.collection.with.non.comparable.keys.display.name=Sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.message=Construction of sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=Don't report non-comparable type parameters
inspection.surround.if.family=Surround with if
inspection.surround.if.quickfix=Surround with ''if ({0}{1})''
inspection.suspicious.list.remove.display.name=Suspicious 'List.remove()' in loop
inspection.switch.expression.backward.expression.migration.inspection.name='switch' expression can be replaced with old style 'switch' statement
inspection.switch.expression.backward.migration.inspection.name=Enhanced 'switch'
inspection.switch.expression.backward.statement.migration.inspection.name='switch' statement can be replaced with old style 'switch' statement
inspection.switch.expression.migration.inspection.name=Statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.warn.only.on.expression=Show warning only if conversion to expression is possible
inspection.switch.expression.migration.option.expression.max.statements=Do not report switches having more than {0} {0, choice, 1#statement|2#statements} in a single branch
inspection.switch.expression.migration.expression.max.statements=Maximum number of statements in one branch to convert to switch expression
inspection.switch.labeled.rule.can.be.code.block.display.name=Labeled switch rule can have code block
inspection.switch.labeled.rule.can.be.code.block.expression.message=Labeled rule's result expression can be wrapped with code block
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Wrap labeled rule's result expression with code block
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Wrap labeled rule's statement with code block
inspection.switch.labeled.rule.can.be.code.block.statement.message=Labeled rule's statement can be wrapped with code block
inspection.text.block.backward.migration.message=Text block can be converted to regular string literal
inspection.text.block.backward.migration.name=Text block can be replaced with regular string literal
inspection.text.block.migration.string.message=String can be replaced with text block
inspection.text.block.migration.concatenation.message=Concatenation can be replaced with text block
inspection.text.block.migration.name=Text block can be used
inspection.text.block.migration.suggest.literal.replacement=Report single string literals
inspection.string.template.migration.string.message=String can be replaced with template
inspection.string.template.reverse.migration.string.message=String template can be replaced with string concatenation
inspection.string.template.migration.concatenation.message=Concatenation can be replaced with string template
inspection.string.template.migration.name=String template can be used
inspection.string.template.reverse.migration.name=String template can be concatenated string
inspection.implicit.to.explicit.class.backward.migration.name=Implicitly declared class can be replaced with ordinary class
inspection.implicit.to.explicit.class.backward.migration.fix.name=Convert implicitly declared class into regular class
inspection.explicit.to.implicit.class.migration.name=Explicit class declaration can be converted into implicitly declared class
inspection.explicit.to.implicit.class.migration.fix.name=Convert into implicitly declared class
inspection.inconsistent.text.block.indent.name=Inconsistent whitespace indentation in text block
inspection.inconsistent.text.block.indent.message=Text block indent consists of tabs and spaces
inspection.inconsistent.text.block.indent.spaces.to.tabs.one.to.one.fix=Replace spaces with tabs (1 space = 1 tab)
inspection.inconsistent.text.block.indent.spaces.to.tabs.many.to.one.fix=Replace spaces with tabs ({0} spaces = 1 tab)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.one.fix=Replace tabs with spaces (1 tab = 1 space)
inspection.inconsistent.text.block.indent.tabs.to.spaces.one.to.many.fix=Replace tabs with spaces (1 tab = {0} spaces)
inspection.suspicious.return.byte.input.stream.name = Suspicious byte value returned from 'InputStream.read()'
inspection.suspicious.return.byte.input.stream.convert.to.unsigned = Convert to an unsigned byte
inspection.trailing.whitespaces.in.text.block.name=Trailing whitespace in text block
inspection.trailing.whitespaces.in.text.block.message=Trailing whitespace characters inside text block
inspection.trailing.whitespaces.in.text.block.remove.whitespaces=Remove trailing whitespace characters
inspection.trailing.whitespaces.in.text.block.replaces.whitespaces.with.escapes=Escape trailing whitespace characters
inspection.undeclared.service.usage.message=Usage of service ''{0}'' is not declared in module-info
inspection.undeclared.service.usage.name=Usage of service not declared in 'module-info'
inspection.unused.assignment.option=Report prefix expressions that can be replaced with a binary expression
inspection.unused.assignment.option1=Report postfix expressions where the changed value is not used
inspection.unused.assignment.option2=Report redundant initializers
inspection.unused.assignment.option3=Report pattern variables whose values are never used
inspection.unused.assignment.option4=Report iteration parameters whose values are never used
inspection.unused.assignment.problem.descriptor1=Variable <code>#ref</code> #loc is never used
inspection.unused.assignment.problem.descriptor2=Variable <code>{0}</code> initializer <code>#ref</code> #loc is redundant
inspection.unused.assignment.problem.descriptor3=The value <code>{0}</code> assigned to <code>#ref</code> #loc is never used
inspection.unused.assignment.problem.descriptor4=The value changed at <code>#ref</code> #loc is never used
inspection.unused.assignment.problem.descriptor5=The value of pattern variable <code>#ref</code> #loc is never used
inspection.unused.assignment.problem.descriptor6=The value of foreach iteration parameter <code>#ref</code> #loc is never used
inspection.unused.assignment.remove.assignment.quickfix=Remove redundant assignment
inspection.unused.assignment.remove.assignment.quickfix.title=Remove Redundant Assignment
inspection.unused.assignment.remove.initializer.quickfix=Remove redundant initializer
inspection.unused.assignment.remove.initializer.quickfix.title=Remove Redundant Initializer
inspection.unused.parameter.problem.descriptor=Parameter <code>#ref</code> is not used
inspection.unused.parameter.composer=Parameter <code>#ref</code> is not used in any implementation
inspection.unused.parameter.composer1=Parameter <code>#ref</code> is not used in this method nor in any of its overriding methods
inspection.unused.parameter.delete.family=Safe delete unused parameter(s)
inspection.unused.parameter.delete.quickfix=Safe delete unused parameter ''{0}''
inspection.unused.return.value.display.name=Method can be made 'void'
inspection.unused.return.value.make.void.quickfix=Make method 'void'
inspection.unused.return.value.problem.descriptor=Return value of the method is never used
inspection.unused.symbol.check.accessors=Getters/setters
inspection.unused.symbol.check.classes=Classes:
inspection.unused.symbol.check.fields=Fields:
inspection.unused.symbol.check.inner.classes=Inner classes:
inspection.unused.symbol.check.localvars=Local variables
inspection.unused.symbol.check.methods=Methods:
inspection.unused.symbol.check.parameters=Parameters in
inspection.unused.symbol.check.parameters.excluding.hierarchy=Excluding hierarchy
inspection.empty.module.info.file=Empty 'module-info.java' file
inspection.unresolved.module.dependencies.problem.descriptor=Unresolved module dependencies
inspection.auto.add.module.requirements.quickfix=Fill in module dependencies
inspection.value.based.warnings=Value-based warnings
inspection.preview.feature=Preview Feature warning
inspection.value.based.warnings.synchronization=Attempt to synchronize on an instance of a value-based class
inspection.variable.assigned.to.itself.display.name=Variable is assigned to itself
inspection.wrapper.type.may.be.primitive.fix.name=Convert wrapper type to primitive
inspection.wrapper.type.may.be.primitive.name=Type may be primitive
intention.add.explicit.type.arguments.family=Add explicit type arguments
intention.add.on.demand.static.import.family=Add on-demand static import
intention.add.on.demand.static.import.text=Add on-demand static import for ''{0}''
intention.add.single.member.import.text=Add import for ''{0}''
intention.add.single.member.static.import.family=Add single-member static import
intention.add.single.member.static.import.text=Add static import for ''{0}''
intention.assign.field.from.parameter.family=Assign parameter to field
intention.assign.field.from.parameter.text=Assign parameter to field ''{0}''
intention.bind.fields.from.parameters.family=Bind parameters to fields
intention.bind.fields.from.parameters.text=Bind {0} parameters to fields
intention.break.string.on.line.breaks.text=Break string on '\\n'
intention.compose.function.family=Replace nested function call with composition
intention.compose.function.text=Replace nested function call with andThen call
intention.convert.color.representation.family=Convert Color representation
intention.convert.color.representation.text=Convert to ''new Color{0}''
intention.convert.compact.constructor.to.canonical=Convert compact constructor to canonical
intention.convert.to.single.return.name=Transform body to single exit-point form
intention.convert.to.single.return.progress.title=Transform body to single exit-point form
intention.convert.to.single.return.command.text=Transform Body To Single Exit-Point Form
intention.create.annotation.method.from.usage=Create @interface method ''{0}()''
intention.create.field.from.parameter.family=Create field for parameter
intention.create.field.from.parameter.text=Create field for parameter ''{0}''
intention.create.test.dialog.choose.super.class=Choose Superclass
intention.create.test.dialog.class.name=Class name:
intention.create.test.dialog.fix.library=Fix
intention.create.test.dialog.generate=Generate:
intention.create.test.dialog.java=Java
intention.create.test.dialog.library.not.found={0} library not found in the module
intention.create.test.dialog.select.methods=Generate test &methods for:
intention.create.test.dialog.setUp=set&Up/@Before
intention.create.test.dialog.show.inherited=Show &inherited methods
intention.create.test.dialog.super.class=Superclass:
intention.create.test.dialog.tearDown=tear&Down/@After
intention.create.test.dialog.testing.library=Testing &library:
intention.encapsulate.field.text=Encapsulate field
intention.error.cannot.create.class.message=Cannot Create Class ''{0}''
intention.error.cannot.create.class.title=Failed to Create Class
intention.extract.if.condition.family=Extract 'if' condition
intention.extract.if.condition.text=Extract if ({0})
intention.extract.map.step.family=Extract to separate mapping method
intention.extract.map.step.text=Extract variable ''{0}'' to ''{1}'' operation
intention.extract.method.text=Extract method
intention.extract.set.from.comparison.chain.family=Extract Set from comparison chain
intention.extract.set.from.comparison.chain.popup.title=Extract Set from Comparison Chain
intention.family.add.javadoc=Add Javadoc
intention.family.copy.abstract.method.implementation=Copy abstract method implementation
intention.family.create.a.class.in.package=Create a class in package
intention.family.edit.method.contract=Edit method contract
intention.family.edit.range=Edit range
intention.family.expand.static.import=Expand static import
intention.family.fix.bounded.wildcards=Fix bounded wildcards
intention.family.make.external.annotations.explicit=Make external annotations explicit
intention.family.make.inferred.annotations.explicit=Make inferred annotations explicit
intention.family.move.it=Move it
intention.family.put.arguments.on.one.line=Put arguments on one line
intention.family.put.arguments.on.separate.lines=Put arguments on separate lines
intention.family.put.parameters.on.one.line=Put parameters on one line
intention.family.put.parameters.on.separate.lines=Put parameters on separate lines
intention.family.put.record.components.on.one.line=Put record components on one line
intention.family.put.record.components.on.separate.lines=Put record components on separate lines
intention.family.replace.optional.ispresent.condition.with.functional.style.expression=Replace Optional presence condition with functional style expression
intention.family.sort.content=Sort content
intention.family.swap.if.statements=Swap 'if' statements
intention.family.unimplement.interface.class=Unimplement Interface/Class
intention.family.variable.access.from.inner.class=Move into anonymous object
intention.implement.abstract.class.default.text=Implement Abstract Class
intention.implement.abstract.class.family=Implement abstract class or interface
intention.implement.abstract.method.command.name=Implement method
intention.implement.abstract.method.error.no.classes.message=There are no classes found where this method can be implemented
intention.implement.abstract.method.error.no.classes.title=No Classes Found
intention.implement.abstract.method.family=Implement abstract method
intention.implement.abstract.method.searching.for.descendants.progress=Searching For Descendants...
intention.implement.abstract.method.text=Implement method ''{0}''
intention.inline.map.family=Inline stream mapping method
intention.inline.map.inline.text=Inline ''{0}()'' body into the next ''{1}()'' call
intention.inline.map.merge.text=Merge ''{0}()'' call and ''{1}()'' call
intention.introduce.variable.text=Introduce local variable
intention.invert.if.condition=Invert 'if' condition
intention.merge.filter.family=Merge filters
intention.merge.filter.text=Merge filter chain
intention.move.field.assignment.to.declaration=Move assignment to field declaration
intention.move.initializer.to.constructor=Move initializer to constructor
intention.move.initializer.to.set.up=Move initializer to setUp method
intention.override.method.text=Override method ''{0}''
intention.replace.concatenation.with.formatted.output.family=Replace concatenation with formatted output
intention.replace.concatenation.with.formatted.output.text=Replace '+' with 'java.text.MessageFormat.format()'
intention.split.declaration.assignment.text=Split into declaration and assignment
intention.split.declaration.family=Split declaration
intention.split.filter.family=Split filter
intention.split.filter.text=Split into filter chain
intention.split.if.family=Split 'if'
intention.split.if.text=Split into 2 'if' statements
intention.split.switch.branch.with.several.case.values.copy.text=Copy 'switch' branch
intention.split.switch.branch.with.several.case.values.family=Split switch branch with several case values into individual 'switch' branches
intention.split.switch.branch.with.several.case.values.split.text=Split values of 'switch' branch
intention.surround.resource.with.ARM.block=Surround with try-with-resources block
intention.surround.with.ARM.block.template=try-with-resources
intention.text.add.method.contract.to.0=Add method contract to ''{0}()''...
intention.text.add.range.to.0=Add range to ''{0}''...
intention.text.annotate.externally=Annotate externally
intention.text.collapse.repeating.annotations=Collapse repeating annotations
intention.text.create.a.class.in.0=Create a class in ''{0}''
intention.text.create.a.class.in.package.preview=Opens a dialog to create a class in package ''{0}''
intention.text.edit.method.contract.of.0=Edit method contract of ''{0}()''...
intention.text.edit.range.of.0=Edit range of ''{0}''...
intention.text.fix.method.0.parameters.with.bounded.wildcards=Fix method ''{0}'' parameters with bounded wildcards
intention.text.generate.missing.test.methods=Generate missing test methods
intention.text.replace.implements.with.static.import=Replace implements with static import
intention.text.replace.static.import.with.qualified.access.to.0=Replace static import with qualified access to {0}
intention.text.unimplement.0=Unimplement {0}
intention.text.implements.list.remove.others=Remove other ''{0}'' references
intention.unroll.loop.family=Unroll loop
intention.unwrap.else.branch=Unwrap 'else' branch
intention.unwrap.else.branch.changes.semantics=Unwrap 'else' branch (changes semantics)
intention.use.single.member.static.import.text=Use static import for ''{0}''
intention.wrap.with.unmodifiable=Wrap with unmodifiable collection or map
intention.wrap.with.unmodifiable.list=Wrap with unmodifiable list
intention.wrap.with.unmodifiable.map=Wrap with unmodifiable map
intention.wrap.with.unmodifiable.set=Wrap with unmodifiable set

#intention categories
intention.category.annotations=Java/Annotations
intention.category.comments=Java/Comments
intention.category.concurrency=Java/Concurrency
intention.category.collections=Java/Collections
intention.category.conditional.operator=Java/Conditions
intention.category.control.flow=Java/Control flow
intention.category.declaration=Java/Declaration
intention.category.expressions=Java/Expressions
intention.category.i18n=Java/Internationalization
intention.category.imports=Java/Imports
intention.category.junit=Java/JUnit
intention.category.other=Java/Other
intention.category.refactorings=Java/Refactorings
intention.category.streams=Java/Streams
intention.category.strings=Java/Strings
intention.category.try.statements=Java/Try statements

interface.not.allowed=Interface is not allowed
java.line.markers=Java line markers
java.preview.features.accept.notification.link=Accept
java.preview.features.alert.title=Experimental Feature Alert
java.preview.features.legal.notice=You must accept the terms of legal notice of the beta Java specification to enable support for "{0}".<br/><br/>\
  <b>The implementation of an early-draft specification developed under the Java Community Process (JCP) is made available for testing and evaluation purposes only and is not compatible with any specification of the JCP.</b>{1}
java.preview.level={0} (Preview)
java.preview.features.notification.title=Java preview features
java.preview.features.warning=Newer IDE versions may discontinue support for Java preview features. When Java {0} is released, support for the {1} (Preview) language level may be dropped.
java.preview.features.unsupported.title=Unsupported Java preview features
java.preview.features.unsupported=Java language level <b>{0} (Preview)</b> used in this project is not supported anymore. \
  Code insight for the preview features may work incorrectly.<br>\
  It''s strongly encouraged to migrate to newer Java version or stop using preview features.
java.terms.exception=exception
java.terms.region=region
java.terms.instance.initializer=instance initializer
java.terms.of.annotation.type={0} of annotation type {1}
java.terms.of.anonymous.class={0} of anonymous class
java.terms.of.class={0} of class {1}
java.terms.of.enum={0} of enum {1}
java.terms.of.interface={0} of interface {1}
java.terms.static.initializer=static initializer
java.terms.type.parameter=type parameter
java.terms.variable.of.method={0} of {1}
java.configurable.logger.unspecified=Unspecified
java.configurable.logger.not.found=Logger was not found inside the project
java.configurable.logger.identifier.long=Identifier is too long
javadoc.candidates.not.found=<html>No candidates found for method call <b>{0}</b>.</html>
javadoc.constructor.candidates=<html>Candidates for new <b>{0}</b>() are:<br>{1}</html>
javadoc.deprecated=Deprecated
javadoc.description.copied.from.class=From class:
javadoc.description.copied.from.field=From field:
javadoc.description.copied.from.interface=From interface:
#short index to be shown on the inferred annotation in the documentation popup
javadoc.description.inferred.annotation.hint=i
javadoc.generate.arguments=Command line arguments:
javadoc.generate.exited=\n"javadoc" finished with exit code $EXIT_CODE$
javadoc.generate.heap.size=&Maximum heap size:
javadoc.generate.include.jdk.library.sources.in.sourcepath.option=Include JDK and library sources in -sourcepath
javadoc.generate.link.to.jdk.documentation.option=Link to JDK documentation (use -link option)
javadoc.generate.locale=&Locale:
javadoc.generate.no.classes.in.selected.packages.error=Selected scope contain no Java classes
javadoc.generate.no.jdk=Cannot generate JavaDoc - no Java SDK is configured for the project. Please specify a Java SDK in Settings | Project Structure.
javadoc.generate.no.javadoc.tool=Cannot generate JavaDoc - no javadoc tool found at {0} or {1}. Please specify a valid Java SDK in Settings | Project Structure.
javadoc.generate.open.in.browser=Open &generated documentation in browser
javadoc.generate.options.separator=JavaDoc Options
javadoc.generate.options.hierarchy=Generate hierarchy tree
javadoc.generate.options.index=Generate index
javadoc.generate.options.index.per.letter=Separate index per letter
javadoc.generate.options.navigator=Generate navigation bar
javadoc.generate.output.directory=Output &directory:
javadoc.generate.output.directory.browse=Browse Output Directory
javadoc.generate.scope.row=Visibility level:
javadoc.generate.sources.progress=Looking for sources to generate Javadoc
javadoc.generate.tag.list.deprecated=Deprecated list
javadoc.generate.temp.file.error=Cannot create temporary file
javadoc.generate.temp.file.does.not.exist=Temporary file doesn't exist or cannot be opened
javadoc.generate.title=Generate JavaDoc
javadoc.generate.ok=Generate
javadoc.generate.validation.error=Specify the output directory.
javadoc.method.in.class={0} in class {1}
javadoc.method.in.interface={0} in interface {1}
javadoc.method.overrides=Overrides:
javadoc.method.specified.by=Specified by:
javadoc.option.automatically.insert.closing.tag.javadoc=Automatically insert closing tag in JavaDoc
javadoc.option.javadoc.title=JavaDoc
javadoc.see.also=See Also:
javadoc.settings.title=Javadoc
javadoc.since=Since:
javadoc.author=Author:
javadoc.version=Version:
javadoc.apiNote=API Note:
javadoc.implNote=Implementation<br>Note:
javadoc.implSpec=Implementation<br>Requirements:
javadoc.type.parameters=Type parameters:
jvm.logging.configurable.display.name = JVM Logging
jvm.logging.configurable.id = jvm.logging
jvm.logging.configurable.java.group.display.name = Java
jrt.node.short=[JRT]
label.add.math.max.0.count.to.avoid.possible.semantics.change=Add Math.max(0, count) to avoid possible semantics change
label.class.filter.editor.add.dialog.filter.pattern=Enter the filter pattern:
label.configurable.logger.type=Logger:
label.configurable.logger.generation.variable.name= Variable name:
label.contract=&Contract:
label.enter.fully.qualified.class.name=Enter fully qualified class name
label.entry.points=Entry points:
label.forbid.api.usages=Forbid usages of API newer than
label.forbid.api.usages.project=(according to project settings)
label.from.inclusive=&From (inclusive):
label.implementation=Implementation:
label.implements.method.of_class_or_interface.name=implements method of {0, choice, 0#interface|1#class} ''{1}''.
label.implements.method.of_interfaces=implements methods of the following classes/interfaces:
label.maximal.reported.method.visibility=Maximal method visibility:
label.method=Method ''{0}''
label.ignore.complicated.fix=Ignore when a quick-fix cannot be provided
label.minimal.reported.method.usage.count=Minimal method usage count to report parameter:
label.mutates=&Mutates:
label.name.prefix=Name prefix:
label.name.suffix=Name suffix:
label.naming.field=Field:
label.naming.local.variable=Local variable:
label.naming.parameter=Parameter:
label.naming.static.field=Static field:
label.naming.subclass=Subclass:
label.naming.test.class=Test class:
label.overrides.method.of_class_or_interface.name=overrides method of {0, choice, 0#interface|1#class} ''{1}''.
label.show.import.popup.for=Show auto-import tooltip for:
label.to.inclusive=&To (inclusive):
label.unused.declaration.reachable.from.tests.option=When entry points are in test sources, mark callees as:
line.marker.recursive.call=Recursive call
line.marker.type.external.annotations=External annotations
line.marker.type.inferred.contract.annotations=Inferred contract annotations
line.marker.type.inferred.nullability.annotations=Inferred nullability annotations
link.configurable.logger.generator.display.name = <a href='link'>Settings</a>
listbox.import.package=Package
listbox.import.static=Static
listbox.import.with.subpackages=With Subpackages
# suppress inspection "UnusedProperty"
macro.array.variable=arrayVariable()
macro.class.name=Class name
macro.classpath.entry=Entry in the classpath the element belongs to
macro.component.type.of.array=componentTypeOf(Array)
macro.descendant.classes.enum=descendantClassesEnum(String)
macro.expression.type=expressionType(Expression)
macro.file.fully.qualified.package=File fully qualified package
macro.file.package=File package
macro.guess.element.type.of.container=guessElementType(Container)
macro.iterable.component.type=iterableComponentType(ArrayOrIterable)
# suppress inspection "UnusedProperty"
macro.iterable.variable=iterableVariable()
macro.javadoc.output.directory=JavaDoc output directory
macro.project.classpath=Project's classpath
macro.variable.of.type=variableOfType(Type)
methods.to.implement.chooser.title=Select Methods to Implement
methods.to.override.chooser.title=Select Methods to Override
methods.to.override.implement.chooser.title=Select Methods to Override/Implement
methods.to.override.generate.javadoc=Generate missing JavaDoc
module.not.in.requirements=The module ''{0}'' does not have the module ''{1}'' in requirements
module.package.not.exported=The module ''{0}'' does not export the package ''{1}'' to the module ''{2}''
module.package.not.open=The module ''{0}'' does not open the package ''{1}'' to the module ''{2}''
module.type.java.description=Java modules are used for developing <b>JVM-based</b> desktop and web applications, including applications that use <b>Java EE</b> and other enterprise development frameworks.
module.type.java.name=Java Module
navigate.to.duplicate.fix=Navigate to duplicate
no.methods.overriding.0.are.found=No methods overriding {0, choice, 0#|1# ''''{1}''''|2#these classes} are found
no.patterns=No class patterns configured
node.call.hierarchy.unknown.jsp=unknown jsp
node.hierarchy.java.lang.object=All classes are derived from java.lang.Object
notification.navigation.to.overriding.classes=Navigation to overriding classes is not possible during index update
notification.navigation.to.overriding.methods=Navigation to overriding methods is not possible during index update
notification.text.full.thread.dump.was.successfully.copied.to.clipboard=Full thread dump was successfully copied to clipboard
nullable.notnull.annotations.panel.title={0} annotations:
nullable.notnull.annotations.runtime.instrumentation.tooltip=Add runtime assertions for notnull-annotated methods and parameters
nullable.notnull.configuration.dialog.title=Nullable/NotNull Configuration
nullable.notnull.annotation.used.label=Annotation used for code generation:
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Navigate to 'null' argument usages
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.preview=Shows a list of usages where 'null' is passed as an argument.
nullable.stuff.inspection.navigate.null.argument.usages.view.name=''null'' argument usages for parameter {0}
offline.inspections.jdk.not.found={0} not found
offline.inspections.library.urls.were.not.resolved=Roots {0} of the library ''{1}'' from module ''{2}'' were not resolved
offline.inspections.library.was.not.resolved=Please configure library ''{0}'' which is used in module ''{1}''
offline.inspections.no.source.roots=No source roots detected for module ''{0}''
options.java.attribute.descriptor.abstract.class=Classes and Interfaces//Abstract class
options.java.attribute.descriptor.abstract.method=Methods//Abstract method
options.java.attribute.descriptor.annotation.attribute.name=Annotations//Annotation attribute name
options.java.attribute.descriptor.annotation.name=Annotations//Annotation name
options.java.attribute.descriptor.anonymous.class=Classes and Interfaces//Anonymous class
options.java.attribute.descriptor.class=Classes and Interfaces//Class
options.java.attribute.descriptor.constructor.call=Methods//Constructor call
options.java.attribute.descriptor.constructor.declaration=Methods//Constructor declaration
options.java.attribute.descriptor.enum=Classes and Interfaces//Enum
options.java.attribute.descriptor.implicit.anonymous.parameter=Parameters//Implicit anonymous class parameter
options.java.attribute.descriptor.inherited.method=Methods//Inherited method
options.java.attribute.descriptor.instance.field=Class Fields//Instance field
options.java.attribute.descriptor.instance.final.field=Class Fields//Instance final field
options.java.attribute.descriptor.interface=Classes and Interfaces//Interface
options.java.attribute.descriptor.javadoc.comment=Comments//JavaDoc//Text
options.java.attribute.descriptor.javadoc.markup=Comments//JavaDoc//Markup
options.java.attribute.descriptor.javadoc.tag=Comments//JavaDoc//Tag
options.java.attribute.descriptor.javadoc.tag.value=Comments//JavaDoc//Tag value
options.java.attribute.descriptor.lambda.parameter=Parameters//Lambda parameter
options.java.attribute.descriptor.method.call=Methods//Method call
options.java.attribute.descriptor.method.declaration=Methods//Method declaration
options.java.attribute.descriptor.method.imported.call=Methods//Static imported method call
options.java.attribute.descriptor.reassigned.local.variable=Variables//Reassigned local variable
tooltip.reassigned.local.variable=Reassigned local variable
options.java.attribute.descriptor.reassigned.parameter=Parameters//Reassigned parameter
tooltip.reassigned.parameter=Reassigned parameter
options.java.attribute.descriptor.static.field=Class Fields//Static field
options.java.attribute.descriptor.static.final.field=Class Fields//Constant (static final field)
options.java.attribute.descriptor.static.final.imported.field=Class Fields//Constant (static final imported field)
options.java.attribute.descriptor.static.imported.field=Class Fields//Static imported field
options.java.attribute.descriptor.static.method=Methods//Static method
options.java.attribute.descriptor.type.parameter=Parameters//Type parameter
options.java.attribute.descriptor.public=Visibility//Public
options.java.attribute.descriptor.protected=Visibility//Protected
options.java.attribute.descriptor.package.private=Visibility//Package-private
options.java.attribute.descriptor.private=Visibility//Private
options.java.display.name=Java
override.implement.broken.file.template.message=Please Correct "Overridden/Implemented Method Body" Template
override.implement.broken.file.template.title=File Template Error
package.dependencies.production.node.text=Production Classes
package.dependencies.test.node.text=Test Classes
package.pattern.provider.hint.label=Use <b>*.txt</b> to match all 'txt' files in the project, <b>file:path_in_project//*</b> to match all files in a directory recursively, <b>src:foo..*</b> to match all classes in a package recursively.
packaging.jlink.artifact.name=JLink
packaging.jlink.artifact.title=Run-time image (JLink)
packaging.jlink.compression.level=Compression level
packaging.jlink.compression.zero.level=No compression
packaging.jlink.compression.first.level=String sharing
packaging.jlink.compression.second.level=Zip
packaging.jlink.verbose.tracing=Enable verbose tracing
paste.class.command.name=Paste Class ''{0}''
please.report.a.bug=Please report a bug
popup.title.choose.framework=Choose Framework
popup.title.choose.test=Choose Test
popup.title.select.a.jar.file=Select a JAR File
popup.title.select.qualified.name=Select Qualified Name
postfix.template.language.level.title=Minimum language level:
press.0.to.see.inheritors.of.1=Press {0} to see inheritors of {1}
press.0.to.see.non.imported.classes=Press {0} to see non-imported classes
pressing.0.twice.without.a.class.qualifier=Pressing {0} twice without a class qualifier would show all accessible static methods
project.problems.hint.text={0} related {0, choice, 0#problem|2#problems}
project.problems.window.title=Problems Related to {0}
project.problems.fix.text=Show related problems
project.problems.fix.description=Found problems related to ''{0}''
project.problems.title=Related problems
title.related.problems.inlay.hints=Related Problems
progress.creating.class=Creating class {0}
progress.title.check.applicability=Check applicability...
progress.title.download.library.descriptor=Download Library Descriptor
progress.title.find.references.in.implement.extends.lists=Find References in Implement/Extends Lists...
progress.title.finding.cause=Finding cause
progress.title.looking.for.libraries=Looking for Libraries
progress.title.optimize.imports=Optimize Imports...
progress.title.preprocess.usages=Preprocess Usages
progress.title.search.for.overriding.methods=Search for overriding methods...
progress.title.searching.for.sub.classes=Searching for Subclasses
prompt.choose.base.class.of.the.hierarchy=Choose Base Class of the Hierarchy to Search In
prompt.create.non.existing.package=Package {0} does not exist.\nDo you want to create it?
prompt.delete.class={0,choice,1#class|2#classes}
prompt.delete.field={0,choice,1#field|2#fields}
prompt.delete.interface={0,choice,1#interface|2#interfaces}
prompt.delete.method={0,choice,1#method|2#methods}
prompt.delete.package={0,choice,1#package|2#packages}
prompt.delete.type.parameter={0,choice,1#type parameter|2#type parameters}
#{1} presents an action verb with preposition: "to refactor" is the default value, RefactorinBundle:to.refactor
prompt.do.you.want.to.action_verb.the.method.from_class=Do you want {1} the base {0,choice,1#method|2#methods} instead?
psi.search.overriding.progress=Searching for Overriding Methods...
quickfix.add.variable.family.name=Initialize variable
quickfix.add.variable.text=Initialize variable ''{0}''
quickfix.family.avoid.mutation.using.stream.api=Avoid mutation using Stream API
quickfix.family.change.javadoc.to=Change to ...
quickfix.family.find.cause=Find cause
quickfix.family.remove.javadoc.tag=Remove tag
quickfix.family.remove.redundant.parameter=Remove redundant parameter
quickfix.family.remove.redundant.parameter.types=Remove redundant parameter types
quickfix.family.replace.cast.type=Replace cast type
quickfix.family.replace.inefficient.stream.count=Replace inefficient Stream.count()
quickfix.family.replace.optional.chain.with.if.statements=Replace Optional chain with if statements
quickfix.family.replace.stream.api.chain.with.loop=Replace Stream API chain with loop
quickfix.family.replace.with.java.stream.api.pipeline=Replace with Java Stream API pipeline
quickfix.family.replace.with.magic.constant=Replace with magic constant
quickfix.family.replace.with.method.reference=Replace with method reference
quickfix.family.replace.with.optional.of.nullable.chain=Replace with Optional.ofNullable() chain
quickfix.family.replace.with.stream.api.equivalent=Replace with Stream API equivalent
quickfix.family.simplify.foreach.lambda=Simplify forEach lambda
quickfix.family.simplify.stream.call.chain=Simplify stream call chain
quickfix.family.use.flatmap=Use 'flatMap'
quickfix.family.wrap.with.mutable.collection=Wrap with mutable collection
quickfix.name.find.jar.on.web=Find JAR on web
quickfix.text.0.may.not.work.before.jdk.11.0.2={0} (may not work before JDK 11.0.2)
quickfix.text.avoid.mutation.using.stream.api.0.operation=Avoid mutation using Stream API ''{0}()'' operation
quickfix.text.remove.javadoc.0=Remove ''@{0}'' tag
quickfix.text.remove.javadoc.0.1=Remove @{0} {1}
quickfix.text.remove.not.null.annotation=Remove not-null annotation
quickfix.text.replace.0.stream.with.1.2=Replace {0}.stream() with {1}.{2}()
quickfix.text.replace.collect.0.with.1.2=Replace ''collect({0}())'' with ''{1}''{2}
quickfix.text.replace.filter.0.is.present.with.any.match=Replace ''filter().{0}().isPresent()'' with ''anyMatch()''
quickfix.text.replace.stream.0.with.1.2=Replace ''stream().{0}()'' with ''{1}()''{2}
quickfix.text.suffix.may.change.semantics=\ (may change semantics)
quickfix.text.wrap.0.with.1=Wrap ''{0}'' with ''{1}''
quickfix.text.replace.url.with.html=Replace URL with HTML link
radio.button.subclass.of.0=Subclass of ''{0}''
radio.button.unused.declaration.unused.option=unused
radio.button.unused.declaration.used.option=used
radio.button.with.provider.method=With 'provider()' method
radio.use.fully.qualified.class.names.in.javadoc=Use fully qualified class names in JavaDoc:
radio.use.fully.qualified.class.names.in.javadoc.always=Always
radio.use.fully.qualified.class.names.in.javadoc.if.not.imported=If not already imported
radio.use.fully.qualified.class.names.in.javadoc.never=Never, use short name and add import
scheduled.thread.pool.executor.with.zero.core.threads.display.name='ScheduledThreadPoolExecutor' with zero core threads
scheduled.thread.pool.executor.with.zero.core.threads.description='ScheduledThreadPoolExecutor' should not have zero core threads
scope.hierarchy=Hierarchy of {0}
sdk.cannot.create=Cannot Create SDK
sdk.java.no.classes=Cannot find JDK classes in ''{0}''
sdk.configured.external.config.title=JDK is configured ({0})
sdk.configured=''{0}'' is set as project JDK.
section.title.inspection.suspicious.names.ignore.methods=Ignore methods:
set.language.level=Set language level
set.language.level.to.0=Set language level to {0}
settings.completion.ml.java.display.name=Java
settings.inlay.java.annotations=Annotations
settings.inlay.java.builder.like.methods=Builder-like methods
settings.inlay.java.complex.expressions.binary.functional.array.access.and.other=Complex expressions as arguments
settings.inlay.java.enum.constants=Enum constants
settings.inlay.java.external.annotations=External annotations
settings.inlay.java.inferred.annotations=Inferred annotations
settings.inlay.java.inheritors=Inheritors
settings.inlay.java.insert.annotation=Insert annotation
settings.inlay.java.implicit.types=Implicit types
settings.inlay.java.implicit.types.description=Local variables declared with the var keyword when the inferred type may not be clear from the right part of the assignment, for example, when using a factory method.
settings.inlay.java.methods.with.same.named.numbered.parameters=Methods with same-named numbered parameters
settings.inlay.java.new.expressions='New' expressions
settings.inlay.java.non.literals.in.case.of.multiple.parameters.with.the.same.type=Non-literals in case of multiple parameters with the same type
settings.inlay.java.parameters.with.names.that.are.contained.in.the.method.name=Parameters with names that are contained in the method name
settings.inlay.java.show.hints.for=Show hints for:
settings.inlay.java.show.parameter.hints.for=Show parameter hints for:
settings.inlay.java.show.parameter.hints.when.expression.type.is.clear.description=Array initializer, switch, conditional, reference, instance of, assignment, call, qualified, type cast, class object access expressions.
settings.inlay.java.turn.off.external.annotations=Turn off external annotations
settings.inlay.java.turn.off.inferred.annotations=Turn off inferred annotations
settings.inlay.java.usages=Usages
# suppress inspection "UnusedProperty"
inlay.parameters.java.method.name.contains.parameter.name=Methods that take a single argument when the expected argument is clear from the method name, like in accessor methods.
# suppress inspection "UnusedProperty"
inlay.parameters.java.multiple.params.same.type=Calls to methods with more than one non-literal argument of the same type.
# suppress inspection "UnusedProperty"
inlay.parameters.java.build.like.method=Methods that return an instance of the class they operate on, for example, calls in StringBuilder chains or intermediate operations in Java 8 Stream API.
# suppress inspection "UnusedProperty"
inlay.parameters.java.simple.sequentially.numbered=Methods that take multiple parameters, whose names consist of one letter followed by a number.
# suppress inspection "UnusedProperty"
inlay.parameters.java.enums=Enum constant declarations that use a parametrized constructor.
# suppress inspection "UnusedProperty"
inlay.parameters.java.new.expr=Calls to parametrized constructors.
# suppress inspection "UnusedProperty"
inlay.parameters.java.clear.expression.type=Method calls that use a complex expression as an argument, for example, the ternary operator or a Java 13 switch statement.
inlay.MethodChainsInlayProvider.description=Method return types in call chains.
inlay.annotation.hints.inferred.annotations=Annotations that IntelliJ IDEA generates by scanning libraries and project code. These annotations help you understand code contracts and improve the capabilities of static analysis. They include: <br> @Contract <br> @Nullable <br> @NotNull <br> @Unmodifiable <br>@UnmodifiableView <br><br><a href='https://www.jetbrains.com/help/idea/inferring-nullity.html#inferred-annotations'>Documentation</a>
inlay.annotation.hints.external.annotations=Annotations that are stored outside your source code.<br>These annotations are useful when you need an annotation, but adding it to the source code is not an option (for example, when working with a library code).<br><br><a href='https://www.jetbrains.com/help/idea/external-annotations.html'>Documentation</a>
show.import.popup.for.classes=&Classes
show.import.popup.for.static.methods.and.fields=&Static methods and fields
exclude.import.wildcard.comment=Use the * wildcard to exclude all members of a specified class or package
special.annotations.annotations.preview=Adds ''@{0}'' to a list of annotations that will be ignored by this inspection
special.annotations.annotations.list=Additional special annotations:
special.annotations.list.add.annotation.class=Add Annotation Class
special.annotations.list.annotation.class=Annotation Class
special.annotations.list.annotation.pattern.message=Add annotations pattern
special.annotations.list.annotation.pattern=Add Annotations Pattern
special.annotations.list.remove.pattern=Remove
spi.extension.error.message=Registered extension should implement {0}
filetype.spi.description=Service Provider Interface
spi.no.provider.error.message=No service provider "{0}" found
status.bar.overridden.methods.highlighted.message={0} overridden {0, choice, 1#method|2#methods} found (press {1} again to remove the highlighting, Escape to remove all highlighting)
surround.with.dowhile.template=do / while
surround.with.for.template=for
surround.with.ifelse.expression.template=if (expr) {...} else {...}
surround.with.not.instanceof.template=!(expr instanceof Type)
surround.with.runnable.template=Runnable
surround.with.synchronized.template=synchronized
surround.with.try.catch.finally.template=try / catch / finally
surround.with.try.catch.incorrect.template.message=Invalid file template for catch body
surround.with.try.catch.template=try / catch
surround.with.cast=Surround With Cast
tab.title.entry.points=Entry points
tab.title.members.to.report=Members to report
table.cell.constructors=constructors
title.cannot.create.class=Cannot Create Class
title.import.layout=Import Layout
title.javadoc=JavaDoc
title.naming=Naming
title.naming.final.modifier=Variable declaration
title.naming.variable=Variable
title.naming.functional.expressions=Lambda Body
title.package.not.found=Package Not Found
title.packages=Packages
title.packages.to.use.import.with=Packages to Use Import with '*'
to.import.a.method.statically.press.0=To import a method statically, press {0}
unscramble.detect.analyze.threaddump.from.clipboard.item=Automatically detect and analyze thread dumps copied to the clipboard outside of IntelliJ IDEA
unscramble.log.path.label=&Log file:
unscramble.no.unscrambler.item=<No unscrambler installed>
unscramble.normalize.button=&Normalize
unscramble.stacktrace.caption=Put a stack trace or a complete thread dump here:
unscramble.unscrambled.deadlock.tab=<Deadlock>
unscramble.unscrambled.stacktrace.tab=<Stacktrace>
unscramble.unscrambled.threaddump.tab=<Threads>
unscramble.unscrambler.combobox=Un&scrambler:
unscramble.use.unscrambler.checkbox=&Unscramble stack trace
new.line.when.body.is.presented=New line when body is presented
unwrap.anonymous=Unwrap 'anonymous...'
unwrap.array.initializer=Unwrap array initializer
unwrap.conditional=Unwrap 'f ? a : b'
unwrap.lambda=Unwrap 'lambda...'
unwrap.synchronized=Unwrap 'synchronized...'
unwrap.switch.expression=Unwrap 'switch' expression
unwrap.switch.statement=Unwrap 'switch' statement
usage.target.exception=Exception
usage.target.package.in.directory={0} (in {1})
use.external.annotations=Use &external annotations
generate.type.use.before.type=Put generated annotations with target TYPE_USE between the modifiers and the type
generate.type.use.before.type.description=<html>Annotations with target TYPE_USE will be placed after any modifiers and directly<br>before the type. When disabled, they will be placed before any modifiers.</html>
wrapping.annotation.enums=Enum field annotations
wrapping.annotation.parameters=Annotation parameters
wrapping.record.components=Record components
wrapping.multi.catch.types=Types in multi-catch
wrapping.deconstruction.patterns=Deconstruction patterns
align.types.in.multi.catch=Align types in multi-catch
wrapping.text.blocks=Text blocks
wrapping.switch.statement.or.expression='switch' statement/expression
wrapping.semicolon.after.call.chain=Move ';' to the new line
wrong.package.statement=Wrong package statement
title.code.vision=Code vision
title.code.vision.inlay.hints=Code Vision
highlight.throws.popup.throwing.places=Places throwing {0}
highlight.throws.popup.usages=Usages of {0}
psi.error.incorrect.class.template.message=Cannot create {0} - incorrect {1} template.
presentable.text.anonymous.class=Anonymous class
presentable.text.code.from.context=Code from {0}
presentable.text.code.display=Code
presentable.text.invalid.element.name=INVALID
inspection.simplify.for.each.extract.intermediate.operations=Extract intermediate operations
inspection.message.can.be.replaced.with.files.writestring=Can be replaced with 'Files.writeString()'
inspection.notnull.field.not.initialized.message={0} fields must be initialized
highlight.throws.class.name=Highlight Throws {0}
class.patterns.panel.add.class=Add Class
multiple.usages.of.static.import.found=Multiple Usages of the Static Import Found
external.annotations.roots=Annotation Roots
inspection.stream.api.migration.can.be.replaced.with.call=Can be replaced with ''{0}'' call
highlight.suppressed.warnings.choose.inspections=Choose Inspections to Highlight Suppressed Problems from
inspection.magic.constants.should.be.one.of.values=Should be one of: {0}{1,choice,0#|1# or their combination}
live.template.context.consumer.function=Consumer function
live.template.context.statement=Statement
live.template.context.else='else' position
live.template.context.expression=Expression
live.template.context.declaration=Declaration
inspection.unused.display.name=Unused declaration
inspection.unused.assignment.display.name=Unused assignment
inspection.unchecked.warning.display.name=Unchecked warning
inspection.convert.2.streamapi.display.name=Loop can be collapsed with Stream API
inspection.optional.to.if.display.name='Optional' can be replaced with sequence of 'if' statements
inspection.stream.to.loop.display.name=Stream API call chain can be replaced with loop
inspection.anonymous.2.method.ref.display.name=Anonymous type can be replaced with method reference
inspection.convert.2.method.ref.display.name=Lambda can be replaced with method reference
inspection.lambda.can.be.method.call.display.name=Lambda can be replaced with method call
inspection.functional.expression.can.be.folded.display.name=Functional expression can be folded
inspection.trivial.functional.expression.usage.display.name=Trivial usage of functional expression
inspection.magic.constant.display.name=Magic constant
inspection.static.pseudo.functional.style.method.display.name=Guava pseudo-functional call can be converted to Stream API call
inspection.overwritten.key.display.name=Overwritten Map, Set, or array element
inspection.collection.add.all.can.be.replaced.with.constructor.display.name=Redundant 'Collection.addAll()' call
inspection.manual.min.max.calculation.display.name=Manual min/max calculation
inspection.explicit.array.filling.display.name=Explicit array filling
inspection.java.8.collection.remove.if.display.name=Loop can be replaced with 'Collection.removeIf()'
inspection.java.8.list.replace.all.display.name=Loop can be replaced with 'List.replaceAll()'
inspection.java.8.map.api.display.name=Simplifiable 'Map' operations
inspection.string.repeat.can.be.used.display.name=String.repeat() can be used
inspection.read.write.string.can.be.used.display.name='Files.readString()' or 'Files.writeString()' can be used
inspection.java.9.collection.factory.display.name=Immutable collection creation can be replaced with collection factory call
inspection.explicit.argument.can.be.lambda.display.name=Explicit argument can be lambda
inspection.excessive.lambda.usage.display.name=Excessive lambda usage
inspection.redundant.stream.optional.call.display.name=Redundant step in 'Stream' or 'Optional' call chain
inspection.obvious.null.check.display.name=Null-check method is called with obviously non-null argument
inspection.simplify.stream.api.call.chains.display.name=Stream API call chain can be simplified
inspection.simplify.optional.call.chains.display.name=Optional call chain can be simplified
inspection.simplify.collector.display.name=Simplifiable collector
inspection.use.bulk.operation.display.name=Bulk operation can be used instead of iteration
inspection.comparator.combinators.display.name='Comparator' combinator can be used
inspection.replace.inefficient.stream.count.display.name=Inefficient Stream API call chains ending with count()
inspection.redundant.lambda.parameter.type.display.name=Redundant lambda parameter types
inspection.wrapper.type.may.be.primitive.display.name=Wrapper type may be primitive
inspection.optional.get.without.is.present.display.name=Optional.get() is called without isPresent() check
inspection.optional.is.present.display.name=Non functional style 'Optional.isPresent()' usage
inspection.conditional.can.be.optional.display.name=Conditional can be replaced with Optional
inspection.optional.assigned.to.null.display.name=Null value for Optional type
inspection.excessive.range.check.display.name=Excessive range check
inspection.condition.covered.by.further.condition.display.name=Condition is covered by further condition
inspection.move.field.assignment.to.initializer.display.name=Field assignment can be moved to initializer
inspection.frequently.used.inheritor.inspection.display.name=Class may extend a commonly used base class
inspection.slow.abstract.set.remove.all.description=Call to 'set.removeAll(list)' may work slowly
inspection.slow.abstract.set.remove.all.fix.family.name=Use 'Set.remove' instead of 'Set.removeAll'
inspection.slow.list.contains.all.description=Call to 'list.containsAll(collection)' may have poor performance
inspection.slow.list.contains.all.fix.family.name=Wrap in 'HashSet' constructor
inspection.slow.list.contains.all.fix.name=Wrap ''{0}'' in ''HashSet'' constructor
slice.filter.parse.error.null.filter.not.applicable.for.primitive.type=''null'' filter is not applicable for primitive type {0}
slice.filter.parse.error.not.null.filter.not.applicable.for.primitive.type=''!null'' filter is not applicable for primitive type {0}
slice.filter.parse.error.enum.constant.not.found=Enum constant not found: {0}
slice.filter.parse.error.incorrect.expression=Incorrect expression: {0}
slice.filter.parse.error.incorrect.constant.type=Incorrect constant type (required: {0})
slice.filter.parse.error.expression.must.evaluate.to.constant=Expression must evaluate to a constant: {0}
slice.filter.parse.error.incorrect.constant.expected.number=Incorrect constant (expected number): {0}
action.find.similar.stack.call.diverged=Line numbers are likely diverged. Try to find the current location inside ''{0}.{1}()''
action.find.similar.stack.call.methods=Similar Methods to ''{0}.{1}()''
action.find.similar.stack.call.similar.calls=Possible Locations Inside ''{0}.{1}()''
action.find.similar.stack.call.methods.not.found=No similar methods to ''{0}.{1}()''
action.find.similar.stack.call.location.not.found=No similar location inside ''{0}.{1}()''
action.dfa.from.stacktrace.text=Find why ''{0}'' could be {1}
slice.usage.message.assertion.violated=(assertion violated!)
slice.usage.message.in.file.stopped.here=(in {0} file - stopped here)
slice.usage.message.tracking.container.contents=(Tracking container ''{0}{1}'' contents)
slice.usage.message.location=in {0}
intention.name.move.into.if.branches=Move up into 'if' statement branches
intention.name.collapse.into.loop=Collapse into loop
intention.family.name.make.sealed=Seal class
intention.error.make.sealed.class.is.used.in.functional.expression=Class is used in functional expression
intention.error.make.sealed.class.has.anonymous.or.local.inheritors=Some of the inheritors are anonymous or local
intention.error.make.sealed.class.different.packages=Module is unnamed and some of the inheritors are in the different package
intention.error.make.sealed.class.inheritors.not.in.java.file=Some of the inheritors are not in java files
intention.error.make.sealed.class.different.modules=Some of the inheritors are in different modules
intention.error.make.sealed.class.interface.has.no.inheritors=Interface has no inheritors
inspection.fill.permits.list.no.missing.inheritors=Sealed class has no missing inheritors
inspection.fill.permits.list.display.name=Same file subclasses are missing from permits clause of a sealed class
inspection.fill.permits.list.fix.name=Add missing subclasses to the permits clause
update.external.annotations=Update External Annotations
intention.create.switch.statement=Create switch statement
sort.threads.by.type=Sort Threads by Type
sort.threads.by.name=Sort Threads by Name
inspection.message.pattern.variables.can.be.replaced.with.cast.preserve.option=Try to preserve unused variables from patterns during quickfix
inspection.message.pattern.variables.can.be.replaced.with.cast=Using 'instanceof' with patterns
inspection.message.pattern.variables.can.be.replaced.with.cast.family.name=Replace without patterns
inspection.message.pattern.variables.can.be.replaced.with.cast.fix.name=Replace ''{0}'' with casts
inspection.message.record.can.be.converted.to.class=Record can be converted to class
intention.family.name.convert.record.to.class=Convert record to class
class.can.be.record.display.name=Class can be record class
class.can.be.record.quick.fix=Convert to record class
class.can.be.record.suggest.renaming.accessors=Suggest renaming accessor methods
class.can.be.record.conversion.make.member.more.accessible=If members become more accessible:
class.can.be.record.conversion.strategy.do.not.convert=Do not suggest conversion
class.can.be.record.conversion.strategy.show.members=Show conflicts view
class.can.be.record.conversion.strategy.convert.silently=Convert silently
class.can.be.record.suppress.conversion.if.annotated=Suppress conversion if class is annotated by:
class.can.be.record.suppress.conversion.if.annotated.fix.name=Suppress record conversion if annotated by ''{0}''
extracted.class.should.have.unique.name=Extracted class should have unique name. Name ''{0}'' is already in use by one of the inner classes
invalid.extracted.class.name=''{0}'' is invalid extracted class name
caller.chooser.referenced.code.title=Referenced Code
dialog.title.choose.annotation=Choose {0} Annotation
unchecked.warning.inspection.settings.ignore.unchecked.assignment=Ignore unchecked assignment
unchecked.warning.inspection.settings.ignore.unchecked.generics.array.creation.for.vararg.parameter=Ignore unchecked generics array creation for vararg parameter
unchecked.warning.inspection.settings.ignore.unchecked.call.as.member.of.raw.type=Ignore unchecked call as member of raw type
unchecked.warning.inspection.settings.ignore.unchecked.cast=Ignore unchecked cast
unchecked.warning.inspection.settings.ignore.unchecked.overriding=Ignore unchecked overriding
unchecked.warning.inspection.reason.expr.has.raw.type.so.result.erased=. Reason: ''{0}'' has raw type, so result of {1} is erased
unchecked.warning.inspection.message.unchecked.generics.array.creation.for.varargs.parameter=Unchecked generics array creation for varargs parameter
type.migration.dialog.message.invalid.type=''{0}'' is not a valid type
type.migration.dialog.message.void.not.applicable=Only method return types can be migrated to 'void'
type.migration.dialog.message.vararg.type.not.applicable=Only the last parameter of a method can be migrated to a vararg type
type.migration.dialog.message.disjunction.type.not.applicable=Only a catch block parameter can be migrated to a union type
stream.to.loop.inspection.message.replace.stream.api.chain.with.loop=Replace Stream API chain with loop
stream.to.loop.inspection.message.replace.foreach.call.with.loop=Replace 'forEach()' call with loop
todo.index.not.available=N/A
simplify.stream.inspection.message.can.be.replaced=''{0}'' can be replaced with ''{1}''
simplify.stream.inspection.message.can.be.replaced.may.change.semantics=''{0}'' can be replaced with ''{1}'' (may change semantics)
inspection.message.filter.is.present.chain.can.be.replaced.with.anymatch=The ''filter().{0}().isPresent()'' chain can be replaced with ''anyMatch()''
simplify.stream.match.negation.fix.name=Replace {0} with {1}(...)
simplify.stream.collection.creation.fix.name=Replace with ''{0}'' constructor
simplify.stream.simple.stream.of.fix.name.use.stream.element.explicitly=Use Stream element explicitly
simplify.stream.simple.stream.of.message=Unnecessary single-element Stream
simplify.stream.replace.with.element.iteration.fix.message=Can be replaced with element iteration
simplify.stream.remove.boolean.identity.fix.name=Merge with previous 'map()' call
simplify.stream.remove.boolean.identity.fix.message=Can be merged with previous 'map()' call
simplify.stream.replace.support.with.collection.fix.name=Replace with ''{0}.{1}()'' call
simplify.stream.replace.support.with.collection.fix.message=Can be replaced with ''{0}.{1}()'' call
simplify.stream.swap.filter.and.map.fix.name=Swap 'filter()' and 'map()'
simplify.stream.swap.filter.and.map.fix.message='filter()' and 'map()' can be swapped
simplify.stream.inspection.iterate.take.while.fix.name=Replace with three-arg 'iterate()'
simplify.stream.inspection.iterate.take.while.fix.message=Can be replaced with three-arg 'iterate()'
side.effects.pattern.message=<html>\n<body>\nThere are possible side effects found in {0}<br>\nYou can:\n<br>\n-\\&nbsp;<b>Remove</b> variable usages along with all expressions involved, or<br>\n-\\&nbsp;<b>Transform</b> expressions assigned to variable into the statements on their own.<br>\n<div style="padding-left: 0.6cm;">\n  That is,<br>\n  <table border="0">\n    <tr>\n      <td><code>{1};</code></td>\n    </tr>\n  </table>\n  becomes: <br>\n  <table border="0">\n    <tr>\n      <td><code>{2};</code></td>\n    </tr>\n  </table>\n</div>\n</body>\n</html>
side.effects.expression.presentation=expression ''{0}''
change.signature.from.usage.short.name=<html> Change signature of {0}({1})</html>
default.param.value.warning={0, choice, 0#Constructor|1#Method} with the chosen signature already exists
qualify.static.constant.access=Qualify static constant access
qualify.static.access.command.name=Qualify Static Access
qualify.static.call.fix.text=Qualify static call
pull.members.up.fix.name=Pull members up
extract.superclass.command.name=Extract superclass
extract.interface.command.name=Extract interface
choose.super.class.popup.title=Choose super class
intention.name.pull.method.up.and.make.it.abstract.conditionally=Pull method ''{0}'' to ''{1}''{2, choice, 0# and make it abstract|1#}
intention.name.extract.method.to.new.interface=Extract method ''{0}'' to new interface
intention.name.pull.method.up.make.it.abstract=Pull method ''{0}'' up and make it abstract
intention.name.pull.method.up=Pull method ''{0}'' up
intention.name.copy.to.final.temp.variable=Copy ''{0}'' to {1, choice, 0#|1#effectively }final temp variable
intention.name.make.variable.final=Make {1, choice, 0#''''{0}''''|1#variables} final
intention.name.transform.variables.into.final.one.element.array=Transform {1, choice, 0#''''{0}''''|1#variables} into final one element array
type.information.value=Value
type.information.not.equal.to=Not equal to
type.information.range=Range
type.information.nullability=Nullability
type.information.constraints=Constraints
type.information.mutability=Mutability
type.information.locality=Locality
type.information.local.object=local object
type.information.type=Type
simplify.optional.chain.inspection.remove.redundant.steps.from.optional.chain=Remove redundant steps from optional chain
simplify.optional.chain.inspection.to.x=Simplify optional chain to ''{0}''
simplify.optional.chain.inspection.map.or.else.description=Optional chain can be simplified
simplify.optional.chain.inspection.optional.rewrapping.name=Unwrap
simplify.optional.chain.inspection.optional.rewrapping.description=Unnecessary Optional rewrapping
simplify.optional.chain.inspection.or.else.return.fix.name=Replace null check with {0}({1})
simplify.optional.chain.inspection.or.else.return.fix.description=Null check can be eliminated
simplify.optional.chain.inspection.or.else.non.null.fix.name=Replace null check with ifPresent()
simplify.optional.chain.inspection.or.else.non.null.fix.description=Null check can be eliminated with 'ifPresent'
simplify.optional.chain.inspection.fix.name.remove.redundant.optional.chain=Remove redundant Optional chain
simplify.optional.chain.inspection.fix.description.optional.chain.can.be.eliminated=Optional chain can be eliminated
simplify.optional.chain.inspection.fix.description.replace.with.value.of.name=Replace with 'String.valueOf()'
simplify.optional.chain.inspection.fix.description.replace.with.value.of.description=Optional chain can be replaced with 'String.valueOf()'
generate.test.support.method.error.no.template.found.for.framework=No template found for {0}:{1}
generate.test.support.method.error.method.already.exists=Method {0} already exists
generate.test.support.method.error.cannot.generate.method=Cannot generate method: {0}
base.package.project.wizard.error.x.not.valid.package={0} is not a valid package name
class.patterns.separator.mark.code.as.entry.point.if.qualified.name.matches=Mark Code as Entry Point if Qualified Name Matches
class.patterns.error.method.pattern.0.must.be.a.valid.java.identifier=Method pattern ''{0}'' must be a valid java identifier, only ''*'' are accepted as placeholders
class.patterns.error.class.pattern.0.must.be.a.valid.java.qualifier=Pattern must be a valid java qualified name, only '*' are accepted as placeholders
code.style.generation.settings.error.not.valid.identifier.part.in.prefix=Not a valid java identifier part in prefix ''{0}''
code.style.generation.settings.error.not.valid.identifier.part.in.suffix=Not a valid java identifier part in suffix ''{0}''
hide.out.of.cyclic.packages.action.text=Hide Packages Without Cyclic Dependencies
hide.out.of.cyclic.packages.action.description=Hide packages without cyclic dependencies
generate.missed.tests.action.error.no.tests.found=No tests found.
generate.missed.tests.action.failed.to.detect.framework=Failed to detect test framework for {0}
pull.up.accessible.conflict={0} won''t be accessible
pull.up.accessible.conflict.1={0} won''t be accessible from {1}
pull.up.concrete.inherit.abstract.method.conflict=Concrete {0} will inherit a new abstract method
pull.up.members.usage.view.description.code.references.node=Class to pull up members to "{0}"
pull.up.members.usage.view.description.processed.elements.node=Pull up members from class {0}
refactoring.method.reference.to.lambda.conflict=Method reference will be converted to lambda
introduce.variable.change.semantics.warning=Extracting selected expression would change the semantic of the whole expression.
introduce.variable.change.type.adv=Press {0} to change type
introduce.variable.reassign.adv=Press {0} to reassign existing variable
introduce.functional.variable.accessibility.conflict=Variable {0} is not effectively final and won''t be accessible inside functional expression
introduce.functional.variable.interface.chooser.title=Choose Applicable Functional Interface: {0} -> {1}
introduce.functional.variable.nothing.found.message=No applicable functional interfaces found
introduce.parameter.object.no.accessor.conflict.message={0, choice, 0#Getter|1#Setter} for field ''{1}'' is required
push.down.anonymous.conflict=Unable to push implements to anonymous class
push.down.static.nonstatic.conflict=Static {0} can''t be pushed to non-static {1}
push.down.missed.implementation.conflict=Non abstract {0} will miss implementation of {1}
push.down.super.method.call.changed.conflict=Super method call will resolve to another method
move.classes.invalid.destination.package.name.message=''{0}'' is invalid destination package name
move.classes.destination.class.not.found.message=Destination class not found
move.class.import.from.default.package.conflict={0} won''t be accessible from the default package
destination.combo.test.root.not.expected.conflict=Test root is selected while the source root is expected
destination.combo.source.root.not.expected.conflict=Source root is selected while the test root is expected
leave.in.same.source.root.item=Leave in same source root
move.inner.select.target.package.title=Select Target Package
move.member.enum.conflict=Enum type won't be applicable in the current context
move.member.final.initializer.conflict=The initializer of final {0} will be left behind.
rename.package.invalid.name.error=Not a valid package name
rename.package.ignored.name.warning=Trying to create a package with ignored name, result will not be visible
rename.package.class.already.exist.conflict=Class with qualified name ''{0}''  already exist
rename.package.command.name=Rename package
class.filter.editor.table.model.column.name.pattern=Pattern
class.filter.editor.table.model.column.name.isActive=Is Active
create.class.mapping.dialog.title=Choose {0} Class
import.layout.panel.up.button=Up
import.layout.panel.down.button=Down
import.layout.panel.blank.line.entry=<blank line>
import.layout.panel.all.other.imports=all other imports
edit.contract.dialog.hint=<html>Please specify the contract text<p>Example: <code>_, null -> false</code><br><small>See intention action description for more details</small></html>
edit.contract.dialog.mutates.hint=Specify comma-separated elements that can be mutated<p>Example: <code>this,param1</code><p>Leave empty for unspecified side effects.
edit.range.dialog.message=Leave empty if unrestricted
edit.range.error.invalid.value=Invalid value
edit.range.value.should.be.less.than=Should not be less than {0}
edit.range.value.should.be.bigger.than=Should not be bigger than {0}
edit.range.should.not.be.greater.than.to=Should not be greater than 'to'
edit.range.should.not.be.less.than.from=Should not be less than 'from'
generate.constructor.already.exists=Constructor already exists
generate.equals.no.fields.for.generation=No fields to include in equals/hashCode have been found
generate.getter.and.setter.error.setters.for.read.only.not.generated=Setters for read-only fields were not generated
generate.getter.and.setter.error.no.fields=No fields have been found to generate getters/setters for
generate.getter.and.setter.error.no.fields.without.getters.and.setters=No fields without getter/setter were found
generate.getter.error.no.fields=No fields have been found to generate getters for
generate.getter.error.no.fields.without.getters=No fields without getter were found
generate.getter.setter.header.visibility.hint.=Visibility is applied according to File | Settings | Editor | Code Style | Java | Code Generation
generate.members.nothing.to.insert=Nothing found to insert
generate.setters.no.fields=No fields have been found to generate setters for
generate.setters.no.fields.without.setters=No fields without setter were found
implement.abstract.method.potential.implementations.with.weaker.access=Potential implementations with weaker access privileges are found: {0}
implement.method.no.methods.to.implement=No methods to implement have been found
action.sort.by.percent.classes.which.overrides.method.text=Sort by Percentage of Subclasses That Override the Method
action.sort.by.percent.classes.which.overrides.method.description=Sort by percentage of subclasses that override the method
override.methods.error.no.methods=No methods to override have been found
base.package.parameter.wizard.label=Base &package:
type.migration.multi.root.toolwindow.title=Migrate Type of {0}
type.migration.single.root.toolwindow.title=Migrate Type of {0} from ''{1}'' to ''{2}''
type.migration.processed.elements.header=Root for type migration
type.migration.cannot.convert.message=Cannot convert type of expression <b>{0}</b>{3, choice, 0#|1# from '<'b'>'{1}'<'/b'>'} to <b>{2}</b>
type.migration.cannot.convert.vararg.message=Cannot convert call <b>{0}</b> from vararg to non-vararg
type.migration.replaced.notification=Replaced with {0}
type.migration.cannot.convert.tooltip=Cannot convert type of expression from {0} to {1}
type.migration.cannot.convert.vararg.tooltip=Cannot convert call from vararg to non-vararg
type.migration.getter.rename.suggestion.text=Rename getter from ''{0}'' to ''{1}'' since the return type is migrated to ''{2}''?
type.migration.getter.rename.suggestion.never.migrate.method.names=Never Migrate Method Names
type.migration.getter.rename.suggestion.always.migrate.method.names=Always Migrate Method Names
hint.text.press.to.go.through.inlined.occurrences=Press {0} to go through {1} inlined occurrences
hint.text.occurrences.were.inlined={0} occurrences were inlined
action.expand.static.import.text=Expand Static Import
class.cannot.be.inlined.because.a.call.to.its.constructor.is.unresolved=Class cannot be inlined because a call to its constructor is unresolved
class.cannot.be.inlined.because.it.is.used.as.a.this.qualifier=Class cannot be inlined because it is used as a 'this' qualifier
class.cannot.be.inlined.because.it.is.used.in.a.throws.clause=Class cannot be inlined because it is used in a 'throws' clause
class.cannot.be.inlined.because.it.is.used.in.a.catch.clause=Class cannot be inlined because it is used in a 'catch' clause
class.cannot.be.inlined.because.it.has.usages.of.its.class.literal=Class cannot be inlined because it has usages of its class literal
class.cannot.be.inlined.because.it.has.static.initializers=Class cannot be inlined because it has static initializers
class.cannot.be.inlined.because.it.has.usages.of.fields.not.inherited.from.its.superclass=Class cannot be inlined because it has usages of fields not inherited from its superclass
class.cannot.be.inlined.because.it.has.static.fields.with.non.constant.initializers=Class cannot be inlined because it has static fields with non-constant initializers
class.cannot.be.inlined.because.it.has.static.non.final.fields=Class cannot be inlined because it has static non-final fields
class.cannot.be.inlined.because.it.has.usages.of.its.inner.classes=Class cannot be inlined because it has usages of its inner classes
class.cannot.be.inlined.because.it.has.static.inner.classes=Class cannot be inlined because it has static inner classes
class.cannot.be.inlined.because.it.has.static.methods=Class cannot be inlined because it has static methods
class.cannot.be.inlined.because.there.are.usages.of.its.methods.not.inherited.from.its.superclass.or.interface=Class cannot be inlined because there are usages of its methods not inherited from its superclass or interface
class.cannot.be.inlined.because.its.constructor.contains.return.statements=Class cannot be inlined because its constructor contains 'return' statements
class.cannot.be.inlined.because.an.interface.implemented.by.it.cannot.be.resolved=Class cannot be inlined because an interface implemented by it cannot be resolved
class.cannot.be.inlined.because.its.superclass.cannot.be.resolved=Class cannot be inlined because its superclass cannot be resolved
library.classes.cannot.be.inlined=Library classes cannot be inlined
enums.cannot.be.inlined=Enums cannot be inlined
interfaces.cannot.be.inlined=Interfaces cannot be inlined
annotation.types.cannot.be.inlined=Annotation types cannot be inlined
type.parameters.cannot.be.inlined=Type parameters cannot be inlined
postfix.template.editor.choose.class.title=Choose Class
null.check.surrounder.description=if (expr != null) {...}
push.method.down.command.name=Push method down...
replace.implements.with.static.import.field.usages.progress=Find Constant Field Usages...
show.siblings.choose.super.class.title=Choose super class or interface
show.siblings.find.usages.method.title=Super methods
show.siblings.find.usages.class.title=Super classes/interfaces
switch.stmt.template.description=switch (expr) {...}
wrap.return.value.created.class.not.accessible.conflict=Created class won't be accessible in the call place
wrap.return.value.existing.class.does.not.have.getter.conflict=Existing class does not have getter for selected field
wrap.return.value.existing.class.does.not.have.appropriate.constructor.conflict=Existing class does not have appropriate constructor
wrap.return.value.anonymous.class.presentation=Anonymous {0}
empty.title=Empty
separator.annotations.to.copy=Annotations to Copy
action.go.to.functional.implementation.text=Find Functional Interface Implementations
action.go.to.implementation.text=Go to Implementation(s)
action.go.to.subclass.text=Go to Subclass(es)
action.go.to.overriding.methods.text=Go to Overriding Methods
action.go.to.super.method.text=Go to Super Method
tooltip.recursive.call=Recursive call
label.compact.constructor=Compact constructor
label.canonical.constructor=Canonical constructor
edit.contract.dialog.checkbox.impure.method=Method may produce &side effects
separator.mark.as.entry.point.if.annotated.by=Mark as entry point if annotated by:
separator.mark.field.as.implicitly.written.if.annotated.by=Mark field as implicitly written if annotated by:
rename.super.methods.chooser.popup.title={0} has super methods
rename.super.base.chooser.popup.title={0}{1, choice, 0# implements|1# overrides} method of {2}
add.methods.dialog.or=\ or
command.name.delegate.detected.change=Delegate
encapsulate.fields.dialog.javadoc.title=Javadoc
find.jar.hint.text.no.libraries.found.for.fqn=No libraries found for ''{0}''
dependant.sdk.unsatisfied.dependency.message=You need to configure a Java SDK first
javadoc.gen.error.modules.without.module.info=IDEA cannot generate Javadoc as modules {0} do not contain module-info.java file
javadoc.gen.error.module.source.path.is.not.evaluated=IDEA cannot generate Javadoc as module-source-path cannot be evaluated
generate.members.implement.command=implement
code.style.settings.angle.spacing.brackets=Angle brackets
code.style.settings.spacing.after.closing.angle.bracket=After closing angle bracket
code.style.settings.spacing.around.type.bounds=Around type bounds
non.code.annotations.explanation.external.and.inferred.available=External and <i>inferred</i> annotations available.
non.code.annotations.explanation.external.available=External annotations available.
non.code.annotations.explanation.inferred.available=<i>Inferred</i> annotations available.
non.code.annotations.explanation.full.signature=Full signature:
type.migration.command.name=TypeMigration
dfa.constraint.not.null=not-null
dfa.constraint.0.not.null={0} (not-null)
dfa.constraint.null.or.0=null or {0}
label.class.pattern.syntax.explanation=Leave the method blank to represent constructors\nAny * will match against one or more characters in the qualified name (including dots)
dialog.message.modules.dont.refer.to.existing.annotations.library={0, choice, 0#Module|2#Modules} {1} {0, choice, 0#doesn''t|2#don''t} refer to the existing ''{2}'' library with IntelliJ IDEA nullity annotations. Would you like to add the {0, choice, 0#dependency|2#dependencies} now?
tab.title.slices.grouped.by.nullness=\ (Grouped by Nullness)
exclude.0.from.auto.import=Exclude ''{0}'' from auto-import
column.name.method.entry.point=Method
column.name.class.entry.point=Class
column.name.with.subclasses.entry.point=With Subclasses
code.vision.implementations.hint={0, choice, 1#1 implementation|2#{0,number} implementations}
code.vision.inheritors.hint={0, choice, 1#1 inheritor|2#{0,number} inheritors}
code.vision.overrides.hint={0, choice, 1#1 override|2#{0,number} overrides}
hint.text.tostring.method.could.not.be.created.from.template=''toString()'' method could not be created from template ''{0}''
hint.text.tostring.template.invalid=toString() template ''{0}'' is invalid
command.name.generate.tostring=Generate toString()
hint.text.removed.imports=Removed {0} {1, choice, 0#import|1#imports}
hint.text.added.imports=, added {0} {1, choice, 0#import|1#imports}
hint.text.rearranged.imports=Rearranged imports
enum.constant.ordinal=Enum constant ordinal: 
tab.title.infer.nullity.preview=Infer Nullity Preview
inspection.message.full.description=Full description
popup.title.debug.recent.tests=Debug Recent Tests
list.item.suite=[suite] {0}
list.item.configuration=[configuration] {0}
no.jre.description=<no JRE>
popup.content.tests.were.not.found.in.module=Tests were not found in module ''{0}''.\n
popup.content.tests.were.not.found.in.module.use.instead=Use {0, choice, 0#module {1} |1#one of\n{2}\n}instead
popup.content.tests.were.not.found.in.module.search.in.dependencies=Search across module dependencies instead
postfix.template.provider.name=Java
postfix.template.condition.void.name=void
postfix.template.condition.non.void.name=non void
postfix.template.condition.boolean.name=boolean
postfix.template.condition.number.name=number
postfix.template.condition.not.primitive.type.name=not primitive type
postfix.template.condition.array.name=array
inspection.redundant.unmodifiable.call.display.name=Redundant usage of the ''{0}'' wrapper
inspection.redundant.unmodifiable.call.description=Redundant usage of unmodifiable collection wrappers
inspection.redundant.unmodifiable.call.unwrap.argument.quickfix=Unwrap argument
completion.override.implement.methods=Override/Implement methods...
lambda.tree.node.presentation=Lambda
inspection.meaningless.record.annotation.description=Meaningless record annotation
inspection.meaningless.record.annotation.message.method.and.parameter=Annotation has no effect: its targets are METHOD and PARAMETER but both accessor and canonical constructor are explicitly declared
inspection.meaningless.record.annotation.message.method=Annotation has no effect: its target is METHOD but the corresponding accessor is explicitly declared
inspection.meaningless.record.annotation.message.parameter=Annotation has no effect: its target is PARAMETER but the canonical constructor is explicitly declared
header.method.to.be.converted=Method to be converted
accessible.name.change.modifier=Change Modifier
usages.telescope={0,choice, 0#no usages|1#1 usage|2#{0,number} usages}

label.jvm.method.name=JVM method name
label.jvm.field.name=JVM field name
label.jvm.class.name=JVM class name
link.configure.classes.excluded.from.completion=Configure classes excluded from completion
inspection.preview.feature.0.is.preview.api.message={0} is a preview API and may be removed in a future release
progress.title.detect.overridden.methods=Check overriding methods
intention.name.iterate.over=Iterate over {0}
advanced.settings.group.compiler=Compiler
advanced.setting.compiler.lower.process.priority=Run compilation with lower priority
advanced.setting.compiler.lower.process.priority.description=Run external JPS process with IDLE priority on Windows and nice level 10 on Linux/macOS
advanced.setting.compiler.automake.allow.when.app.running=Allow auto-make to start even if developed application is currently running
advanced.setting.compiler.automake.allow.when.app.running.description=Automatically started make may eventually delete some classes that are required by the application
advanced.setting.compiler.unified.ic.implementation=Enable unified Java/Kotlin incremental compilation implementation
advanced.setting.compiler.unified.ic.implementation.description=External JPS process will use new incremental compilation implementation that can handle both Java- and Kotlin-produced bytecode
advanced.settings.group.java=Java
advanced.setting.code.vision.java.minimal.usages=Code Vision: Minimum usages required to show inlay hints
advanced.setting.java.completion.qualifier.as.argument=Enable completion for static methods, which uses qualifier as a first argument
advanced.setting.java.sdkmanrc.watcher=Start listening for changes in configuration files ('.sdkmanrc', '.tool-versions', \u2026) on project opening
dialog.title.check.functional.interface.candidates=Check Functional Interface Candidates...
popup.title.select.target.code.block=Select Target Code Block
target.code.block.presentable.text=Containing block
conflict.message.method.will.override.method.base.class=Renamed {0} will override method of the base {1}
progress.title.looking.for.jdk=Looking for JDK...
dialog.title.check.configuration=Check Configuration...
dialog.message.template.not.found=Template not found
dialog.message.template.not.applicable=Template is not applicable
dialog.message.class.not.found=Template class ''{0}'' not found
notification.content.was.set.up=JDK ''{0}'' was set up for the project
notification.content.change.jdk=Change JDK
button.to.another.directory=To &Directory
button.to.another.source.root=To &Source Root
where.do.you.want.to.move.directory.prompt={0}\n\nWould you like to move the directory to another source root or another directory?
loading.additional.annotations=Loading additional annotations...
tooltip.anonymous=Anonymous
tooltip.has.several.functional.implementations=Has several functional implementations
tooltip.implements.method=Implements method
tooltip.implements.method.in=Implements method in
tooltip.is.functionally.implemented.in=Is functionally implemented in
tooltip.is.implemented.by=Is implemented by
tooltip.is.implemented.by.several.subclasses=Is implemented by several subclasses
tooltip.is.implemented.in=Is implemented in
tooltip.is.implemented.in.several.subclasses=Is implemented in several subclasses
tooltip.is.overridden.by.several.subclasses=Is overridden by several subclasses
tooltip.is.overridden.in=Is overridden in
tooltip.is.overridden.in.several.subclasses=Is overridden in several subclasses
tooltip.is.subclassed.by=Is subclassed by
tooltip.overrides.method=Overrides method
tooltip.overrides.method.in=Overrides method in
tooltip.via.subclass=via subclass
progress.title.calculate.applicable.types=Calculate applicable types...
completion.inner.scope.tail.text=\ (from {0} block)
completion.inner.scope=inner
javadoc.documentation.url.checked=The following documentation {0, choice, 1#URL was|2#URLs were} checked:
javadoc.edit.api.docs.paths=Edit API docs paths
intention.family.name.move.class.to.test.root=Move class to test root
intention.name.move.class.to.test.root=Move ''{0}'' to test root
megabytes.unit=megabytes
java.platform.module.system.name=Java Platform Module System
dialog.title.move.directory=Move Directory
progress.title.checking.if.class.exists=Check target class ''{0}'' exists
quickfix.find.cause.description=Attempts to highlight code elements that resulted in this warning and explain how exactly they contribute.
completion.generate.via.wizard=(generate via wizard)
notification.group.jdk.resolve.problems=Failed to resolve JDK
notification.group.jshell=JShell problem occurred
notification.group.repository=JAR files synchronized with repository
notification.group.source.searcher=Failed to find sources for JAR file
notification.group.language.level=Preview Java language level requires accepting license
notification.group.preview.features=Preview Java language level may be discontinued
notification.group.redundant.exports=Redundant exports/opens can be removed
notification.group.setup.jdk=JDK configured
notification.group.setup.external.annotations=Failed to load external annotations
notification.group.testintegration=Failed to generate tests for @TestDataPath
notification.group.legacy.library=Legacy library depends on IDE installation
notification.group.arch.checker=JDK and system architectures are different
arch.checker.notification.title=JDK can cause slow builds
arch.checker.notification.content=The JDK and system architectures do not match. Builds can be much slower as a consequence.
arch.checker.notification.project.structure=Configure JDK
inspection.io.stream.constructor.description='InputStream' and 'OutputStream' can be constructed using 'Files' methods
inspection.input.stream.constructor.message='InputStream' can be constructed using 'Files.newInputStream()'
inspection.output.stream.constructor.message='OutputStream' can be constructed using 'Files.newOutputStream()'
inspection.bulk.file.attributes.read.description=Bulk 'Files.readAttributes()' call can be used
inspection.replace.with.bulk.file.attributes.read.fix.family.name=Replace with bulk 'Files.readAttributes()' call
inspection.bulk.file.attributes.read.message=Multiple file attribute calls can be replaced with single 'Files.readAttributes()' call
external.annotations.problem.title=Unable to read external annotations
external.annotations.problem.parse.error=File: {0}<br>Problem: {1}
external.annotations.open.file=Open annotations file
intention.family.name.set.explicit.variable.type=Set explicit variable type
intention.name.set.variable.type=Set variable type to ''{0}''
introduce.parameter.inlay.title.delegate=Delegate
introduce.parameter.inlay.tooltip.delegate=Delegate via overloading method
introduce.parameter.advertisement.text=Press {0} to delegate via overloading method or {1} to show more options
progress.title.collect.method.overriders=Collect method overriders...
remove.var.keyword.text=Remove 'var'

error.message.ide.does.not.support.starting.processes.using.old.java=IDE doesn''t support starting Java processes using Java {0}, \
  the minimum supported version is 1.7. Change the run configuration to use a newer Java version.

intention.family.name.upgrade.jdk=Upgrade JDK
intention.name.upgrade.jdk.to=Upgrade JDK to {0}+
intention.family.name.box.primitive.in.conditional.branch=Box primitive value in conditional branch
environment.key.description.project.jdk=Absolute path to project JDK
environment.key.description.project.jdk.name=IDE-visible name of project JDK.
progress.title.detecting.jdk=Detecting JDK
progress.title.restore.references=Restoring references
increase.language.level.preview.description=Language level for module ''{0}'' will be changed to ''{1}''
open.settings.dialog.for.module.preview.text=Open settings dialog for module ''{0}''
button.add.dependency=Add Dependency
adds.ext.library.preview=Adds library ''{0}'' to module ''{1}''
adds.ext.library.preview.import=Adds library ''{0}'' to the dependencies of module ''{1}'' and imports ''{2}''
adds.module.dependencies.preview=Adds {0, choice, 1#module ''''{1}''''|2#one of {2}} to the dependencies of module ''{3}'' and imports unresolved classes
adds.library.preview=Adds {0, choice, 1#library ''''{1}''''|2#one of {2}} to the dependencies of module ''{3}'' and imports unresolved ''{4}''
adds.library.preview.no.import=Adds {0, choice, 1#library ''''{1}''''|2#one of {2}} to the dependencies of module ''{3}''
notification.content.added.annotations=Added {0} {0, choice, 1#annotation|2#annotations}
java.method.chains.inlay.provider.name=Method chains
java.implicit.types.inlay.provider.name=Implicit types
intention.make.final.fixer.stream=Make ''{0}'' effectively final using stream API
intention.make.final.fixer.if=Make ''{0}'' effectively final by moving initializer to the ''if'' statement
package.classes=Package classes:
invert.quickfix.preview=Opens a dialog to invert the selected boolean and choose its new name.
validator.text.not.valid.class.name=Not a valid class name
validator.text.class.not.found=Class not found
validator.text.no.annotation=Must be annotation
validator.text.wrong.superclass=Wrong superclass
compiler.options=Compiler options
vm.option.description.requires=\ (requires {0})
vm.option.description.option=Option:
vm.option.description.category=Category:
vm.option.description.type=Type:
vm.option.description.default.value=Default value:
vm.option.description.description=Description:
vm.option.description.standard=Standard
vm.option.description.product=Product
vm.option.description.diagnostic=Diagnostic
vm.option.description.experimental=Experimental
hint.text.not.valid.java.identifier=Not a valid Java identifier
command.name.replace.type=Replace Type
java.completion.tag={0, choice, 1#Tag:|2#Tags:}
intention.family.name.dismiss=Dismiss
intention.family.name.ignore.project=Do not show again in this project
fix.move.to.source.root=Move to source root
warning.java.file.outside.source.root=Java file is located outside of the module source root, so it won't be compiled
inspection.message.snippet.file.not.found=Snippet file ''{0}'' is not found
inspection.message.snippet.region.not.found=Region is not found
javadoc.snippet.not.found=Snippet not found: {0}
javadoc.snippet.region.not.found=Region not found: {0}
javadoc.snippet.error.unknown.enum.value=@{0}: unknown {1} ''{2}''; only {3} are supported
javadoc.snippet.error.markup.tag.expected=Markup tag or attribute expected
javadoc.snippet.error.unsupported.attribute=@{0}: unsupported attribute: ''{1}''
javadoc.snippet.error.duplicate.attribute=@{0}: duplicate attribute: ''{1}''
javadoc.snippet.error.missing.required.attribute=@{0}: missing ''{1}'' attribute
javadoc.snippet.error.both.substring.and.regex=@{0}: either regex or substring should be specified but not both
javadoc.snippet.error.malformed.regular.expression=@{0}: malformed regular expression: {1}
javadoc.snippet.error.malformed.replacement=@{0}: malformed regular expression replacement ''{1}'': {2}
javadoc.snippet.error.regex.too.complex=@{0}: too complex regular expression ''{1}''
intention.family.name.synchronize.inline.snippet=Synchronize inline snippet
inspection.message.external.snippet.differs.from.inline.snippet=External snippet differs from inline snippet
package.chooser.modal.progress.title=Searching for packages...
convert.number.hex=hex
convert.number.binary=binary
convert.number.octal=octal
convert.number.decimal=decimal
convert.number.plain.format=plain format
convert.number.scientific.format=scientific format
delete.initializer.completely=Delete initializer completely
delete.assignment.completely=Delete assignment completely
popup.title.remove.unused.variable=Remove Unused Variable
intention.family.name.extract.possible.side.effects=Extract possible side effects
intention.family.name.delete.possible.side.effects=Delete possible side effects
intention.extract.set.from.comparison.chain.replace.only.this=Replace only this occurrence
intention.extract.set.from.comparison.chain.replace.all=Replace all occurrences
intention.text.replace.all.delete.import=Replace all and delete the import
intention.text.replace.this.occurrence.keep.import=Replace this occurrence and keep the import
popup.title.choose.target.class=Choose Target Class
tooltip.incorrect.file.template=Incorrect ''{0}'' file template
label.ignored.exceptions=Ignored exceptions:
intention.family.name.add.main.method=Add 'main' method
intention.sequenced.collection.can.be.used.display.name=SequencedCollection method can be used
intention.sequenced.collection.can.be.used.fix.name=Replace with SequencedCollection method call

inspection.mapping.before.count.family.name=Mapping call before count()
inspection.mapping.before.count.message=The ''{0}()'' call does not change the final count and might be optimized out.
unknown.library=Unknown Library
intention.name.delete.method=Delete method ''{0}()''
intention.name.delete.method.title=Delete Method ''{0}()''
intention.name.delete.method.with.callees=... along with other private methods used only there
intention.name.delete.method.only=... and nothing else
intention.family.name.delete.private.method=Delete private method
checkbox.check.for.jdk.updates=Check for JDK updates
intention.family.name.rename.to.ignored=Rename to ignored
tooltip.variable.used=Variable ''{0}'' is used
