0.already.contains.field.1={0} already contains field {1}
0.already.contains.inner.class.named.1={0} already contains inner class named {1}
0.already.has.parameter.named.1.use.this.name.anyway={0} already has a parameter named ''{1}''.\nUse this name anyway?
0.contains.call.with.null.argument.for.parameter.1={0} contains call with null argument for parameter {1}
0.implements.1={0} implements {1}.
0.is.1.and.will.not.be.accessible.from.2.in.the.target.class={0} is {1} and will not be accessible from {2}.
dialog.message.0.would.hide.which.1.used.by.moved.2={0} would hide {1} which is used by moved {2}.
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.parameters={0} is a part of method hierarchy. Do you want to delete multiple parameters?
0.is.a.part.of.method.hierarchy.do.you.want.to.delete.multiple.type.parameters={0} is a part of method hierarchy. Do you want to delete multiple type parameters?
0.is.an.interface.method.implementation.will.be.added.to.all.directly.implementing.classes={0} is an interface. \nMethod implementation will be added to all directly implementing classes.\n Proceed?
0.is.an.interface.that.has.no.implementing.classes={0} is an interface that has no implementing classes
0.is.not.a.legal.java.identifier=''{0}'' is not a legal java identifier
0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect={0} is not accessible from {1}. Value for introduced parameter in that method call will be incorrect.
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} is not initialized in declaration. Such fields are not allowed in interfaces.
0.is.not.static.it.cannot.be.moved.to.the.interface={0} is not static. It cannot be moved to the interface
0.is.used.for.writing.in.1={0} is used for writing in {1}
0.refactoring.is.supported.only.for.final.fields={0} refactoring is supported only for final fields
0.upcasts.an.instance.of.1.to.2={0} upcasts an instance of {1} to {2}
0.uses.1.of.an.instance.of.a.2={0} uses {1} of an instance of a {2}
0.uses.1.which.needs.class.instance={0} uses {1}, which needs class instance
0.uses.a.package.local.1={0} uses package-private {1}
0.uses.non.static.1.which.is.not.passed.as.a.parameter={0} uses non-static {1}, which is not passed as a parameter
0.will.be.inaccessible.from.1={0} will be inaccessible from {1}
0.will.become.inaccessible.from.1={0} will become inaccessible from {1}
0.will.hide.renamed.1={0} will hide renamed {1}
0.will.no.longer.override.1={0} will no longer override {1}
0.will.no.longer.be.record.component.accessor={0} will no longer be {1} getter
0.will.no.longer.be.canonical.constructor=Constructor will no longer be canonical
0.will.not.be.accessible.from.1.after.inlining={0} will not be accessible from {1} after inlining
0.will.override.renamed.1={0} will override renamed {1}
a.package.local.class.0.will.no.longer.be.accessible.from.1=Package-local class {0} will no longer be accessible from {1}
accept.signature.change=Accept Signature Change
add.object.as.a.parameter.to.constructors.with.name=Add &object as a parameter to constructors with name:
add.parameters.for.fields=Add parameters for &fields:
add.parameters.for.fields.to.constructors=Add parameters for &fields to constructors:
all.candidate.variables.have.types.not.in.project=All candidate variables (method parameters and containing class fields) have types that are not in project
all.candidate.variables.have.unknown.types=All candidate variables (method parameters and containing class fields) have unknown types
all.invocations.keep.the.method=Inline all and k&eep the method
all.references.and.remove.super.class=Inline &all references and remove the class
all.references.and.remove.the.class=Inline &all references and remove the class
all.references.and.remove.the.field=Inline &all and remove the field
all.references.keep.field=Inline all and k&eep the field
all.these.directories.will.be.moved.and.all.references.to.0.will.be.changed=All these directories will be moved, and all references to {0} \nwill be changed.
analyze.and.replace.usages=Analyze and Replace Usages
analyze.module.conflicts=Analyze Module Conflicts\u2026
annotate.field.as.nonnls.checkbox=Annotate &field as @NonNls
anonymous.class.description=anonymous class derived from {0}
anonymous.class.text=Anonymous class
anonymous.to.inner.enum.constant.cannot.refactor.message=Enum constant can't be converted to inner class
anonymousToInner.class.name.label.text=Class name:
anonymousToInner.make.class.static.checkbox.text=Make class &static
anonymousToInner.no.inner.class.name=Class name should be specified
anonymousToInner.parameters.panel.border.title=Constructor Parameters
anonymousToInner.refactoring.name=Convert Anonymous to Inner
localToInner.refactoring.name=Convert Local Class to Inner
auto.rename.module.dialog.description=Rename Java modules with the following names to:
auto.rename.module.dialog.title=Rename Java Modules
auto.rename.module.entity=Java Module
boolean.method.result=boolean method result
can.t.restore.context.for.method.extraction=Can't restore context for method extraction
cannot.find.or.create.destination.directory=Cannot find or create destination directory
cannot.introduce.field.in.interface=Non-constant fields are not allowed in an interface.
0.is.not.visible.to.members.of.1={0} is not visible to members of {1}
cannot.move=Cannot Move
cannot.move.inner.class.0.into.itself=Cannot move inner class {0} into itself
cannot.move.package.into.itself=Cannot move package into itself
caret.position.warning.message=The caret should be positioned on type of field, variable, method or method parameter to be refactored
change.method.signature.action.name=Change Method Signature
change.signature.default.value.missing.warning.message=Default value is missing. Method calls will contain blanks instead of the new parameter value.
change.signature.use.any.checkbox=&Use Any Var
changeClassSignature.bad.value=Wrong {0} value: ''{1}'' for parameter ''{2}''
changeClassSignature.class.label.text=Change signature of <code>{0}</code>.
changeClassSignature.no.type.parameters=Class cannot have type parameters
changeClassSignature.parameters.panel.border.title=Parameters:
changeClassSignature.refactoring.name=Change Class Signature
changeClassSignature.already.contains.type.parameter=''{0}'' already contains type parameter ''{1}''
changeClassSignature.Type.parameter.can.not.be.primitive=Type parameter can't be primitive
changeSignature.validating.title=Validating\u2026
changeSignature.processing.changes.title=Processing changes\u2026
changeSignature.bound.value.column=Bound Value
changeSignature.cannot.resolve.return.type=Return type ''{0}'' cannot be resolved.\nContinue?
changeSignature.default.value.column=Default Value
changeSignature.exception.caller.chooser=Select Methods To Propagate New Exceptions
changeSignature.exceptions.panel.border.title=Exceptions
changeSignature.exceptions.wont.propagate=Recursive propagation of exception changes won't be performed
changeSignature.no.return.type=Return type is not specified
changeSignature.no.type.for.exception=Specify type for exception
changeSignature.no.type.for.parameter=Specify {0} type for parameter ''{1}''
changeSignature.not.throwable.type=Wrong type ''{0}'' for exception, should extend java.lang.Throwable
changeSignature.propagate.exceptions.title=Propagate E&xceptions\u2026
changeSignature.vararg.not.last=Vararg parameter should be the last in method signature
changeSignature.wrong.return.type=Wrong return type: ''{0}''
changeSignature.wrong.type.for.exception=Wrong type: ''{0}'' for exception
changeSignature.wrong.type.for.parameter=Wrong type: ''{0}'' for parameter ''{1}''
changeSignature.empty.caller.method.text=Caller method text with highlighted callee call would be shown here
changeSignature.empty.callee.method.text=Callee method text would be shown here
changeSignature.contract.converter.external.annotations=Automatic update of external annotation is not supported
changeSignature.contract.converter.mutation.contract=Annotation contains mutation contract
changeSignature.contract.converter.definition.error=Error in contract definition: {0}
changeSignature.contract.converter.invalid.clause=Invalid contract clause ''{0}''
changeSignature.contract.converter.parameter.removed=Parameter ''{0}'' was deleted, but contract clause ''{1}'' depends on it
changeSignature.contract.converter.invalid.return.reference=Invalid reference in return value: {0}
changeSignature.contract.converter.return.parameter.removed=Parameter ''{0}'' was deleted, but contract clause ''{1}'' returns it
changeSignature.contract.converter.can.not.update.annotation=@Contract annotation cannot be updated automatically: {0}
changeSignature.contract.converter.inherited.annotation=Annotation is inherited from base method
changeSignature.use.any.var=Use any var.
checking.conflicts=Checking Conflicts\u2026
choose.the.ones.you.want.to.be.deleted=Choose the ones you want to be deleted
class.0.already.exists=Class {0} already exists
class.0.is.not.accessible.from.target.1=Class {0} is not accessible from target {1}
class.0.not.found=Class {0} not found.
class.body.description=class body of {0}
class.description={1, choice, 0#|1#local }class {0}
class.does.not.exist.in.the.project=Class does not exist in project. Do you want to create it?
class.does.not.have.base.classes.or.interfaces=Class {0} does not have base classes or interfaces
class.does.not.have.implicit.default.constructor=Class {0} does not have implicit default constructor
class.has.been.successfully.created=Class {0} has been successfully created
class.is.abstract={0} is abstract.
class.is.anonymous.warning.message=Refactoring cannot be performed, because anonymous classes cannot have subclasses
class.is.final.warning.message=Refactoring cannot be performed, because the class is final
class.is.interface={0} is an interface.
class.is.never.used=Class is never used
class.name.prompt=Class &name:
collect.overloads=Collect overloads\u2026
comments.elements.header=Occurrences found in comments, strings and non-code files {0}
constructor.being.refactored.is.used.in.initializer.of.0=Constructor being refactored is used in initializer of {0}. Non-static factory of inner class{1} cannot be used in this context. Resulting code will not compile.
constructor.description=constructor {0}
constructor.with.builder.new.setter.prefix.dialog.message=New setter prefix:
constructor.with.builder.parameters.to.pass.to.the.builder.title=Parameters to Pass to the Builder
constructor.with.builder.rename.setters.prefix.action.name=Rename Setters Prefix
convert.anonymous.to.inner.action.name=Convert Anonymous to Inner\u2026
convert.local.to.inner.action.name=Convert Local to Inner\u2026
convert.anonymous.to.inner.fix.name=Convert anonymous to inner class
convert.local.to.inner.fix.name=Convert local class to inner class
convert.anonymous.or.local.to.inner.fix.name=Convert anonymous or local class to inner
convert.local.to.field.title=Convert Local to Field
convert.to.instance.method.title=Convert To Instance Method
convertToInstanceMethod.all.reference.type.parameters.are.not.in.project=No target class for the instance method is found: no method parameter with a type referencing a class in the project found.
convertToInstanceMethod.all.reference.type.parameters.have.unknown.types=No target class for the instance method is found: method parameter types are unknown.
convertToInstanceMethod.method.is.not.static=Method {0} is not static
convertToInstanceMethod.no.default.ctor=Additionally, the containing class doesn't have a default constructor.
convertToInstanceMethod.no.parameters.with.reference.type=There are no parameters that have reference type.
convert.to.record.title=Convert To Record Class
convert.to.record.accessor.more.accessible={0} is {1}. Converting to a record will make the corresponding implicit accessor method {2}.
convert.to.record.ctor.more.accessible={0} is {1}. Converting to a record will make the corresponding implicit canonical record constructor {2}.
copy.class.clone.0.1=Clone {0} {1}
copy.class.copy.0.1=Copy {0} {1}
copy.handler.clone.class=Clone Class
copy.handler.copy.class=Copy Class
copy.handler.copy.class.with.dialog=Copy Class\u2026
copy.handler.copy.classes.with.dialog=Copy Classes\u2026
current.class=current class
dataflow.to.here.expand.progress=Expanding All Nodes...{0}
dataflow.to.here.group.by.leaf.action.description=Determine whether null can flow into this expression
dataflow.to.here.group.by.leaf.action.text=Group by Leaf Expression Nullness{0, choice, 1#|2#  (Analysis in Progress)}
dataflow.to.here.variable.dereferenced.tooltip=Variable dereferenced
declare.final=Declare &final
declare.generated.annotations=&Generate annotations
declare.static.checkbox=Declare &static
declare.static.pass.fields.checkbox=Declare &static (pass fields as params)
declare.var.type=Declare &var type
declare.varargs.checkbox=Declare v&arargs
default.visibility.border.title=Default Visibility
delete.variable.declaration=&Delete variable declaration
destination.directory.does.not.correspond.to.any.package=The destination directory does not correspond to any package
destination.package=Destination &package:
different.name.expected=Different name expected
directory.0.already.contains.1.named.2=Directory {0} \nalready contains {1} named ''{2}''
directory.0.already.contains.a.file.named.1=Directory {0} \nalready contains a file named ''{1}''
do.not.replace=Do &not replace
do.not.show.this.message.in.the.future=&Do not show this message in the future
do.you.want.to.process.overriding.methods.with.covariant.return.type=Do you want to process overriding methods\nwith covariant return type?
dialog.message.overriding.methods.with.weaken.visibility=Do you want to reduce the visibility of overriding methods to ''{0}'' as well?
edit.migration.entry.title=Edit Class/Package Migration Rule
edit.migration.map.title.new=New Migration Map
edit.migration.map.title.existing=Edit Migration Map
edit.migration.map.ok.button=Save
element.will.no.longer.be.accessible={0} will no longer be accessible from {1}
encapsulate.fields..encapsulated.fields.visibility.border.title=Encapsulated Fields' Visibility
encapsulate.fields..package.local.radio=Package lo&cal
encapsulate.fields.accessors.visibility.border.title=Accessors' Visibility
encapsulate.fields.command.name=Encapsulating fields in {0}
encapsulate.fields.encapsulate.border.title=Encapsulate
encapsulate.fields.existed.accessor.hidden=There is already a {0} which would be hidden by generated accessor
encapsulate.fields.existed.accessor.hides.generated=There is already a {0} which would hide generated accessor for {1}
encapsulate.fields.expression.type.is.used=Unable to proceed with postfix/prefix expression when it's result type is used
encapsulate.fields.field.column.name=Field
encapsulate.fields.fields.to.be.encapsulated=Fields to be encapsulated
encapsulate.fields.fields.to.encapsulate.border.title=Fields to Encapsulate
encapsulate.fields.get.access.checkbox=&Get access
encapsulate.fields.getter.column.name=Getter
encapsulate.fields.getter.exists=There is already method {0} which differs from getter {1} by return type only
encapsulate.fields.no.target=Nothing found to encapsulate
encapsulate.fields.nothing.todo.warning.message=Class has no fields to encapsulate
encapsulate.fields.private.radio=Pr&ivate
encapsulate.fields.protected.radio=Pro&tected
encapsulate.fields.refactoring.cannot.be.applied.to.interface=Encapsulate fields refactoring cannot be applied to interface
encapsulate.fields.set.access.checkbox=&Set access
encapsulate.fields.setter.column.name=Setter
encapsulate.fields.setter.exists=There is already method {0} which differs from setter {1} by return type only
encapsulate.fields.title=Encapsulate Fields
encapsulate.fields.use.accessors.even.when.field.is.accessible.checkbox=&Use accessors even when field is accessible
entity.name.constructor.parameter=Parameter
entity.name.inheritor=Inheritor
entity.name.test=Test
entity.name.variable=Variable
entity.name.accessor=Accessor
enum.constant.description=enum constant {0}
enum.description={1, choice, 0#|1#local }enum {0}
error.cannot.resolve=Cannot resolve {0}
error.incorrect.data=Incorrect Data
error.not.supported.for.jsp={0} refactoring is not supported for JSP
error.not.supported.for.local=Class extending a local class can't be converted to an inner class
error.not.supported.for.package.info={0} refactoring is not supported for package-info.java
error.wrong.caret.position.anonymous=Caret should be positioned inside anonymous or local class to be refactored
error.wrong.caret.position.constructor=Caret should be positioned inside constructor to be refactored
error.wrong.caret.position.local.or.expression.name=Caret should be positioned at the name of local variable or expression to be refactored
error.wrong.caret.position.method=Caret should be positioned inside method to be refactored
error.wrong.name.input=Wrong name: {0}
expand.method.reference.warning=Method is used in one or more method references. Proceeding will convert these method references to lambda expressions.
expression.result=expression result
extract.chained.constructor.checkbox=Extract &chained constructor
extract.delegate.as.enum.checkbox=Extract as enum
extract.delegate.create.nested.checkbox=Create nested class
extract.delegate.generate.accessors.checkbox=&Generate accessors
extract.delegate.unable.create.warning.message=Unable to create class with the given name
extract.method.control.flow.analysis.failed=Code contains syntax errors. Cannot perform necessary analysis.
extract.method.error.prefix=Unable to extract method.
extract.method.error.class.outside.used=Local class is used out of the selected block.
extract.method.error.class.outside.defined=Local class is defined out of the selected block.
extract.method.error.many.outputs=There are multiple variables to return.
extract.method.error.wrap.many.outputs=There are several output variables in the selected code block.\n The method can be extracted if we fold them into {0}.
extract.method.error.wrap.many.outputs.class=a single object
extract.method.error.wrap.many.outputs.record=a new record
extract.method.error.many.exits=There are multiple exit points.
extract.method.error.many.finals=There is an assignment to the final field.
extract.method.error.variable.in.expression=There is a variable to return inside of the selected expression.
extract.method.error.class.not.found=Selected block should be a part of java class.
template.error.invalid.identifier.name=Invalid identifier name
template.error.variable.already.defined=Variable with such name is already defined
template.error.class.already.defined=A class named ''{0}'' is already defined in scope
extract.method.error.method.conflict=Method with the same signature already exists
extract.method.object.anonymous.make.varargs.option=Make &varargs
extract.method.object.class.name=&Class name:
extract.method.object.create.anonymous.class=Create &anonymous class
extract.method.object.create.inner.class=Create &inner class
extract.method.object.inner.class.visibility=Visibility:
extract.method.object.inner.make.static.option=Make &static
extract.method.object.inner.make.varargs.option=Make &varargs
extract.method.object.inner.visibility.package.local=pac&kage local
extract.method.object.inner.visibility.private=pri&vate
extract.method.object.inner.visibility.protected=pr&otected
extract.method.object.inner.visibility.public=pu&blic
extract.method.object.method.name=&Method name:
extract.method.object.parameters=Parameters
extract.method.object.signature.preview=Signature preview
extract.method.object.suggestion=Would you like to Extract Method Object?
extract.parameters.to.replace.duplicates=Extract Parameters to Replace Duplicates
extract.subclass.command=Extract Subclass
extractSuper.rename.original.class.to=&Rename original class to:
extractSuperInterface.javadoc=JavaDoc
factory.method.name.label=Factory method name:
failed.to.re.run.refactoring=Failed to Re-Run Refactoring
field.0.is.already.defined.in.the.1=Field {0} is already defined in the {1}
field.0.is.never.used=Field {0} is never used
field.0.is.not.accessible=Field {0} is not accessible from {1}
field.0.will.hide.field.1.of.the.base.class=Field {0} will hide \na field {1} of the base {2}
field.declaration.radio=Field &declaration
field.description=field {0}
field.name=&Field name:
fields.to.be.refactored.should.belong.to.the.same.class=Fields to be refactored should belong to the same class
functional.interface.broken=Functional expression demands functional interface to have exact one method
generate.getter.for.delegated.component=Generate &getter for delegated component
generate.module.descriptors.analysing.message=Analysing Dependencies
generate.module.descriptors.build.required.message=Couldn't generate module descriptors because the project hasn't been built yet
generate.module.descriptors.collecting.message=Collecting Dependencies
generate.module.descriptors.command.title=Generate module-info Descriptors
generate.module.descriptors.no.suitable.modules.message=Found no modules which may contain module-info
generate.module.descriptors.io.exceptions.message=Problem with reading the module {0} files
generate.module.descriptors.preparing.message=Preparing Code
generate.module.descriptors.rebuild.message=The project needs to be built for better accuracy of dependencies calculation. \n\
  Start the build before generating module-info descriptors?
generate.module.descriptors.scanning.message=Scanning Compiler Output
generate.module.descriptors.title=Generate Module Descriptors
getter.and.setter.methods.found.for.the.field.0=Getter and setter methods found for the field {0}. \n{1} them as well?
getter.method.found.for.the.field.0=Getter method found for the field {0}. \n{1} the getter as well?
idea.has.not.found.any.code.that.can.be.replaced.with.method.call={0} has not found any duplicates
ignore.button=Ignore
implicit.last.parameter.warning=Implicit last parameter should not be deleted
infer.class.type.args.warning=Impossible to infer class type arguments. When proceed, raw {0} would be created
information.title=Information
initializer.for.variable.cannot.be.a.constant.initializer=Initializer for variable {0} cannot be a constant initializer
inline.action.name=Inline
inline.anonymous.conflict.progress=Searching for class "{0}" inheritors\u2026
inline.class.elements.header=Class to inline
inline.conflicts.progress=Check if inline is possible\u2026
inline.constant.field.not.supported.for.enum.constants={0} is not supported for enum constants
inline.element.unknown.header=Unknown element
inline.field.action.name=Inline Field\u2026
inline.field.command=Inline field {0}
inline.field.elements.header=Field to inline
inline.field.field.name.label=Field {0}
inline.field.field.occurrences=Field {0} has {1} {1, choice, 1#occurrence|2#occurrences}
inline.field.title=Inline Field
inline.field.used.in.javadoc=Inlined field is used in javadoc
inline.field.used.in.reflection=Inlined field is used reflectively
inline.field.initializer.is.not.accessible=Field initializer refers to {0}, which is not accessible in {1}
inline.local.unable.try.catch.warning.message=Unable to inline outside try/catch statement
inline.local.used.as.resource.cannot.refactor.message=Variable is used as resource reference
inline.local.variable.declared.outside.cannot.refactor.message=Variable is declared outside a code block
inline.method.calls.not.accessible.in=Inlined method calls {0} which won''t be accessed in {1}
inline.method.calls.not.accessible.on.qualifier=Inlined method calls {0} which won''t be accessible on qualifier {1}
inline.method.checking.tail.calls.progress=Checking tail call usages
inline.method.elements.header=Method to inline
inline.method.method.label=Method {0}
inline.method.method.occurrences=Method {0} has {1} {1, choice, 1#occurrence|2#occurrences}
inline.method.multiline.method.in.ctor.call=Inline cannot be applied to multiline method in constructor call
inline.method.multiline.method.in.loop.condition=Inline cannot be applied to multiline method in loop condition
inline.method.object.action.name=Inline Object
inline.method.object.suggestion.message=Do you want to inline the object and the subsequent call?
inline.method.qualifier.usage.side.effect=Inlined method is used in method reference with side effects in qualifier
inline.method.used.in.javadoc=Inlined method is used in javadoc
inline.method.used.in.reflection=Inlined method is used reflectively
inline.parameter.action.name=Inline Parameter\u2026
inline.parameter.cannot.find.initializer.warning.message=Cannot find constant initializer for parameter
inline.parameter.confirmation=Inline parameter ''{0}'' with initializer ''{1}''?
inline.parameter.error.hierarchy=Inline parameter is not supported when method is a part of inheritance hierarchy
inline.parameter.error.non.project.method=Inline is not supported for non-project methods
inline.parameter.error.varargs=Inline for varargs parameters is not supported
inline.parameter.dependency.unavailable.in.static.method=Parameter initializer depends on {0} which is not available inside the static method
inline.parameter.depends.on.caller.parameter=Parameter initializer depends on callers parameter
inline.parameter.depends.on.non.static=Parameter initializer depends on non static member from some other class
inline.parameter.depends.on.non.static.class=Parameter initializer depends on non static class which is not available inside static method
inline.parameter.depends.on.this.inside.static.method=Parameter initializer depends on this which is not available inside the static method
inline.parameter.depends.on.unavailable.element.inside.method=Parameter initializer depends on {0} which is not available inside the method and cannot be inlined
inline.parameter.depends.on.unavailable.value=Parameter initializer depends on value which is not available inside method
inline.parameter.initializer.depends.on.inaccessible.value=Parameter initializer depends on value which is not available inside method and cannot be inlined
inline.parameter.method.usages.progress=Searching for method usages
inline.parameter.no.usages.warning.message=Method has no usages
inline.parameter.not.accessible.warning.message=Constant initializer is not accessible in method body
inline.parameter.refactoring=Inline Parameter
inline.parameter.replace.with.local.checkbox=R&eplace with local variable
inline.parameter.write.usages.warning.message=Inline parameter which has write usages is not supported
inline.pattern.variable.title=Inline Pattern Variable
inline.super.class=Inline Super Class
inline.super.class.action.name=Inline Super Class\u2026
inline.super.class.label=Class {0}
inline.super.ctor.can.be.replaced=Constructor {0} can be replaced with any of {1}
inline.super.doc.panel.title=JavaDoc for Inlined Members
inline.super.expr.can.be.replaced={0} can be replaced with any of {1}
inline.super.no.anonymous.class=Cannot inline into anonymous class.
inline.super.no.ctor=Constructor matching super not found
inline.super.no.inner.class=Cannot inline into the inner class. Move ''{0}'' to upper level
inline.super.no.substitution=No consistent substitution found for {0}. Expected ''{1}'' but found ''{2}''.
inline.super.no.return.in.super.ctor=Refactoring is not supported when return statement interrupts the execution flow of super constructor
inline.super.non.project.class.warning.message=Cannot inline non-project class
inline.super.static.import.can.be.replaced=Static import can be replaced with any of {0}
inline.super.target.instead.of.super.class=Instance of target type is passed to a place where super class is expected.
inline.super.type.element.can.be.replaced={0} can be replaced with any of {1}
inline.super.type.params.differ=Type parameters do not agree in {0}. Expected {1} but found {2}
inline.super.unknown.type=Type is unknown
inline.to.anonymous.border.title=Inline
inline.to.anonymous.command.name=Inline class {0}
inline.to.anonymous.name.label=Class {0}
inline.to.anonymous.no.abstract=Abstract classes cannot be inlined
inline.to.anonymous.no.ctor.calls=Class cannot be inlined because a call to its constructor inside body
inline.to.anonymous.no.get.class.calls=Result of getClass() invocation would be changed
inline.to.anonymous.no.method.calls=Class cannot be inlined because a call to its member inside body
inline.to.anonymous.no.multiple.interfaces=Classes which implement multiple interfaces cannot be inlined
inline.to.anonymous.no.superclass.and.interface=Classes which have a superclass and implement an interface cannot be inlined
inline.to.anonymous.refactoring=Inline to Anonymous Class
inline.vars.elements.header=Variable to inline
inlined.method.implements.method.from.0=Inlined method implements method from {0}
inlined.method.overrides.method.from.0=Inlined method overrides method from {0}
inlined.method.will.be.transformed.to.single.return.form=Inlined method will be transformed to single-return form
inner.class.0.is.already.defined.in.class.1=Inner class {0} is already defined in class {1}.\nContinue anyway?
inner.class.0.is.not.static=Inner class {0} is not static.\n{1} refactoring is supported for static members only.
inner.class.exists=Inner class named ''{0}'' is already defined\nin class ''{1}''
inner.class.name=&Inner class name:
instance.initializer.description=instance initializer of {0}
instances.casted.to.java.lang.object=Instances casted to java.lang.Object
instances.of.0.upcasted.to.1.were.found=Instances of {0} upcasted to {1} were found. If you continue, they will be shown in a separate Find tab.
instances.upcasted.to.java.lang.object.found=Instances upcasted to java.lang.Object found
instances.upcasted.to.object=Instances upcasted to Object
interface.0.does.not.have.inheritors=Interface {0} does not have inheritors
interface.description={1, choice, 0#|1#local }interface {0}
interface.does.not.have.base.interfaces=Interface {0} does not have base interfaces
interface.has.been.successfully.created=Interface {0} has been successfully created
introduce.constant.enum.cb=Extract as &enum constant
introduce.constant.field.of.type=Constant (static final field) of &type:
introduce.constant.introduce.to.class=Extract to &class (fully qualified name)\:
introduce.constant.move.to.another.class.checkbox=&Move to another class
introduce.field.field.of.type=Field of &type:
introduce.field.static.field.of.type=Static field of &type:
introduce.functional.variable.pass.fields.checkbox=Pass &fields as params
introduce.local.variable.to.reassign.title=Choose variable to reassign
introduce.parameter.command=Extracting parameter to {0}
introduce.parameter.convert.lambda=&Convert to functional expression
introduce.parameter.duplicates.progress=Search method duplicates\u2026
introduce.parameter.elements.header=Adding parameter to a method
introduce.parameter.object.create.inner.class=Create &inner class
introduce.parameter.object.create.new.class=&Create new class
introduce.parameter.object.escalate.visibility.option=&Escalate visibility
introduce.parameter.object.existing.class.name=&Name
introduce.parameter.object.generate.accessors.option=&Generate accessors
introduce.parameter.object.inner.class.name=&Name
introduce.parameter.object.new.class.name=&Name
introduce.parameter.object.new.class.package.name=&Package name
introduce.parameter.object.use.existing.class=&Use existing class
introduce.parameter.super.method.checkbox=Refactor s&uper method
introduced.variable.will.conflict.with.0=Introduced variable will conflict with {0}
introducing.variable.may.break.code.logic=Introducing variable may break code logic
invalid.expression.context=Invalid expression context.
invalid.package.name=Invalid package name: {0}
invalid.target.package.name.specified=Invalid target package name specified
invert.boolean.foreach=Foreach parameter initializer can't be inverted
invert.boolean.wrong.type=Return type of the method or type of the variable to be refactored should be boolean
invocations.to.be.inlined=Invocations to be inlined {0}
is.modified.in.loop.body={0} is modified in loop body
javadoc.for.abstracts=JavaDoc for abstracts
keep.original.signature=Keep Original Signature
lambda.to.reference.side.effect.warning.message=There are possible side effects found in method reference qualifier.\nIntroduce local variable?
local.variable.description=local variable {0}
pattern.variable.description=pattern variable {0}
local.will.be.hidden.renamed.description=Renamed field will hide {0}
locate.caret.inside.a.method=Locate caret inside a member
locate.duplicates.action.name=Locate duplicates
make.0.static=Make {0} Static
make.method.static.title=Make Method Static
make.static.command=Making {0} Static
make.static.description.label=Make {0} {1} static
make.static.elements.header={0} to be made static
make.static.method.references.progress=Search for method references
make.static.methods.to.propagate.dialog.title=Select Methods To Propagate Static
members.to.form.interface.title=Members To Form Interface
members.to.form.superclass.title=Members To Form Superclass
method.0.is.overridden.by.1=Method {0} is overridden by {1}
method.0.will.hide.method.of.the.base.class=Method {0} will hide \nthe method of the base class {1}
method.0.will.implement.method.of.the.base.class=Method {0} will implement \na method of the base class {1}
method.0.will.override.a.method.of.the.base.class=Method {0} will override \na method of the base class {1}
method.call.would.be.linked.to.0.after.rename=Method call would be linked to "{0}" after rename
method.column=Method
method.description=method {0}
method.does.not.have.a.body=Method {0} does not have a body
method.duplicates.found.message={0, choice, 1#1 code fragment|2#{0,number} code fragments} found
method.has.an.empty.body=Method {0} has an empty body.
method.is.not.a.constructor=Method is not a constructor
migration.class=Class
migration.dialog.ok.button.text=Run
migration.dialog.title=Package and Class Migration
migration.dialog.alert.name=Delete Migration Map
migration.dialog.alert.text=Delete ''{0}'' Migration?
migration.dialog.alert.delete=Delete
migration.dialog.link.delete=Delete
migration.dialog.link.duplicate=Duplicate and edit\u2026
migration.dialog.link.edit=Edit\u2026
migration.dialog.scope.label=Scope:
migration.dialog.scope.whole.project=Whole project
migration.entry.class=Class
migration.entry.new.name=New name:
migration.entry.old.name=Old name:
migration.entry.package=Package
migration.map.description.label=Map description:
migration.map.name.prompt=Map name:
migration.new.name.column.header=New name
migration.no.usages.found.in.the.project=No usages found in the project
migration.old.name.column.header=Old name
migration.package=Package
migration.package.with.subpackages=Package with subpackages
migration.title=Migration
migration.type.column.header=Type
migration.edit.duplicated.migration.name={0} copy
migration.edit.existing.name=A migration with the same name already exists.
migration.edit.empty.name=A migration name cannot be empty.
migration.edit.empty.table=The migration table cannot be empty.
migration.edit.copy.existing=Copy an existing
move.class=Move Class\u2026
move.class.refactoring.cannot.be.applied.to.anonymous.classes=Move Class refactoring cannot be applied to anonymous classes
move.class.to.inner.command.name=Move {0, choice, 1#class|2#classes} {1} to {2}
move.class.to.inner.move.to.self.error=It is not allowed to move a class into itself
move.class.to.inner.nonstatic.error=It is not allowed to move a class into a non-static inner class
move.class.to.inner.find.target.class.progress=Looking for target class\u2026
move.classes=Move Classes\u2026
move.classes.and.packages=Move Classes and Packages\u2026
move.classes.command=Moving {0} to package {1}
move.classes.destination.make.inner=&Make inner class of
move.classes.destination.package.prompt=To package:
move.classes.destination.to.package=To packa&ge
move.classes.invalid.package.name.warning.message=Invalid Package Name
move.classes.or.packages.title=Move
move.classes.or.packages.different.modules.exports.conflict=Moving {0} from module {1} to module {2} can hide access to it
move.classes.or.packages.new.module.exports.conflict=Changing exports/opens statements of package {0} grants access to other types and its members in the same package
move.classes.or.packages.unused.exports.notification.title=Unused exports/opens<br>\nin module {0,choice, 1#descriptor|2#descriptors} found
move.classes.or.packages.unused.exports.action.name=Delete unused exports/opens
move.classes.or.packages.unused.exports.command.name=Deleting Unused Exports/Opens
move.enum.constant.cb=Move as &enum constants if possible
move.files.regrouping.command.name=Regrouping\u2026
move.files.to.new.directory.prompt=To directory:
move.inner.class.action.name=Move Inner Class\u2026
move.inner.class.command=Moving inner class {0}
move.inner.class.to.another.class=&Move inner class {0} to another class
move.inner.class.to.be.moved=Class to be moved
move.inner.class.to.upper.level=Move &inner class {0} to upper level
move.inner.class.to.upper.level.preview=Move inner class ''{0}'' to the top level of a package of your choice.
move.inner.class.to.upper.level.or.another.class.preview=Move inner class ''{0}'' to the top level of a package of your choice or to an another class.
move.class.to.new.file.or.make.inner.class.preview=Move class ''{0}'' to a new file in a package of your choice or convert it to an inner class of an existing one.
move.inner.class.to.upper.level.action.name=Move Inner Class to Upper Level\u2026
move.instance.method.delegate.title=Move Instance Method\u2026
move.instance.method.elements.header=Move instance method
move.instance.method.handler.make.method.static=Would you like to make method ''{0}'' static and then move?
move.members.action.name=Move Members\u2026
move.method.enter.a.valid.name.for.parameter=Please Enter a Valid name for Parameter
move.method.is.not.supported.for.0=Move instance method is not supported for {0}
move.method.is.not.supported.for.constructors=Move method is not supported for constructors
move.method.is.not.supported.for.generic.classes=Move method is not supported for generic classes
move.method.is.not.supported.for.non.project.methods=Move method is not supported for non-project methods
move.method.this.parameter.label=Select a name for ''{0}.this'' parameter
move.methods.panel.title=&Methods to Move to the Extracted Class
move.methods.used.in.extracted.block.only=Move Methods Used in Extracted Block Only
move.nonstatic.class.from.jsp.not.supported=Moving non-static classes from JSP page is not supported
move.package.or.directory=Move Package or Directory\u2026
move.package.refactoring.cannot.be.applied.to.default.package=Move Package refactoring cannot be applied to default package
move.packages.or.directories=Move Packages or Directories\u2026
move.single.class.or.package.name.label=Move {0} {1}
move.specified.classes=Move specified classes
move.specified.packages=Move specified packages
move.to.inner.duplicate.inner.class=Class {0} already contains an inner class named {1}
move.class.or.package.build.directories=Building directory list
moving.local.classes.is.not.supported=Moving local classes is not supported
no.class.name.specified=No class name specified
no.exact.method.duplicates.were.found=<html><b>{0,choice, 0#No|1#One|2#{0}} exact method {0,choice, 0#duplicates were|1#duplicate was|2#duplicates were} found</b>, though changed method as shown below has {1} more {1,choice, 1#duplicate|2#duplicates} </html>
no.initializer.present.for.the.field=No initializer present for the field
no.parameter.name.specified=No parameter name specified
no.usages.can.be.replaced=No usages of {0} \ncan be replaced with usages of {1}
occurrences.to.be.migrated=Occurrences to be migrated {0}
ok.button=OK
only.fields.variables.of.methods.of.valid.type.can.be.considered=Only fields, variables, method parameters\u00A0or methods of valid type can be considered.
package.description=package {0}
package.does.not.exist=Package {0} does not exist.\nDo you want to create it?
package.does.not.exist.preview=Package {0} does not exist.\nThe refactoring would create it later for you.
package.name.prompt=Packa&ge name:
parameter.description=parameter {0}
parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class=Parameter initializer contains {0}, but not all calls to method are in its class
parameter.name.prompt=Parameter na&me\:
parameter.of.type=Parameter of &type:
parameter.type.table.column.title=Type
parameter.used.in.method.body.warning={0} is used in method body
pass.outer.class.instance.as.parameter=Pass o&uter class' instance as a parameter
please.enter.a.valid.target.package.name=Please enter a valid target package name
press.the.do.migrate.button=Press the "Do Migrate" button at the bottom of the search results panel\nto migrate using the migration map "{0}"\n
preview.usages.to.be.changed=&Preview usages to be changed
process.duplicates.change.signature.promt=In order to replace all occurrences method signature will be changed. Proceed?
process.duplicates.title=Process Duplicates
process.methods.duplicates.title=Process Method {2} Duplicate ({0} of {1})
processing.progress.text=Processing {0}
project.files.have.been.changed=Project files have been changed.\nWould you like to re-run the refactoring?
push.down.delete.warning.text={0}Pushing members down will result in them being deleted. Would you like to proceed?
push.down.enum.no.constants.warning.text=Enum {0} doesn''t have constants to inline to.
push.down.no.inheritors.class.warning.text=Class {0} does not have inheritors.
push.down.no.inheritors.final.class.warning.text=Final class {0} does not have inheritors.
re.run.refactoring=Re-Run Refactoring
record.description={1, choice, 0#|1#local }record {0}
refactoring.cannot.be.applied.no.sources.attached={0} refactoring cannot be applied: no sources attached
refactoring.cannot.be.applied.to.abstract.methods={0} refactoring cannot be applied to abstract methods
refactoring.cannot.be.applied.to.inline.non.chaining.constructors={0} refactoring cannot be applied to inline non-chaining constructors
refactoring.cannot.be.applied.to.native.methods={0} refactoring cannot be applied to native methods
refactoring.cannot.be.applied.to.vararg.constructors={0} refactoring cannot be applied to vararg constructors
refactoring.extract.method.dialog.duplicates.count={0,choice, 1#One|2#{0,number}} duplicate code {0,choice, 1#fragment|2#fragments} can be replaced with the extracted method call
refactoring.extract.method.dialog.duplicates.pending=Searching for duplicates\u2026
refactoring.extract.method.dialog.duplicates.progress=Searching for Duplicates
refactoring.extract.method.inner.class.defined=Inner class {0} is already defined in class {1}.
refactoring.extract.method.preview.button.refactor=&Do Refactor
refactoring.extract.method.preview.button.rerun=R&erun Refactoring
refactoring.extract.method.preview.failed=Failed to extract method
refactoring.extract.method.preview.group.duplicates=Duplicate code fragments
refactoring.extract.method.preview.group.method=Method to extract
refactoring.extract.method.preview.group.original=Original code fragment
refactoring.extract.method.preview.preparing=Preparing Diff
refactoring.extract.method.preview.updating=Updating Diff
refactoring.extract.method.reference.to.change=References to be changed
refactoring.introduce.variable.enum.in.label.message=Enum constant in switch label cannot be extracted
refactoring.is.not.supported.for.jsp.classes=Refactoring is not supported for JSP classes
refactoring.is.not.supported.in.the.current.context={0} refactoring is not supported in the current context
references.in.code.to.elements.from.migration.map=References in code to elements from migration map "{0}" {1}
references.to.0.to.be.replaced.with.references.to.1=References to ''{0}'' to be replaced with references to ''{1}''{2}
remove.parameter.0.no.longer.used=Remove parameter ''{0}'' no longer used
rename.constructor.parameters.title=Rename Constructor Parameters
rename.constructor.parameters.with.the.following.names.to=Rename parameters with the following names to:
rename.inheritors.with.the.following.names.to.title=Rename Inheritors with the Following Names to:
rename.module.already.exists=Module ''{0}'' already exists in the project
rename.module.directory.command=Rename module and directory to ''{0}''
rename.module.directory.title=Rename Module &and Directory
rename.overloads=Rename &overloads
rename.overloads.dialog.title=Rename Overloads
rename.overloads.to.dialog.description=Rename overloads to:
rename.parameter.in.hierarchy.to.dialog.description=Rename parameter in hierarchy to:
rename.parameters.dialog.title=Rename Parameters
rename.tests=Rename t&ests
rename.tests.title=Rename Tests
rename.tests.with.the.following.names.to=Rename tests with the following names to:
rename.variables=Rename &variables
rename.variables.title=Rename Variables
title.rename.variables.with.the.following.names.to=Rename Variables with the Following Names to:
rename.accessors=Rename &accessors
rename.accessors.title=Rename Getters/Setters
rename.accessors.with.the.following.names.to=Rename accessors with the following names to:
renamed.class.will.hide.0.in.1=Renamed class will hide {0} in {1}
renaming.method.will.override.final.0=Renaming method will override final "{0}"
rename.test.method=Rename test method
rename.test.method.title=Rename Test Methods
rename.test.method.description=Rename test methods with the following names to:
rename.test.method.entity.name=Test Method
replace.all.fields=&Replace all fields
replace.all.occurrences.of.expression.0.occurrences=Replace &all occurrences ({0})
replace.constructor.0.with.a.factory.method=Replace constructor {0} with a factory method
replace.constructor.builder.create.new=&Create new
replace.constructor.builder.use.existing=&Use existing
replace.constructor.existing.builder.fqn=&Builder class name (fully qualified)
replace.constructor.new.builder.class.name=Builder class &name
replace.constructor.new.builder.package=&Package for new builder
replace.constructor.with.factory.method=Replace constructor with factory method
replace.constructor.with.factory.method.title=Replace Constructor With Factory Method
replace.constructor.with.factory.target.fq.name=In (fully qualified name):
replace.default.constructor.of.0.with.a.factory.method=Replace default constructor of {0} with a factory method
replace.default.constructor.with.factory.method=Replace default constructor with factory method
replace.fields.inaccessible.in.usage.context=Replace fields &inaccessible in usage context
replace.fields.used.in.expressions.with.their.getters=Replace fields &used in expressions with their getters
replace.inheritance.from=&Replace with delegation inheritance from:
replace.inheritance.with.delegation.command=Replacing inheritance with delegation in {0}
replace.inheritance.with.delegation.delegate.members.title=Delegate members
replace.inheritance.with.delegation.elements.header=Replace inheritance with delegation
replace.inheritance.with.delegation.invalid.field=''{0}'' is invalid field name for delegation
replace.inheritance.with.delegation.invalid.inner.class=''{0}'' is invalid field name for delegation
replace.inheritance.with.delegation.title=Replace Inheritance With Delegation
replace.instance.qualifiers.with.class.references=Replace instance qualifiers with class references
replace.method.code.duplicates.title=Replace Code Duplicates
replace.method.duplicates.scope.chooser.message=Analysis scope
replace.method.duplicates.scope.chooser.title=Specify {0} Scope
replace.this.code.fragment.and.change.signature=\nMethod signature will be changed to \n{0}
replace.this.code.fragment.and.make.method.static=(Method will be made static)
replace.this.code.fragment.and.make.method.static.visible=(Method will be made static and {0})
replace.this.code.fragment.and.make.method.visible=(Method will be made {0})
replace.with.method.call.does.not.work.for.constructors=Replace With Method Call does not work for constructors
replace.write.access.occurrences=Rep&lace write access occurrences
replacing.inheritance.with.delegation=Replacing inheritance with delegation
safe.delete.search.for.caller.method.usages.progress=Search for Caller Method Usages\u2026
safe.delete.select.members.to.propagate.dialog.title=Select Members To Propagate Safe Delete
safe.delete.select.methods.to.propagate.delete.parameters.dialog.title=Select Methods To Propagate Parameter Deletion
safe.delete.parameter.usage.warning={0} has a call-side usage that is not safe to delete.
select.source.root.chooser.title=Select Source Root
selected.block.contains.invocation.of.another.class.constructor=Selected block contains invocation of another class constructor
selected.block.contains.statement.outside.of.class=Selected block contains a statement outside a class
selected.block.should.represent.an.expression=Selected block should represent an expression
selected.expression.cannot.be.extracted=Selected expression cannot be extracted
selected.expression.cannot.be.a.constant.initializer=Selected expression cannot be a constant initializer
selected.expression.has.void.type=Selected expression has type 'void'
selected.expression.introduces.pattern.variable=Selected expression introduces pattern variable ''{0}''
popup.title.choose.class.to.introduce.constant=Choose class to introduce constant
popup.title.choose.class.to.introduce.field=Choose class to introduce field
setter.method.found.for.the.field.0=Setter method found for the field {0}. \n{1} the setter as well?
side.effects.detected.title=Side Effects Detected
source.folder.0.has.package.prefix.1=Source folder {0} has package prefix ''{1}''\nPackage ''{2}'' cannot be created there.
static.initializer.description=static initializer of {0}
class.initializer.description={0, choice, 0#static|1#instance} initializer
superclass.cannot.be.accessed.in.subclass=Superclass won't be accessible in subclass
superclass.cannot.be.extracted.from.an.enum=Superclass cannot be extracted from enum
superclass.cannot.be.extracted.from.a.record=Superclass cannot be extracted from record
synthetic.jsp.class.is.referenced.in.the.method=Synthetic jsp class is referenced in method
target.0.is.not.accessible.from.1=Target {0} is not accessible from {1}
there.are.going.to.be.multiple.destination.files.with.the.same.name=There are going to be multiple destination files with the same name
there.are.multiple.exit.points.in.the.selected.code.fragment=There are multiple exit points in the selected code fragment
there.are.multiple.output.values.for.the.selected.code.fragment=There are multiple output values for the selected code fragment:
there.are.no.variables.that.have.reference.type=There are no method parameters or containing class fields that have reference type
there.are.unused.methods.that.override.methods.you.delete=There are unused methods that override methods you delete
there.is.already.a.0.in.1=There is already a {0} in {1}
there.is.already.a.0.it.will.conflict.with.an.introduced.parameter=There is already a {0}. It will conflict with the introduced parameter
there.is.already.a.0.it.will.conflict.with.the.renamed.1=An existing {0} has the same name
there.is.already.type.parameter.in.0.with.name.1=There is already type parameter in {0} with name {1}
this.method=This method
this.reference.only.and.keep.super.class=Inline this reference only and &keep the super class
this.reference.only.and.keep.the.class=Inline this reference only and &keep the class
this.reference.only.and.keep.the.field=Inline this only and &keep the field
turn.refs.to.super.command=Replacing Usages of {0} with {1}
turnRefsToSuper.change.usages.to=&Change usages of {0} to:
turnRefsToSuper.use.superclass.in.instanceof=&Use interface/superclass in instanceof
type.migration.action.name=Type Migration
type.migration.choose.scope.title=Choose scope where change signature may occur
type.migration.conflicts.found=Found migration conflicts
type.migration.exclude.action.text=&Exclude
type.migration.include.action.text=&Include
type.migration.return.type.of.method.label=Migrate return type {0} of method {1} to
type.migration.type.of.field.label=Migrate type {0} of field {1} to
type.migration.type.of.record.component.label=Migrate type {0} of record component {1} to
type.migration.type.of.variable.label=Migrate type {0} of variable {1} to
type.migration.type.of.pattern.variable.label=Migrate type {0} of pattern variable {1} to
type.migration.type.of.parameter.label=Migrate type {0} of parameter {1} to
type.migration.class.type.argument.label=Migrate class type argument {0} to
type.migration.migrate.button.text=&Migrate
type.migration.no.conflicts.found=No migration conflicts found
type.migration.no.scope.warning.message=Scope is not chosen
type.migration.reasons.to.migrate=Found reasons to migrate
type.migration.rerun.button.text=&Rerun Type Migration
type.migration.select.suggestion=Select root to find reasons to migrate
type.of.the.selected.expression.cannot.be.determined=Type of selected expression cannot be determined.
unable.to.start.type.migration=Unable to start type migration
unknown.expression.type=Unknown expression type.
unused.overriding.methods.title=Unused Overriding Methods
use.interface.where.possible.title=Use Interface Where Possible
use.super.references.prompt=At this stage {0} can analyze usages of {1} \nand replace them with usages of {2} where possible.\nDo you want to proceed?
use.variable.initializer.to.initialize.parameter=Use variable &initializer to initialize parameter
variable.0.is.changed.before.last.access=Variable ''{0}'' is changed before last access to variable ''{1}''.
variable.does.not.have.an.initializer=Variable {0} does not have an initializer.
variable.is.accessed.for.writing=Variable ''{0}'' is accessed for writing
variable.is.never.used.before.modification=Variable {0} is never used before modification
variable.of.type=Variable of &type:
would.you.like.to.replace.default.constructor.of.0.with.factory.method=Would you like to replace default constructor of {0} with factory method?
wrap.return.value.create.inner.class=Create &inner class
wrap.return.value.create.new.class=&Create new class
wrap.return.value.existing.class.name=Name
wrap.return.value.inner.class.name=Na&me
wrap.return.value.new.class.name=&Name
wrap.return.value.new.class.package.name=&Package name
wrap.return.value.use.existing.class=&Use existing class
wrap.return.value.wrapper.field=Wrapper &field

replace.inside.current.lambda=Create variable inside current lambda
replace.as.separate.operation=Extract as ''{0}'' operation
replace.all.occurrences.changes.semantics=Replace all {0} occurrences (will change semantics!)
replace.all.read.and.write=Replace read and write occurrences (will change semantics!)
replace.all.and.extract=Replace all {0} occurrences and extract as ''{1}'' operation
replace.lambda.chain.detected=Lambda chain detected
replace.occurrences.inside.statement=Replace {0} occurrences in{2, choice, 1#|2# outer} ''{1}'' block
extract.method.object=Extract Method Object
replace.constructor.with.builder=Replace Constructor with Builder
replace.constructor.with.builder.text=Replace constructor with builder
type.migration.error.hint.title=Type Migration

extract.method.dialog.separator.parameters=&Parameters
extract.method.conflict.parameter=Conflicting parameter name: {0}
extract.method.conflict.variable=Variable with name {0} is already defined in the selected scope
extract.method.error.annotation.value=Unable to extract method from annotation value
extract.method.error.local.class.defined.outside=Cannot extract method because the selected code fragment uses local classes defined outside of the fragment
extract.method.error.local.class.used.outside=Cannot extract method because the selected code fragment defines local classes used outside of the fragment
extract.method.error.local.class.variable.used.outside=Cannot extract method because the selected code fragment defines variable of local class type used outside of the fragment
extract.method.error.make.static=Failed to make static
extract.method.preview.node.invalid.prefix=Invalid 
suggest.signature.preview.method.call.prefix=method call:
suggest.signature.preview.title.before=Before
suggest.signature.preview.after.title=After
removing.redundant.imports.progress.title=Removing redundant imports
introduce.parameter.object.error.class.does.not.exist=''{0}'' does not exist
introduce.parameter.object.error.invalid.qualified.parameter.class.name=''{0}'' is invalid qualified parameter class name
introduce.parameter.object.error.invalid.parameter.class.package.name=''{0}'' is invalid parameter class package name
introduce.parameter.object.error.invalid.parameter.class.name=''{0}'' is invalid parameter class name
introduce.parameter.object.error.inner.class.already.exist=Inner class with name ''{0}'' already exists
introduce.parameter.object.error.invalid.inner.class.name=''{0}'' is invalid inner class name
introduce.parameter.object.error.no.field.associated.found=No field associated with {0} found
introduce.parameter.object.error.existing.class.misses.compatible.constructor=No compatible constructor in the existing class
introduce.parameter.object.error.created.class.wont.be.accessible=Created class won't be accessible
introduce.parameter.object.error.file.already.exits=File already exits: {0}
replace.constructor.builder.error.identifier.invalid=Identifier ''{0}'' is invalid
replace.constructor.builder.optional.setter.table.title=Optional Setter
replace.constructor.builder.default.value.table.title=Default Value
replace.constructor.builder.setter.name.table.title=Setter Name
replace.constructor.builder.field.name.table.title=Field Name
replace.constructor.builder.parameter.table.title=Parameter
replace.constructor.builder.select.builder.class.chooser.title=Select Builder Class
replace.constructor.builder.error.invalid.builder.qualified.class.name=''{0}'' is invalid builder qualified class name
replace.constructor.builder.error.invalid.builder.package.name=''{0}'' is invalid builder package name
replace.constructor.builder.error.invalid.builder.class.name=''{0}'' is invalid builder class name
replace.constructor.builder.error.invalid.setter.name=''{0}'' is not a valid setter name
replace.constructor.builder.error.invalid.field.name=''{0}'' is not a valid field name
replace.constructor.builder.error.no.constructors=Current class doesn't have constructors to replace with builder.
replace.constructor.builder.error.caret.position=The caret should be positioned inside a class whose constructors are to be replaced with builder.
replace.constructor.builder.error.no.constructor.chain=Found constructors are not reducible to a simple chain
replace.constructor.builder.error.class.with.chosen.name.already.exist=A class with the selected name already exist.
replace.constructor.builder.error.selected.class.was.not.found=Selected class was not found.
replace.constructor.factory.error.invalid.factory.method.name=''{0}'' not a valid factory method name
replace.constructor.factory.error.factory.method.already.exists=Factory method {0} already exists and will be used instead of the newly created.
java.safe.delete.empty.callee.text=Callee text would be shown here
java.safe.delete.caller.text=Caller text with highlighted callee would be shown here
# {0} = method; {1} = class; {2} = protected/package-private/private
push.up.super.class.signature.conflict={0} in superclass would clash with a {2} method from {1}
push.up.abstract.accessibility.in.subclass.conflict={0} uses {1} which won''t be accessible from the subclass.
push.up.abstract.accessible.from.the.subclass.conflict=Can''t make {0} abstract as it won''t be accessible from the subclass.
push.down.unrelated.defaults.conflict={0} will inherit unrelated defaults from {1} and {2}
move.member.write.access.in.interface.conflict={0} is written to, but an interface is only allowed to contain constants.
dialog.message.enum.constant.0.won.t.be.compilable.in.1={0} won''t be compilable when moved to {1}.
dialog.message.non.constant.will.not.be.compilable.in.interface=Non-constant {0} will not be compilable when moved to an interface.
dialog.message.static.class.initializers.are.not.allowed.in.interfaces=Static class initializers are not allowed in interfaces.
refactor.only.current.method.choice=Refactor only current method
refactor.base.method.choice=Refactor base {0, choice, 0#methods|1#method}
automatic.parameter.renamer.entity.name=Parameter
automatic.overload.renamer.entity.name=Overload
extract.method.checkbox.annotate=Annotate
extract.method.checkbox.make.static=Make static
extract.method.checkbox.make.static.and.pass.fields=Make static and pass fields
extract.method.link.label.more.options=More options
extract.method.progress.search.duplicates=Searching for duplicates
extract.method.progress.replace.duplicates=Replacing duplicates
dialog.message.field.doesnt.have.initializer=Field {0} doesn''t have an initializer
dialog.message.replace.duplicates.works.with.constants.only=Replace Duplicates works with constants only
dialog.message.caret.should.be.inside.method.or.constant=Caret should be positioned inside a method or constant
inline.object.command.name=Inline Object
extract.method.gotit.signature.header=Change the method signature
extract.method.gotit.signature.message=<html><p style=''margin-bottom:3px;''>1. Edit the signature</p><p style=''margin-bottom:3px;''>2. Update usages: click the icon in the gutter or press {0}</p><p><font color=gray>To reorder parameters, use {1} or {2}.</font></p></html>
extract.method.gotit.navigation.header=Looking to change the method signature?
extract.method.gotit.navigation.message=Go to the method declaration to do it:<br/>{0} the method name or press {1}.
introduce.variable.no.matching.occurrences=No matching occurrences
inline.super.no.inheritors.warning.message=Cannot inline class without inheritors
inline.superclass.foreign.language.conflict.message=Cannot inline to {0}
field.0.won.t.be.initialized.already.in.class.initializer=Field ''{0}'' won''t be initialized inside class initializer
dialog.title.analyze.code.fragment.to.extract=Analyze code to extract\u2026
move.label.text=Move:
dialog.title.move.directory.to.source.root=Move Directory to Source Root
dialog.title.confirm.move=Confirm Move
dialog.message.moving.directories.to=Moving directories to ''{0}''
progress.title.collect.hierarchy=Collect ''{0}'' hierarchy
introduce.variable.message.expression.refers.to.pattern.variable.declared.outside=The expression refers to the pattern variable ''{0}'' declared outside
introduce.variable.message.cannot.extract.in.implicit.class=Cannot extract in implicitly declared class
tooltip.cannot.inline.pattern.variable=Cannot inline pattern variable
inline.popup.highlight=Highlight {0} conflicting {0, choice, 1#write|2#writes}
inline.popup.ignore.conflicts=Ignore writes and continue
inline.warning.variables.used.in.initializer.are.updated=Unsafe Inline: Variables Used in Initializer Are Updated