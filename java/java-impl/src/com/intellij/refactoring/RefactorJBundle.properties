add.property=Add Property
add.property.dialog.title=Add property to {0}
property.name.field.label=Property name:
property.type.field.label=Property type:
create.property.getter.checkbox=Create property getter
create.property.setter.checkbox=Create property setter
add.property.to.constructors.checkbox=Add property to constructors
make.property.final.checkbox=Make property final
initialization.expression.checkbox=Initialization expression (optional):
cannot.perform.the.refactoring=Cannot perform the refactoring.\n
refactor.j.is.not.licensed=Refactor-J is not licensed.
the.caret.should.be.positioned.in.the.class.to.add.to.property.to=The caret should be positioned in the class to add to property to.
class.to.be.add.property.to=Class to be add property to
constructor.calls.to.be.updated.view.descriptor=Constructor calls to be updated {0}
unable.to.find.the.requested.class=Unable to find the requested class
no.class.found=No class found
search.for.class.text=Search for class
search.for.class.family.name=Search For Class
add.global.library=Add library dependency
global.library.source=Global Library: {0}
add.module.dependency=Add module dependency
module.source=Module: {0}
project.library.source=Project Library: {0}
add.project.library=Add library dependency
class.found.column.header=Class found
source.column.header=Source
action.column.header=Action
class.search.results.title=Class search results
extract.class.title=Extract Class
extract.class.from.label=Extract class from {0}
name.for.new.class.label=&Name for new class:
choose.destination.package.label=Choose Destination Package
package.for.new.class.label=&Package name:
name.for.wrapper.class.label=Class name:
package.for.wrapper.class.label=Package name:
members.to.extract.label=Mem&bers to Extract
generate.array.access.methods.title=Choose members to generate array access methods for
generate.collection.access.methods.title=Choose members to generate collection access methods for
generate.array.methods.undo.string=Generate Array Methods
generate.collection.methods.undo.string=Generate Collection Methods

there.already.exists.a.class.with.the.chosen.name=There already exists a class with the chosen name.
introduce.parameter.object=Introduce Parameter Object
introduce.type.parameter=Introduce Type Parameter
the.caret.should.be.positioned.at.on.a.type.to.be.parameterized=The caret should be positioned at a type to be parameterized.
type.selected.is.not.in.class.context=Type selected is not in class context.
type.parameters.can.not.be.introduced.as.type.parameters=Type parameters can not be introduced as type parameters.
primitive.types.can.not.be.introduced.as.type.parameters=Primitive types can not be introduced as type parameters.
conflicts.found=Conflicts found
there.are.non.genericizable.instances.of.the.type.you.selected=There are non-genericizable instances of the type you selected.\n
do.you.wish.to.continue=Do you wish to continue?.\n
introduce.type.parameter.title=Introduce Type Parameter
name.for.new.type.parameter.label=Name for new type parameter:
the.caret.should.be.positioned.within.a.class.to.be.refactored=The caret should be positioned within a class to be refactored.
push.javadoc.down=Push Javadoc Down
the.selected.class.is.an.enumeration=The selected class is an enumeration.
the.selected.class.has.no.overridden.methods.with.javadoc=The selected class has no overriden methods with javadoc.
push.javadoc.down.title=Push Javadoc Down
replace.existing.comments.checkbox=Replace existing comments
use.inheritdoc.comments=Use @inheritdoc comments
push.javadoc.down.from.label=Push Javadoc down from:
methods.to.copy.javadoc.from=Methods to copy javadoc from
remove.property=Remove Property
the.caret.should.be.positioned.at.on.a.property.to.be.removed=The caret should be positioned at a property to be removed.
remove.property.getter.checkbox=Remove property getter
remove.property.setter.checkbox=Remove property setter
remove.property.title=Remove Property
remove.property.border=Remove property {0}
replacement.expression.label=Replacement expression (optional):
remove.middleman=Remove Middleman
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=The caret should be positioned at the name of the field to be refactored.
field.selected.is.not.used.as.a.delegate=Field selected is not used as a delegate.
wrap.return.value=Wrap Return Value
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored=The caret should be positioned at the name of the method to be refactored, inside parameters list or inside method call.
method.selected.returns.void=Method selected returns 'void'.
constructor.returns.can.not.be.wrapped=Constructor returns can not be wrapped.
wrap.return.value.title=Wrap Return Value
the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored=The caret should be positioned at an annotation to be refactored to be refactored.
pull.annotation.up=Pull Annotation Up
pull.annotation.up.title=Pull Annotation Up
replace.existing.annotations.checkbox=Replace existing annotations
pull.up.annotation.from.label=Pull up annotation from {0} to:
pull.javadoc.up.title=Pull Javadoc Up
pull.up.javadoc.from.label=Pull up javadoc from {0} to:
methods.to.pull.up.javadoc.from.panel=Methods to pull up javadoc from
remove.type.parameter=Remove Type Parameter
the.caret.should.be.positioned.at.the.name.of.the.type.parameter.to.be.refactored=The caret should be positioned at the name of the type parameter to be refactored.
type.parameter.selected.extends.multiple.types=Type parameter selected extends multiple types.
type.parameter.question.label=Do you wish to remove type parameter {0} and all uses of it?
method.to.wrap.returns.from.label=Method to wrap returns from:
method.whose.return.are.to.wrapped=Method whose return are to wrapped
references.to.be.modified.usage.view=References to be modified {0}
reference=reference
type.parameter.to.be.remove=Type parameter to be remove
references.to.be.changed.usage.view=References to be changed {0}
references.to.be.made.removed.usage.view=References to be made removed {0}
property.to.be.removed=Property to be removed
remove.middleman.field.header=Remove middleman field:
references.to.expose.usage.view=References to expose {0}
retain.all.delegating.methods.radio.button=Retain all delegating methods
remove.middleman.title=Remove Middleman
delete.all.delegating.methods.radio.button=Delete all delegating methods
field.label=Field {0}
delete.delegating.methods.border=Delete delegating methods
make.class.inner.title=Make Class Inner
make.class.an.inner.class.border=Make class {0} an inner class
outer.class.label=Outer class:
choose.destination.class.label=Choose destination class
add.property.command=Add property {0} to {1}
refactor=Refactor
preview=Preview
wrapped.return.command.name=Wrapped return as {0} for {1}{2}{3}()
split.loop.text=Split loop
split.loop.family.name=Split Loop
removed.type.parameter.from.class.command.name=Removed type parameter {0} from class {1}
removed.type.parameter.from.method.command.name=Removed type parameter {0} from method {1}()
remove.property.command.name=Remove property {0}
exposed.delegation.command.name=Exposed delegation to {0}{1}{2}
push.up.javadoc.command.name=Push up Javadoc
javadoced.class=Javadoced class
superclass.methods.to.be.javadoced=Superclass methods to be javadoced
push.annotation.down=Push Annotation Down
0.refactor.j.is.not.licensed={0}Refactor-J is not licensed.
0.the.caret.should.be.positioned.at.an.annotation.to.be.refactored.to.be.refactored={0}The caret should be positioned at an annotation to be refactored to be refactored.
push.down.annotation.command.name=Push down annotation
annotation=Annotation
subclass.elements.to.be.annotated=Subclass elements to be annotated
push.annotation.down.title=Push Annotation Down
pull.up.annotation.command.name=Pull up annotation
superclass.elements.to.be.annotated=Superclass elements to be annotated
pull.javadoc.up=Pull Javadoc Up
pull.up.javadoc.command.name=Pull up Javadoc
merge.loops.text=Merge loops
merge.loops.family.name=Merge Loops
make.class.inner=Make Class Inner
the.caret.should.be.positioned.at.on.a.class.to.be.made.into.an.inner.class=The caret should be positioned at a class to be made into an inner class.
only.outer.classes.and.static.inner.classes.may.be.made.inner=Only outer classes and static inner classes may be made inner.
a.class.can.not.be.made.an.inner.class.of.itself=A class can not be made an inner class of itself.
a.class.can.not.be.made.an.inner.class.of.one.of.it.s.decendents=A class can not be made an inner class of one of it's decendents.
make.class.inner.command.name=Move class {0} inside class {1}
invert.boolean=Invert Boolean
the.caret.should.be.positioned.at.the.name.of.the.variable.or.parameter.to.be.refactored=The caret should be positioned at the name of the variable or parameter to be refactored.
variable.selected.is.not.boolean=Variable selected is not boolean.
invert.boolean.title=Invert boolean
do.you.wish.to.invert.all.uses.of.variable=Do you wish to invert all uses of variable {0}?
parameter.selected.is.not.boolean=Parameter selected is not boolean.
do.you.wish.to.invert.all.uses.of.parameter=Do you wish to invert all uses of parameter {0}?
invert.parameter.command.name=Inverted {0}({1})
invert.variable.command.name=Inverted
variable.to.be.inverted=Variable to be inverted
references.to.be.inverted.0=References to be inverted {0}
parameterize.class.radio.button=Parameterize class {0}
parameterize.method.radio.button=Parameterize method {0}()
genericize.uses.border=Genericize uses of {0}
introduced.type.parameter.command.name=Introduced type {0} as parameter to class {1}
type.parameter.to.be.introduced=Type parameter to be introduced
class.references.to.be.made.inner=Class references to be made inner
references.to.be.made.inner.usage.view=References to be made inner {0}
control.flow.category=Control Flow
other.category=Other
genericize.uses.in.border=Genericize uses of {0} in {1}
extract.class=Extract Class
the.selected.class.is.an.interface=The selected class is an interface.
the.selected.class.is.an.annotation.type=The selected class is an annotation type.
the.refactoring.is.not.supported.on.non.static.inner.classes=The refactoring is not supported on non-static inner classes.
the.selected.class.has.no.members.to.extract=The selected class has no members to extract.
references.to.extract=References to extract
extracting.from.class=Extracting from class:
extracted.class.command.name=Extracted class {0}
method.to.extract.parameters.from.label=Method to extract parameters from
name.for.new.parameter.label=Name for new parameter:
method.selected.has.no.parameters=Method selected has no parameters.
parameters.to.extract.border=Parameters to Extract
parameter=Parameter
your.evaluation.license.for.refactor.j.will.expire.in.less.than.n.days=Your evaluation license for Refactor-J will expire in less than {0} days.\n
refactor.j.licensed.to=Refactor-J licensed to:
can.only.pull.annotations.up.on.methods.parameters.and.classes=Can only pull annotations up on methods, parameters, and classes
can.not.find.any.available.superclasses.for.the.selected.class=Can not find any available superclasses for the selected class
can.not.find.any.available.super.methods.for.the.selected.method=Can not find any available super-methods for the selected method
can.only.push.annotations.down.on.methods.parameters.and.classes=Can only push annotations down on methods, parameters, and classes
can.not.find.any.available.subclasses.for.the.selected.class=Can not find any available subclasses for the selected class
can.not.find.any.available.overriding.methods.for.the.selected.method=Can not find any available overriding methods for the selected method
delete.selected.annotation.checkbox=Delete selected annotation
push.annotation.down.from.label=Push annotation down from:
there.already.exists.an.incompatible.class.with.the.chosen.name=There already exists an incompatible class with the chosen name
weaken.type=Weaken Type
weaken.type.label=Weaken the type of ''{0}'' from {1} to:
weaken.type.command.name=Weaken type
weaken.type.refactoring.is.not.supported.for.primitive.types=Weaken type refactoring is not supported for primitive types
weaken.type.refactoring.is.not.supported.for.arrays=Weaken type refactoring is not supported for arrays
weaken.type.refactoring.is.not.supported.for.type.parameters=Weaken type refactoring is not supported for type parameters
invalid.type.for.weaken.type.refactoring=Invalid type for Weaken Type refactoring
weaken.type.refactoring.is.not.supported.for.constructors=Weaken type refactoring is not supported for constructors
the.selected.type.cannot.be.weakened=The selected type cannot be weakened
the.selected.type.cannot.be.weakened.because.the.method.is.declared.in.a.non.project.class=The selected type cannot be weakened because the method is declared in a non-project class
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=The selected method cannot be wrapped because it is defined in a non-project class
existing.wrapper.class.label=Use Existing Parameter Class
select.wrapper.class=Select parameter class
could.not.find.selected.wrapping.class=Could not find selected wrapping class
there.already.exists.a.class.with.the.selected.name=There already exists a class with the selected name
pull.annotation.up.from.label=Pull annotation up from:
convert.equality.disjunction.to.set.contains=Convert Equality Disjunction To Set.contains()
convert.to.set.contains=Convert to Set.contains()
the.caret.should.be.positioned.at.the.name.of.the.variable.parameter.or.method.to.be.refactored=The caret should be positioned at the name of the variable, parameter, or method to be refactored.
convert.to.String.format=Convert to String.format
convert.to.printf=Convert to printf
convert.to.MessageFormat.format=Convert to MessageFormat.format
split.string=Split string
copy.javadoc.to.inheritors=Copy Javadoc to inheritors
copy.javadoc.to.ancestors=Copy Javadoc to ancestors
