cannot.perform.the.refactoring=Cannot perform the refactoring.\n
extract.class.title=Extract Delegate
extract.class.from.label=Extract delegate from {0}
name.for.new.class.label=&Name for new class:
choose.destination.package.label=Choose Destination Package
package.for.new.class.label=&Package name:
members.to.extract.label=Mem&bers to Extract
there.already.exists.a.class.with.the.chosen.name=There already exists a class with the chosen name.
introduce.parameter.object=Introduce Parameter Object
the.caret.should.be.positioned.within.a.class.to.be.refactored=The caret should be positioned within a class to be refactored.
the.selected.class.is.an.enumeration=The selected class is an enumeration.
remove.middleman=Remove Middleman
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=The caret should be positioned at the name of the field to be refactored.
field.selected.is.not.used.as.a.delegate=Field selected is not used as a delegate.
wrap.return.value=Wrap Return Value
the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored=The caret should be positioned at the name of the method to be refactored, inside parameters list or inside method call.
method.selected.returns.void=Method selected returns 'void'.
constructor.returns.can.not.be.wrapped=Constructor returns cannot be wrapped.
wrap.return.value.title=Wrap Return Value
method.to.wrap.returns.from.label=Method to wrap returns from:
method.whose.return.are.to.wrapped=Method whose return are to wrapped
references.to.be.modified.usage.view=References to be modified {0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files}
reference=reference
remove.middleman.field.header=Remove middleman field:
references.to.expose.usage.view=References to expose {0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files}
remove.middleman.title=Remove Middleman
refactor=Refactor
preview=Preview
wrapped.return.command.name=Wrapped return as {0} for {1}()
exposed.delegation.command.name=Exposed delegation to {0}
annotation=Annotation
the.selected.class.is.an.interface=The selected class is an interface.
the.selected.class.is.an.annotation.type=The selected class is an annotation type.
the.refactoring.is.not.supported.on.non.static.inner.classes=The refactoring is not supported on non-static inner classes.
the.selected.class.has.no.members.to.extract=The selected class has no members to extract.
the.selected.class.should.belong.to.project.sources=The selected class should belong to project sources
references.to.extract=References to extract ( {0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files})
extract.class.as.enum.column.title=As Enum
extract.class.depends.on.0.from.1.tooltip=Depends on {0} from {1}
extract.class.depends.on.0.from.new.class=Depends on {0} from new class {1}
extracting.from.class=Extracting from class:
extracted.class.command.name=Extracted Class {0}
extracted.class.not.accessible.in.0=Extracted class won''t be accessible in {0}
method.selected.has.no.parameters=Method selected has no parameters.
parameter=Parameter
the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class=The selected method cannot be wrapped because it is defined in a non-project class
select.wrapper.class=Select Parameter Class
could.not.find.selected.wrapping.class=Could not find selected wrapping class
there.already.exists.a.class.with.the.selected.name=There already exists a class with the selected name
dialog.message.invalid.inner.class.name=''{0}'' is invalid inner class name
dialog.message.inner.class.with.name.already.exist=Inner class with name ''{0}'' already exist
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' is invalid qualified wrapper class name
dialog.message.invalid.wrapper.class.name=''{0}'' is invalid wrapper class name
dialog.message.wrapper.field.not.found=Wrapper field not found
dialog.message.invalid.wrapper.class.package.name=''{0}'' is invalid wrapper class package name
popup.title.effective.visibility=Effective Visibility
field.needs.getter=Field ''{0}'' needs getter
field.needs.setter=Field ''{0}'' needs setter
initializer.requires.moved.members=Class initializer requires moved members
constructor.requires.moved.members=Constructor requires moved members
case.value.can.not.be.replaced.with.enum={0} can not be replaced with enum
referenced.element.out.of.project={0} is out of project
unable.to.migrate.statement.to.enum=Unable to migrate statement to enum constant.{0}
codestyle.settings.extractor.command.name=CodeStyleSettings Extractor

