add.import=Add Import
class.to.import.chooser.title=Class to Import
method.to.import.chooser.title=Method to Import
field.to.import.chooser.title=Field to Import
access.static.via.class.reference.family=Access static via class reference
access.static.via.class.reference.text=Access static ''{1}.{0}'' via class ''{2}'' reference
add.default.constructor.family=Add Default Constructor
add.default.constructor.text=Add {0} no-args constructor to {1}
add.catch.clause.family=Add exception to catch clause
add.catch.clause.text=Add 'catch' clause(s)
add.finally.block.family=Add 'finally' block
add.exception.to.throws.inherited.method.warning.text=Method ''{0}'' is inherited.\n\
  Do you want to add exceptions to method signatures in the whole method hierarchy?
method.is.inherited.warning.title=Method Is Inherited
add.exception.to.throws.text=Add {0, choice, 0#exception|2#exceptions} to method signature
add.exception.to.throws.family=Add exception to method signature
add.exception.to.existing.catch.family=Add Exception to Existing Catch Clause
add.exception.to.existing.catch.generic=Add exception to existing catch clause
add.exception.to.existing.catch.replacement=Replace ''{0}'' with more generic ''{1}''
add.exception.to.existing.catch.no.replacement=Add ''{1}'' to catch with ''{0}''
add.exception.to.existing.catch.chooser.title=Select Catch Block

add.method.body.text=Add method body
add.method.family=Add method
add.method.text=Add Method ''{0}'' to Class ''{1}''
add.new.array.family=Add missing new expression
add.new.array.text=Add ''new {0}[]''
add.return.statement.text=Add 'return' statement
add.runtime.exception.to.throws.text=Add runtime exception(s) to method signature
add.runtime.exception.to.throws.family=Add Runtime Exception to Method Signature
add.typecast.family=Add type cast
add.typecast.text=Cast to ''{0}''
# {1} = one of fix.expression.role.xyz values
add.typecast.cast.text=Cast {1} to ''{0}''
# {1} = one of fix.expression.role.xyz values
add.typecast.convert.text=Convert {1} to ''{0}''

# use object (accusative) case in translation, if applicable
fix.expression.role.qualifier=qualifier
# use object (accusative) case in translation, if applicable
fix.expression.role.literal=literal
# use object (accusative) case in translation, if applicable
fix.expression.role.expression=expression
# use object (accusative) case in translation, if applicable
fix.expression.role.argument=argument
# use object (accusative) case in translation, if applicable
fix.expression.role.nth.argument={0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} argument
# use object (accusative) case in translation, if applicable
fix.expression.role.lambda.return=lambda return

add.docTag.to.custom.tags=Add ''@{0}'' to custom tags
add.docTag.to.custom.tags.preview=Adds this tag to a list of custom tags that will be ignored by this inspection.
fix.javadoc.family=Fix Javadoc
adjust.package.family=Adjust package name
adjust.package.text=Set package name to ''{0}''
bring.variable.to.scope.family=Bring variable to scope
bring.variable.to.scope.text=Bring ''{0}'' into scope

add.type.arguments.text=Add explicit type arguments to {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} argument
add.type.arguments.single.argument.text=Add explicit type arguments

change.class.signature.text=Change signature of ''{0}'' to match ''{1}''
change.class.signature.family=Change class signature

uidesigner.change.bound.field.type=Change bound field type
cannot.change.field.exception=Cannot change field ''{0}'' type.\nReason: {1}

# {0} - original keyword (extends or implements), {1} - proposed keyword (implements or extends), {2} - class name
exchange.extends.implements.keyword=Change ''{0} {2}'' to ''{1} {2}''
uidesigner.change.gui.component.type=Change GUI component type
change.method.signature.from.usage.family=Change method signature from usage

# {0} - original method signature including name, {1} - method name, {2} - proposed new parameters list
change.method.signature.from.usage.text=Change signature of ''{0}'' to ''{1}({2})''
add.parameter.from.usage.text=Add ''{0}'' as {1,number,ordinal} {2} to {3} ''{4}''
remove.parameter.from.usage.text=Remove {0,number,ordinal} {1} from {2} ''{3}''
change.parameter.from.usage.text=Change {0,number,ordinal} {1} of {2} ''{3}'' from ''{4}'' to ''{5}''
searching.for.usages.progress.title=Searching For Usages...
create.class.from.new.family=Create Class from New
create.class.from.usage.family=Create Class from Usage
# suppress inspection "UnusedProperty"
create.class.from.usage.text=Create {0} ''{1}''
create.inner.class.from.usage.text=Create inner {0} ''{1}''
create.element.in.class=Create {0} ''{1}'' in ''{2}''
# suppress inspection "UnusedProperty"
create.constant.from.usage.family=Create Constant From Usage
# suppress inspection "UnusedProperty"
create.constructor.from.new.family=Create Constructor from New
create.constructor.from.new.text=Create constructor
# suppress inspection "UnusedProperty"
create.constructor.from.super.call.family=Create Constructor From super() Call
# suppress inspection "UnusedProperty"
create.constructor.from.this.call.family=Create Constructor From this() Call
create.constructor.family=Create constructor
create.constructor.text=Create constructor in ''{0}''
create.constructor.body.command=Create Constructor Body
create.constructor.matching.super=Create constructor matching super
super.class.constructors.chooser.title=Choose Super Class Constructors
create.field.from.usage.family=Create field from usage
target.class.chooser.title=Choose Target Class
target.method.chooser.title=Choose Target Method
new.method.body.template.error.text=Please Correct "New Method Body" Template
new.method.body.template.error.title=File Template Error
cannot.create.java.file.error.text=Cannot create {0}.java in {1}: {2}
cannot.create.java.file.error.title=File Creation Failed
cannot.create.java.package.error.text=Cannot create {0} in {1}: {2}
cannot.create.java.package.error.title=Package Creation Failed
create.accessor.for.unused.field.family=Create Accessor for Unused Field
create.getter.for.field=Create getter for ''{0}''
create.setter.for.field=Create setter for ''{0}''
create.getter.and.setter.for.field=Create getter and setter for ''{0}''
create.local.from.usage.family=Create Local from Usage
create.local.from.instanceof.usage.family=Create local variable from instanceof usage
create.local.from.instanceof.usage.text=Insert ''({0}){1}'' declaration
create.member.from.usage.family=Create member from usage
create.method.from.usage.family=Create method from usage
create.method.body=Create Method Body
create.method.from.usage.text=Create method ''{0}''
create.type.parameter.from.usage.family=Create type parameter from usage
create.type.parameter.from.usage.text=Create type parameter ''{0}''
create.type.parameter.from.usage.chooser.title=Place to add type parameter
create.parameter.from.usage.family=Create parameter from Usage
create.property.from.usage.family=Create property From Usage
create.property.from.usage.text=Create property ''{0}''
create.property.from.usage.full.text=Create property ''{0}'' in ''{1}''
create.read.only.property.from.usage.text=Create read-only property ''{0}''
create.read.only.property.from.usage.full.text=Create read-only property ''{0}'' in ''{1}''
create.write.only.property.from.usage.text=Create write-only property ''{0}''
create.write.only.property.from.usage.full.text=Create write-only property ''{0}'' in ''{1}''
# suppress inspection "UnusedProperty"
create.getter=Create Getter
# suppress inspection "UnusedProperty"
create.setter=Create Setter
create.annotation.family=Add annotation to declaration
create.annotation.text=Annotate as @{0}
defer.final.assignment.with.temp.family=Defer final assignment with temp
defer.final.assignment.with.temp.text=Defer assignment to ''{0}'' using temp variable
delete.catch.family=Delete catch
delete.catch.text=Delete catch for ''{0}''
delete.body.text=Delete method body
enable.optimize.imports.on.the.fly=Enable 'Settings | Editor | General | Auto Import | Optimize imports on the fly'
implement.methods.fix=Implement methods
import.class.fix=Import class
insert.new.fix=Insert new
insert.super.constructor.call.family=Insert base class constructor call
make.class.an.interface.family=Make Class an Interface
make.class.an.interface.text=Make ''{0}'' an interface
make.interface.an.class.text=Make ''{0}'' a class
make.vararg.parameter.last.family=Make vararg parameter last
make.vararg.parameter.last.text=Move ''{0}'' to the end of the list
make.receiver.parameter.first.family=Make receiver parameter first
make.receiver.parameter.first.text=Move 'this' to the beginning of the list
fix.parameter.type.family=Fix Parameter Type
fix.parameter.type.text=Make ''{0}'' take parameter of type ''{1}'' here
fix.return.type.family=Fix return type
fix.return.type.or.predecessor.text=Make ''{0}'' return ''{1}'' or ancestor
fix.return.type.text=Make ''{0}'' return ''{1}''
fix.throws.list.family=Fix throws list
fix.throws.list.add.exception=Add ''{0}'' to ''{1}'' throws list
fix.throws.list.remove.exception=Remove ''{0}'' from ''{1}'' throws list
fix.modifiers.family=Fix modifiers

anonymous.class.presentation=Anonymous class derived from {0}
# {0} owner class name
class.initializer.presentation={0} class initializer
add.modifier.fix=Make ''{0}'' {1}
remove.modifier.fix=Make ''{0}'' not {1}
add.modifier.fix.family=Make {0}
remove.modifier.fix.family=Make not {0}

remove.override.fix.family=Remove override
remove.override.fix.text=Remove override annotation from method declaration

change.inheritors.visibility.warning.text=Do you want to change inheritors' visibility to visibility of the base method?
change.inheritors.visibility.warning.title=Change Inheritors
move.class.in.extend.list.family=Move Class in Extend list
move.bound.class.to.front.fix.text=Move bound ''{0}'' to the beginning of the bounds list of type parameter ''{1}''
move.catch.up.family=Move Catch Up
move.catch.up.text=Move catch for ''{0}'' before ''{1}''
move.class.to.separate.file.family=Move Class to Separate File
move.class.to.separate.file.text=Move class ''{0}'' to ''{0}.java''
move.class.to.package.family=Move Class to Package
move.class.to.package.text=Move to package ''{0}''

# change if (!a == b) ...  =>  if (!(a == b)) ...
negation.broader.scope.family=Negation Broader Scope
negation.broader.scope.text=Change to ''!({0})''

optimize.imports.fix=Optimize imports
remove.qualifier.fix=Remove qualifier
remove.unused.element.family=Remove unused {0}
rename.wrong.reference.family=Rename wrong reference
rename.wrong.reference.text=Rename reference
reuse.variable.declaration.family=Reuse previous variable
reuse.variable.declaration.text=Reuse previous variable ''{0}''
navigate.variable.declaration.family=Navigate to variable declaration
navigate.variable.declaration.text=Navigate to previous declared variable ''{0}''
navigate.duplicate.element.text=Navigate to duplicate {0}
safe.delete.family=Safe delete
safe.delete.text=Safe delete ''{0}''
setup.jdk.location.family=Setup JDK Location
setup.jdk.location.text=Setup JDK
side.effects.warning.dialog.title=Side Effects Found
simplify.boolean.expression.family=Simplify boolean expression
simplify.boolean.expression.text=Simplify ''{0}'' to {1}
fix.super.method.return.type.family=Fix Super Method Return Type
fix.super.method.return.type.text=Make ''{0}'' return ''{1}''
surround.with.try.catch.fix=Surround with try/catch
make.final.family=Make Final
# suppress inspection "UnusedProperty"
make.final.copy.to.temp=Copy ''{0}'' to {1} temp variable
fix.variable.type.family=Fix variable type
fix.variable.type.text=Change {0} ''{1}'' type to ''{2}''
fix.receiver.parameter.type.family=Fix receiver parameter type
fix.receiver.parameter.type.text=Change to the enclosing class type
fix.receiver.parameter.name.family=Fix the name of the receiver parameter

# Sample: Boolean b = "true"; -> Boolean b = Boolean.valueOf("true");
wrap.expression.using.static.accessor.family=Wrap expression
wrap.expression.using.static.accessor.text=Wrap using ''{0}()''
# {1} = one of fix.expression.role.xyz values
wrap.expression.using.static.accessor.text.role=Wrap {1} using ''{0}()''
replace.with.qualifier.text=Replace with qualifier
replace.with.qualifier.text.role=Replace {0} with qualifier

# {0} - qualified class name suggested to be imported.
side.effect.action.remove=&Remove
side.effect.action.transform=&Transform
side.effect.action.cancel=&Cancel
side.effect.message1=<html><body>\
  There are possible side effects found in expressions assigned to the variable ''{0}''<br>\
  You can:<ul><li><b>Remove</b> variable usages along with all expressions involved</li>\
  </body></html>
# {0} - variable name, {1} - variable type, {2} - expression with side effect, {3} - same expression transformed to hold the effect

change.parameter.class.family=Change Parameter Class

change.extends.list.family=Extend Class from
add.class.to.extends.list=Make ''{0}'' extend ''{1}''
remove.class.from.extends.list=Make ''{0}'' not extend ''{1}''
add.interface.to.implements.list=Make ''{0}'' implement ''{1}''
remove.interface.from.implements.list=Make ''{0}'' not implement ''{1}''
create.field.text=Create field {0}
create.property.text=Create property {0}
add.constructor.parameter.name=Add constructor parameter
remove.suppression.action.name=Remove ''{0}'' suppression
remove.suppression.action.family=Remove suppression
remove.qualifier.action.text=Remove qualifier
fix.argument.family=Fix arguments
change.new.operator.type.text=Change ''{0}'' to ''new {1}{2}''
change.new.operator.type.family=Change new operator type

fix.unused.symbol.injection.family=Add to dependency injection annotations
fix.unused.symbol.injection.text=Suppress unused warning if annotated by ''{0}''
fix.add.write.annotation.text=Assume fields annotated by ''@{0}'' as implicitly written
fix.add.write.annotation.description=Add ''@{0}'' to the list of annotations that mark an implicitly written field.<p>This list can be edited in the ''Unused declaration'' inspection settings under ''Entry points | Annotations''
fix.add.special.annotation.family=Add to Special Annotations
fix.add.special.annotation.text=Add ''{0}'' to special annotations list

orderEntry.fix.add.dependency.on.module=Add dependency on module ''{0}''
orderEntry.fix.add.dependency.on.module.choose=Add dependency on module...
orderEntry.fix.choose.module.to.add.dependency.on=Choose Module to Add Dependency on
orderEntry.fix.family.add.module.dependency=Add module dependency
orderEntry.fix.add.library.to.classpath=Add library ''{0}'' to classpath
orderEntry.fix.family.add.library.to.classpath=Add library to classpath
orderEntry.fix.family.add.library.to.classpath.options=Add library to classpath...
popup.title.choose.library.to.add.dependency.on=Choose Library to Add Dependency on
orderEntry.fix.circular.dependency.warning=Adding dependency on module ''{0}'' will introduce circular dependency between modules ''{1}'' and ''{2}''.\nAdd dependency anyway?
orderEntry.fix.title.circular.dependency.warning=Circular Dependency Warning

static.import.method.text=Import static method
static.import.method.choose.method.to.import=Choose Method to Import
static.import.constant.text=Import static constant

add.library.title.dialog=Add ''{0}'' Library to Project
add.library.title.choose.folder=Choose Directory
add.library.description.choose.folder=Choose directory where the library will be copied
add.library.error.not.found=Library file ''{0}'' does not exist
add.library.error.cannot.copy=Cannot copy ''{0}'' to ''{1}''\n({2})
add.library.use.bundled.library.radio.button=&Use ''{0}'' from {1} distribution
add.library.copy.files.to.radio.button=&Copy ''{0}'' library files to

permute.arguments=Permute arguments
fix.single.character.string.to.char.literal.text=Change {0} to {1} (to {2} literal)
fix.single.character.string.to.char.literal.family=Fix literal type

change.to.append.family=Fix StringBuilder append
change.to.append.text=Change to ''{0}''

convert.to.string.family=Fix character literal
convert.to.string.text=Convert to string literal

initialize.final.field.in.constructor.name=Initialize in constructor
initialize.final.field.in.constructor.choose.dialog.title=Choose Constructors to Add Initialization to

remove.redundant.arguments.text=Remove redundant arguments to call ''{0}''
remove.redundant.arguments.family=Remove redundant arguments

replace.with.list.access.text=Replace with list access

add.qualifier=Add qualifier
add.qualifier.original.class.chooser.title=Original Class

annotations.fix=Annotations
add.missing.annotation.parameters.fix=Add missing annotation parameters - {0}
add.missing.annotation.single.parameter.fix=Add missing annotation parameter ''{0}''

add.method.qualifier.fix.text=Add qualifier ''{0}'' to method
add.method.qualifier.fix.family=Add method qualifier

collection.addall.can.be.replaced.with.constructor.fix.options.dialog.title=Add Class To Check
collection.addall.can.be.replaced.with.constructor.fix.options.label=Classes to check:
collection.addall.can.be.replaced.with.constructor.fix.description='#ref()' call can be replaced with parametrized constructor call
collection.addall.can.be.replaced.with.constructor.fix.family.name=Replace 'addAll()/putAll()' call with parametrized constructor call
collection.addall.can.be.replaced.with.constructor.fix.name=Replace ''{0}()'' call with parametrized constructor call

add.exception.from.field.initializer.to.constructor.throws.text=Add exception to class {0, choice, 0#default constructor|1#constructor|2#constructors} signature
add.exception.from.field.initializer.to.constructor.throws.family.text=Add exception to class constructors signature
java.8.map.api.inspection.fix.text=Replace with ''{0}'' method call
java.8.map.api.inspection.description=Can be replaced with single ''Map.{0}'' method call
java.8.map.api.inspection.fix.family.name=Replace with single Map method call
java.8.collection.removeif.inspection.description=The loop can be replaced with 'Collection.removeIf'
java.8.collection.removeif.inspection.fix.name=Replace the loop with 'Collection.removeIf'
java.8.list.sort.inspection.description=Collections.sort could be replaced with List.sort
java.8.list.sort.inspection.fix.name=Replace with List.sort
java.8.list.replaceall.inspection.description=The loop can be replaced with 'List.replaceAll'
java.8.list.replaceall.inspection.fix.name=Replace the loop with 'List.replaceAll'

wrap.with.optional.parameter.text=Wrap {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} argument using ''java.util.Optional''
wrap.with.optional.single.parameter.text=Wrap using 'java.util.Optional'

move.file.to.source.root.text=Move file to a source root
delete.return.fix.family=Delete return
delete.return.fix.text=Delete return {0}
delete.return.fix.side.effects.text=Delete return {0} and extract side effects

delete.reference.fix.text=Delete reference
delete.unreachable.statement.fix.text=Delete unreachable statement

extract.side.effects.convert.to.if=Extract side effects as an 'if' statement
extract.side.effects=Extract side {0, choice, 1#effect|2#effects}
extract.side.effects.family.name=Delete statement extracting side effects

module.info.add.directive.family.name=Add a directive to module-info.java
module.info.add.requires.name=Add ''requires {0}'' directive to module-info.java
module.info.add.exports.name=Add ''exports {0}'' directive to module-info.java
module.info.add.opens.name=Add ''opens {0}'' directive to module-info.java
module.info.add.uses.name=Add ''uses {0}'' directive to module-info.java

collection.to.array.text=Apply conversion ''.toArray({0})''
collection.to.array.family.name=Apply conversion '.toArray()'

insert.sam.method.call.fix.name=Insert ''.{0}'' to call functional interface method
insert.sam.method.call.fix.family.name=Insert single abstract method call

wrap.with.adapter.call.family.name=Adapt using call or new object
wrap.with.adapter.text=Adapt using ''{0}''
# {1} = one of fix.expression.role.xyz values
wrap.with.adapter.text.role=Adapt {1} using ''{0}''
wrap.with.adapter.parameter.single.text=Adapt argument using ''{0}''
wrap.with.adapter.parameter.multiple.text=Adapt {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} argument using ''{1}''

java.9.merge.module.statements.fix.family.name=Merge with other ''{0}'' directive
java.9.merge.module.statements.fix.name=Merge with other ''{0} {1}'' directive

adjust.method.accepting.functional.expression.fix.family.name=Adjust method accepting functional expression
adjust.method.accepting.functional.expression.fix.text=Replace ''{0}()'' with ''{1}()''

add.compiler.option.fix.name=Add ''{0}'' to module compiler options

create.service.implementation.fix.family.name=Create service implementation class
create.service.implementation.fix.name=Create class ''{0}''

create.service.interface.fix.family.name=Create service
create.service.interface.fix.name=Create service ''{0}''

convert.variable.to.field.in.anonymous.class.fix.name=Move ''{0}'' into anonymous object
change.method.parameters.text=Change method parameters to ''{0}''
change.method.parameters.family=Change method parameters

change.type.family=Change type
change.type.text=Change type to ''{0}''

add.default.branch.to.variable.initializing.switch.fix.name=Add ''default'' branch to the ''switch'' statement which initializes ''{0}''

insert.empty.parenthesis=Insert '()'
remove.parameter.list=Remove parameter list

convert.primitive.to.boxed.type=Convert primitive to boxed type

choose.class.to.move.popup.title=Choose Class to Move
move.0.in.1=Move ''{0}'' in ''{1}''...
move.0.from.module.1.to.2=Move ''{0}'' from module ''{1}'' to ''{2}''

add.0.to.classpath=Add ''{0}'' to classpath

iterate.iterable=Iterate

choose.fields.to.generate.constructor.parameters.for=Choose Fields to Generate Constructor Parameters for
choose.constructors.to.add.parameter.to=Choose Constructors to Add Parameter to
add.constructor.parameters=Add constructor parameters

add.annotation.attribute.name.family.name=Add annotation attribute name
add.annotation.attribute.name=Add ''{0}=''

replace.with.getter.setter=Replace with getter/setter
replace.with.getter=Replace with getter
replace.with.setter=Replace with setter

wrap.with.block=Wrap with block
create.block=Create block

replace.for.each.loop.with.iterator.for.loop=Replace 'for each' loop with iterator 'for' loop

surround.annotation.parameter.value.with.quotes=Surround annotation parameter value with quotes
surround.with.array.initialization=Surround with array initialization

create.service.implementation=Create Service Implementation
create.service=Create Service

choose.default.value.parameters.popup.title=Choose Default Value Parameters
generate.overloaded.method.or.constructor.with.default.parameter.values=Generate overloaded {0} with default parameter values
generate.overloaded.method.with.default.parameter.values=Generate overloaded method with default parameter values

remove.unreachable.branches=Remove unreachable branches
simplify.boolean.expression.extracting.side.effects=\ extracting side effects
intention.move.parenthesis.name=Fix closing parenthesis placement

extend.sealed.title=Make ''{0}'' {1, choice, 1#extend|2#implement} ''{2}'' and

implement.or.extend.fix.family=Implement/Extend required base class
implement.or.extend.fix.implement.text=Make ''{0}'' implement ''{1}''
implement.or.extend.fix.extend.text=Make ''{0}'' extend ''{1}''

seal.class.from.permits.list.fix=Seal inheritor

unwrap.array.initializer.fix=Replace array initializer with its element
replace.with.type.pattern.fix=Replace with type pattern

make.annotation.applicable.to.0.fix=Make annotation applicable to {0}

merge.duplicate.attributes.family=Merge duplicate attributes

move.switch.branch.up.family=Move switch branch up
move.switch.branch.up.text=Move switch branch ''{0}'' before ''{1}''

qualify.method.call.fix=Qualify the call with ''{0}''
qualify.method.call.family=Qualify method call

remove.redundant.nested.patterns.fix.text=Remove redundant nested pattern{0, choice, 1#|2#s}
add.missing.nested.patterns.fix.text=Add missing nested pattern{0, choice, 1#|2#s}

change.annotation.attribute.value.family=Change annotation attribute
change.annotation.attribute.value.text=Change ''{0}'' annotation attribute