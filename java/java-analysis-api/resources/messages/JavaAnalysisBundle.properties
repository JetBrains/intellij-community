add.explicit.type.arguments=Add explicit type arguments

# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=annotation type
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=constructor
# suppress inspection "UnusedProperty"
annotation.target.FIELD=field
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=local variable
# suppress inspection "UnusedProperty"
annotation.target.METHOD=method
# suppress inspection "UnusedProperty"
annotation.target.MODULE=module
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=package
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=parameter
# suppress inspection "UnusedProperty"
annotation.target.RECORD_COMPONENT=record component
# suppress inspection "UnusedProperty"
annotation.target.TYPE=type
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=type parameter
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=type use

change.type.arguments=Change type arguments
change.type.arguments.to.0=Change type arguments to <{0}>
convert.0.to.float=Convert ''{0}'' to float

dataflow.message.array.index.out.of.bounds=Array index is out of bounds
dataflow.message.negative.array.size=Negative array size
dataflow.message.arraystore=Storing element of type <code>{0}</code> to array of <code>{1}</code> elements will produce <code>ArrayStoreException</code>
dataflow.message.assigning.null.notannotated=Assigning <code>null</code> value to non-annotated field
dataflow.message.assigning.null=<code>null</code> is assigned to a variable that is annotated with @NotNull
dataflow.message.assigning.nullable.notannotated=Expression <code>#ref</code> #loc might be null but is assigned to non-annotated field
dataflow.message.assigning.nullable=Expression <code>#ref</code> might evaluate to null but is assigned to a variable that is annotated with @NotNull
dataflow.message.cce.always=Casting <code>{0}</code> to <code>#ref</code> #loc will produce <code>ClassCastException</code> for any non-null value
dataflow.message.cce=Casting <code>{0}</code> to <code>#ref</code> #loc may produce <code>ClassCastException</code>
dataflow.message.constant.condition.when.reached=Condition <code>#ref</code> #loc is always <code>{0, choice, 0#false|1#true}</code> when reached
dataflow.message.constant.condition=Condition <code>#ref</code> #loc is always <code>{0, choice, 0#false|1#true}</code>
dataflow.message.constant.method.reference=Method reference result is always ''{0}''
dataflow.message.constant.no.ref=Condition is always {0, choice, 0#false|1#true}
dataflow.message.contract.fail.index=The call to '#ref' always fails as an argument is out of bounds
dataflow.message.contract.fail=The call to '#ref' always fails, according to its method contracts
dataflow.message.immutable.modified=Immutable object is modified
dataflow.message.immutable.passed=Immutable object is passed where mutable is expected
dataflow.message.npe.array.access.sure=Array access <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.array.access=Array access <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.field.access.sure=Dereference of <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.field.access=Dereference of <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=Inner class construction will produce <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=Inner class construction may produce <code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=Method invocation <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.method.invocation=Method invocation <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=Method reference invocation <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.only.switch.label=Switch label <code>#ref</code> #loc is the only reachable in the whole switch
dataflow.message.passing.null.argument.nonannotated=Passing <code>null</code> argument to non-annotated parameter
dataflow.message.passing.null.argument=Passing <code>null</code> argument to parameter annotated as @NotNull
dataflow.message.passing.nullable.argument.methodref.nonannotated=Method reference argument might be null but passed to non-annotated parameter
dataflow.message.passing.nullable.argument.methodref=Method reference argument might be null
dataflow.message.passing.nullable.argument.nonannotated=Argument <code>#ref</code> #loc might be null but passed to non-annotated parameter
dataflow.message.passing.nullable.argument=Argument <code>#ref</code> #loc might be null
dataflow.message.passing.non.null.argument.to.optional=Passing a non-null argument to <code>Optional</code>
dataflow.message.passing.null.argument.to.optional=Passing <code>null</code> argument to <code>Optional</code>
dataflow.message.pointless.assignment.expression=Condition <code>#ref</code> #loc at the left side of assignment expression is always <code>{0}</code>. Can be simplified
dataflow.message.pointless.same.arguments=Arguments of '#ref' are the same. Calling this method with the same arguments is meaningless
dataflow.message.pointless.same.argument.and.result=Result of ''#ref'' is the same as the {0,choice,1#first|2#second} argument making the call meaningless
dataflow.message.redundant.assignment=Variable is already assigned to this value
dataflow.message.redundant.instanceof=Condition <code>#ref</code> #loc is redundant and can be replaced with a null check
dataflow.message.redundant.update=Variable update does nothing
dataflow.message.return.notnull.from.nullable=@{0} method ''{1}'' always returns a non-null value
dataflow.message.return.null.from.notnull=<code>null</code> is returned by the method declared as @{0}
dataflow.message.return.null.from.notnullable=<code>null</code> is returned by the method which is not declared as @{0}
dataflow.message.return.nullable.from.notnull.function=Function may return null, but it's not allowed here
dataflow.message.return.nullable.from.notnull=Expression <code>#ref</code> might evaluate to null but is returned by the method declared as @{0}
dataflow.message.return.nullable.from.notnullable=Expression <code>#ref</code> might evaluate to null but is returned by the method which is not declared as @{0}
dataflow.message.storing.array.null=<code>null</code> is stored to an array of @NotNull elements
dataflow.message.storing.array.nullable=Expression <code>#ref</code> might evaluate to null but is stored to an array of @NotNull elements
dataflow.message.unboxing.nullable.argument.methodref=Passing an argument to the method reference requires unboxing which may produce <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=Use of <code>#ref</code> #loc would need unboxing which may produce <code>NullPointerException</code>
dataflow.message.unboxing=Unboxing of <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.unreachable.switch.label=Switch label <code>#ref</code> #loc is unreachable
dataflow.message.constant.expression=Result of <code>#ref</code> #loc is always ''{0}''
dataflow.message.constant.value=Value <code>#ref</code> #loc is always ''{0}''
dataflow.method.fails.with.null.argument=Method will throw an exception when parameter is null
dataflow.message.unknown.nullability=\ (unknown nullability)
dataflow.not.precise={0} is complex: data flow results could be imprecise
dataflow.too.complex={0} is too complex to analyze by data flow algorithm

delete.repeated.0=Delete repeated ''{0}''
delete.repeated.interface=Delete repeated interface
exception.removal.will.break.source.code.proceed.anyway=Exception removal will break source code. Proceed anyway?

feature.generics=Generics
feature.annotations=Annotations
feature.static.imports=Static imports
feature.for.each=For-each loops
feature.varargs=Variable arity methods
feature.hex.fp.literals=Hexadecimal floating point literals
feature.diamond.types=Diamond types
feature.multi.catch=Multi-catches
feature.try.with.resources=Try-with-resources
feature.binary.literals=Binary literals
feature.underscores.in.literals=Underscores in literals
feature.extension.methods=Extension methods
feature.method.references=Method references
feature.lambda.expressions=Lambda expressions
feature.type.annotations=Type annotations
feature.type.receivers=Receiver parameters
feature.intersections.in.casts=Intersection types in casts
feature.static.interface.calls=Static interface method calls
feature.try.with.resources.refs=Resource references
feature.modules=Modules
feature.lvti=Local variable type inference
feature.var.lambda.parameter='var' in lambda parameters
feature.text.blocks=Text block literals
feature.text.block.escape.sequences='\\s' and '\\' escape sequences
feature.enhanced.switch=Enhanced 'switch' blocks
feature.switch.expressions='switch' expressions
feature.records=Records
feature.patterns.instanceof=Patterns in 'instanceof'
feature.sealed.classes=Sealed classes
feature.local.interfaces=Local interfaces
feature.local.enums=Local enums
feature.inner.statics=Static declarations in inner classes
feature.patterns.in.switch=Patterns in switch
feature.guarded.and.parenthesised.patterns=Guarded and parenthesized patterns

find.searching.for.references.to.class.progress=Searching for references to class {0}...
find.usages.panel.title.derived.classes.cap=Derived classes
find.usages.panel.title.derived.classes=derived classes
find.usages.panel.title.derived.interfaces.cap=Derived interfaces
find.usages.panel.title.derived.interfaces=derived interfaces
find.usages.panel.title.implementing.classes.cap=Implementing classes
find.usages.panel.title.implementing.classes=implementing classes
find.usages.panel.title.implementing.methods.cap=Implementing methods
find.usages.panel.title.implementing.methods=implementing methods
find.usages.panel.title.overloaded.methods.usages.cap=Overloaded methods
find.usages.panel.title.overloaded.methods.usages=overloaded methods
find.usages.panel.title.overriding.methods.cap=Overriding methods
find.usages.panel.title.overriding.methods=overriding methods
find.usages.panel.title.base.methods.cap=Usages of base method
find.usages.panel.title.base.methods=usages of base method
message.class.inaccessible.from.module=Class ''{0}'' is not accessible from module ''{1}''
message.class.inaccessible=Class ''{0}'' is not accessible here

inspection.i18n.quickfix.annotate=Annotate...
inspection.i18n.quickfix.annotate.as=Annotate as @{0}
inspection.i18n.quickfix.annotate.element=Annotate {0} ''{1}''...
inspection.i18n.quickfix.annotate.element.as=Annotate {0} ''{1}'' as @{2}
inspection.reference.default.package=<default>
error.message.invalid.java.type=Invalid Java type
move.0.to.the.beginning=Move ''{0}'' to the beginning
move.to.front=Move to front
processing.method.usages=Processing Method Usages...
qualify.0=Qualify {0}
qualify.with.0.this=Qualify with {0}.this
remove.annotation=Remove annotation
remove.left.side.of.assignment=Remove left side of assignment
replace.get.class.with.class.literal=Replace getClass() with .class literal
service.provides=Provides service
service.uses=Uses service
service.click.to.navigate=Click to navigate
suppress.for.parameter=Suppress for parameter
suppress.for.statement.with.comment=Suppress for statement with comment
intention.add.annotation.family=Add annotation
intention.add.type.annotation.family=Add type annotation
intention.text.remove.annotation=Remove

scope.package=Package {0}

0.field.is.always.initialized.not.null=@{0} field is always initialized not-null
access.can.be.0=Access can be {0}
access.to.field.code.ref.code.outside.of.declared.guards.loc=Access to field <code>#ref</code> outside of declared guards #loc
call.to.method.code.ref.code.outside.of.declared.guards.loc=Call to method <code>#ref()</code> outside of declared guards #loc
annotate.as.safevarargs=Annotate as '@SafeVarargs'
annotate.overridden.methods.parameters.family.name=Annotate overridden method parameters
annotate.overridden.methods.parameters=Annotate overridden method parameters as ''@{0}''
anonymous.ref.loc.can.be.replaced.with.0=Anonymous #ref #loc can be replaced with {0}
anonymous.ref.loc.can.be.replaced.with.lambda=Anonymous #ref #loc can be replaced with lambda
assigning.a.collection.of.nullable.elements=Assigning a collection of nullable elements into a collection of non-null elements
nullable.stuff.error.overriding.nullable.with.notnull=Overriding a collection of nullable elements with a collection of non-null elements
nullable.stuff.error.overriding.notnull.with.nullable=Overriding a collection of not-null elements with a collection of nullable elements
comparision.between.object.and.primitive=Comparision between Object and primitive is illegal and is accepted in java 7 only
custom.exception.class.should.have.a.constructor=Custom exception class should have a constructor with a single message parameter of String type
delimiters.argument.contains.duplicated.characters=Delimiters argument contains duplicated characters
deprecated.class.usage.group.xml=XML
deprecated.member.0.is.still.used=Deprecated member ''{0}'' is still used
detach.library.quickfix.name=Detach library
detach.library.roots.quickfix.name=Detach unused library roots
don.t.report.unused.jars.inside.used.library=Don't report unused jars inside used library
explicit.type.argument.ref.loc.can.be.replaced.with=Explicit type argument #ref #loc can be replaced with <>
exports.to.itself.delete.module.ref.fix=Delete reference to module ''{0}''
exports.to.itself.delete.statement.fix=Delete directive
html.classes.exposed.with.code.module.info.code.html=<html>Classes exposed with <code>module-info</code></html>
html.ignore.overrides.of.deprecated.abstract.methods=<html>Ignore overrides of deprecated abstract methods from non-deprecated supers</html>
ignore.casts.in.suspicious.collections.method.calls=Ignore clarifying casts
ignore.exceptions.thrown.by.entry.points.methods=Ignore exceptions thrown by entry points methods
ignore.in.the.same.outermost.class=Ignore in the same outermost class
ignore.inside.deprecated.members=Ignore inside deprecated members
ignore.inside.non.static.imports=Ignore inside non-static imports
ignore.members.of.deprecated.classes=Ignore members of deprecated classes
ignore.operation.which.results.in.negative.value=Ignore '<<' operation which results in negative value
inspection.annotate.method.quickfix.family.name=Annotate method
inspection.annotate.method.quickfix.name=Annotate method with ''@{0}''
inspection.annotate.overridden.method.and.self.quickfix.family.name=Annotate overridden methods and self
inspection.annotate.overridden.method.and.self.quickfix.name=Annotate overridden methods and self with ''@{0}''
inspection.annotate.overridden.method.quickfix.family.name=Annotate overridden methods
inspection.annotate.overridden.method.quickfix.name=Annotate overridden methods with ''@{0}''
inspection.annotate.overridden.method.nullable.quickfix.name=Annotate overridden methods as ''@{0}''
inspection.c.style.array.declarations.option=Ignore C-style declarations in variables
inspection.can.be.final.accept.quickfix=Make final
inspection.can.be.final.option1=Report methods
inspection.can.be.final.option2=Report fields
inspection.can.be.final.option=Report classes
inspection.can.be.local.parameter.problem.descriptor=Parameter <code>#ref</code> can have <code>final</code> modifier
inspection.can.be.local.variable.problem.descriptor=Variable <code>#ref</code> can have <code>final</code> modifier
inspection.can.be.replaced.with.message=Can be replaced with ''{0}''
inspection.class.getclass.display.name=Suspicious 'Class.getClass()' call
inspection.class.getclass.fix.remove.name=Remove 'getClass()' call
inspection.class.getclass.fix.replace.name=Replace with 'Class.class'
inspection.class.getclass.message='getClass()' is called on Class instance
inspection.class.has.no.to.string.method.description=Class ''{0}'' does not override ''toString()'' method
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option=Exclude classes (reg exp):
inspection.class.has.no.to.string.method.ignore.abstract.classes.option=Ignore abstract classes
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option=Ignore deprecated classes
inspection.class.has.no.to.string.method.ignore.enum.classes.option=Ignore enum classes
inspection.class.has.no.to.string.method.ignore.records.option=Ignore records
inspection.class.has.no.to.string.method.ignore.exception.classes.option=Ignore exception classes
inspection.class.has.no.to.string.method.ignore.inner.classes.option=Ignore inner classes
inspection.class.has.no.to.string.method.ignore.test.classes.option=Ignore test classes
inspection.common.if.parts.disable.highlight.tail.call=Do not highlight common parts, if tail statement is call
inspection.common.if.parts.family.else.if.description='else if' can be merged
inspection.common.if.parts.family.else.if=Merge 'else if' statement
inspection.common.if.parts.family=Extract common parts of 'if' statement
inspection.common.if.parts.settings.highlight.when.tail.call=Highlight when the last common statement is a call
inspection.compiler.javac.quirks.anno.array.comma.fix=Remove trailing comma
inspection.compiler.javac.quirks.anno.array.comma.problem=Trailing comma in annotation array initializer may cause compilation error in some Javac versions (e.g. JDK 5 and JDK 6).
inspection.compiler.javac.quirks.name=Javac quirks
inspection.compiler.javac.quirks.qualifier.type.args.fix=Remove generic parameter
inspection.compiler.javac.quirks.qualifier.type.args.problem=Generics in qualifier reference may cause compilation error in some Javac versions (e.g. JDK 5 and JDK 6).
inspection.constant.on.wrong.side.of.a.comparison.side.option=Constant should be on this side of a comparison:
inspection.contract.display.name=Contract issues
inspection.data.flow.redundant.instanceof.quickfix=Replace with a null check
inspection.data.flow.simplify.boolean.expression.quickfix=Simplify boolean expression
inspection.data.flow.simplify.to.assignment.quickfix.name=Simplify to normal assignment
inspection.data.flow.turn.off.constant.references.quickfix=Don't report values which are guaranteed to be constant
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=Don't report nullable methods which always return not-null value
inspection.data.flow.turn.off.true.asserts.quickfix=Don't report always true assertions
inspection.duplicate.throws.display.name=Duplicate throws
inspection.duplicate.throws.ignore.subclassing.option=Ignore exceptions subclassing others
inspection.duplicate.throws.more.general.problem=There is a more general exception, ''{0}'', in the throws list already.
inspection.duplicate.throws.problem=Duplicate throws
inspection.equals.hashcode.only.one.defined.problem.descriptor=Class has {0} defined but does not define {1}
inspection.export.results.can.be.final.description=Declaration can have final modifier
inspection.expression.can.be.replaced.with.message=Expression can be replaced with ''{0}''
inspection.field.not.used.in.to.string.description2=Field ''{0}'' is not used in ''toString()'' method
inspection.field.not.used.in.to.string.description=Method ''{0}'' is not used in ''toString()'' method
inspection.implicit.subclass.display.forClass=Class ''{0}'' could be implicitly subclassed and must not be final
inspection.implicit.subclass.display.name=Final declaration can't be overridden at runtime
inspection.implicit.subclass.extendable=Make ''{0}'' overridable
inspection.implicit.subclass.make.class.extendable=Make class ''{0}'' {1,choice,0#|1#and method {2} |1<and {1} required methods }extendable
inspection.infinite.loop.option=Ignore when placed in Thread.run
inspection.java.module.naming.terminal.digits=Module name component ''{0}'' should avoid terminal digits
inspection.java.module.naming=Java module name contradicts the convention
inspection.local.can.be.final.display.name=Local variable or parameter can be 'final'
inspection.local.can.be.final.option1=Report method parameters
inspection.local.can.be.final.option2=Report catch parameters
inspection.local.can.be.final.option3=Report foreach parameters
inspection.local.can.be.final.option4=Report variables which are implicit final
inspection.local.can.be.final.option=Report local variables
inspection.module.exports.package.to.itself=Module exports/opens package to itself
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=Parameter annotated @{0} must not override @{1} parameter
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=Parameter annotated @{0} should not override non-annotated parameter
inspection.nullable.problems.NotNull.parameter.receives.null.literal=Parameter annotated @{0} should not receive ''null'' as an argument
inspection.nullable.problems.Nullable.NotNull.conflict=Cannot annotate with both @{0} and @{1}
inspection.nullable.problems.Nullable.method.overrides.NotNull=Method annotated with @{0} must not override @{1} method
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=Constructor parameter for @{0} field might be annotated @{0} itself
inspection.nullable.problems.annotated.field.getter.conflict=Getter for @{0} field is annotated @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated=Getter for @{0} field might be annotated @{0} itself
inspection.nullable.problems.annotated.field.setter.parameter.conflict=Setter parameter for @{0} field is annotated @{1}
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=Setter parameter for @{0} field might be annotated @{0} itself
inspection.nullable.problems.method.overrides.NotNull=Not annotated method overrides method annotated with @{0}
inspection.nullable.problems.parameter.overrides.NotNull=Not annotated parameter overrides @{0} parameter
inspection.nullable.problems.primitive.type.annotation=Primitive type members cannot be annotated
inspection.nullable.problems.receiver.annotation=Receiver parameter is inherently not-null
inspection.nullable.problems.outer.type=Outer type is inherently not-null
inspection.nullable.problems.at.constructor=Nullability annotation is not applicable to constructors
inspection.nullable.problems.at.enum.constant=Nullability annotation is not applicable to enum constants
inspection.nullable.problems.at.wildcard=Nullability annotation is not applicable to wildcard type
inspection.nullable.problems.at.local.variable=Nullability annotation is not applicable to local variables
inspection.nullable.problems.at.type.parameter=Nullability annotation is not applicable to type parameters
inspection.nullable.problems.at.reference.list=Nullability annotation is not applicable to extends/implements clause
inspection.objects.equals.can.be.simplified.display.name='Objects.equals()' can be replaced with 'equals()'
inspection.redundant.cast.problem.descriptor=Casting {0} to {1} is redundant
inspection.redundant.cast.remove.quickfix=Remove redundant cast(s)
inspection.redundant.field.initialization.option=Only warn on initialization to null
inspection.redundant.requires.statement.description=Redundant directive ''requires {0}''
inspection.redundant.requires.statement.fix.family=Delete redundant 'requires' directive
inspection.redundant.requires.statement.fix.name=Delete directive ''requires {0}''
inspection.redundant.throws.problem.descriptor1=The declared exception {0} is never thrown in this method, nor in its derivables
inspection.redundant.throws.problem.descriptor2=The declared exception {0} is never thrown
inspection.redundant.throws.problem.descriptor=The declared exception {0} is never thrown in method implementations
inspection.redundant.throws.remove.quickfix=Remove unnecessary 'throws' declarations
inspection.redundant.type.display.name=Redundant type arguments
inspection.redundant.type.no.generics.method.reference.problem.descriptor=Type arguments are redundant for the non-generic method reference
inspection.redundant.type.no.generics.problem.descriptor=Type arguments are redundant for the non-generic method call
inspection.redundant.type.problem.descriptor=Explicit type arguments can be inferred
inspection.redundant.type.remove.quickfix=Remove type arguments
inspection.reference.anonymous.name=anonymous ({0})
inspection.reference.implicit.constructor.name=implicit constructor of {0}
inspection.reference.lambda.name=lambda ({0})
inspection.reference.default.lambda.name=lambda
inspection.reference.method.reference.name=method reference ({0})
inspection.reference.default.method.reference.name=method reference
inspection.reference.jsp.holder.method.anonymous.name=<% page content %>
inspection.requires.auto.module.message='requires' directive for an automatic module
inspection.requires.auto.module.option=Highlight only transitive dependencies
inspection.requires.auto.module.transitive='requires transitive' directive for an automatic module
inspection.requires.auto.module=Dependencies on automatic modules
inspection.same.return.value.display.name=Method returns the same value
inspection.same.return.value.problem.descriptor1=Method and all its derivables always return {0}
inspection.same.return.value.problem.descriptor2=All implementations of this method always return {0}
inspection.same.return.value.problem.descriptor=Method always returns {0}
inspection.surround.requirenonnull.quickfix=Replace with ''Objects.requireNonNull({0})''
inspection.suspicious.array.method.call.display.name=Suspicious 'Arrays' method call
inspection.suspicious.array.method.call.problem.arrays=Array types are incompatible: arrays are always different
inspection.suspicious.array.method.call.problem.element=Element type is not compatible with array type
inspection.suspicious.collections.method.calls.display.name=Suspicious collection method call
inspection.suspicious.collections.method.calls.problem.descriptor1=Suspicious call to ''{0}''
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}'' may not contain {2} of type ''{1}''
inspection.suspicious.getter.setter.field.option=Only warn when field matching getter/setter name is present
inspection.suspicious.integer.div.assignment.option=Report suspicious but possibly exact divisions
inspection.unary.plus.unary.binary.option=Only report in confusing binary or unary expression context
inspection.unnecessary.super.qualifier.option=Ignore clarification 'super' qualifier
inspection.use.compare.method.fix.family.name=Replace with single comparison method
inspection.use.compare.method.option.double=Suggest Double.compare() and Float.compare()
inspection.use.compare.method.turn.off.double=Do not suggest Double.compare() and Float.compare() methods
inspection.visibility.accept.quickfix=Accept suggested access level
inspection.visibility.compose.suggestion=Can be {0}
inspection.visibility.option.constants=Suggest weaker visibility for constants
inspection.visibility.option.package.private.members=Suggest package-private visibility level for class members
inspection.visibility.package.private.top.level.classes=Suggest package-private visibility level for top-level classes
inspection.visibility.private.inner.members=<html>Suggest private for inner class members when referenced from outer class only</html>
instance.member.guarded.by.static.0.loc=Instance member guarded by static "{0}" #loc
instance.member.guarded.by.static.ref.loc=Instance member guarded by static #ref #loc
junit.rule.classrule.option=Report @ClassRule problems
junit.rule.rule.option=Report @Rule problems
make.0.default.annotation=Make "{0}" default annotation
make.default.the.last.case.family.name=Make 'default' the last case
make.final.and.annotate.as.safevarargs=Make final and annotate as '@SafeVarargs'
method.reference.mapped.to.comparator=Method reference mapped to 'Comparator' interface does not fulfill the 'Comparator' contract
module.0.with.language.level.1.depends.on.module.2.with.language.level.3=Module {0} with language level {1} depends on module {2} with language level {3}
non.final.field.code.ref.code.in.immutable.class.loc=Non-final field <code>#ref</code> in @Immutable class  #loc
non.final.guarded.by.field.0.loc=Non-final @GuardedBy field "{0}" #loc
non.final.guarded.by.field.ref.loc=Non-final @GuardedBy field #ref #loc
non.null.type.argument.is.expected=Non-null type argument is expected
not.annotated.method.is.used.as.an.override.for.a.method.annotated.with.0=Not annotated method is used as an override for a method annotated with {0}
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=Overridden method parameters are not annotated
nullable.stuff.problems.overridden.methods.are.not.annotated=Overridden methods are not annotated
parameter.can.be.null=Parameter can be null
parameter.is.always.not.null=Parameter is always not-null
possible.heap.pollution.from.parameterized.vararg.type.loc=Possible heap pollution from parameterized vararg type #loc
redundant.block.marker=Redundant block marker
remove.block.marker.comments=Remove block marker comments
remove.dependency=Remove dependency
remove.switch.branch.0=Remove switch branch ''{0}''
remove.switch.label.0=Remove switch label ''{0}''
remove.switch.label=Remove switch label
replace.0.with=Replace ''''{0}'''' with ''''=''''
replace.anonymous.class.with.lambda.alternative=Replace anonymous class with lambda alternative
replace.operator.assignment.with.assignment=Replace Operator Assignment with Assignment
replace.stringtokenizer.delimiters.parameter.with.unique.symbols=Replace StringTokenizer delimiters parameter with unique symbols
replace.var.with.explicit.type=Replace 'var' with explicit type
replace.with.0=Replace with {0}
replace.with.comparator=Replace with comparator
replace.with.constant.value=Replace with constant value
replace.with.expression.lambda=Replace with expression lambda
replace.with.lambda=Replace with lambda
replace.with.boolean.equals=Replace with Boolean.equals
report.suspicious.but.possibly.correct.method.calls=&Report suspicious but possibly correct method calls
report.when.interface.is.not.annotated.with.functional.interface=Report when interface is not annotated with @FunctionalInterface
searching.for.overriding.methods=Searching for Overriding Methods
statement.lambda.can.be.replaced.with.expression.lambda=Statement lambda can be replaced with expression lambda
static.inheritrance.fix.replace.progress=Replacing usages of {0}
static.member.guarded.by.instance.0.loc=Static member guarded by instance "{0}" #loc
static.member.guarded.by.instance.ref.loc=Static member guarded by instance #ref #loc
suppress.all.for.class=Suppress all inspections for class
suppress.inspection.class=Suppress for class
suppress.inspection.field=Suppress for field
suppress.inspection.member=Suppress for member
suppress.inspection.method=Suppress for method
suppress.inspection.module=Suppress for module declaration
suspected.module.dependency.problem.descriptor=Module ''{0}'' does not depend on module ''{1}''. Though ''{1}'' was not inspected for exported dependencies needed for scope ''{2}''
unknown.guardedby.reference.0.loc=Unknown @GuardedBy reference "{0}" #loc
unknown.guardedby.reference.ref.loc=Unknown @GuardedBy reference #ref #loc
unnecessary.module.dependency.display.name=Unnecessary module dependency
unnecessary.module.dependency.problem.descriptor=Module ''{0}'' sources do not depend on module ''{1}'' sources
unused.import.display.name=Unused import
unused.import.statement=Unused import statement
unused.library.display.name=Unused library
unused.library.problem.descriptor=Unused library ''{0}''
unused.library.roots.problem.descriptor=Unused roots {0} from library ''{1}''
var.can.be.replaced.with.explicit.type='var' can be replaced with explicit type
vararg.method.call.with.50.poly.arguments=Vararg method call with 50+ poly arguments may cause compilation and analysis slowdown
inspection.inconsistent.language.level.display.name=Inconsistent language level settings
inspection.weaker.access.display.name=Declaration access can be weaker
inspection.can.be.final.display.name=Declaration can have 'final' modifier
inspection.redundant.throws.display.name=Redundant 'throws' clause
inspection.java.9.redundant.requires.statement.display.name=Redundant 'requires' directive in module-info
inspection.numeric.overflow.display.name=Numeric overflow
inspection.redundant.cast.display.name=Redundant type cast
inspection.deprecated.is.still.used.display.name=Deprecated member is still used
inspection.deprecated.class.usage.inspection.display.name=Deprecated API usage in XML
inspection.field.access.not.guarded.display.name=Unguarded field access or method call
inspection.instance.guarded.by.static.display.name=Instance member guarded by static field
inspection.non.final.field.in.immutable.display.name=Non-final field in '@Immutable' class
inspection.non.final.guard.display.name=Non-final '@GuardedBy' field
inspection.static.guarded.by.instance.display.name=Static member guarded by instance field or this
inspection.unknown.guard.display.name=Unknown '@GuardedBy' field
inspection.use.compare.method.display.name='compare()' method can be used to compare numbers
inspection.convert.2.diamond.display.name=Explicit type can be replaced with '<>'
inspection.convert.2.lambda.display.name=Anonymous type can be replaced with lambda
inspection.invalid.comparator.method.reference.display.name=Invalid method reference used for 'Comparator'
inspection.safe.varargs.detector.display.name=Possible heap pollution from parameterized vararg type
inspection.block.marker.comments.display.name=Block marker comment
inspection.string.tokenizer.delimiter.display.name=Duplicated delimiters in 'StringTokenizer'
inspection.anonymous.has.lambda.alternative.display.name=Anonymous type has shorter lambda alternative
inspection.java.8.list.sort.display.name='Collections.sort()' can be replaced with 'List.sort()'
inspection.class.has.no.to.string.method.display.name=Class does not override 'toString()' method
inspection.field.not.used.in.to.string.display.name=Field not used in 'toString()' method
inspection.contract.checker.clause.syntax=A contract clause must be in form arg1, ..., argN -> return-value
inspection.contract.checker.unknown.return.value=Return value should be one of: {0}. Found: {1}
inspection.contract.checker.unknown.constraint=Constraint should be one of: {0}. Found: {1}
inspection.contract.checker.empty.constraint=Constraint should not be empty
inspection.contract.checker.unreachable.contract.clause=Contract clause ''{0}'' is unreachable: previous contracts cover all possible cases
inspection.contract.checker.contract.clause.never.satisfied=Contract clause ''{0}'' is never satisfied as its conditions are covered by previous contracts
inspection.contract.checker.pure.method.mutation.contract=Pure method cannot have mutation contract
inspection.contract.checker.parameter.count.mismatch=Method takes {0} parameters, while contract clause ''{1}'' expects {2}
inspection.contract.checker.primitive.parameter.nullability=Parameter ''{0}'' has primitive type ''{1}'', so ''{2}'' is not applicable
inspection.contract.checker.inferred.notnull.parameter.null=Parameter ''{0}'' is inferred to be not-null, so ''null'' is not applicable
inspection.contract.checker.notnull.parameter.null=Parameter ''{0}'' is annotated as not-null, so ''null'' is not applicable
inspection.contract.checker.inferred.notnull.parameter.notnull=Parameter ''{0}'' is inferred to be not-null, so ''!null'' is always satisfied
inspection.contract.checker.notnull.parameter.notnull=Parameter ''{0}'' is annotated as not-null, so ''!null'' is always satisfied
inspection.contract.checker.boolean.condition.for.nonboolean.parameter=Parameter ''{0}'' has ''{1}'' type (expected boolean)
inspection.contract.checker.contract.violated=Contract clause ''{0}'' is violated
inspection.contract.checker.no.exception.thrown=Contract clause ''{0}'' is violated: no exception is thrown
inspection.contract.checker.method.always.fails.trivial=Return value of clause ''{0}'' could be replaced with ''fail'' as method always fails
inspection.contract.checker.method.always.fails.nontrivial=Return value of clause ''{0}'' could be replaced with ''fail'' as method always fails in this case
contract.return.validator.not.applicable.for.constructor=not applicable for constructor
contract.return.validator.not.applicable.static=not applicable for static method
contract.return.validator.not.applicable.primitive=not applicable for primitive return type ''{0}''
contract.return.validator.return.type.must.be.boolean=method return type must be 'boolean'
contract.return.validator.method.return.incompatible.with.method.containing.class=method return type should be compatible with method containing class
contract.return.validator.too.few.parameters=not applicable for method that has {0, choice, 0#no parameters|1#one parameter|2#{0} parameters} 
contract.return.validator.incompatible.return.parameter.type=return type ''{0}'' must be convertible from parameter type ''{1}''
contract.return.value.validation.prefix=Contract return value ''{0}'':
suspicious.invocation.handler.implementation.display.name=Suspicious 'InvocationHandler' implementation
suspicious.invocation.handler.implementation.method.unused.message=Method is never used in 'invoke': it's unlikely that 'hashCode', 'equals' and 'toString' are implemented correctly
suspicious.invocation.handler.implementation.type.mismatch.message=Incompatible type might be returned when proxying method ''{0}()'': required: {1}; got: {2}
suspicious.invocation.handler.implementation.null.returned.for.toString.message=Null might be returned when proxying method 'toString()': this is discouraged
suspicious.invocation.handler.implementation.null.returned.message=Null might be returned when proxying method ''{0}()'': this may cause NullPointerException
error.class.not.found=Class {0} not found
intention.name.qualify.expression=Qualify {0} expression with ''{1}''
nullability.null=null
nullability.nullable=nullable
nullability.non.null=non-null
duplication.policy.ask=Ask
duplication.policy.replace=Replace existing
duplication.policy.generate.duplicate=Generate duplicating method
dftype.presentation.empty.optional=empty Optional
dftype.presentation.present.optional=present Optional
mutability.unknown=unknown
mutability.modifiable=modifiable
mutability.must.not.modify=input parameter that should not be modified
mutability.unmodifiable.view=unmodifiable view
mutability.unmodifiable=unmodifiable
special.field.array.length=Array length
special.field.string.length=String length
special.field.collection.size=Size
special.field.unboxed.value=Unboxed value
special.field.optional.value=Optional value
special.field.enum.ordinal=Enum ordinal
text.unused.import.in.template=Unused import (specified in template)
text.raw.ctor.reference.with.type.parameters=Raw constructor reference with explicit type parameters for constructor

dfa.find.cause.unable=Unable to find the cause
dfa.find.cause.cast.may.fail=cast may fail
dfa.find.cause.may.be.null=may be null
dfa.find.cause.call.always.fails=call always fails
dfa.find.cause.one.of.the.following.happens=one of the following happens:
dfa.find.cause.an.execution.might.exist.where=an execution might exist where:
dfa.find.cause.value.is.always.the.same=value is always {0}
dfa.find.cause.size.is.always.zero=size is always zero
dfa.find.cause.value.x.is.always.the.same=value ''{0}'' is always ''{1}''
dfa.find.cause.compile.time.constant=it''s compile-time constant which evaluates to ''{0}''
dfa.find.cause.equality.established.from.condition=''{0}'' was established from condition
dfa.find.cause.was.assigned.to=''{0}'' was assigned to ''{1}''
dfa.find.cause.was.assigned=''{0}'' was assigned
dfa.find.cause.operand.of.boolean.expression.is.the.same=operand #{0} of {1, choice, 0#and|1#or}-chain is {2}
dfa.find.cause.comparison.arguments.are.the.same=comparison arguments are the same
dfa.find.cause.comparison.arguments.are.different.constants=comparison arguments are different constants
dfa.find.cause.variable.is.initialized={0} ''{1}'' is initialized to {2}
dfa.find.cause.object.kind.generic=an object
dfa.find.cause.object.kind.expression=an expression
dfa.find.cause.object.kind.method.return=method return
dfa.find.cause.type.known={0} type is {1}
# ___PLACE___ is replaced with dfa.find.cause.place.*
dfa.find.cause.type.is.known.from.place=type of ''{0}'' is known from ___PLACE___
dfa.find.cause.condition.is.known.from.place=it''s known that ''{0}'' from ___PLACE___
dfa.find.cause.range.is.known.from.place=range is known from ___PLACE___
dfa.find.cause.value.is.known.from.place=''{0}'' is known to be ''{1}'' from ___PLACE___
dfa.find.cause.place.line.number=line #{0}
dfa.find.cause.place.here=here
dfa.find.cause.values.cannot.be.equal.because=values cannot be equal because {0}
dfa.find.cause.condition.was.checked.before=condition ''{0}'' was checked before
dfa.find.cause.condition.was.deduced=condition ''{0}'' was deduced
dfa.find.cause.was.passed.as.non.null.parameter=''{0}'' was passed as an argument to a method accepting non-null parameter
dfa.find.cause.was.dereferenced=''{0}'' was dereferenced
dfa.find.cause.instanceof.implies.non.nullity=the 'instanceof' check implies non-nullity
dfa.find.cause.nullability.inferred={0} ''{1}'' was inferred to be ''{2}''
dfa.find.cause.nullability.externally.annotated={0} ''{1}'' is externally annotated as ''{2}''
dfa.find.cause.nullability.explicitly.annotated={0} ''{1}'' is annotated as ''{2}''
dfa.find.cause.nullability.inherited.from.container={0} ''{1}'' inherits container annotation, thus ''{2}''
dfa.find.cause.nullability.inherited.from.class={0} ''{1}'' inherits annotation from class {2}, thus ''{3}''
dfa.find.cause.nullability.inherited.from.package={0} ''{1}'' inherits annotation from package {2}, thus ''{3}''
dfa.find.cause.nullability.inherited.from.named.element={0} ''{1}'' inherits from {2}, thus ''{3}''
dfa.find.cause.field.initializer.nullability=field ''{0}'' is initialized to ''{1}'' value
dfa.find.cause.field.assigned.nullability=field ''{0}'' is known to be always initialized to ''{1}'' value
# E.g. "length of parameter"
dfa.find.cause.special.field.of.something={0} of {1}
dfa.find.cause.array.length.is.always.non.negative=array length is always non-negative
dfa.find.cause.string.length.is.always.non.negative=string length is always non-negative
dfa.find.cause.collection.size.is.always.non.negative=collection size is always non-negative
dfa.find.cause.range.is.specified.by.annotation=the range of ''{0}'' is specified by annotation as {1}
# %s is replaced with value range like {0..255} or 'odd', etc. (see long.range.set.presentation.* above)
dfa.find.cause.result.of.primitive.cast.template=result of ''({0})'' cast is %s
dfa.find.cause.result.of.numeric.operation.template=result of ''{0}'' is %s
dfa.find.cause.left.operand.range.template=left operand is %s
dfa.find.cause.right.operand.range.template=right operand is %s
dfa.find.cause.numeric.cast.operand.template=cast operand is %s
dfa.find.cause.numeric.range.generic.template=value is %s
# Here {0} is replaced with dfa.find.cause.nonnull.expression.kind.*
dfa.find.cause.obviously.non.null.expression=expression cannot be null as it''s {0}
dfa.find.cause.nonnull.expression.kind.newly.created.object=newly created object
dfa.find.cause.nonnull.expression.kind.literal=literal
dfa.find.cause.nonnull.expression.kind.primitive.type=a value of primitive type ''{0}''
dfa.find.cause.nonnull.expression.kind.concatenation=concatenation
dfa.find.cause.nonnull.expression.kind.this.object='this' object
# Here {0} is replaced with dfa.find.cause.contract.kind.*
# {1} = method or constructor; {2} is name
dfa.find.cause.contract.trivial=according to {0}, {1} ''{2}'' always returns ''{3}'' value
# Here {0} is replaced with dfa.find.cause.contract.kind.*
# {1} = method or constructor; {2} is name
dfa.find.cause.contract.throws.on.condition=according to {0}, {1} ''{2}'' throws exception when {3}
# Here {0} is replaced with dfa.find.cause.contract.kind.*
# {1} = method or constructor; {2} is name
dfa.find.cause.contract.returns.on.condition=according to {0}, {1} ''{2}'' returns ''{3}'' when {4}
dfa.find.cause.contract.kind.explicit=contract
dfa.find.cause.contract.kind.inferred=inferred contract
dfa.find.cause.contract.kind.hard.coded=hard-coded contract
dfa.find.cause.primitive.boxed=primitive value was boxed

type.constraint.assignability.explanation.exact={0} is already known to be {1}
type.constraint.assignability.explanation.exact.subtype={0} type is exactly {1} which is a subtype of {2}
type.constraint.assignability.explanation.exact.not.subtype={0} type is exactly {1} which is not a subtype of {2}
type.constraint.assignability.explanation.subtype.of.subtype={0} is already known to be {1} which is a subtype of {2}
type.constraint.assignability.explanation.not.instance.of={0} is known to be not {1}
type.constraint.assignability.explanation.not.instance.of.supertype={0} is known to be not {1} which is a supertype of {2}
type.constraint.assignability.explanation.definitely.inconvertible={0} is known to be {1} which is definitely incompatible with {2}
inspection.message.javac.quick.intersection.type.problem=Intersection type ''{0}'' cannot be instantiated, because ''{1}'' is final
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9=Suggest package-private visibility level for classes in exported packages (Java 9+)
generate.members.position.at.caret=At caret
generate.members.position.after.equals.and.hashcode=After equals() and hashCode()
generate.members.position.at.the.end.of.class=At the end of class

navigate.to.overridden.methods.title=Overriding methods of {0}
subclasses.search.progress.title=Searching for Overridden Methods
progress.title.searching.for.overridden.methods=Searching for Overridden Methods
arguments.count.mismatch=Expected {0} arguments but found {1}
inspection.message.nullable.method.implements.non.null.method=Nullable method ''{0}'' from ''{1}'' implements non-null method from ''{2}''
inspection.message.non.annotated.method.implements.non.null.method=Non-annotated method ''{0}'' from ''{1}'' implements non-null method from ''{2}''
inspection.message.non.null.parameter.should.not.override.nullable.parameter=Non-null parameter ''{0}'' in method ''{1}'' from ''{2}'' should not override nullable parameter from ''{3}''
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter=Non-annotated parameter ''{0}'' in method ''{1}'' from ''{2}'' should not override non-null parameter from ''{3}''
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter=Non-null parameter ''{0}'' in method ''{1}'' from ''{2}'' should not override non-annotated parameter from ''{3}''
element.kind.keys=keys
element.kind.values=values
element.kind.objects=objects
mutation.signature.problem.static.method.cannot.mutate.this=Static method cannot mutate 'this'
mutation.signature.problem.reference.to.parameter.invalid=Reference to parameter #{0} is invalid
mutation.signature.problem.parameter.has.immutable.type=Parameter #{0} has immutable type ''{1}''
mutation.signature.problem.invalid.token=Invalid token: {0}; supported are ''this'', ''param1'', ''param2'', and so on.
required.type=Required type
provided.type=Provided
type.mismatch.reason=reason: {0}
inspection.message.code.generation.different.nullability.annotation.will.be.used=The generated code will use ''{1}'' instead of ''{0}''.
change.visibility.level=Make {0} {1}
text.shebang.mechanism.in.java.files.not.permitted=Shebang mechanism in .java files is not permitted
inspection.redundant.tostring.option.notnull.qualifier=Report only when qualifier is known to be not-null
highlighting.try.blocks=Highlighting try blocks...
intention.family.name.remove.new.family.name=Remove 'new'
intention.name.remove.new.display.name=Remove 'new'
inspection.unsatisfied.range.display.name=Return value is outside of declared range
inspection.unsatisfied.range.message=Return value range ''{0}'' is outside of declared range ''{1}''
inspection.unsatisfied.range.message.value=Return value ''{0}'' is outside of declared range ''{1}''