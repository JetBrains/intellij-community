insufficient.language.level={0} are not supported at language level ''{1}''
illegal.unicode.escape=Illegal Unicode escape sequence

annotation.not.allowed.here=Annotations are not allowed here
annotation.not.applicable=''@{0}'' not applicable to {1}
annotation.not.allowed.void='void' type may not be annotated
annotation.not.allowed.var='var' type may not be annotated
annotation.not.allowed.class=Class literal type may not be annotated
annotation.not.allowed.ref=Annotation is not applicable to this kind of reference
annotation.not.allowed.static=Static member qualifying type may not be annotated
annotation.not.allowed.on.package=Package annotations should be in file package-info.java
annotation.type.expected=Annotation type expected
annotation.missing.attribute={0} missing though required
annotation.repeated.target=Repeated annotation target
annotation.attribute.annotation.name.is.missing=Annotation attribute of the form 'name=value' expected
annotation.attribute.unknown.method=Cannot find @interface method ''{0}()''
annotation.attribute.duplicate=Duplicate attribute ''{0}''
annotation.attribute.non.class.literal=Attribute value must be a class literal
annotation.attribute.incompatible.type=Incompatible types. Found: ''{1}'', required: ''{0}''
annotation.attribute.illegal.array.initializer=Illegal initializer for ''{0}''
annotation.attribute.non.enum.constant=Attribute value must be an enum constant
annotation.attribute.non.constant=Attribute value must be constant
annotation.member.may.not.have.throws.list='throws' not allowed on @interface method
annotation.member.may.not.have.parameters=@interface members may not have parameters
annotation.member.invalid.type=Invalid type ''{0}'' for annotation member
annotation.member.clash=@interface member clashes with ''{0}'' in {1}
annotation.may.not.have.extends.list='extends' not allowed on @interface
annotation.cyclic.element.type=Cyclic annotation element type
annotation.container.wrong.place=Container annotation ''{0}'' must not be present at the same time as the element it contains
annotation.container.not.applicable=Container annotation ''@{0}'' is not applicable to {1}
annotation.duplicate=Duplicate annotation
annotation.duplicate.explained=Duplicate annotation. {0}
annotation.duplicate.non.repeatable=Duplicate annotation. The declaration of ''{0}'' does not have a valid java.lang.annotation.Repeatable annotation
annotation.malformed.repeatable.explained={0}
annotation.cannot.be.local=Local annotations are not allowed
annotation.permits='permits' not allowed on @interface

annotation.container.missed.annotation=Container annotation ''{0}'' does not have required @{1} annotation
annotation.container.no.value=Invalid container annotation ''{0}'': no ''value'' method declared
annotation.container.bad.type=Invalid container annotation ''{0}'': ''value'' method should have type ''{1}''
annotation.container.low.retention=Container annotation ''{0}'' has shorter retention (''{1}'') than the contained annotation
annotation.container.wide.target=Target of container annotation ''{0}'' is not a subset of target of this annotation
annotation.container.abstract=Container annotation ''{0}'' does not have a default value for ''{1}''

lambda.not.a.functional.interface={0} is not a functional interface
lambda.no.target.method.found=No target method found
lambda.multiple.sam.candidates=Multiple non-overriding abstract methods found in interface {0}
lambda.sealed.functional.interface=Functional interface can't be declared as 'sealed'

safe.varargs.on.record.component=@SafeVarargs is not allowed on a record component
safe.varargs.on.fixed.arity=@SafeVarargs is not allowed on methods with fixed arity
safe.varargs.on.non.final.method=@SafeVarargs is not allowed on non-final instance methods

receiver.wrong.context=Receivers are not allowed outside of method parameter list
receiver.static.context=The receiver cannot be used in a static context
receiver.wrong.position=The receiver should be the first parameter
receiver.type.mismatch=The receiver type does not match the enclosing class type
receiver.name.mismatch=The receiver name does not match the enclosing class type

override.on.static.method=Static methods cannot be annotated with @Override
override.on.non-overriding.method=Method does not override method from its superclass

class.must.implement.method=Class ''{0}'' must implement abstract method ''{1}'' in ''{2}''
class.must.implement.method.or.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
class.must.implement.method.enum.constant=Enum constant ''{0}'' must implement abstract method ''{1}'' in ''{2}''
class.duplicate=Duplicate class: ''{0}''
class.duplicate.in.other.file=Duplicate class found in the file ''{0}''
class.cyclic.inheritance=Cyclic inheritance involving ''{0}''
class.reference.list.duplicate=Duplicate reference to ''{0}'' in ''{1}'' list
class.reference.list.name.expected=Class name expected
class.reference.list.inner.private=''{0}'' has private access in ''{1}''
class.reference.list.no.enclosing.instance=No enclosing instance of type ''{0}'' is in scope
class.clashes.with.package=Class ''{0}'' clashes with package of same name
class.wrong.filename=Class ''{0}'' is public, should be declared in a file named ''{0}.java''
class.sealed.no.inheritors=Sealed class must have subclasses
class.sealed.incomplete.permits=Sealed class permits clause must contain all subclasses
class.sealed.inheritor.expected.modifiers.can.be.final=Modifier 'sealed', 'non-sealed' or 'final' expected
class.sealed.inheritor.expected.modifiers=Modifier 'sealed' or 'non-sealed' expected
class.sealed.permits.on.non.sealed=Invalid permits clause: ''{0}'' must be sealed
class.cannot.extend.multiple.classes=Class cannot extend multiple classes
class.implements.class=Interface expected here
class.extends.interface=No interface expected here
class.extends.final=Cannot inherit from {1, choice, 1#final class|2#enum|3#record|4#non-abstract value class} ''{0}''
class.extends.prohibited.class=Classes cannot directly extend ''{0}''
class.inherits.type.parameter=Class cannot inherit from its type parameter
class.anonymous.extends.sealed=Anonymous classes must not extend sealed classes
class.already.imported=''{0}'' is already defined in this compilation unit
class.not.enclosing=''{0}'' is not an enclosing class
class.cannot.be.referenced.from.static.context=''{0}'' cannot be referenced from a static context
class.inheritance.different.type.arguments=''{0}'' cannot be inherited with different type arguments: ''{1}'' and ''{2}''
class.inheritance.raw.and.generic=''{0}'' cannot be inherited as a raw type and with generic type arguments ''{1}''
class.not.accessible=Cannot access {0}

class.implicit.no.main.method=Implicitly declared class contains no 'main' method
class.implicit.invalid.file.name=The file name of an implicitly declared class is not a valid identifier
class.implicit.initializer=Initializers are not allowed in implicitly declared classes
class.implicit.package.statement=Package statement is not allowed for implicitly declared class

value.class.extends.non.abstract=Value classes may only extend abstract value classes or 'java.lang.Object'

interface.constructor=Constructor is not allowed in interface
interface.class.initializer=Class initializer is not allowed in interface
interface.implements='implements' not allowed on interface
interface.extends.class=Interface expected here

record.instance.initializer=Instance initializer is not allowed in record
record.instance.field=Instance field is not allowed in record
record.no.header=Record has no header declared
record.header.regular.class=Record header declared for non-record
record.extends='extends' not allowed on record
record.permits='permits' not allowed on record
record.component.vararg.not.last=Vararg record component must be the last in the list
record.component.cstyle.declaration=C-style array declaration not allowed in record component
record.component.restricted.name=Illegal record component name ''{0}''
record.accessor.wrong.return.type=Incorrect component accessor return type. Expected: ''{0}'', found: ''{1}''
record.accessor.non.public=Record component accessor must be 'public'
record.constructor.stronger.access={0} access level cannot be more restrictive than the record access level (''{1}'')
record.special.method.type.parameters={0} cannot have type parameters
record.special.method.throws={0} should not declare ''throws'' clause
record.canonical.constructor.wrong.parameter.type=Incorrect parameter type for record component ''{0}''. Expected: ''{1}'', found: ''{2}''
record.canonical.constructor.wrong.parameter.name=Canonical constructor parameter names must match record component names. Expected: ''{0}'', found: ''{1}''
record.no.constructor.call.in.non.canonical=Non-canonical record constructor must delegate to another constructor

record.canonical.constructor=Canonical constructor
record.compact.constructor=Compact constructor
record.accessor=Record component accessor

vararg.not.last.parameter=Vararg parameter must be the last in the list
vararg.cstyle.array.declaration=C-style array declaration not allowed in vararg parameter

enum.extends='extends' not allowed on enum
enum.permits='permits' not allowed on enum

instantiation.enum=Enum types cannot be instantiated
instantiation.abstract=''{0}'' is abstract; cannot be instantiated

identifier.restricted=''{0}'' is a restricted identifier and cannot be used for type declarations

type.parameter.extends.interface.expected=Interface expected here
type.parameter.cannot.be.followed.by.other.bounds=Type parameter cannot be followed by other bounds
type.parameter.on.enum=Enum may not have type parameters
type.parameter.on.annotation.member=@interface members may not have type parameters
type.parameter.on.annotation=@interface may not have type parameters
type.parameter.duplicate=Duplicate type parameter: ''{0}''
type.parameter.incompatible.upper.bounds=Type parameter {0} has incompatible upper bounds: {1}
type.parameter.inferred.type.not.within.extend.bound=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should extend ''{1}''
type.parameter.inferred.type.not.within.implement.bound=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should implement ''{1}''
type.parameter.type.not.within.extend.bound=Type parameter ''{0}'' is not within its bound; should extend ''{1}''
type.parameter.type.not.within.implement.bound=Type parameter ''{0}'' is not within its bound; should implement ''{1}''
type.parameter.absent.class=Type ''{0}'' does not have type parameters
type.parameter.absent.method=Method ''{0}'' does not have type parameters
type.parameter.count.mismatch=Wrong number of type arguments: {0}; required: {1}
type.parameter.actual.inferred.mismatch=Actual type argument and inferred type contradict each other

method.duplicate=''{0}'' is already defined in ''{1}''
method.throws.class.name.expected=Class name expected
method.interface.body=Interface abstract methods cannot have body
method.abstract.body=Abstract methods cannot have a body
method.native.body=Native methods cannot have a body
method.static.in.interface.should.have.body=Static methods in interfaces should have a body
method.private.in.interface.should.have.body=Private methods in interfaces should have a body
method.default.should.have.body=Extension method should have a body
method.default.in.class=Extension methods can only be used within an interface
method.should.have.body.or.abstract=Method body or 'abstract' modifier expected
method.should.have.body=Method body expected
method.instance.overrides.static=Instance method ''{0}'' in ''{1}'' cannot override static method ''{2}'' in ''{3}''
method.static.overrides.instance=Static method ''{0}'' in ''{1}'' cannot override instance method ''{2}'' in ''{3}''
method.overrides.final=''{0}'' cannot override ''{1}'' in ''{2}''; overridden method is final
method.inheritance.weaker.privileges={0}; attempting to assign weaker access privileges (''{1}''); was ''{2}''
method.inheritance.clash.unrelated.return.types={0}; methods have unrelated return types
method.inheritance.clash.incompatible.return.types={0}; attempting to use incompatible return type
method.inheritance.clash.does.not.throw={0}; overridden method does not throw ''{1}''
method.no.parameter.list=Parameter list expected
method.missing.return.type=Invalid method declaration; return type required
clash.methods.message=''{0}'' clashes with ''{1}''
clash.methods.message.show.classes=''{0}'' in ''{2}'' clashes with ''{1}'' in ''{3}''

constructor.ambiguous.implicit.call=Ambiguous implicit constructor call: both ''{0}'' and ''{1}'' match
constructor.no.default=There is no parameterless constructor available in ''{0}''

type.incompatible=Incompatible types. Found: ''{1}'', required: ''{0}''
type.incompatible.tooltip.required.type=Required type:
type.incompatible.tooltip.provided.type=Provided:
type.incompatible.reason.ambiguous.method.reference=<br/>reason: method reference is ambiguous: both ''{0}'' and ''{1}'' match
type.incompatible.reason.inference=<br/>reason: {0}
type.void.not.allowed='void' type is not allowed here
type.void.illegal=Illegal type: 'void'
type.inaccessible=''{0}'' is inaccessible here
type.restricted.identifier=Illegal reference to restricted type ''{0}''
type.unknown.class=Unknown class: ''{0}''
type.argument.primitive=Type argument cannot be of a primitive type
type.wildcard.cannot.be.instantiated=Wildcard type ''{0}'' cannot be instantiated directly
type.wildcard.not.expected=No wildcard expected
type.wildcard.may.be.used.only.as.reference.parameters=Wildcards may be used only as reference parameters

lvti.no.initializer=Cannot infer type: 'var' on variable without initializer
lvti.lambda=Cannot infer type: lambda expression requires an explicit target type
lvti.method.reference=Cannot infer type: method reference requires an explicit target type
lvti.array='var' is not allowed as an element type of an array
lvti.null=Cannot infer type: variable initializer is 'null'
lvti.void=Cannot infer type: variable initializer is 'void'
lvti.self.referenced=Cannot infer type for ''{0}'', it is used in its own variable initializer
lvti.compound='var' is not allowed in a compound declaration

label.without.statement=Label without statement
label.duplicate=Label ''{0}'' already in use
label.unresolved=Undefined label: ''{0}''
label.must.be.loop=''continue'' target must be a loop label: ''{0}''

break.outside.switch.or.loop='break' outside of switch or loop
break.out.of.switch.expression=Break out of switch expression is not allowed
continue.outside.loop='continue' statement outside of loop
continue.out.of.switch.expression=Continue out of switch expression is not allowed

foreach.not.applicable=Foreach not applicable to type ''{0}''

new.expression.qualified.malformed=Invalid qualified new
new.expression.qualified.static.class=Qualified new of static class
new.expression.qualified.anonymous.implements.interface=Anonymous class implements interface; cannot have qualifier for new
new.expression.qualified.qualified.class.reference=Qualified class reference is not allowed in qualified new
new.expression.diamond.not.allowed=Diamond operator is not allowed here
new.expression.diamond.not.applicable=Diamond operator is not applicable for non-parameterized types
new.expression.diamond.inference.failure={0}
new.expression.diamond.anonymous.inner.non.private=Cannot use '<>' due to non-private method which doesn't override or implement a method from a supertype
new.expression.anonymous.implements.interface.with.type.arguments=Anonymous class implements interface; cannot have type arguments
new.expression.arguments.to.default.constructor.call=Default constructor is invoked with arguments
new.expression.unresolved.constructor=Cannot resolve constructor ''{0}''

reference.type.argument.static.class=Type arguments are not allowed here because class ''{0}'' is static
reference.type.needs.type.arguments=Improperly formed type: ''{0}'' needs type arguments because its qualifier has type arguments
reference.local.class.other.switch.branch=Local class ''{0}'' cannot be referenced from another switch branch
reference.member.before.constructor=Cannot reference ''{0}'' before superclass constructor is called
reference.field.forward=Cannot read value of field ''{0}'' before the field''s definition
reference.field.self=Cannot read value of field ''{0}'' from inside the field''s definition
reference.enum.forward=Cannot refer to enum constant ''{0}'' before its definition
reference.enum.self=Cannot refer to enum constant ''{0}'' from inside its own definition
reference.qualifier.not.expression=Qualifier must be an expression
reference.qualifier.primitive=Cannot access fields on ''{0}'' type
reference.unresolved=Cannot resolve symbol ''{0}''
reference.ambiguous=Reference to ''{0}'' is ambiguous, both ''{1}'' and ''{2}'' match
reference.implicit.class=Implicitly declared class ''{0}'' cannot be referenced

statement.case.outside.switch=Case statement outside switch
statement.invalid=Invalid statement
statement.declaration.not.allowed=Declaration not allowed here
statement.bad.expression=Not a statement

guard.misplaced=Guard is allowed after patterns only
guard.evaluated.to.false=This case label has a guard that is a constant expression with value 'false'

comment.shebang.java.file=Shebang mechanism in .java files is not permitted
comment.unclosed=Unclosed comment

literal.illegal.underscore=Illegal underscore
literal.hexadecimal.no.digits=Hexadecimal numbers must contain at least one hexadecimal digit
literal.binary.no.digits=Binary numbers must contain at least one binary digit
literal.integer.too.large=Integer number too large
literal.long.too.large=Long number too large
literal.floating.malformed=Malformed floating point literal
literal.floating.too.large=Floating point number too large
literal.floating.too.small=Floating point number too small
literal.character.too.long=Too many characters in character literal
literal.character.unclosed=Unclosed character literal
literal.character.illegal.escape=Illegal escape character in character literal
literal.character.empty=Empty character literal
literal.string.illegal.line.end=Line end not allowed in string literals
literal.string.illegal.escape=Illegal escape character in string literal
literal.text.block.unclosed=Unclosed text block
literal.text.block.no.new.line=Illegal text block start: missing new line after opening quotes

#{0} - exceptions list (comma separated), {1} - exceptions count in the list
exception.unhandled=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
#{0} - exceptions list (comma separated), {1} - exceptions count in the list
exception.unhandled.close=Unhandled {1, choice, 0#exception|2#exceptions} from auto-closeable resource: {0}
exception.must.be.disjoint=Types in multi-catch must be disjoint: ''{0}'' is a subclass of ''{1}''
exception.already.caught=Exception ''{0}'' has already been caught
exception.never.thrown.try=Exception ''{0}'' is never thrown in the corresponding try block
exception.never.thrown.try.multi=Exception ''{0}'' is never thrown in the corresponding try block

call.super.enum.constructor=Call to super is not allowed in enum constructor
call.super.qualifier.not.inner.class=Qualifier is not allowed because superclass ''{0}'' is not a non-static inner class
call.expected=Method call expected
call.static.interface.method.qualifier=Static method may only be called on its containing interface
call.formal.varargs.element.type.inaccessible.here=Formal varargs element type {0} is inaccessible here
call.type.inference.error={0}
call.wrong.arguments=''{0}'' in ''{1}'' cannot be applied to ''{2}''
call.wrong.arguments.count.mismatch=Expected {0, choice, 0#no arguments|1#1 argument|1<{0} arguments} but found {1}
call.direct.abstract.method.access=Abstract method ''{0}'' cannot be accessed directly
call.constructor.must.be.first.statement=Call to ''{0}'' must be first statement in constructor body
call.constructor.only.allowed.in.constructor=Call to ''{0}'' only allowed in constructor body
call.constructor.must.be.top.level.statement=Call to ''{0}'' must be top-level statement in constructor body
call.constructor.duplicate=Only one explicit constructor call allowed in constructor
call.constructor.record.in.canonical=Canonical constructor cannot delegate to another constructor
call.constructor.recursive=Recursive constructor call
call.unresolved=Cannot resolve method ''{0}''
call.ambiguous=Ambiguous method call: both ''{0}'' and ''{1}'' match
# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
call.ambiguous.tooltip=\
  <html><body><table border=0>\
  <tr><td colspan={0}>Ambiguous method call. Both</td></tr>\
  <tr>{1}<td>in <b>{2}</b>\\&nbsp;and</td></tr>\
  <tr>{3}<td>in <b>{4}</b>\\&nbsp;match</td></tr>\
  </table></body></html>

array.illegal.initializer=Illegal initializer for ''{0}''
array.initializer.not.allowed=Array initializer is not allowed here
array.type.expected=Array type expected; found: ''{0}''
array.generic=Generic array creation not allowed
array.empty.diamond=Array creation with '<>' not allowed
array.type.arguments=Array creation with type arguments not allowed
array.too.many.dimensions=Too many array dimensions

pattern.type.pattern.expected=Type pattern expected

expression.expected=Expression expected
expression.super.dot.expected='.' expected
expression.super.not.enclosing.class=''{0}'' is not an enclosing class
expression.super.bad.qualifier.method.overridden=Bad type qualifier in default super call: method {0} is overridden in {1}
expression.super.bad.qualifier.redundant.extended=Bad type qualifier in default super call: redundant interface {0} is extended by {1}
expression.super.no.enclosing.instance=No enclosing instance of type ''{0}'' is in scope
expression.super.unqualified.default.method=Unqualified super reference is not allowed in extension method
expression.qualified.class.expected=Class name expected here

assignment.declared.outside.guard=Cannot assign a value to variable ''{0}'', because it is declared outside the guard

binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
unary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}''

string.template.void.not.allowed.in.embedded=Expression with the 'void' type is not allowed as a string template embedded expression
string.template.processor.missing=Processor missing from string template expression
string.template.raw.processor=Raw processor type is not allowed: {0}

modifier.not.allowed=Modifier ''{0}'' not allowed here
modifier.not.allowed.local.class=Modifier ''{0}'' not allowed on local classes
modifier.not.allowed.non.sealed=Modifier 'non-sealed' is not allowed on classes that do not have a sealed superclass
modifier.repeated=Repeated modifier ''{0}''
modifier.incompatible=Illegal combination of modifiers ''{0}'' and ''{1}''

access.private=''{0}'' has private access in ''{1}''
access.protected=''{0}'' has protected access in ''{1}''
access.package.local=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
access.generic.problem=Cannot access ''{0}'' in ''{1}''

incomplete.project.state.pending.reference=Not resolved until the project is fully loaded

import.single.class.conflict=''{0}'' is already defined in a single-type import
import.single.static.class.already.defined=Class ''{0}'' is already defined in a single static import
import.single.static.class.ambiguous=Class ''{0}'' is ambiguous in a single static import
import.single.static.field.already.defined=Field ''{0}'' is already defined in a single static import
import.single.static.field.ambiguous=Field ''{0}'' is ambiguous in a single static import
import.static.on.demand.resolves.to.class=Class {0} not found

underscore.identifier=Since Java 9, '_' is a keyword, and may not be used as an identifier
underscore.identifier.unnamed=Using '_' as a reference is not allowed
underscore.identifier.lambda=Use of '_' as a lambda parameter name is not allowed

unnamed.field.not.allowed=Unnamed field is not allowed
unnamed.method.parameter.not.allowed=Unnamed method parameter is not allowed
unnamed.variable.not.allowed.in.this.context=Unnamed variable declaration is not allowed in this context
unnamed.variable.brackets=Brackets are not allowed after an unnamed variable declaration
unnamed.variable.without.initializer=Unnamed variable declaration must have an initializer

return.outside.switch.expression=Return outside of enclosing switch expression
return.compact.constructor='return' statement is not allowed in compact constructor
return.outside.method=Return outside method
return.before.explicit.constructor.call='return' not allowed before ''{0}'' call
return.value.missing=Missing return value
return.from.void.method=Cannot return a value from a method with void result type
return.from.constructor=Cannot return a value from a constructor

catch.type.parameter=Cannot catch type parameters
