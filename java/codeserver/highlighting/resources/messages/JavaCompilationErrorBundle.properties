# This bundle contains only messages referred from JavaErrorKinds or context objects used there
# Do not add unrelated messages to this bundle 

insufficient.language.level={0} are not supported at language level ''{1}''
illegal.unicode.escape=Illegal Unicode escape sequence
illegal.character=Illegal character: {0}
preview.api.usage={0} is a preview API and is disabled by default
syntax.error={0}

annotation.not.allowed.here=Annotations are not allowed here
annotation.not.applicable=''@{0}'' not applicable to {1}
annotation.not.allowed.void='void' type may not be annotated
annotation.not.allowed.var='var' type may not be annotated
annotation.not.allowed.class=Class literal type may not be annotated
annotation.not.allowed.ref=Annotation is not applicable to this kind of reference
annotation.not.allowed.static=Static member qualifying type may not be annotated
annotation.not.allowed.on.package=Package annotations only allowed in a 'package-info.java' file
annotation.not.allowed.in.permit.list=Annotations not allowed in 'permits' list
annotation.type.expected=Annotation type expected
annotation.missing.attribute={0} missing but required
annotation.repeated.target=Repeated annotation target
annotation.attribute.name.missing=Annotation attribute of the form 'name=value' expected
annotation.attribute.unknown.method=Cannot find @interface method ''{0}()''
annotation.attribute.duplicate=Duplicate attribute ''{0}''
annotation.attribute.non.class.literal=Attribute value must be a class literal
annotation.attribute.incompatible.type=Incompatible types. Found: ''{1}'', required: ''{0}''
annotation.attribute.illegal.array.initializer=Illegal initializer for ''{0}''
annotation.attribute.non.enum.constant=Attribute value must be an enum constant
annotation.attribute.non.constant=Attribute value must be constant
annotation.member.may.not.have.throws.list='throws' not allowed on @interface method
annotation.member.may.not.have.parameters=@interface members may not have parameters
annotation.member.invalid.type=Invalid type ''{0}'' for annotation member
annotation.member.clash=@interface member clashes with ''{0}'' in {1}
annotation.may.not.have.extends.list='extends' not allowed on @interface
annotation.cyclic.element.type=Cyclic annotation element type
annotation.container.wrong.place=Container annotation ''{0}'' must not be present together with the element it contains
annotation.container.not.applicable=Container annotation ''@{0}'' is not applicable to {1}
annotation.duplicate=Duplicate annotation
annotation.duplicate.explained=Duplicate annotation. {0}
annotation.duplicate.non.repeatable=Duplicate annotation. The declaration of ''{0}'' does not have a valid java.lang.annotation.Repeatable annotation
annotation.malformed.repeatable.explained={0}
annotation.cannot.be.local=Local annotations are not allowed
annotation.permits='permits' not allowed on @interface

annotation.container.missed.annotation=Container annotation ''{0}'' does not have required @{1} annotation
annotation.container.no.value=Invalid container annotation ''{0}'': no ''value'' method declared
annotation.container.bad.type=Invalid container annotation ''{0}'': ''value'' method should have type ''{1}''
annotation.container.low.retention=Container annotation ''{0}'' has shorter retention (''{1}'') than the contained annotation
annotation.container.wide.target=Target of container annotation ''{0}'' is not a subset of this annotation\u2019s target
annotation.container.abstract=Container annotation ''{0}'' does not have a default value for ''{1}''

lambda.not.a.functional.interface={0} is not a functional interface
lambda.no.target.method.found=No target method found
lambda.multiple.sam.candidates=Multiple non-overriding abstract methods found in {0}
lambda.sam.generic=Target method is generic
lambda.sealed.functional.interface=Functional interface cannot be declared as 'sealed'
lambda.not.expected=Unexpected lambda expression
lambda.parameters.inconsistent.var=Cannot mix 'var' and explicitly typed parameters in lambda expression
lambda.sealed=Lambda cannot implement a sealed interface
lambda.type.inference.failure=Cannot infer functional interface type
lambda.inference.error={0}
lambda.return.type.error={0}
lambda.target.not.interface=Target type of a lambda conversion must be an interface
lambda.incompatible.parameter.types=Incompatible parameter type in lambda expression: expected {0} but found {1}
lambda.wrong.number.of.parameters=Wrong number of parameters in lambda expression: expected {0} but found {1}

method.reference.not.expected=Method reference expression is not expected here
method.reference.sealed=Method reference cannot implement a sealed interface
method.reference.return.type.error={0}
method.reference.unresolved.constructor=Cannot resolve constructor ''{0}''
method.reference.unresolved.method=Cannot resolve method ''{0}''
method.reference.inference.error={0}
method.reference.raw.constructor=Raw constructor reference with explicit type parameters for constructor
method.reference.qualifier.class.unresolved=Cannot find class {0}
method.reference.qualifier.wildcard=Unexpected wildcard
method.reference.abstract.method=Abstract method ''{0}'' cannot be accessed directly
method.reference.non.static.method.in.static.context=Non-static method cannot be referenced from a static context
method.reference.static.method.non.static.qualifier=Static method referenced through non-static qualifier
method.reference.static.method.receiver=Static method referenced through receiver
method.reference.parameterized.qualifier=Parameterized qualifier on static method reference
method.reference.enclosing.instance.not.in.scope=An enclosing instance of type {0} is not in scope

safe.varargs.on.record.component=@SafeVarargs is not allowed on a record component
safe.varargs.on.fixed.arity=@SafeVarargs is not allowed on methods with fixed arity
safe.varargs.on.non.final.method=@SafeVarargs is not allowed on non-final instance methods

receiver.wrong.context=Receivers are not allowed outside of method\u2019s parameter list
receiver.static.context=The receiver cannot be used in a static context
receiver.wrong.position=The receiver should be the first parameter
receiver.type.mismatch=The receiver type does not match the enclosing class type
receiver.name.mismatch=The receiver name does not match the enclosing class type

override.on.static.method=Static methods cannot be annotated with @Override
override.on.non-overriding.method=Method does not override method from its superclass

class.must.implement.method=Class ''{0}'' must implement abstract method ''{1}'' in ''{2}''
class.must.implement.method.or.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
class.must.implement.method.enum.constant=Enum constant ''{0}'' must implement abstract method ''{1}'' in ''{2}''
class.duplicate=Duplicate class: ''{0}''
class.duplicate.in.other.file=Duplicate class found in the file ''{0}''
class.cyclic.inheritance=Cyclic inheritance involving ''{0}''
class.reference.list.duplicate=Duplicate reference to ''{0}'' in ''{1}'' list
class.reference.list.name.expected=Class name expected
class.reference.list.inner.private=''{0}'' has private access in ''{1}''
class.reference.list.no.enclosing.instance=No enclosing instance of type ''{0}'' is in scope
class.clashes.with.package=Class ''{0}'' clashes with package of same name
class.wrong.filename=Class ''{0}'' is public, should be declared in a file named ''{0}.java''
class.sealed.no.inheritors=Sealed class must have subclasses
class.sealed.incomplete.permits=Sealed class permits clause must contain all subclasses
class.sealed.inheritor.expected.modifiers.can.be.final=Modifier 'sealed', 'non-sealed' or 'final' expected
class.sealed.inheritor.expected.modifiers=Modifier 'sealed' or 'non-sealed' expected
class.sealed.permits.on.non.sealed=Invalid ''permits'' clause: ''{0}'' must be sealed
class.cannot.extend.multiple.classes=Class cannot extend multiple classes
class.implements.class=Interface expected here
class.extends.interface=No interface expected here
class.extends.final=Cannot inherit from {1, choice, 1#final class|2#enum|3#record|4#non-abstract value class} ''{0}''
class.extends.prohibited.class=Classes cannot directly extend ''{0}''
class.extends.sealed.local=Local classes must not extend sealed classes
class.extends.sealed.another.package={0} ''{1}'' from another package not allowed to extend sealed {2} ''{3}'' in unnamed module
class.extends.sealed.another.module=Class is not allowed to extend sealed class from another module
class.extends.sealed.not.permitted=''{0}'' is not allowed in the sealed hierarchy
class.inherits.type.parameter=Class cannot inherit from its type parameter
class.anonymous.extends.sealed=Anonymous classes must not extend sealed classes
class.already.imported=''{0}'' is already defined in this compilation unit
class.not.enclosing=''{0}'' is not an enclosing class
class.cannot.be.referenced.from.static.context=''{0}'' cannot be referenced from a static context
class.inheritance.different.type.arguments=''{0}'' cannot be inherited with different type arguments: ''{1}'' and ''{2}''
class.inheritance.raw.and.generic=''{0}'' cannot be inherited as a raw type and with generic type arguments ''{1}''
class.inheritance.method.clash=Methods {0} from {1} and {2} from {3} are inherited with the same signature
class.not.accessible=Cannot access {0}
class.generic.extends.exception=Generic class may not extend 'java.lang.Throwable'
class.initializer.must.complete.normally=Initializer must be able to complete normally
class.permitted.not.direct.subclass=Invalid ''permits'' clause: ''{0}'' must directly {1, choice, 1#extend|2#implement} ''{2}''
class.permitted.must.have.modifier=All sealed class subclasses must either be final, sealed or non-sealed
class.or.package.expected=Expected class or package
class.inherits.abstract.and.default={0} inherits abstract and default for {1} from types {2} and {3}
class.inherits.unrelated.defaults={0} inherits unrelated defaults for {1} from types {2} and {3}

class.implicit.no.main.method=Compact source file contains no 'main' method
class.implicit.invalid.file.name=The name of a compact source file is not a valid identifier
class.implicit.initializer=Initializers are not allowed in compact source files
class.implicit.package.statement=Package statement is not allowed in compact source files

package.clashes.with.class=Package ''{0}'' clashes with class of same name

value.class.extends.non.abstract=Value classes may only extend abstract value classes or 'java.lang.Object'

interface.constructor=Constructor is not allowed in interface
interface.class.initializer=Class initializer is not allowed in interface
interface.implements='implements' not allowed on interface
interface.extends.class=Interface expected here

record.instance.initializer=Instance initializer is not allowed in records
record.instance.field=Instance field is not allowed in records
record.no.header=Record has no header declared
record.header.regular.class=Record header declared for non-record
record.extends='extends' not allowed on records
record.permits='permits' not allowed on records
record.component.vararg.not.last=Vararg record component must be the last in the list
record.component.cstyle.declaration=C-style array declaration not allowed in record component
record.component.restricted.name=Illegal record component name ''{0}''
record.component.not.initialized=Record component ''{0}'' might not be initialized in canonical constructor
record.accessor.wrong.return.type=Incorrect component accessor return type. Expected: ''{0}'', found: ''{1}''
record.accessor.non.public=Record component accessor must be 'public'
record.constructor.stronger.access={0} access level cannot be more restrictive than the record access level (''{1}'')
record.special.method.type.parameters={0} cannot have type parameters
record.special.method.throws={0} should not declare a ''throws'' clause
record.canonical.constructor.wrong.parameter.type=Incorrect parameter type for record component ''{0}''. Expected: ''{1}'', found: ''{2}''
record.canonical.constructor.wrong.parameter.name=Canonical constructor parameter names must match record component names. Expected: ''{0}'', found: ''{1}''
record.no.constructor.call.in.non.canonical=Non-canonical record constructor must delegate to another constructor

record.canonical.constructor=Canonical constructor
record.compact.constructor=Compact constructor
record.accessor=Record component accessor

vararg.not.last.parameter=Vararg parameter must be the last in the list
vararg.cstyle.array.declaration=C-style array declaration not allowed in vararg parameter

enum.extends='extends' not allowed on enum
enum.permits='permits' not allowed on enum
enum.constant.illegal.access.in.constructor=Accessing {0, choice, 1#static field|2#enum constant} from enum {1, choice, 1#constructor|2#instance field initializer|3#instance initializer} is not allowed
enum.constant.modifier=No modifiers allowed for enum constants

instantiation.enum=Enum types cannot be instantiated
instantiation.abstract=''{0}'' is abstract; cannot be instantiated
instantiation.local.class.wrong.static.context=Local class ''{0}'' cannot be instantiated from a different static context

identifier.restricted=''{0}'' is a restricted identifier and cannot be used for type declarations

type.parameter.extends.interface.expected=Interface expected here
type.parameter.cannot.be.followed.by.other.bounds=Type parameter cannot be followed by other bounds
type.parameter.on.enum=Enum may not have type parameters
type.parameter.on.annotation.member=@interface members may not have type parameters
type.parameter.on.annotation=@interface may not have type parameters
type.parameter.duplicate=Duplicate type parameter: ''{0}''
type.parameter.incompatible.upper.bounds=Type parameter {0} has incompatible upper bounds: {1}
type.parameter.inferred.type.not.within.extend.bound=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should extend ''{1}''
type.parameter.inferred.type.not.within.implement.bound=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should implement ''{1}''
type.parameter.type.not.within.extend.bound=Type parameter ''{0}'' is not within its bound; should extend ''{1}''
type.parameter.type.not.within.implement.bound=Type parameter ''{0}'' is not within its bound; should implement ''{1}''
type.parameter.absent.class=Type ''{0}'' does not have type parameters
type.parameter.absent.method=Method ''{0}'' does not have type parameters
type.parameter.count.mismatch=Wrong number of type arguments: {0}; required: {1}
type.parameter.actual.inferred.mismatch=Actual type argument and inferred type contradict each other

method.duplicate=''{0}'' is already defined in ''{1}''
method.throws.class.name.expected=Class name expected
method.interface.body=Interface abstract methods cannot have a body
method.abstract.body=Abstract methods cannot have a body
method.abstract.in.non.abstract.class=Abstract method in non-abstract class
method.native.body=Native methods cannot have a body
method.static.in.interface.should.have.body=Static methods in interfaces should have a body
method.private.in.interface.should.have.body=Private methods in interfaces should have a body
method.default.should.have.body=Extension method should have a body
method.default.in.class=Extension methods can only be used within an interface
method.default.overrides.object.member=Default method ''{0}'' overrides a member of ''java.lang.Object''
method.should.have.body.or.abstract=Method body or 'abstract' modifier expected
method.should.have.body=Method body expected
method.instance.overrides.static=Instance method ''{0}'' in ''{1}'' cannot override static method ''{2}'' in ''{3}''
method.static.overrides.instance=Static method ''{0}'' in ''{1}'' cannot override instance method ''{2}'' in ''{3}''
method.overrides.final=''{0}'' cannot override ''{1}'' in ''{2}''; overridden method is final
method.inheritance.weaker.privileges={0}; attempting to assign weaker access privileges (''{1}''); was ''{2}''
method.inheritance.clash.unrelated.return.types={0}; methods have unrelated return types
method.inheritance.clash.incompatible.return.types={0}; incompatible return type
method.inheritance.clash.does.not.throw={0}; overridden method does not throw ''{1}''
method.no.parameter.list=Parameter list expected
method.missing.return.type=Invalid method declaration; return type required
method.generic.same.erasure={0}; both methods have same erasure
method.generic.same.erasure.override={0}; both methods have same erasure, yet neither overrides the other
method.generic.same.erasure.hide={0}; both methods have same erasure, yet neither hides the other
clash.methods.message=''{0}'' clashes with ''{1}''
clash.methods.message.show.classes=''{0}'' in ''{2}'' clashes with ''{1}'' in ''{3}''

constructor.ambiguous.implicit.call=Ambiguous implicit constructor call: both ''{0}'' and ''{1}'' match
constructor.no.default=There is no no-arg constructor available in ''{0}''
constructor.in.implicit.class=Explicit constructor in implicitly declared class of a compact source file is not allowed

type.incompatible=Incompatible types. Found: ''{1}'', required: ''{0}''
type.incompatible.tooltip.required.type=Required type:
type.incompatible.tooltip.provided.type=Provided:
type.incompatible.reason.ambiguous.method.reference=reason: method reference is ambiguous: both ''{0}'' and ''{1}'' match
type.incompatible.reason.inference=reason: {0}
type.void.not.allowed='void' type is not allowed here
type.void.illegal=Illegal type: 'void'
type.inaccessible=''{0}'' is inaccessible from here
type.restricted.identifier=Illegal reference to restricted type ''{0}''
type.unknown.class=Unknown class: ''{0}''
type.argument.primitive=Type argument cannot be of a primitive type
type.argument.not.allowed=Reference parameters are not allowed here
type.argument.on.raw.type=Type arguments given on a raw type
type.argument.on.raw.method=Type arguments given on a raw method
type.argument.in.permits.list=Generics are not allowed in permits list
type.wildcard.cannot.be.instantiated=Wildcard type ''{0}'' cannot be instantiated directly
type.wildcard.not.expected=No wildcard expected
type.wildcard.may.be.used.only.as.reference.parameters=Wildcards may only be used as reference parameters

lvti.no.initializer=Cannot infer type: 'var' on variable without an initializer
lvti.lambda=Cannot infer type: lambda expression requires an explicit target type
lvti.method.reference=Cannot infer type: method reference requires an explicit target type
lvti.array='var' is not allowed as an element type of an array
lvti.null=Cannot infer type: variable initializer is 'null'
lvti.void=Cannot infer type: variable initializer is 'void'
lvti.self.referenced=Cannot infer type for ''{0}'', it is used in its own variable initializer
lvti.compound='var' is not allowed in a compound declaration

label.without.statement=Label without statement
label.duplicate=Label ''{0}'' already in use
label.unresolved=Undefined label: ''{0}''
label.must.be.loop=''continue'' target must be a loop label: ''{0}''

break.outside.switch.or.loop='break' outside of switch or loop
break.out.of.switch.expression=Break out of switch expression is not allowed
continue.outside.loop='continue' statement outside of loop
continue.out.of.switch.expression=Continue out of switch expression is not allowed

yield.unexpected='yield' outside of a switch expression
yield.void=Expression type should not be 'void'

foreach.not.applicable=Foreach not applicable to type ''{0}''

new.expression.qualified.malformed=Invalid qualified new
new.expression.qualified.static.class=Qualified new of static class
new.expression.qualified.anonymous.implements.interface=Unexpected qualifier for anonymous class implementing interface
new.expression.qualified.qualified.class.reference=Qualified class reference is not allowed in qualified new
new.expression.diamond.not.allowed=Diamond operator is not allowed here
new.expression.diamond.not.applicable=Diamond operator is not applicable to non-parameterized types
new.expression.diamond.inference.failure={0}
new.expression.diamond.anonymous.inner.non.private=Cannot use '<>' due to a non-private method which doesn't override or implement a method from a supertype
new.expression.anonymous.implements.interface.with.type.arguments=Anonymous class implements interface; cannot have type arguments
new.expression.arguments.to.default.constructor.call=Default constructor is invoked with arguments
new.expression.unresolved.constructor=Cannot resolve constructor ''{0}''
new.expression.type.parameter=Type parameter ''{0}'' cannot be instantiated directly

reference.type.argument.static.class=Type arguments are not allowed here because class ''{0}'' is static
reference.type.needs.type.arguments=Improperly formed type: ''{0}'' needs type arguments because its qualifier has type arguments
reference.local.class.other.switch.branch=Local class ''{0}'' cannot be referenced from another switch branch
reference.member.before.constructor=Cannot reference ''{0}'' before superclass constructor is called
reference.field.forward=Cannot read value of field ''{0}'' before the field''s definition
reference.field.self=Cannot read value of field ''{0}'' from inside the field''s definition
reference.enum.forward=Cannot refer to enum constant ''{0}'' before its definition
reference.enum.self=Cannot refer to enum constant ''{0}'' from inside its own definition
reference.qualifier.not.expression=Qualifier must be an expression
reference.qualifier.primitive=Cannot access fields on ''{0}'' type
reference.unresolved=Cannot resolve symbol ''{0}''
reference.ambiguous=Reference to ''{0}'' is ambiguous, both ''{1}'' and ''{2}'' match
reference.implicit.class=Implicitly declared class of a compact source file ''{0}'' cannot be referenced
reference.class.in.default.package=Class ''{0}'' is in the default package
reference.non.static.from.static.context=Non-static {0} ''{1}'' cannot be referenced from a static context
reference.outer.type.parameter.from.static.context=''{0}'' cannot be referenced from a static context
reference.select.from.type.parameter=Cannot select from a type parameter
reference.package.not.found=Package not found: {0}

statement.case.outside.switch=Case statement outside switch
statement.invalid=Invalid statement
statement.declaration.not.allowed=Declaration not allowed here
statement.bad.expression=Not a statement
statement.unreachable=Unreachable statement
statement.unreachable.loop.body=Loop condition is always false making the loop body unreachable

switch.rule.should.produce.result=Switch expression rule should produce a result in all execution paths
switch.expression.no.result='switch' expression does not have any result expressions
switch.expression.should.produce.result=Switch expression should produce a result in all execution paths
switch.expression.incompatible.type=Bad type in switch expression: {0} cannot be converted to {1}
switch.expression.cannot.be.void=Target type for switch expression cannot be void
switch.label.expected=Statement must be prepended with a case label
switch.different.case.kinds=Different 'case' kinds used in 'switch'
switch.selector.type.invalid=Selector type of ''{0}'' is not supported
switch.selector.type.invalid.level=Selector type of ''{0}'' is not supported at language level ''{1}''
switch.null.type.incompatible=''null'' cannot be converted to ''{0}''
switch.null.label.not.allowed=Invalid case label combination: 'null' can only be used as a single case label or paired only with 'default'
switch.label.qualified.enum=An enum switch case label must be the unqualified name of an enumeration constant
switch.label.constant.expected=Constant expression required
switch.label.pattern.expected=Pattern expected for switch selector type ''{0}''
switch.label.unexpected=Constant expression, pattern or null is required
switch.label.duplicate.unconditional.pattern=Duplicate unconditional pattern
switch.label.duplicate.default=Duplicate default label
switch.label.duplicate=Duplicate label ''{0}''
switch.fallthrough.to.pattern=Illegal fall-through to a pattern
switch.multiple.labels.with.pattern.variables=Multiple switch labels are permitted for a switch labeled statement group only if none of them declare any pattern variables
switch.default.null.order=Invalid case label order: 'null' must be first and 'default' must be second
switch.default.label.not.allowed=Default label not allowed here: 'default' can only be used as a single case label or paired only with 'null'
switch.label.combination.constants.and.patterns=Invalid case label combination: a case label must consist of either a list of case constants or a single case pattern
switch.label.combination.constants.and.patterns.unnamed=Invalid case label combination: a case label must consist of either a list of case constants or a list of case patterns
switch.label.multiple.patterns=Invalid case label combination: a case label must not consist of more than one case pattern
switch.label.multiple.patterns.unnamed=Invalid case label combination: multiple patterns are allowed only if none of them declare any pattern variables
switch.dominance.violation=Label is dominated by a preceding case label ''{0}''
switch.default.and.boolean='switch' has all boolean values and a default label
switch.default.label.contains.case=The label for the default case must only use the 'default' keyword, without 'case'
switch.unconditional.pattern.and.default='switch' has both an unconditional pattern and a default label
switch.unconditional.pattern.and.boolean='switch' has all boolean values and an unconditional pattern
switch.empty=''switch'' {0} does not have any case clauses
switch.incomplete=''switch'' {0} does not cover all possible input values

guard.misplaced=Guard is allowed after patterns only
guard.evaluated.to.false=Case label has a guard that is a constant expression with value 'false'

comment.shebang.java.file=Shebang mechanism in .java files is not permitted
comment.unclosed=Unclosed comment

literal.illegal.underscore=Illegal underscore
literal.hexadecimal.no.digits=Hexadecimal numbers must contain at least one hexadecimal digit
literal.binary.no.digits=Binary numbers must contain at least one binary digit
literal.integer.too.large=Integer number too large
literal.long.too.large=Long number too large
literal.floating.malformed=Malformed floating point literal
literal.floating.too.large=Floating point number too large
literal.floating.too.small=Floating point number too small
literal.character.too.long=Too many characters in character literal
literal.character.unclosed=Unclosed character literal
literal.character.illegal.escape=Illegal escape character in character literal
literal.character.empty=Empty character literal
literal.string.illegal.line.end=Line end not allowed in string literals
literal.string.illegal.escape=Illegal escape character in string literal
literal.text.block.unclosed=Unclosed text block
literal.text.block.no.new.line=Illegal text block start: missing new line after opening quotes

#{0} - exception list (comma separated), {1} - exceptions count in the list
exception.unhandled=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
#{0} - exception list (comma separated), {1} - exceptions count in the list
exception.unhandled.close=Unhandled {1, choice, 0#exception|2#exceptions} from auto-closeable resource: {0}
exception.must.be.disjoint=Types in multi-catch must be disjoint: ''{0}'' is a subclass of ''{1}''
exception.already.caught=Exception ''{0}'' has already been caught
exception.never.thrown.try=Exception ''{0}'' is never thrown in the corresponding try block
exception.never.thrown.try.multi=Exception ''{0}'' is never thrown in the corresponding try block

call.super.enum.constructor=Call to 'super' is not allowed in enum constructor
call.super.qualifier.not.inner.class=Qualifier is not allowed because superclass ''{0}'' is not a non-static inner class
call.expected=Method call expected
call.static.interface.method.qualifier=Static method may only be called on its containing interface
call.formal.varargs.element.type.inaccessible.here=Formal varargs element type {0} is inaccessible from here
call.type.inference.error={0}
call.wrong.arguments=''{0}'' in ''{1}'' cannot be applied to ''{2}''
call.wrong.arguments.count.mismatch=Expected {0, choice, 0#no arguments|1#1 argument|1<{0} arguments} but found {1}
call.direct.abstract.method.access=Abstract method ''{0}'' cannot be accessed directly
call.constructor.must.be.first.statement=Call to ''{0}'' must be first statement in constructor body
call.constructor.only.allowed.in.constructor=Call to ''{0}'' only allowed in constructor body
call.constructor.must.be.top.level.statement=Call to ''{0}'' must be top-level statement in constructor body
call.constructor.duplicate=Only one explicit constructor call allowed in constructor
call.constructor.record.in.canonical=Canonical constructor cannot delegate to another constructor
call.constructor.recursive=Recursive constructor call
call.unresolved=Cannot resolve method ''{0}''
call.unresolved.name=Cannot resolve method ''{0}''
call.qualifier.primitive=Cannot call methods on ''{0}'' type
call.ambiguous.no.match=Cannot resolve method ''{0}'' in ''{1}''
call.ambiguous=Ambiguous method call: both ''{0}'' and ''{1}'' match
# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
call.ambiguous.tooltip=\
  <html><body><table border=0>\
  <tr><td colspan={0}>Ambiguous method call. Both</td></tr>\
  <tr>{1}<td>in <b>{2}</b>\\&nbsp;and</td></tr>\
  <tr>{3}<td>in <b>{4}</b>\\&nbsp;match</td></tr>\
  </table></body></html>
call.parsed.as.deconstruction.pattern=Constant expression, pattern or null is required
call.member.before.constructor=Cannot call ''{0}'' before superclass constructor is called

array.illegal.initializer=Illegal initializer for ''{0}''
array.initializer.not.allowed=Array initializer is not allowed here
array.type.expected=Array type expected; found: ''{0}''
array.generic=Generic array creation not allowed
array.empty.diamond=Array creation with '<>' not allowed
array.type.arguments=Array creation with type arguments not allowed
array.too.many.dimensions=Too many array dimensions


pattern.type.pattern.expected=Type pattern expected
pattern.deconstruction.variable=Identifier is not allowed here
pattern.deconstruction.annotation=Annotations are not allowed in deconstruction pattern types
pattern.deconstruction.requires.record=Deconstruction pattern can only be applied to a record, ''{0}'' is not a record
pattern.deconstruction.count.mismatch=Incorrect number of nested patterns: expected {0} but found {1}
pattern.not.exhaustive=Pattern ''{0}'' is not exhaustive on ''{1}''
pattern.unsafe.cast=''{0}'' cannot be safely cast to ''{1}''
pattern.cannot.infer.type=Cannot infer pattern type: {0}
pattern.instanceof.supertype=Pattern type ''{0}'' is a supertype of expression type ''{1}''
pattern.instanceof.equals=Pattern type ''{0}'' is the same as expression type
pattern.expected.class.or.array.type=Class or array type is required

variable.must.be.final=Variable ''{0}'' is accessed from within inner class, needs to be declared final
variable.must.be.final.resource=Variable used as a try-with-resources resource should be final or effectively final
variable.must.be.effectively.final=Variable ''{0}'' is accessed from within inner class, needs to be final or effectively final
variable.must.be.effectively.final.lambda=Variable used in lambda expression should be final or effectively final
variable.must.be.effectively.final.guard=Variable used in guard expression should be final or effectively final
variable.not.initialized=Variable ''{0}'' might not have been initialized
variable.already.assigned=Variable ''{0}'' might already have been assigned to
variable.already.assigned.constructor=Cannot assign final field ''{0}'' {1, choice, 1#before|2#after} chained constructor call
variable.already.assigned.field=Final field ''{0}'' is already initialized in another field initializer
variable.already.assigned.initializer=Final field ''{0}'' is already initialized in a class initializer
variable.assigned.in.loop=Variable ''{0}'' might be assigned in a loop
variable.already.defined=Variable ''{0}'' is already defined in the scope
field.not.initialized=Field ''{0}'' might not have been initialized
field.initialized.before.constructor.call=Cannot assign initialized field ''{0}'' before superclass constructor is called

instanceof.type.parameter=Class or array expected
instanceof.illegal.generic.type=Illegal generic type for instanceof
instanceof.unsafe.cast=''{0}'' cannot be safely cast to ''{1}''

cast.inconvertible=Inconvertible types; cannot cast ''{0}'' to ''{1}''
cast.intersection.not.interface=Interface expected here
cast.intersection.unexpected.type=Unexpected type: class is expected
cast.intersection.repeated.interface=Repeated interface
cast.intersection.inheritance.clash={0} cannot be inherited with different arguments: {1} and {2}

expression.expected=Expression expected
expression.super.dot.expected='.' expected
expression.super.not.enclosing.class=''{0}'' is not an enclosing class
expression.super.bad.qualifier.method.overridden=Bad type qualifier in default super call: method {0} is overridden in {1}
expression.super.bad.qualifier.redundant.extended=Bad type qualifier in default super call: redundant interface {0} is extended by {1}
expression.super.no.enclosing.instance=No enclosing instance of type ''{0}'' is in scope
expression.super.unqualified.default.method=Unqualified super reference is not allowed in extension method
expression.qualified.class.expected=Class name expected here
expression.class.type.parameter=Cannot access class object of a type parameter
expression.class.parameterized.type=Cannot access class object of a parameterized type

resource.declaration.or.variable.expected=Declaration, final, or effectively final variable expected

assignment.declared.outside.guard=Cannot assign a value to variable ''{0}'', because it is declared outside the guard
assignment.to.final.variable=Cannot assign a value to final variable ''{0}''
lvalue.variable.expected=Variable expected

binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
unary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}''

string.template.void.not.allowed.in.embedded=Expression with the 'void' type is not allowed as a string template embedded expression
string.template.processor.missing=Processor missing from string template expression
string.template.raw.processor=Raw processor type is not allowed: {0}

modifier.not.allowed=Modifier ''{0}'' not allowed here
modifier.not.allowed.local.class=Modifier ''{0}'' not allowed on local classes
modifier.not.allowed.non.sealed=Modifier 'non-sealed' is not allowed on classes that do not have a sealed superclass
modifier.repeated=Repeated modifier ''{0}''
modifier.incompatible=Illegal combination of modifiers ''{0}'' and ''{1}''

access.private=''{0}'' has private access in ''{1}''
access.protected=''{0}'' has protected access in ''{1}''
access.package.local=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
access.generic.problem=Cannot access ''{0}'' in ''{1}''

incomplete.project.state.pending.reference=Not resolved until the project is fully loaded

import.single.class.conflict=''{0}'' is already defined in a single-type import
import.single.static.class.already.defined=Class ''{0}'' is already defined in a single static import
import.single.static.class.ambiguous=Class ''{0}'' is ambiguous in a single static import
import.single.static.field.already.defined=Field ''{0}'' is already defined in a single static import
import.single.static.field.ambiguous=Field ''{0}'' is ambiguous in a single static import
import.static.on.demand.resolves.to.class=Class {0} not found
import.list.extra.semicolon=Extra semicolons between import statements are not allowed

underscore.identifier=Since Java 9, '_' is a keyword and may not be used as an identifier
underscore.identifier.unnamed=Using '_' as a reference is not allowed
underscore.identifier.lambda=Use of '_' as a lambda parameter name is not allowed

unnamed.field.not.allowed=Unnamed field is not allowed
unnamed.method.parameter.not.allowed=Unnamed method parameter is not allowed
unnamed.variable.not.allowed.in.this.context=Unnamed variable declaration is not allowed in this context
unnamed.variable.brackets=Brackets are not allowed after an unnamed variable declaration
unnamed.variable.without.initializer=Unnamed variable declaration must have an initializer

return.outside.switch.expression=Return outside of enclosing switch expression
return.compact.constructor='return' statement is not allowed in compact constructor
return.outside.method=Return outside method
return.before.explicit.constructor.call=''return'' not allowed before ''{0}'' call
return.value.missing=Missing return value
return.from.void.method=Cannot return a value from a method with void result type
return.from.constructor=Cannot return a value from a constructor
return.missing=Missing return statement

catch.type.parameter=Cannot catch type parameters

module.no.package=A module file should not have a 'package' statement
module.conflicting.packages=Package ''{0}'' exists in another module: {1}
module.conflicting.reads=Module ''{0}'' reads package ''{1}'' from both ''{2}'' and ''{3}''
module.file.wrong.name=Module declarations only allowed in a 'module-info.java' file
module.file.duplicate='module-info.java' already exists in the module
module.duplicate.requires=Duplicate ''requires'': {0}
module.duplicate.exports=Duplicate ''exports'': {0}
module.duplicate.exports.target=Duplicate ''exports'' target: {0}
module.duplicate.opens=Duplicate ''opens'': {0}
module.duplicate.opens.target=Duplicate ''opens'' target: {0}
module.duplicate.uses=Duplicate ''uses'': {0}
module.duplicate.provides=Duplicate ''provides'': {0}
module.duplicate.implementation=Duplicate implementation: {0}
module.file.wrong.location=Module declaration should be located in a module's source root
module.opens.in.weak.module='opens' is not allowed in an open module
module.service.enum=The service definition is an enum: {0}
module.service.alien=The service implementation must be defined in the same module as the provides directive
module.service.provider.type=The ''provider'' method return type must be a subtype of the service interface type: {0}
module.service.implementation.type=The service implementation type must be a subtype of the service interface type, or have a public static no-args 'provider' method
module.service.abstract=The service implementation is an abstract class: {0}
module.service.inner=The service implementation is an inner class: {0}
module.service.no.constructor=The service implementation does not have a public default constructor: {0}
module.not.found=Module not found: {0}
module.not.on.path=Module is not in dependencies: {0}
module.cyclic.dependence=Cyclic dependency: {0}
module.reference.package.not.found=Package not found: {0}
module.reference.package.empty=Package is empty: {0}
module.access.from.named=Package ''{0}'' is declared in module ''{1}'', which does not export it to module ''{2}''
module.access.from.unnamed=Package ''{0}'' is declared in module ''{1}'', which does not export it to the unnamed module
module.access.to.unnamed=Package ''{0}'' is declared in the unnamed module, but module ''{1}'' does not read it
module.access.package.bad.name=Package ''{0}'' is declared in module with an invalid name (''{1}'')
module.access.bad.name=Module ''{0}'' has an invalid name
module.access.package.not.in.graph=Package ''{0}'' is declared in module ''{1}'', which is not in the module graph
module.access.not.in.graph=Module ''{0}'' is missing from the module graph
module.access.package.does.not.read=Package ''{0}'' is declared in module ''{1}'', but module ''{2}'' does not read it
module.access.does.not.read=Module ''{0}'' fails to read ''{1}''
module.access.jps.dependency.problem=Module dependency for ''{0}'' is not specified in project structure
module.import.not.allowed=Module import is not allowed
