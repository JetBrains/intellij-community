0.is.not.an.identifier=''{0}'' is not an identifier.
annotation.name.is.missing=Annotation attribute of the form 'name=value' expected
implicit.class.context.display=Implicit class
anonymous.class.context.display=Anonymous in {0}
anonymous.class.derived.display=Anonymous class derived from {0}
aux.context.display=of {0}
class.file.version=ver. {0}
bound.not.expected=Unexpected bound
catch.without.try='catch' without 'try'
class.context.display={0} in {1}
class.literal.expected=.class expected
context.type.java.comment=Comment
context.type.string=String

default.language.level.description=SDK default

# These constants are used from JavaElementKind
# When localizing you may use the parameter #0 which signals the desired grammatical case:
# 0 = nominative case (subject)
# 1 = accusative case (object)
element.abstract_method=abstract method
element.annotation=annotation
element.anonymous_class=anonymous class
element.class=class
element.type.parameter=type parameter
element.type.parameters=type parameters
element.constant=constant field
element.constructor=constructor
element.enum=enum
element.enum_constant=enum constant
element.expression=expression
element.field=field
element.initializer=initializer
element.interface=interface
element.label=label
element.local_variable=local variable
element.method=method
element.module=module
element.package=package
element.package.statement=package statement
element.parameter=parameter
element.pattern_variable=pattern variable
element.record=record
element.record_component=record component
element.snippet_body=snippet body
element.statement=statement
element.unknown=element
element.variable=variable
element.throws.list=throws list
element.extends.list=extends list
element.permits.list=permits list
element.type.arguments=type arguments
element.type.semicolon=semicolon
element.receiver.parameter=receiver parameter
element.method.call=method call

feature.assertions=Assertions
feature.enums=Enums
feature.generics=Generics
feature.annotations=Annotations
feature.override.interface=@Override in interfaces
feature.static.imports=Static imports
feature.for.each=For-each loops
feature.varargs=Variable arity methods
feature.hex.fp.literals=Hexadecimal floating point literals
feature.diamond.types=Diamond types
feature.multi.catch=Multi-catches
feature.try.with.resources=Try-with-resources
feature.binary.literals=Binary literals
feature.underscores.in.literals=Underscores in literals
feature.string.switch=Strings in 'switch' statements
feature.objects.class=java.util.Objects API
feature.stream.and.optional.api=Stream and Optional API
feature.advanced.collection.api=Lambda methods in collections
feature.with.initial=ThreadLocal.withInitial()
feature.extension.methods=Extension methods
feature.method.references=Method references
feature.lambda.expressions=Lambda expressions
feature.type.annotations=Type annotations
feature.type.receivers=Receiver parameters
feature.intersections.in.casts=Intersection types in casts
feature.static.interface.calls=Static interface method calls
feature.effectively.final=Effectively final variables
feature.try.with.resources.refs=Resource references
feature.modules=Modules
feature.private.interface.methods=Private interface methods
feature.utf8.property.files=Property files in UTF-8 encoding
feature.collection.factories=Collection factory methods
feature.lvti=Local variable type inference
feature.var.lambda.parameter='var' in lambda parameters
feature.nestmates=Nest-based access control
feature.text.blocks=Text block literals
feature.text.block.escape.sequences='\\s' escape sequences
feature.enhanced.switch=Enhanced 'switch' blocks
feature.switch.expressions='switch' expressions
feature.serial.annotation=@Serial annotation
feature.records=Records
feature.patterns.instanceof=Patterns in 'instanceof'
feature.sealed.classes=Sealed classes
feature.strictfp=Always-strict floating point semantics
feature.no.this.capture=Inner classes don't capture 'this'
feature.local.interfaces=Local interfaces
feature.local.enums=Local enums
feature.inner.statics=Static declarations in inner classes
feature.patterns.in.switch=Patterns in switch
feature.javadoc.snippets=@snippet in Javadoc
feature.pattern.guard.and.record.patterns=Pattern guards and record patterns
feature.record.patterns.in.for.each=Record patterns in for-each loops
feature.primitive.types.in.patterns=Primitive types in patterns, instanceof and switch
feature.implicit.import.in.implicit.classes=Implicit import in implicitly declared classes
feature.enum.qualified.name.in.switch=Qualified enum as a constant in switch
feature.string.templates=String templates
feature.unnamed.vars=Unnamed patterns and variables
feature.implicit.classes=Implicitly declared classes
feature.instance.main.method=Instance main method
feature.inherited.static.main.method=Inherited static main method
feature.scoped.values=Scoped Values
feature.structured.concurrency=Structured Concurrency
feature.sequenced.collections=Sequenced Collections
feature.classfile.api=ClassFile API
feature.stream.gatherers=Stream Gatherers
feature.foreign.functions=Foreign Function & Memory API
feature.virtual.threads=Virtual Threads
feature.statements.before.super=Statements before super()
feature.module.import.declarations=Module Import Declarations

else.without.if='else' without 'if'
enum.constant.context=Enum constant ''{0}'' in ''{1}''
expected.array.initializer=Array initializer expected
expected.boolean.expression=Boolean expression expected
expected.catch.or.finally='catch' or 'finally' expected
expected.class.or.interface='class' or 'interface' expected
expected.class.reference=Class reference expected
expected.colon=':' expected
expected.colon.or.arrow=':' or '->' expected
expected.comma=',' expected
expected.comma.or.rparen=',' or ')' expected
expected.comma.or.semicolon=',' or ';' expected
expected.dot='.' expected
expected.eq='=' expected
expected.expression=Expression expected
expected.case.label.element=Expression, pattern, 'default' or 'null' expected
expected.template.fragment=Template fragment expected
expected.gt='>' expected.
expected.gt.or.comma='>' or ',' expected
expected.identifier=Identifier expected
expected.identifier.or.type=Identifier or type expected
expected.lbrace='{' expected
expected.lbrace.or.semicolon='{' or ';' expected
expected.lbracket='[' expected
expected.lparen='(' expected
expected.lparen.or.lbracket='(' or '[' expected
expected.lt.or.lparen='<' or '(' expected
expected.module.declaration=Module declaration expected
expected.module.statement=Module directive expected
expected.package.reference=Package reference expected
expected.parameter=Parameter expected
expected.parameter.or.rparen=Annotation attribute or ')' expected
expected.rbrace='}' expected
expected.rbracket=']' expected
expected.resource=Resource definition expected
expected.rparen=')' expected
expected.semicolon=';' expected
expected.identifier.or.semicolon=Identifier or ';' expected
expected.statement=Statement expected
expected.string=String literal expected
expected.switch.label='case', 'default' or '}' expected
expected.switch.rule=Expression, block or throw statement expected
expected.type=Type expected
expected.type.parameter=Type parameter expected
expected.value=Value expected
expected.while='while' expected
expected.with='with' expected
expected.pattern=Pattern expected
filetype.class.description=Java class
filetype.class.display.name=Java class
filetype.java.module.display.name=Java module
filetype.java.description=Java
filetype.java.module.description=Java module
filetype.jshell.description=JShell snippet
finally.without.try='finally' without 'try'
import.statement.identifier.or.asterisk.expected.=Identifier or '*' expected

java.terms.anonymous.class.base.ref=anonymous {0}
javadoc.exception.tag.class.is.not.throwable=Class {0} is not a descendant of Throwable
javadoc.exception.tag.exception.is.not.thrown={0} is not declared to be thrown by method {1}
javadoc.exception.tag.wrong.tag.value=Wrong tag value
javadoc.param.tag.parameter.name.expected=Parameter name expected
javadoc.param.tag.type.parameter.gt.expected='>' expected
javadoc.param.tag.type.parameter.name.expected=Type parameter name expected
javadoc.ref.tag.class.ref.expected=Class reference expected
javadoc.value.field.required=@value tag must reference a field
javadoc.value.field.with.initializer.required=@value tag must reference a field with a constant initializer
javadoc.value.static.field.required=@value tag must reference a static field
javadoc.value.tag.jdk15.required=@value tag may not have any arguments when JDK 1.4 or earlier is used
jdk.1.3.language.level.description=1.3 - Plain old Java
jdk.1.4.language.level.description=1.4 - 'assert' keyword
jdk.1.5.language.level.description=5 - 'enum' keyword, generics, autoboxing, etc.
jdk.1.6.language.level.description=6 - @Override in interfaces
jdk.1.7.language.level.description=7 - Diamonds, ARM, multi-catch, etc.
jdk.1.8.language.level.description=8 - Lambdas, type annotations, etc.
jdk.1.9.language.level.description=9 - Modules, private methods in interfaces, etc.
jdk.10.language.level.description=10 - Local variable type inference
jdk.11.language.level.description=11 - Local variable syntax for lambda parameters
jdk.12.language.level.description=12 - No new language features
jdk.13.language.level.description=13 - No new language features
jdk.14.language.level.description=14 - Switch expressions
jdk.15.language.level.description=15 - Text blocks
jdk.16.language.level.description=16 - Records, patterns, local enums and interfaces
jdk.17.language.level.description=17 - Sealed types, always-strict floating-point semantics
jdk.18.language.level.description=18 - JavaDoc snippets
jdk.19.language.level.description=19 - No new language features
jdk.20.language.level.description=20 - No new language features
jdk.21.language.level.description=21 - Record patterns, pattern matching for switch
jdk.21.preview.language.level.description=21 (Preview) - String templates, unnamed classes and instance main methods, etc.
jdk.22.language.level.description=22 - Unnamed variables and patterns
jdk.22.preview.language.level.description=22 (Preview) - Statements before super(), string templates (2nd preview), etc.
jdk.23.language.level.description=23 - Markdown documentation comments
jdk.23.preview.language.level.description=23 (Preview) - Primitive types in patterns, implicitly declared classes, etc.
jdk.X.language.level.description=X - Experimental features
jdk.unsupported.preview.language.level.description={0} (Preview) - Unsupported

local.class.preposition=local
method.context.display={0}() in {1}
node.abstract.flag.tooltip=Abstract
node.annotation.tooltip=Annotation
node.anonymous.class.tooltip=Anonymous Class
node.class.tooltip=Class
node.enum.tooltip=Enum
node.exception.tooltip=Exception
node.field.tooltip=Field
node.final.flag.tooltip=Final
node.interface.tooltip=Interface
node.junit.test.tooltip=JUnit Test
node.method.tooltip=Method
node.record.tooltip=Record
node.runnable.class.tooltip=Runnable Class
node.static.flag.tooltip=Static
psi.error.attempt.to.edit.class.file=Cannot modify compiled element in file ''{0}''

task.background.title.maven=Maven

unexpected.identifier=Unexpected identifier
unexpected.token=Unexpected token
unexpected.tokens=Unexpected tokens
error.message.wildcard.not.expected=Unexpected wildcard

bad.return.type.in.method.reference=Bad return type in method reference: cannot convert {0} to {1}
bad.return.type.in.lambda.expression=Bad return type in lambda expression: {0} cannot be converted to {1}
bad.return.type.in.lambda.expression1=Bad return type in lambda expression: {0} cannot be converted to void
missing.return.value.lambda=Missing return value
unexpected.return.value=Unexpected return value
lambda.body.must.be.a.statement.expression=Lambda body must be a statement expression
diamond.error.explicit.type.parameters.for.constructor=Cannot use diamonds with explicit type parameters for constructor
diamond.error.cannot.infer.arguments=Cannot infer arguments
diamond.error.cannot.infer.arguments.unable.to.resolve.constructor=Cannot infer arguments (unable to resolve constructor)
diamond.error.anonymous.inner.classes=Cannot use '<>' with anonymous inner classes
diamond.error.anonymous.inner.classes.non.private=Cannot use '<>' due to non-private method which doesn't override or implement a method from a supertype
diamond.error.cannot.infer.type.arguments=Cannot infer type arguments for {0}
error.incompatible.type.no.type.variable=no instance(s) of type variable(s) exist so that {0}
error.incompatible.type.no.type.variable.0=no instance(s) of type variable(s) {0} exist so that {1}
type.conforms.to.constraint={0} conforms to {1}
type.can.be.converted={0} can be converted to {1}
conflicting.conjuncts={0} and {1}
error.type.parameter.has.incompatible.upper.bounds=Type parameter {0} has incompatible upper bounds: {1}
error.incompatible.upper.bounds=Incompatible upper bounds: {0}
error.inference.variable.has.incompatible.bounds=inference variable {0} has incompatible bounds:\n {1}: {2}\n{3}: {4}
error.incompatible.type={0} is not compatible with {1}
error.incompatible.type.not.a.functional.interface={0} is not a functional interface
error.incompatible.type.no.valid.function.type.found=No valid function type can be found for {0}
error.incompatible.type.parameter.type.is.not.yet.inferred=Parameter type is not yet inferred: {0}
error.incompatible.type.return.type.is.not.yet.inferred=Return type is not yet inferred: {0}
error.incompatible.type.unhandled.exception=Unhandled exception: {0}
error.incompatible.type.failed.to.resolve.argument=Failed to resolve argument
error.incompatible.type.incompatible.parameter.types.in.lambda=Wrong number of lambda parameters: expected {0} but found {1}
error.incompatible.type.incompatible.types.expected.void.lambda=Incompatible types: expected void but the lambda body is neither a statement expression nor a void-compatible block
error.incompatible.type.expected.value.lambda=Incompatible types: expected not void but the lambda body is a block that is not value-compatible
error.incompatible.type.bad.lambda.return.type=Bad return type in lambda expression: {0} cannot be converted to {1}
error.incompatible.type.incompatible.parameter.types.in.method.reference=Incompatible parameter types in method reference expression
error.incompatible.type.incompatible.types.expected.not.void.got.void.method.reference=Incompatible types: expected not void but compile-time declaration for the method reference has void return type
error.incompatible.type.declaration.for.the.method.reference.not.found=No compile-time declaration for the method reference is found
error.incompatible.type.expected.non.void.got.void.method.reference=Incompatible types: expected not void but compile-time declaration for the method reference has void return type
error.incompatible.type.not.convertible=Incompatible types: {0} is not convertible to {1}
error.incompatible.type.incompatible.equality.constraint=Incompatible equality constraint: {0} and {1}
list.item.no.module=<no module>
# {0} = localized element kind ('class', 'field', 'method', etc.); {1} = element name  
element.kind.and.name={0} {1}
command.name.insert.block.statement=Insert Block Statement