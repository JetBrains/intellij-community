# @interface (annotation) related messages
annotation.not.allowed.here=Annotations are not allowed here
annotation.unknown.method=Cannot resolve method ''{0}''
annotation.missing.method=Cannot find method ''{0}''
annotation.incompatible.types=Incompatible types. Found: ''{0}'', required: ''{1}''
annotation.illegal.array.initializer=Illegal initializer for ''{0}''
annotation.duplicate.annotation=Duplicate annotation
annotation.duplicate.attribute=Duplicate attribute ''{0}''
annotation.missing.attribute={0} missing though required
annotation.not.applicable=''@{0}'' not applicable to {1}
annotation.non.constant.attribute.value=Attribute value must be constant
annotation.non.class.literal.attribute.value=Attribute value must be a class literal
annotation.invalid.annotation.member.type=Invalid type for annotation member
annotation.cyclic.element.type=Cyclic annotation element type
annotation.annotation.type.expected=Annotation type expected
annotation.members.may.not.have.throws.list=@interface members may not have throws list
annotation.may.not.have.extends.list=@interface may not have extends list
annotation.name.is.missing=Annotation attribute must be of the form 'name=value'

# These aren't unused.
# suppress inspection "UnusedProperty"
annotation.target.ANNOTATION_TYPE=annotation type
# suppress inspection "UnusedProperty"
annotation.target.TYPE=type
# suppress inspection "UnusedProperty"
annotation.target.TYPE_USE=type use
# suppress inspection "UnusedProperty"
annotation.target.TYPE_PARAMETER=type parameter
# suppress inspection "UnusedProperty"
annotation.target.CONSTRUCTOR=constructor
# suppress inspection "UnusedProperty"
annotation.target.METHOD=method
# suppress inspection "UnusedProperty"
annotation.target.FIELD=field
# suppress inspection "UnusedProperty"
annotation.target.PARAMETER=parameter
# suppress inspection "UnusedProperty"
annotation.target.LOCAL_VARIABLE=local variable
# suppress inspection "UnusedProperty"
annotation.target.PACKAGE=package

# generics related messages
generics.holder.type=Type
generics.holder.method=Method

generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should extend ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should implement ''{1}''
generics.type.parameter.is.not.within.its.bound.extend=Type parameter ''{0}'' is not within its bound; should extend ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=Type parameter ''{0}'' is not within its bound; should implement ''{1}''

# {0} - Type (class) or Method
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' does not have type parameters
generics.wrong.number.of.type.arguments=Wrong number of type arguments: {0}; required: {1}
generics.cannot.be.inherited.with.different.type.arguments=''{0}'' cannot be inherited with different type arguments: ''{1}'' and ''{2}''
generics.select.static.class.from.parameterized.type=Cannot select static class ''{0}'' from parameterized type
generics.methods.have.same.erasure={0}; both methods have same erasure
generics.methods.have.same.erasure.override={0}; both methods have same erasure, yet neither overrides the other
generics.methods.have.same.erasure.hide={0}; both methods have same erasure, yet neither hides the other
generics.type.parameter.cannot.be.instantiated=Type parameter ''{0}'' cannot be instantiated directly
wildcard.type.cannot.be.instantiated=Wildcard type ''{0}'' cannot be instantiated directly
generics.wildcard.not.expected=No wildcard expected
generics.wildcards.may.be.used.only.as.reference.parameters=Wildcards may be used only as reference parameters
generics.type.argument.cannot.be.of.primitive.type=Type argument cannot be of primitive type
generics.unchecked.assignment=Unchecked assignment: ''{0}'' to ''{1}''
generics.unchecked.cast=Unchecked cast: ''{0}'' to ''{1}''
generics.unchecked.call.to.member.of.raw.type=Unchecked call to ''{0}'' as a member of raw type ''{1}''
generics.diamond.not.applicable=Diamond operator is not applicable for non-parameterized types
generics.reference.parameters.not.allowed=Reference parameters are not allowed here
foreach.not.applicable=foreach not applicable to type ''{0}''.
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=It is illegal to access static member ''{0}'' from enum constructor or instance initializer
enum.types.cannot.be.instantiated=Enum types cannot be instantiated
generic.array.creation=Generic array creation
generics.enum.may.not.have.type.parameters=Enum may not have type parameters
generics.annotation.members.may.not.have.type.parameters=@interface members may not have type parameters
annotation.may.not.have.type.parameters=@interface may not have type parameters
generics.duplicate.type.parameter=Duplicate type parameter: ''{0}''
generics.cannot.catch.type.parameters=Cannot catch type parameters
generics.cannot.instanceof.type.parameters=Class or array expected
illegal.generic.type.for.instanceof=Illegal generic type for instanceof
cannot.select.dot.class.from.type.variable=Cannot select from a type variable
method.does.not.override.super=Method does not override method from its superclass
call.to.super.is.not.allowed.in.enum.constructor=Call to super is not allowed in enum constructor
vararg.not.last.parameter=Vararg parameter must be the last in the list
modifiers.for.enum.constants=No modifiers allowed for enum constants
generics.type.arguments.on.raw.type=Type arguments given on a raw type
generics.type.arguments.on.raw.method=Type arguments given on a raw method
classes.extends.enum=Classes cannot directly extend 'java.lang.Enum'
unchecked.overriding.incompatible.return.type=Unchecked overriding: return type requires unchecked conversion. Found ''{0}'', required ''{1}''
local.enum=Enum must not be local

interface.expected=Interface expected here
no.interface.expected=No interface expected here
class.expected=Class name expected here
implements.after.interface=No implements clause allowed for interface
extends.after.enum=No extends clause allowed for enum
static.declaration.in.inner.class=Inner classes cannot have static declarations
class.must.be.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
enum.constant.should.implement.method=Class ''{0}'' must implement abstract method ''{1}'' in ''{2}''
abstract.cannot.be.instantiated=''{0}'' is abstract; cannot be instantiated
duplicate.class.in.other.file=Duplicate class found in the file ''{0}''
duplicate.class=Duplicate class: ''{0}''
public.class.should.be.named.after.file=Class ''{0}'' is public, should be declared in a file named ''{0}.java''
inheritance.from.final.class=Cannot inherit from final ''{0}''
package.name.file.path.mismatch=Package name ''{0}'' does not correspond to the file path ''{1}''
missing.package.statement=Missing package statement: ''{0}''
interface.cannot.be.local=Modifier 'interface' not allowed here
cyclic.inheritance=Cyclic inheritance involving ''{0}''
class.already.imported=''{0}'' is already defined in this compilation unit
class.cannot.extend.multiple.classes=Class cannot extend multiple classes
not.allowed.in.interface=Not allowed in interface
qualified.new.of.static.class=Qualified new of static class
invalid.qualified.new=Invalid qualified new
class.name.expected=Class name expected
no.enclosing.instance.in.scope=No enclosing instance of type ''{0}'' is in scope
is.not.an.enclosing.class=''{0}'' is not an enclosing class
cannot.be.referenced.from.static.context=''{0}'' cannot be referenced from a static context
no.default.constructor.available=There is no default constructor available in ''{0}''
missing.return.statement=Missing return statement
unreachable.statement=Unreachable statement
variable.not.initialized=Variable ''{0}'' might not have been initialized
variable.already.assigned=Variable ''{0}'' might already have been assigned to
variable.assigned.in.loop=Variable ''{0}'' might be assigned in loop
assignment.to.final.variable=Cannot assign a value to final variable ''{0}''
variable.must.be.final=Variable ''{0}'' is accessed from within inner class. Needs to be declared final.
initializer.must.be.able.to.complete.normally=Initializer must be able to complete normally
weaker.privileges={0}; attempting to assign weaker access privileges (''{1}''); was ''{2}''
incompatible.return.type=attempting to use incompatible return type
final.method.override=''{0}'' cannot override ''{1}'' in ''{2}''; overridden method is final
overridden.method.does.not.throw={0}; overridden method does not throw ''{1}''
exception.is.never.thrown=Exception ''{0}'' is never thrown in the method
wrong.method.arguments=''{0}'' in ''{1}'' cannot be applied to ''{2}''
method.call.expected=Method call expected
ambiguous.method.call=Ambiguous method call: both ''{0}'' and ''{1}'' match
ambiguous.reference=Reference to ''{0}'' is ambiguous, both ''{1}'' and ''{2}'' match
cannot.resolve.method=Cannot resolve method ''{0}''
missing.method.body=Missing method body, or declare abstract
abstract.method.in.non.abstract.class=Abstract method in non-abstract class
missing.return.type=Invalid method declaration; return type required
duplicate.method=''{0}'' is already defined in ''{1}''
constructor.call.must.be.first.statement=Call to ''{0}'' must be first statement in constructor body
direct.abstract.method.access=Abstract method ''{0}'' cannot be accessed directly
unrelated.overriding.methods.return.types=methods have unrelated return types
overrides.deprecated.method=Overrides deprecated method in ''{0}''
recursive.constructor.invocation=Recursive constructor invocation
wrong.constructor.arguments=''{0}'' cannot be applied to ''{1}''
cannot.resolve.constructor=Cannot resolve constructor ''{0}''
invalid.package.annotation.containing.file=Package annotations should be in file package-info.java
repeated.annotation.target=Repeated annotation target

clash.methods.message=''{0}'' clashes with ''{1}''
clash.methods.message.show.classes=''{0}'' in ''{2}'' clashes with ''{1}'' in ''{3}''

package.clashes.with.class=Package ''{0}'' clashes with class of same name
class.clashes.with.package=Class ''{0}'' clashes with package of same name

# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
ambiguous.method.html.tooltip=\
  <html><body><table border=0>\
  <tr><td colspan={0}>Ambiguous method call. Both</td></tr>\
  <tr>{1}<td>in <b>{2}</b>\\&nbsp;and</td></tr>\
  <tr>{3}<td>in <b>{4}</b>\\&nbsp;match.</td></tr>\
  </table></body></html>


# {0} - colspan, {1} - method name, {2} - class name, {3} - formal parameters row, {4} - arguments row
argument.mismatch.html.tooltip=\
  <html><body><table border=0>\
  <tr><td><b>{1}</b></td>{3}<td colspan={0}>in <b>{2}</b>\\&nbsp;cannot be applied</td></tr>\
  <tr><td>to</td>{4}</tr>\
  </table></body></html>

# {0} - left raw type, {1} - required row, {2} - right raw type, {3} - found row
incompatible.types.html.tooltip=\
  <html><body>Incompatible types.<table>\
  <tr><td>Required:</td><td>{0}</td>{1}</tr>\
  <tr><td>Found:</td><td>{2}</td>{3}</tr>\
  </table></body></html>

interface.methods.cannot.have.body=Interface methods cannot have body
abstract.methods.cannot.have.a.body=Abstract methods cannot have a body
native.methods.cannot.have.a.body=Native methods cannot have a body
extension.method.should.have.a.body=Extension method should have a body
extension.method.in.class=Extension methods can only be used within an interface

instance.method.cannot.override.static.method=Instance method ''{0}'' in ''{1}'' cannot override static method ''{2}'' in ''{3}''
static.method.cannot.override.instance.method=Static method ''{0}'' in ''{1}'' cannot override instance method ''{2}'' in ''{3}''
inconvertible.type.cast=Inconvertible types; cannot cast ''{0}'' to ''{1}''
variable.expected=Variable expected
binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
unary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}''
return.outside.method=Return outside method
return.from.void.method=Cannot return a value from a method with void result type
missing.return.value=Missing return value

#{0} - exceptions list (comma separated), {1} - exceptions count in the list, {2} - exception source
unhandled.exceptions=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
unhandled.close.exceptions=Unhandled {1, choice, 0#exception|2#exceptions} from {2}: {0}

variable.already.defined=Variable ''{0}'' is already defined in the scope
break.outside.switch.or.loop=Break outside switch or loop
continue.outside.loop=Continue outside of loop
not.loop.label=Not a loop label: ''{0}''
incompatible.modifiers=Illegal combination of modifiers: ''{0}'' and ''{1}''
modifier.not.allowed=Modifier ''{0}'' not allowed here
exception.never.thrown.try=Exception ''{0}'' is never thrown in the corresponding try block
exception.already.caught.warn=Unreachable section: {1, choice, 0#exception|2#exceptions} ''{0}'' {1, choice, 0#has|2#have} already been caught
not.a.statement=Not a statement
incompatible.types=Incompatible types. Found: ''{1}'', required: ''{0}''
valid.switch.selector.types=byte, char, short or int
dot.expected.after.super.or.this='.' expected
unqualified.super.disallowed=Unqualified super reference is not allowed in extension method

non.static.symbol.referenced.from.static.context=Non-static {0} ''{1}'' cannot be referenced from a static context
private.symbol=''{0}'' has private access in ''{1}''
protected.symbol=''{0}'' has protected access in ''{1}''
package.local.symbol=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
visibility.access.problem=Cannot access ''{0}'' in ''{1}''
array.type.expected=Array type expected; found: ''{0}''
expression.expected=Expression expected
array.initializer.not.allowed=Array initializer is not allowed here
case.statement.outside.switch=Case statement outside switch
qualified.enum.constant.in.switch=An enum switch case label must be the unqualified name of an enumeration constant
constant.expression.required=Constant expression required
duplicate.default.switch.label=Duplicate default label
duplicate.switch.label=Duplicate label ''{0}''
switch.colon.expected.after.case.label=':' expected

illegal.forward.reference=Illegal forward reference

unknown.class=Unknown class: ''{0}''
illegal.type.void=Illegal type: 'void'
member.referenced.before.constructor.called=Cannot reference ''{0}'' before supertype constructor has been called
label.without.statement=Label without statement
duplicate.label=Label ''{0}'' already in use
unclosed.comment=Unclosed comment
exception.already.caught=Exception ''{0}'' has already been caught
exception.must.be.disjoint=Types in multi-catch must be disjoint: ''{0}'' is a subclass of ''{1}''
statement.must.be.prepended.with.case.label=Statement must be prepended with case label
void.type.is.not.allowed='void' type is not allowed here
single.import.class.conflict=''{0}'' is already defined in a single-type import
numeric.overflow.in.expression=Numeric overflow in expression
static.member.accessed.via.instance.reference=Static member ''{0}.{1}'' accessed via instance reference
unresolved.label=Undefined label: ''{0}''
deprecated.symbol=''{0}'' is deprecated
cannot.resolve.symbol=Cannot resolve symbol ''{0}''
class.is.already.defined.in.single.static.import=Class ''{0}'' is already defined in a single static import
class.is.ambiguous.in.single.static.import=Class ''{0}'' is ambiguous in a single static import
field.is.already.defined.in.single.static.import=Field ''{0}'' is already defined in a single static import
field.is.ambiguous.in.single.static.import=Field ''{0}'' is ambiguous in a single static import
annotation.interface.members.may.not.have.parameters=@interface members may not have parameters

local.variable.is.never.used=Variable ''{0}'' is never used
local.variable.is.not.used.for.reading=Variable ''{0}'' is assigned but never accessed
local.variable.is.not.assigned=Variable ''{0}'' is never assigned
private.field.is.not.used=Private field ''{0}'' is never used
field.is.not.used=Field ''{0}'' is never used
private.field.is.not.used.for.reading=Private field ''{0}'' is assigned but never accessed
private.field.is.not.assigned=Private field ''{0}'' is never assigned
parameter.is.not.used=Parameter ''{0}'' is never used
private.method.is.not.used=Private method ''{0}'' is never used
method.is.not.used=Method ''{0}'' is never used
constructor.is.not.used=Constructor ''{0}'' is never used
private.constructor.is.not.used=Private constructor ''{0}'' is never used
private.inner.class.is.not.used=Private inner class ''{0}'' is never used
private.inner.interface.is.not.used=Private inner interface ''{0}'' is never used
type.parameter.is.not.used=Type parameter ''{0}'' is never used
local.class.is.not.used=Local class ''{0}'' is never used
class.is.not.used=Class ''{0}'' is never used

hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=Hexadecimal numbers must contain at least one hexadecimal digit
binary.numbers.must.contain.at.least.one.hexadecimal.digit=Binary numbers must contain at least one binary digit
integer.number.too.large=Integer number too large
long.number.too.large=Long number too large
malformed.floating.point.literal=Malformed floating point literal
illegal.line.end.in.character.literal=Illegal line end in character literal
illegal.escape.character.in.character.literal=Illegal escape character in character literal
too.many.characters.in.character.literal=Too many characters in character literal
empty.character.literal=Empty character literal
illegal.line.end.in.string.literal=Illegal line end in string literal
unclosed.char.literal=Unclosed character literal
illegal.escape.character.in.string.literal=Illegal escape character in string literal
floating.point.number.too.large=Floating point number too large
floating.point.number.too.small=Floating point number too small
illegal.underscore=Illegal underscore

import.statement.identifier.or.asterisk.expected.=Identifier or '*' expected

javadoc.exception.tag.exception.class.expected=Exception class expected
javadoc.exception.tag.wrong.tag.value=Wrong tag value
javadoc.exception.tag.class.is.not.throwable=Class {0} is not a descendant of Throwable
javadoc.exception.tag.exception.is.not.thrown={0} is not declared to be thrown by method {1}
javadoc.param.tag.parameter.name.expected=Parameter name expected
javadoc.param.tag.type.parameter.name.expected=Type parameter name expected
javadoc.param.tag.type.parameter.gt.expected='>' expected
javadoc.value.tag.jdk15.required=@value tag may not have any arguments when JDK 1.4 or earlier is used
javadoc.value.field.required=@value tag must reference a field
javadoc.value.static.field.required=@value tag must reference a static field
javadoc.value.field.with.initializer.required=@value tag must reference a field with a constant initializer

expected.identifier=Identifier expected
expected.comma.or.semicolon=',' or ';' expected
unexpected.token=Unexpected token
expected.class.or.interface='class' or 'interface' expected
expected.identifier.or.type=Identifier or type expected
expected.rbracket=']' expected
expected.expression=Expression expected
expected.semicolon=';' expected
expected.class.reference=Class reference expected
expected.lparen='(' expected
expected.rparen=')' expected
expected.eq='=' expected
expected.value=Value expected
expected.rbrace='}' expected
expected.lbrace='{' expected
unexpected.identifier=Unexpected identifier
expected.gt='>' expected.
expected.lbrace.or.semicolon='{' or ';' expected
expected.parameter=Parameter expected
expected.resource=Resource definition expected
expected.type.parameter=Type parameter expected
expected.comma=',' expected
expected.comma.or.rparen=',' or ')' expected
expected.colon=':' expected
expected.type=Type expected
expected.lbracket='[' expected
expected.lparen.or.lbracket='(' or '[' expected
expected.array.initializer=Array initializer expected
unexpected.tokens=Unexpected tokens
expected.gt.or.comma='>' or ',' expected.
string.expected=String literal expected
else.without.if='else' without 'if'
catch.without.try='catch' without 'try'
finally.without.try='finally' without 'try'
expected.statement=Statement expected
expected.while='while' expected
expected.catch.or.finally='catch' or 'finally' expected
expected.boolean.expression=Boolean expression expected
error.cannot.resolve.class=Cannot resolve class ''{0}''
error.cannot.resolve.class.or.package=Cannot resolve class or package ''{0}''
expected.class.or.package=Expected class or package
suspicious.name.assignment=''{0}'' should probably not be assigned to ''{1}''
suspicious.name.parameter=''{0}'' should probably not be passed as parameter ''{1}''
suspicious.name.return=''{0}'' should probably not be returned from method ''{1}''
type.parameter.cannot.be.followed.by.other.bounds=Type parameter cannot be followed by other bounds
generic.extend.exception=Generic class may not extend 'java.lang.Throwable'
illegal.initializer=Illegal initializer for ''{0}''
class.cannot.inherit.from.its.type.parameter=Class cannot inherit from its type parameter
cannot.resolve.package=Cannot resolve package {0}
override.not.allowed.in.interfaces=@Override is not allowed when implementing interface method
wildcard.not.expected=Unexpected wildcard
bound.not.expected=Unexpected bound

feature.generics=Generics
feature.annotations=Annotations
feature.static.imports=Static imports
feature.for.each=For-each loops
feature.varargs=Variable arity methods
feature.hex.fp.literals=Hexadecimal floating point literals
feature.diamond.types=Diamond types
feature.multi.catch=Multi-catches
feature.try.with.resources=Try-with-resources
feature.binary.literals=Binary literals
feature.underscores.in.literals=Underscores in literals
feature.extension.methods=Extension methods
feature.method.references=Method references
feature.lambda.expressions=Lambda expressions
insufficient.language.level={0} are not supported at this language level
