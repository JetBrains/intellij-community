# @interface (annotation) related messages
annotation.not.allowed.here=Annotations are not allowed here
# suppress inspection "UnusedProperty"
annotation.missing.method=Cannot find @interface method ''{0}()''
# suppress inspection "UnusedProperty"
annotation.unknown.method=Cannot find @interface method ''{0}()''
annotation.not.applicable=''@{0}'' not applicable to {1}
annotation.annotation.type.expected=Annotation type expected
annotation.not.allowed.in.permit.list=Annotations not allowed in 'permits' list

# generics related messages
generics.holder.type=Type
generics.holder.method=Method

generics.type.parameter.is.not.within.its.bound.extend=Type parameter ''{0}'' is not within its bound; should extend ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=Type parameter ''{0}'' is not within its bound; should implement ''{1}''

# {0} - Type (class) or Method
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' does not have type parameters
generics.wrong.number.of.type.arguments=Wrong number of type arguments: {0}; required: {1}
generics.methods.have.same.erasure={0}; both methods have same erasure
generics.methods.have.same.erasure.override={0}; both methods have same erasure, yet neither overrides the other
generics.methods.have.same.erasure.hide={0}; both methods have same erasure, yet neither hides the other
generics.type.parameter.cannot.be.instantiated=Type parameter ''{0}'' cannot be instantiated directly
wildcard.type.cannot.be.instantiated=Wildcard type ''{0}'' cannot be instantiated directly
generics.wildcard.not.expected=No wildcard expected
generics.type.argument.cannot.be.of.primitive.type=Type argument cannot be of primitive type
generics.unchecked.assignment=Unchecked assignment: ''{0}'' to ''{1}''
generics.unchecked.cast=Unchecked cast: ''{0}'' to ''{1}''
generics.unchecked.call.to.member.of.raw.type=Unchecked call to ''{0}'' as a member of raw type ''{1}''
generics.unchecked.call=Unchecked method ''{0}'' invocation
generics.diamond.not.applicable=Diamond operator is not applicable for non-parameterized types
generics.reference.parameters.not.allowed=Reference parameters are not allowed here
foreach.not.applicable=Foreach not applicable to type ''{0}''
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=Accessing {0, choice, 1#static field|2#enum constant} from enum {1, choice, 1#constructor|2#instance field initializer|3#instance initializer} is not allowed
generic.array.creation=Generic array creation not allowed
cannot.create.array.with.empty.diamond=Array creation with '<>' not allowed
array.creation.with.type.arguments=Array creation with type arguments not allowed
generics.cannot.catch.type.parameters=Cannot catch type parameters
generics.cannot.instanceof.type.parameters=Class or array expected
illegal.generic.type.for.instanceof=Illegal generic type for instanceof
unsafe.cast.in.instanceof=''{0}'' cannot be safely cast to ''{1}''
instanceof.pattern.supertype=Pattern type ''{0}'' is a supertype of expression type ''{1}''
instanceof.pattern.equals=Pattern type ''{0}'' is the same as expression type
cannot.select.dot.class.from.type.variable=Cannot access class object of a type parameter
bad.qualifier.in.super.method.reference.overridden=Bad type qualifier in default super call: method {0} is overridden in {1}
bad.qualifier.in.super.method.reference.extended=Bad type qualifier in default super call: redundant interface {0} is extended by {1}

modifiers.for.enum.constants=No modifiers allowed for enum constants
generics.type.arguments.on.raw.type=Type arguments given on a raw type
generics.type.arguments.on.raw.method=Type arguments given on a raw method
unchecked.overriding.incompatible.return.type=Unchecked overriding: return type requires unchecked conversion. Found ''{0}'', required ''{1}''

interface.expected=Interface expected here
class.expected=Class name expected here
class.must.be.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
class.must.implement.method=Class ''{0}'' must implement abstract method ''{1}'' in ''{2}''
package.name.file.path.mismatch=Package name ''{0}'' does not correspond to the file path ''{1}''
missing.package.statement=Missing package statement: ''{0}''
missing.package.statement.package.name.invalid=Missing package statement but package name ''{0}'' which corresponds to the file path is invalid
no.enclosing.instance.in.scope=No enclosing instance of type ''{0}'' is in scope
is.not.an.enclosing.class=''{0}'' is not an enclosing class
cannot.be.referenced.from.static.context=''{0}'' cannot be referenced from a static context
missing.return.statement=Missing return statement
unreachable.statement=Unreachable statement
unreachable.statement.false.condition=Loop condition is always false making the loop body unreachable
variable.not.initialized=Variable ''{0}'' might not have been initialized
variable.already.assigned=Variable ''{0}'' might already have been assigned to
variable.assigned.in.loop=Variable ''{0}'' might be assigned in loop
assignment.to.final.variable=Cannot assign a value to final variable ''{0}''
variable.must.be.final=Variable ''{0}'' is accessed from within inner class, needs to be declared final
variable.must.be.final.or.effectively.final=Variable ''{0}'' is accessed from within inner class, needs to be final or effectively final
lambda.variable.must.be.final=Variable used in lambda expression should be final or effectively final
resource.variable.must.be.final=Variable used as a try-with-resources resource should be final or effectively final
guarded.pattern.variable.must.be.final=Variable used in guarded pattern should be final or effectively final
declaration.or.variable.expected=Declaration, final or effectively final variable expected
initializer.must.be.able.to.complete.normally=Initializer must be able to complete normally
incompatible.return.type=attempting to use incompatible return type
exception.is.never.thrown=Exception ''{0}'' is never thrown in the method
wrong.method.arguments=''{0}'' in ''{1}'' cannot be applied to ''{2}''
method.call.expected=Method call expected
ambiguous.method.call=Ambiguous method call: both ''{0}'' and ''{1}'' match
ambiguous.reference=Reference to ''{0}'' is ambiguous, both ''{1}'' and ''{2}'' match
cannot.resolve.method=Cannot resolve method ''{0}''
ambiguous.method.call.no.match=Cannot resolve method ''{0}'' in ''{1}''
abstract.method.in.non.abstract.class=Abstract method in non-abstract class
missing.return.type=Invalid method declaration; return type required
constructor.call.must.be.first.statement=Call to ''{0}'' must be first statement in constructor body
constructor.call.only.allowed.in.constructor=Call to ''{0}'' only allowed in constructor body
constructor.call.must.be.top.level.statement=Call to ''{0}'' must be top-level statement in constructor body
only.one.constructor.call.allowed.in.constructor=Only one explicit constructor call allowed in constructor
direct.abstract.method.access=Abstract method ''{0}'' cannot be accessed directly
overrides.deprecated.method=Overrides deprecated method in ''{0}''
overrides.marked.for.removal.method=Overrides method that is deprecated and marked for removal in ''{0}''
deprecated.default.constructor=Default constructor in ''{0}'' is deprecated
marked.for.removal.default.constructor=Default constructor in ''{0}'' is deprecated and marked for removal
recursive.constructor.invocation=Recursive constructor call
wrong.constructor.arguments=''{0}'' cannot be applied to ''{1}''
cannot.resolve.constructor=Cannot resolve constructor ''{0}''
clash.methods.message=''{0}'' clashes with ''{1}''
clash.methods.message.show.classes=''{0}'' in ''{2}'' clashes with ''{1}'' in ''{3}''

package.clashes.with.class=Package ''{0}'' clashes with class of same name
# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
ambiguous.method.html.tooltip=\
  <html><body><table border=0>\
  <tr><td colspan={0}>Ambiguous method call. Both</td></tr>\
  <tr>{1}<td>in <b>{2}</b>\\&nbsp;and</td></tr>\
  <tr>{3}<td>in <b>{4}</b>\\&nbsp;match</td></tr>\
  </table></body></html>

# {0} - left raw type, {1} - required type arguments row, {2} - right raw type, {3} - found type arguments row, {4} - reason, {5} - greyed title color
incompatible.types.html.tooltip=\
  <html><body><table>\
  <tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>Required type:</td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr>\
  <tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>Provided:</td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr>\
  </table>{4}</body></html>

inconvertible.type.cast=Inconvertible types; cannot cast ''{0}'' to ''{1}''
variable.expected=Variable expected
binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
unary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}''
return.outside.method=Return outside method
return.from.void.method=Cannot return a value from a method with void result type
return.from.constructor=Cannot return a value from a constructor
missing.return.value=Missing return value
return.statement.not.allowed.before.explicit.constructor.call='return' not allowed before ''{0}'' call
return.outside.switch.expr=Return outside of enclosing switch expression
impossible.assign.declared.outside.guard=Cannot assign a value to variable ''{0}'', because it is declared outside the guard

#{0} - exceptions list (comma separated), {1} - exceptions count in the list, {2} - exception source
unhandled.exceptions=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
unhandled.close.exceptions=Unhandled {1, choice, 0#exception|2#exceptions} from {2}: {0}

variable.already.defined=Variable ''{0}'' is already defined in the scope
break.outside.switch.or.loop=Break outside switch or loop
yield.unexpected=Yield outside of switch expression
yield.void=Expression type should not be 'void'
break.outside.switch.expr=Break out of switch expression is not allowed
continue.outside.loop=Continue outside of loop
continue.outside.switch.expr=Continue outside of enclosing switch expression
not.loop.label=Not a loop label: ''{0}''
incompatible.modifiers=Illegal combination of modifiers ''{0}'' and ''{1}''
repeated.modifier=Repeated modifier ''{0}''
modifier.not.allowed=Modifier ''{0}'' not allowed here
modifier.not.allowed.on.local.classes=Modifier ''{0}'' not allowed on local classes
modifier.not.allowed.on.classes.without.sealed.super=Modifier 'non-sealed' not allowed on classes that do not have a sealed superclass
not.a.statement=Not a statement
invalid.statement=Invalid statement
incompatible.types=Incompatible types. Found: ''{1}'', required: ''{0}''
switch.pattern.expected=Pattern expected for switch selector type ''{0}''
unexpected.type=Unexpected type. Found: ''{1}'', required: ''{0}''
incompatible.types.reason.ambiguous.method.reference=<br/>reason: method reference is ambiguous: both ''{0}'' and ''{1}'' match
incompatible.switch.null.type=''{0}'' cannot be converted to ''{1}''
inaccessible.type=''{0}'' is inaccessible here
valid.switch.selector.types=byte, char, short or int
valid.switch.1_7.selector.types=char, byte, short, int, Character, Byte, Short, Integer, String, or an enum
switch.illegal.fall.through.to=Illegal fall-through to a pattern
invalid.case.label.combination.constants.and.patterns=Invalid case label combination: a case label must consist of either a list of case constants or a single case pattern
invalid.case.label.combination.constants.and.patterns.unnamed=Invalid case label combination: a case label must consist of either a list of case constants or a list of case patterns
invalid.case.label.combination.several.patterns.unnamed=Invalid case label combination: multiple patterns are allowed only if none of them declare any pattern variables
invalid.case.label.combination.several.patterns=Invalid case label combination: a case label must not consist of more than one case pattern
null.label.not.allowed.here=Invalid case label combination: 'null' can only be used as a single case label or paired only with 'default'
default.label.must.not.contains.case.keyword=The label for the default case must only use the 'default' keyword, without 'case'
invalid.default.and.null.order=Invalid case label order: 'null' must be first and 'default' must be second
default.label.not.allowed.here=Default label not allowed here: 'default' can only be used as a single case label or paired only with 'null'
multiple.switch.labels=Multiple switch labels are permitted for a switch labeled statement group only if none of them declare any pattern variables
switch.dominance.of.preceding.label=Label is dominated by a preceding case label ''{0}''
switch.unconditional.pattern.and.default.exist='switch' has both an unconditional pattern and a default label
switch.unconditional.boolean.and.default.exist='switch' has all boolean values and a default label
switch.unconditional.boolean.and.unconditional.exist='switch' has all boolean values and an unconditional pattern
switch.class.or.array.type.expected=class or array
switch.invalid.selector.types=Selector type of ''{0}'' is not supported
dot.expected.after.super.or.this='.' expected
unqualified.super.disallowed=Unqualified super reference is not allowed in extension method
static.interface.method.call.qualifier=Static method may only be called on its containing interface
non.static.symbol.referenced.from.static.context=Non-static {0} ''{1}'' cannot be referenced from a static context
private.symbol=''{0}'' has private access in ''{1}''
protected.symbol=''{0}'' has protected access in ''{1}''
package.local.symbol=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
visibility.access.problem=Cannot access ''{0}'' in ''{1}''
visibility.module.access.problem=Access to ''{0}'' in ''{1}'' is prevented by {2}
expression.expected=Expression expected
qualified.enum.constant.in.switch=An enum switch case label must be the unqualified name of an enumeration constant
qualified.enum.constant.in.switch.remove.fix=Remove qualifier
constant.expression.required=Constant expression required
switch.constant.expression.required=Constant expression, pattern or null is required
deconstruction.pattern.requires.record=Deconstruction pattern can only be applied to a record, ''{0}'' is not a record
deconstruction.pattern.type.contain.annotation=Annotations are not allowed in deconstruction pattern types
raw.processor.type.not.allowed=Raw processor type is not allowed: {0}
duplicate.unconditional.pattern.label=Duplicate unconditional pattern
duplicate.default.switch.label=Duplicate default label
duplicate.switch.label=Duplicate label ''{0}''
switch.expr.empty='switch' expression does not have any case clauses
switch.statement.empty='switch' statement does not have any case clauses
switch.expr.incomplete='switch' expression does not cover all possible input values
switch.statement.incomplete='switch' statement does not cover all possible input values
switch.expr.no.result=Switch expression does not have any result expressions
switch.expr.should.produce.result=Switch expression should produce result in all execution paths
switch.expr.rule.should.produce.result=Switch expression rule should produce result in all execution paths
incorrect.number.of.nested.patterns=Incorrect number of nested patterns: expected {0} but found {1}
pattern.is.not.exhaustive=Pattern ''{0}'' is not exhaustive on ''{1}''
identifier.is.not.allowed.here=Identifier is not allowed here

illegal.forward.reference=Cannot read value of field ''{0}'' before the field''s definition
illegal.self.reference=Cannot read value of field ''{0}'' from inside the fields''s definition
illegal.forward.reference.enum=Cannot refer to enum constant ''{0}'' before its definition
illegal.self.reference.enum=Cannot refer to enum constant ''{0}'' from inside its own definition

unknown.class=Unknown class: ''{0}''
illegal.type.void=Illegal type: 'void'
member.referenced.before.constructor.called=Cannot reference ''{0}'' before superclass constructor is called
method.called.before.constructor.called=Cannot call ''{0}'' before superclass constructor is called
assign.initialized.field.before.constructor.call=Cannot assign initialized field ''{0}'' before superclass constructor is called
statement.must.be.prepended.with.case.label=Statement must be prepended with case label
different.case.kinds.in.switch=Different 'case' kinds used in 'switch'
single.import.class.conflict=''{0}'' is already defined in a single-type import
numeric.overflow.in.expression=Numeric overflow in expression
static.member.accessed.via.instance.reference=Static member ''{0}.{1}'' accessed via instance reference
unresolved.label=Undefined label: ''{0}''
deprecated.symbol=''{0}'' is deprecated
deprecated.since.symbol=''{0}'' is deprecated since version {1}
marked.for.removal.symbol=''{0}'' is deprecated and marked for removal
marked.for.removal.symbol.since=''{0}'' is deprecated since version {1} and marked for removal
qualifier.must.be.expression=Qualifier must be an expression
cannot.resolve.symbol=Cannot resolve symbol ''{0}''
cannot.access.member.on.type=Cannot access fields on ''{0}'' type
implicit.class.can.not.be.referenced=Implicitly declared class ''{0}'' cannot be referenced
cannot.call.method.on.type=Cannot call methods on ''{0}'' type
class.is.already.defined.in.single.static.import=Class ''{0}'' is already defined in a single static import
class.is.ambiguous.in.single.static.import=Class ''{0}'' is ambiguous in a single static import
field.is.already.defined.in.single.static.import=Field ''{0}'' is already defined in a single static import
field.is.ambiguous.in.single.static.import=Field ''{0}'' is ambiguous in a single static import
annotation.interface.members.may.not.have.parameters=@interface members may not have parameters
class.in.default.package=Class ''{0}'' is in the default package

local.variable.is.never.used=Variable ''{0}'' is never used
local.variable.is.not.used.for.reading=Variable ''{0}'' is assigned but never accessed
local.variable.is.not.assigned=Variable ''{0}'' is never assigned
private.field.is.not.used=Private field ''{0}'' is never used
field.is.not.used=Field ''{0}'' is never used
field.is.not.used.for.reading={0} field ''{1}'' is assigned but never accessed
private.field.is.not.assigned=Private field ''{0}'' is never assigned
parameter.is.not.used=Parameter ''{0}'' is never used
parameter.excluding.hierarchy.disable.text=Do not highlight parameters for inherited methods
pattern.variable.is.not.used=Pattern variable ''{0}'' is never used
private.method.is.not.used=Private method ''{0}'' is never used
method.is.not.used=Method ''{0}'' is never used
constructor.is.not.used=Constructor ''{0}'' is never used
private.constructor.is.not.used=Private constructor ''{0}'' is never used
private.inner.class.is.not.used=Private inner class ''{0}'' is never used
private.inner.interface.is.not.used=Private inner interface ''{0}'' is never used
type.parameter.is.not.used=Type parameter ''{0}'' is never used
local.class.is.not.used=Local class ''{0}'' is never used
class.is.not.used=Class ''{0}'' is never used
interface.is.not.used=Interface ''{0}'' is never used
enum.is.not.used=Enum ''{0}'' is never used
annotation.interface.is.not.used=@Interface ''{0}'' is never used
record.is.not.used=Record ''{0}'' is never used

illegal.line.end.in.string.literal=Line end not allowed in string literals
illegal.escape.character.in.string.literal=Illegal escape character in string literal
text.block.new.line=Illegal text block start: missing new line after opening quotes
processor.missing.from.string.template.expression=Processor missing from string template expression
expression.with.type.void.not.allowed.as.string.template.embedded.expression=Expression with type 'void' not allowed as string template embedded expression

# suppress inspection "UnusedProperty"
expected.identifier=Identifier expected
# suppress inspection "UnusedProperty"
unexpected.token=Unexpected token
expected.identifier.or.type=Identifier or type expected
# suppress inspection "UnusedProperty"
expected.rbracket=']' expected
# suppress inspection "UnusedProperty"
expected.expression=Expression expected
expected.semicolon=';' expected
# suppress inspection "UnusedProperty"
expected.lparen='(' expected
# suppress inspection "UnusedProperty"
expected.rparen=')' expected
# suppress inspection "UnusedProperty"
expected.rbrace='}' expected
# suppress inspection "UnusedProperty"
expected.lbrace='{' expected
expected.parameter=Parameter expected
expected.comma=',' expected
# suppress inspection "UnusedProperty"
expected.lparen.or.lbracket='(' or '[' expected
# suppress inspection "UnusedProperty"
else.without.if='else' without 'if'
# suppress inspection "UnusedProperty"
catch.without.try='catch' without 'try'
# suppress inspection "UnusedProperty"
finally.without.try='finally' without 'try'
# suppress inspection "UnusedProperty"
expected.statement=Statement expected
# suppress inspection "UnusedProperty"
expected.while='while' expected
# suppress inspection "UnusedProperty"
expected.catch.or.finally='catch' or 'finally' expected
# suppress inspection "UnusedProperty"
expected.boolean.expression=Boolean expression expected
# suppress inspection "UnusedProperty"
expected.switch.label='case', 'default' or '}' expected
# suppress inspection "UnusedProperty"
expected.switch.rule=Expression, block or throw statement expected
error.cannot.resolve.class=Cannot resolve class ''{0}''
error.cannot.resolve.class.or.package=Cannot resolve class or package ''{0}''
expected.class.or.package=Expected class or package
suspicious.name.assignment=''{0}'' should probably not be assigned to ''{1}''
suspicious.name.parameter=''{0}'' should probably not be passed as parameter ''{1}''
suspicious.name.return=''{0}'' should probably not be returned from method ''{1}''
generic.extend.exception=Generic class may not extend 'java.lang.Throwable'
cannot.resolve.package=Cannot resolve package {0}
declaration.not.allowed=Declaration not allowed here

underscore.identifier.error=Since Java 9, '_' is a keyword, and may not be used as an identifier
underscore.identifier.error.unnamed=Using '_' as a reference is not allowed
underscore.lambda.identifier=Use of '_' as a lambda parameter name is not allowed

assert.identifier.warn=Use of 'assert' as an identifier is not supported in releases since Java 1.4
enum.identifier.warn=Use of 'enum' as an identifier is not supported in releases since Java 1.5
underscore.identifier.warn=Use of '_' as an identifier is not supported in releases since Java 9
# {0} = restricted identifier, like 'var', {1} = java version like '10'
restricted.identifier.warn=Use of ''{0}'' as a class name is not supported in releases since Java {1}
module.unwanted.modifier.warn=Modifiers on 'requires java.base' are prohibited in releases since Java 10
yield.unqualified.method.warn=Unqualified call to 'yield' method is not supported in releases since Java 14
redundant.semicolon.warn=Redundant semicolons between import statements are prohibited starting from Java 21

module.no.package=A module file should not have 'package' statement
module.file.wrong.name=Module declaration should be in a file named 'module-info.java'
module.file.duplicate='module-info.java' already exists in the module
module.duplicate.requires=Duplicate ''requires'': {0}
module.duplicate.exports=Duplicate ''exports'': {0}
module.duplicate.opens=Duplicate ''opens'': {0}
module.duplicate.uses=Duplicate ''uses'': {0}
module.duplicate.provides=Duplicate ''provides'': {0}
module.duplicate.exports.target=Duplicate ''exports'' target: {0}
module.duplicate.opens.target=Duplicate ''opens'' target: {0}
module.duplicate.impl=Duplicate implementation: {0}
module.file.wrong.location=Module declaration should be located in a module's source root
module.open.duplicate.text=Go to duplicate
module.not.found=Module not found: {0}
module.ambiguous=Ambiguous module reference: {0}
module.not.on.path=Module is not in dependencies: {0}
module.cyclic.dependence=Cyclic dependence: {0}
module.opens.in.weak.module='opens' is not allowed in an open module
package.not.found=Package not found: {0}
package.is.empty=Package is empty: {0}
module.service.enum=The service definition is an enum: {0}
module.service.alien=The service implementation must be defined in the same module as the provides directive
module.service.impl=The service implementation type must be a subtype of the service interface type, or have a public static no-args 'provider' method
module.service.abstract=The service implementation is an abstract class: {0}
module.service.inner=The service implementation is an inner class: {0}
module.service.no.ctor=The service implementation does not have a public default constructor: {0}
module.service.provider.type=The ''provider'' method return type must be a subtype of the service interface type: {0}
module.service.unused=Service interface provided but not exported or used
module.conflicting.reads=Module ''{0}'' reads package ''{1}'' from both ''{2}'' and ''{3}''
module.conflicting.packages=Package ''{0}'' exists in another module: {1}
module.access.to.unnamed=Package ''{0}'' is declared in the unnamed module, but module ''{1}'' does not read it
module.access.from.named=Package ''{0}'' is declared in module ''{1}'', which does not export it to module ''{2}''
module.access.from.unnamed=Package ''{0}'' is declared in module ''{1}'', which does not export it to the unnamed module
module.access.does.not.read=Package ''{0}'' is declared in module ''{1}'', but module ''{2}'' does not read it
module.does.not.read=Module ''{0}'' fails to read ''{1}''
module.access.not.in.graph=Package ''{0}'' is declared in module ''{1}'', which is not in the module graph
module.not.in.graph=Module ''{0}'' is missing from the module graph
module.access.bad.name=Package ''{0}'' is declared in module with an invalid name (''{1}'')
module.bad.name=Module ''{0}'' has an invalid name

restricted.identifier=''{0}'' is a restricted identifier and cannot be used for type declarations
restricted.identifier.reference=Illegal reference to restricted type ''{0}''

lvti.lambda=Cannot infer type: lambda expression requires an explicit target type
lvti.method.ref=Cannot infer type: method reference requires an explicit target type
lvti.null=Cannot infer type: variable initializer is 'null'
lvti.void=Cannot infer type: variable initializer is 'void'
record.accessor.wrong.return.type=Incorrect component accessor return type. Expected: ''{0}'', found: ''{1}''
record.canonical.constructor.wrong.parameter.type=Incorrect parameter type for record component ''{0}''. Expected: ''{1}'', found: ''{2}''
record.canonical.constructor.wrong.parameter.name=Canonical constructor parameter names must match record component names. Expected: ''{0}'', found: ''{1}''
record.constructor.call.in.canonical=Canonical constructor cannot delegate to another constructor
record.no.constructor.call.in.non.canonical=Non-canonical record constructor must delegate to another constructor
record.special.method.type.parameters={0} cannot have type parameters
record.special.method.non.public={0} must be ''public''
record.special.method.stronger.access={0} access level cannot be more restrictive than the record access level (''{1}'')
record.special.method.throws=''throws'' not allowed on {0}
record.canonical.constructor=Canonical constructor
record.compact.constructor=Compact constructor
record.accessor=Record component accessor
record.component.not.initialized=Record component ''{0}'' might not be initialized in canonical constructor
compact.constructor.in.regular.class=Parameter list expected
record.compact.constructor.return='return' statement is not allowed in compact constructor
insufficient.language.level={0} are not supported at language level ''{1}''

cannot.select.from.a.type.parameter=Cannot select from a type parameter
method.reference.expression.is.not.expected=Method reference expression is not expected here
not.a.functional.interface={0} is not a functional interface
cannot.find.class=Cannot find class {0}
cannot.infer.functional.interface.type=Cannot infer functional interface type
lambda.expression.not.expected=Lambda expression not expected here
lambda.parameters.consistency.message=Cannot mix 'var' and explicitly typed parameters in lambda expression
target.method.is.generic=Target method is generic
multiple.non.overriding.abstract.methods.found.in.0=Multiple non-overriding abstract methods found in {0}
multiple.non.overriding.abstract.methods.found.in.interface.0=Multiple non-overriding abstract methods found in interface {0}
no.target.method.found=No target method found
target.type.of.a.lambda.conversion.must.be.an.interface=Target type of a lambda conversion must be an interface
incompatible.parameter.types.in.lambda=Incompatible parameter types in lambda expression: expected {0} but found {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=Incompatible parameter types in lambda expression: wrong number of parameters: expected {0} but found {1}
an.enclosing.instance.of.type.not.in.scope.method.reference.context=An enclosing instance of type {0} is not in scope
parameterized.qualifier.on.static.method.reference.context=Parameterized qualifier on static method reference
static.method.referenced.through.receiver.method.reference.context=Static method referenced through receiver
static.method.referenced.through.non.static.qualifier.method.reference.context=Static method referenced through non-static qualifier
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=Non-static method cannot be referenced from a static context
abstract.method.0.cannot.be.accessed.directly.method.reference.context=Abstract method ''{0}'' cannot be accessed directly
anonymous.class.implements.interface.cannot.have.type.arguments=Anonymous class implements interface; cannot have type arguments
formal.varargs.element.type.inaccessible.here=Formal varargs element type {0} is inaccessible here
unexpected.type.class.expected=Unexpected type: class is expected
repeated.interface=Repeated interface
class.cannot.be.inherited.with.different.arguments={0} cannot be inherited with different arguments: {1}
bad.type.in.switch.expression=Bad type in switch expression: {0} cannot be converted to {1}
switch.expression.cannot.be.void=Target type for switch expression cannot be void
annotation.on.static.member.qualifying.type.family.name=Move type annotation
actual.type.argument.contradict.inferred.type=Actual type argument and inferred type contradict each other
default.method.overrides.object.member=Default method ''{0}'' overrides a member of ''java.lang.Object''
two.methods.are.inherited.with.same.signature=Methods {0} from {1} and {2} from {3} are inherited with the same signature
cannot.select.from.parameterized.type=Cannot access class object of parameterized type
type.parameter.has.incompatible.upper.bounds=Type parameter {0} has incompatible upper bounds: {1}
not.allowed.in.sealed.hierarchy=''{0}'' is not allowed in the sealed hierarchy
invalid.permits.clause.direct.implementation=Invalid permits clause: ''{0}'' must directly {1, choice, 1#extend|2#implement} ''{2}''
permitted.subclass.must.have.modifier=All sealed class subclasses must either be final, sealed or non-sealed
permits.list.generics.are.not.allowed=Generics are not allowed in permits list
sealed.cannot.be.functional.interface=Sealed class can not be used as functional interface
local.classes.must.not.extend.sealed.classes=Local classes must not extend sealed classes
class.not.allowed.to.extend.sealed.class.from.another.package={0} ''{1}'' from another package not allowed to extend sealed {2} ''{3}'' in unnamed module
class.not.allowed.to.extend.sealed.class.from.another.module=Class is not allowed to extend sealed class from another module
create.class.action.this.not.valid.java.qualified.name=This is not a valid Java qualified name
text.class.inherits.abstract.and.default={0} inherits abstract and default for {1} from types {2} and {3}
text.class.inherits.unrelated.defaults={0} inherits unrelated defaults for {1} from types {2}
text.class.is.not.accessible={0} is not accessible in current context
text.class.cannot.access=Cannot access {0}
auto.closeable.resource=auto-closeable resource
too.many.array.dimensions=Too many array dimensions
error.cannot.infer.pattern.type=Cannot infer pattern type: {0}
error.extra.semicolons.between.import.statements.not.allowed=Extra semicolons between import statements are not allowed
remove.unused.imports.quickfix.text=Remove unused imports
incomplete.project.state.pending.reference=Not resolved until the project is fully loaded
implicit.class.with.explicit.constructor=Explicit constructor in implicitly declared class is not allowed