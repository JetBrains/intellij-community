# @interface (annotation) related messages
annotation.not.allowed.here=Annotations are not allowed here
# suppress inspection "UnusedProperty"
annotation.missing.method=Cannot find @interface method ''{0}()''
# suppress inspection "UnusedProperty"
annotation.unknown.method=Cannot find @interface method ''{0}()''
annotation.not.applicable=''@{0}'' not applicable to {1}
annotation.annotation.type.expected=Annotation type expected
annotation.not.allowed.in.permit.list=Annotations not allowed in 'permits' list

generics.wrong.number.of.type.arguments=Wrong number of type arguments: {0}; required: {1}
generics.methods.have.same.erasure={0}; both methods have same erasure
generics.methods.have.same.erasure.override={0}; both methods have same erasure, yet neither overrides the other
generics.methods.have.same.erasure.hide={0}; both methods have same erasure, yet neither hides the other
generics.type.argument.cannot.be.of.primitive.type=Type argument cannot be of primitive type
generics.unchecked.assignment=Unchecked assignment: ''{0}'' to ''{1}''
generics.unchecked.cast=Unchecked cast: ''{0}'' to ''{1}''
generics.unchecked.call.to.member.of.raw.type=Unchecked call to ''{0}'' as a member of raw type ''{1}''
generics.unchecked.call=Unchecked method ''{0}'' invocation
unsafe.cast.in.instanceof=''{0}'' cannot be safely cast to ''{1}''
modifiers.for.enum.constants=No modifiers allowed for enum constants
unchecked.overriding.incompatible.return.type=Unchecked overriding: return type requires unchecked conversion. Found ''{0}'', required ''{1}''

class.must.be.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
class.must.implement.method=Class ''{0}'' must implement abstract method ''{1}'' in ''{2}''
package.name.file.path.mismatch=Package name ''{0}'' does not correspond to the file path ''{1}''
missing.package.statement=Missing package statement: ''{0}''
missing.package.statement.package.name.invalid=Missing package statement but package name ''{0}'' which corresponds to the file path is invalid
is.not.an.enclosing.class=''{0}'' is not an enclosing class
cannot.be.referenced.from.static.context=''{0}'' cannot be referenced from a static context
missing.return.statement=Missing return statement
unreachable.statement=Unreachable statement
unreachable.statement.false.condition=Loop condition is always false making the loop body unreachable
variable.not.initialized=Variable ''{0}'' might not have been initialized
variable.already.assigned=Variable ''{0}'' might already have been assigned to
variable.assigned.in.loop=Variable ''{0}'' might be assigned in loop
assignment.to.final.variable=Cannot assign a value to final variable ''{0}''
variable.must.be.final=Variable ''{0}'' is accessed from within inner class, needs to be declared final
variable.must.be.final.or.effectively.final=Variable ''{0}'' is accessed from within inner class, needs to be final or effectively final
lambda.variable.must.be.final=Variable used in lambda expression should be final or effectively final
resource.variable.must.be.final=Variable used as a try-with-resources resource should be final or effectively final
guarded.pattern.variable.must.be.final=Variable used in guarded pattern should be final or effectively final
declaration.or.variable.expected=Declaration, final or effectively final variable expected
initializer.must.be.able.to.complete.normally=Initializer must be able to complete normally
incompatible.return.type=attempting to use incompatible return type
exception.is.never.thrown=Exception ''{0}'' is never thrown in the method
ambiguous.reference=Reference to ''{0}'' is ambiguous, both ''{1}'' and ''{2}'' match
cannot.resolve.method=Cannot resolve method ''{0}''
ambiguous.method.call.no.match=Cannot resolve method ''{0}'' in ''{1}''
abstract.method.in.non.abstract.class=Abstract method in non-abstract class
overrides.deprecated.method=Overrides deprecated method in ''{0}''
overrides.marked.for.removal.method=Overrides method that is deprecated and marked for removal in ''{0}''
deprecated.default.constructor=Default constructor in ''{0}'' is deprecated
marked.for.removal.default.constructor=Default constructor in ''{0}'' is deprecated and marked for removal
cannot.resolve.constructor=Cannot resolve constructor ''{0}''
clash.methods.message=''{0}'' clashes with ''{1}''
clash.methods.message.show.classes=''{0}'' in ''{2}'' clashes with ''{1}'' in ''{3}''

package.clashes.with.class=Package ''{0}'' clashes with class of same name
# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
# {0} - left raw type, {1} - required type arguments row, {2} - right raw type, {3} - found type arguments row, {4} - reason, {5} - greyed title color
incompatible.types.html.tooltip=\
  <html><body><table>\
  <tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>Required type:</td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr>\
  <tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>Provided:</td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr>\
  </table>{4}</body></html>

inconvertible.type.cast=Inconvertible types; cannot cast ''{0}'' to ''{1}''
binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
return.outside.method=Return outside method
return.from.void.method=Cannot return a value from a method with void result type
return.from.constructor=Cannot return a value from a constructor
#{0} - exceptions list (comma separated), {1} - exceptions count in the list, {2} - exception source
unhandled.exceptions=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
variable.already.defined=Variable ''{0}'' is already defined in the scope
modifier.not.allowed=Modifier ''{0}'' not allowed here
not.a.statement=Not a statement
invalid.statement=Invalid statement
incompatible.types=Incompatible types. Found: ''{1}'', required: ''{0}''
switch.pattern.expected=Pattern expected for switch selector type ''{0}''
unexpected.type=Unexpected type. Found: ''{1}'', required: ''{0}''
incompatible.types.reason.ambiguous.method.reference=<br/>reason: method reference is ambiguous: both ''{0}'' and ''{1}'' match
incompatible.switch.null.type=''{0}'' cannot be converted to ''{1}''
inaccessible.type=''{0}'' is inaccessible here
valid.switch.selector.types=byte, char, short or int
valid.switch.1_7.selector.types=char, byte, short, int, Character, Byte, Short, Integer, String, or an enum
switch.illegal.fall.through.to=Illegal fall-through to a pattern
invalid.case.label.combination.constants.and.patterns=Invalid case label combination: a case label must consist of either a list of case constants or a single case pattern
invalid.case.label.combination.constants.and.patterns.unnamed=Invalid case label combination: a case label must consist of either a list of case constants or a list of case patterns
invalid.case.label.combination.several.patterns.unnamed=Invalid case label combination: multiple patterns are allowed only if none of them declare any pattern variables
invalid.case.label.combination.several.patterns=Invalid case label combination: a case label must not consist of more than one case pattern
null.label.not.allowed.here=Invalid case label combination: 'null' can only be used as a single case label or paired only with 'default'
default.label.must.not.contains.case.keyword=The label for the default case must only use the 'default' keyword, without 'case'
invalid.default.and.null.order=Invalid case label order: 'null' must be first and 'default' must be second
default.label.not.allowed.here=Default label not allowed here: 'default' can only be used as a single case label or paired only with 'null'
multiple.switch.labels=Multiple switch labels are permitted for a switch labeled statement group only if none of them declare any pattern variables
switch.dominance.of.preceding.label=Label is dominated by a preceding case label ''{0}''
switch.unconditional.pattern.and.default.exist='switch' has both an unconditional pattern and a default label
switch.unconditional.boolean.and.default.exist='switch' has all boolean values and a default label
switch.unconditional.boolean.and.unconditional.exist='switch' has all boolean values and an unconditional pattern
switch.class.or.array.type.expected=class or array
switch.invalid.selector.types=Selector type of ''{0}'' is not supported
non.static.symbol.referenced.from.static.context=Non-static {0} ''{1}'' cannot be referenced from a static context
private.symbol=''{0}'' has private access in ''{1}''
protected.symbol=''{0}'' has protected access in ''{1}''
package.local.symbol=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
visibility.access.problem=Cannot access ''{0}'' in ''{1}''
visibility.module.access.problem=Access to ''{0}'' in ''{1}'' is prevented by {2}
expression.expected=Expression expected
qualified.enum.constant.in.switch=An enum switch case label must be the unqualified name of an enumeration constant
qualified.enum.constant.in.switch.remove.fix=Remove qualifier
constant.expression.required=Constant expression required
switch.constant.expression.required=Constant expression, pattern or null is required
deconstruction.pattern.requires.record=Deconstruction pattern can only be applied to a record, ''{0}'' is not a record
duplicate.unconditional.pattern.label=Duplicate unconditional pattern
duplicate.default.switch.label=Duplicate default label
duplicate.switch.label=Duplicate label ''{0}''
switch.expr.empty='switch' expression does not have any case clauses
switch.statement.empty='switch' statement does not have any case clauses
switch.expr.incomplete='switch' expression does not cover all possible input values
switch.statement.incomplete='switch' statement does not cover all possible input values
switch.expr.no.result=Switch expression does not have any result expressions
switch.expr.should.produce.result=Switch expression should produce result in all execution paths
switch.expr.rule.should.produce.result=Switch expression rule should produce result in all execution paths
incorrect.number.of.nested.patterns=Incorrect number of nested patterns: expected {0} but found {1}
identifier.is.not.allowed.here=Identifier is not allowed here

illegal.forward.reference=Cannot read value of field ''{0}'' before the field''s definition
unknown.class=Unknown class: ''{0}''
illegal.type.void=Illegal type: 'void'
member.referenced.before.constructor.called=Cannot reference ''{0}'' before superclass constructor is called
method.called.before.constructor.called=Cannot call ''{0}'' before superclass constructor is called
assign.initialized.field.before.constructor.call=Cannot assign initialized field ''{0}'' before superclass constructor is called
statement.must.be.prepended.with.case.label=Statement must be prepended with case label
different.case.kinds.in.switch=Different 'case' kinds used in 'switch'
numeric.overflow.in.expression=Numeric overflow in expression
static.member.accessed.via.instance.reference=Static member ''{0}.{1}'' accessed via instance reference
deprecated.symbol=''{0}'' is deprecated
deprecated.since.symbol=''{0}'' is deprecated since version {1}
marked.for.removal.symbol=''{0}'' is deprecated and marked for removal
marked.for.removal.symbol.since=''{0}'' is deprecated since version {1} and marked for removal
cannot.resolve.symbol=Cannot resolve symbol ''{0}''
class.in.default.package=Class ''{0}'' is in the default package

local.variable.is.never.used=Variable ''{0}'' is never used
local.variable.is.not.used.for.reading=Variable ''{0}'' is assigned but never accessed
local.variable.is.not.assigned=Variable ''{0}'' is never assigned
private.field.is.not.used=Private field ''{0}'' is never used
field.is.not.used=Field ''{0}'' is never used
field.is.not.used.for.reading={0} field ''{1}'' is assigned but never accessed
private.field.is.not.assigned=Private field ''{0}'' is never assigned
parameter.is.not.used=Parameter ''{0}'' is never used
parameter.excluding.hierarchy.disable.text=Do not highlight parameters for inherited methods
pattern.variable.is.not.used=Pattern variable ''{0}'' is never used
private.method.is.not.used=Private method ''{0}'' is never used
method.is.not.used=Method ''{0}'' is never used
constructor.is.not.used=Constructor ''{0}'' is never used
private.constructor.is.not.used=Private constructor ''{0}'' is never used
private.inner.class.is.not.used=Private inner class ''{0}'' is never used
private.inner.interface.is.not.used=Private inner interface ''{0}'' is never used
type.parameter.is.not.used=Type parameter ''{0}'' is never used
local.class.is.not.used=Local class ''{0}'' is never used
class.is.not.used=Class ''{0}'' is never used
interface.is.not.used=Interface ''{0}'' is never used
enum.is.not.used=Enum ''{0}'' is never used
annotation.interface.is.not.used=@Interface ''{0}'' is never used
record.is.not.used=Record ''{0}'' is never used

# suppress inspection "UnusedProperty"
expected.identifier=Identifier expected
# suppress inspection "UnusedProperty"
unexpected.token=Unexpected token
expected.identifier.or.type=Identifier or type expected
# suppress inspection "UnusedProperty"
expected.rbracket=']' expected
# suppress inspection "UnusedProperty"
expected.expression=Expression expected
expected.semicolon=';' expected
# suppress inspection "UnusedProperty"
expected.lparen='(' expected
# suppress inspection "UnusedProperty"
expected.rparen=')' expected
# suppress inspection "UnusedProperty"
expected.rbrace='}' expected
# suppress inspection "UnusedProperty"
expected.lbrace='{' expected
expected.parameter=Parameter expected
expected.comma=',' expected
# suppress inspection "UnusedProperty"
expected.lparen.or.lbracket='(' or '[' expected
# suppress inspection "UnusedProperty"
else.without.if='else' without 'if'
# suppress inspection "UnusedProperty"
catch.without.try='catch' without 'try'
# suppress inspection "UnusedProperty"
finally.without.try='finally' without 'try'
# suppress inspection "UnusedProperty"
expected.statement=Statement expected
# suppress inspection "UnusedProperty"
expected.while='while' expected
# suppress inspection "UnusedProperty"
expected.catch.or.finally='catch' or 'finally' expected
# suppress inspection "UnusedProperty"
expected.boolean.expression=Boolean expression expected
# suppress inspection "UnusedProperty"
expected.switch.label='case', 'default' or '}' expected
# suppress inspection "UnusedProperty"
expected.switch.rule=Expression, block or throw statement expected
error.cannot.resolve.class=Cannot resolve class ''{0}''
error.cannot.resolve.class.or.package=Cannot resolve class or package ''{0}''
expected.class.or.package=Expected class or package
suspicious.name.assignment=''{0}'' should probably not be assigned to ''{1}''
suspicious.name.parameter=''{0}'' should probably not be passed as parameter ''{1}''
suspicious.name.return=''{0}'' should probably not be returned from method ''{1}''
cannot.resolve.package=Cannot resolve package {0}
declaration.not.allowed=Declaration not allowed here

assert.identifier.warn=Use of 'assert' as an identifier is not supported in releases since Java 1.4
enum.identifier.warn=Use of 'enum' as an identifier is not supported in releases since Java 1.5
underscore.identifier.warn=Use of '_' as an identifier is not supported in releases since Java 9
# {0} = restricted identifier, like 'var', {1} = java version like '10'
restricted.identifier.warn=Use of ''{0}'' as a class name is not supported in releases since Java {1}
module.unwanted.modifier.warn=Modifiers on 'requires java.base' are prohibited in releases since Java 10
yield.unqualified.method.warn=Unqualified call to 'yield' method is not supported in releases since Java 14
redundant.semicolon.warn=Redundant semicolons between import statements are prohibited starting from Java 21

module.no.package=A module file should not have 'package' statement
module.file.wrong.name=Module declaration should be in a file named 'module-info.java'
module.file.duplicate='module-info.java' already exists in the module
module.duplicate.requires=Duplicate ''requires'': {0}
module.duplicate.exports=Duplicate ''exports'': {0}
module.duplicate.opens=Duplicate ''opens'': {0}
module.duplicate.uses=Duplicate ''uses'': {0}
module.duplicate.provides=Duplicate ''provides'': {0}
module.duplicate.exports.target=Duplicate ''exports'' target: {0}
module.duplicate.opens.target=Duplicate ''opens'' target: {0}
module.duplicate.impl=Duplicate implementation: {0}
module.file.wrong.location=Module declaration should be located in a module's source root
module.open.duplicate.text=Go to duplicate
module.not.found=Module not found: {0}
module.ambiguous=Ambiguous module reference: {0}
module.not.on.path=Module is not in dependencies: {0}
module.cyclic.dependence=Cyclic dependence: {0}
module.opens.in.weak.module='opens' is not allowed in an open module
package.not.found=Package not found: {0}
package.is.empty=Package is empty: {0}
module.service.enum=The service definition is an enum: {0}
module.service.alien=The service implementation must be defined in the same module as the provides directive
module.service.impl=The service implementation type must be a subtype of the service interface type, or have a public static no-args 'provider' method
module.service.abstract=The service implementation is an abstract class: {0}
module.service.inner=The service implementation is an inner class: {0}
module.service.no.ctor=The service implementation does not have a public default constructor: {0}
module.service.provider.type=The ''provider'' method return type must be a subtype of the service interface type: {0}
module.service.unused=Service interface provided but not exported or used
module.conflicting.reads=Module ''{0}'' reads package ''{1}'' from both ''{2}'' and ''{3}''
module.conflicting.packages=Package ''{0}'' exists in another module: {1}
module.access.to.unnamed=Package ''{0}'' is declared in the unnamed module, but module ''{1}'' does not read it
module.access.from.named=Package ''{0}'' is declared in module ''{1}'', which does not export it to module ''{2}''
module.access.from.unnamed=Package ''{0}'' is declared in module ''{1}'', which does not export it to the unnamed module
module.access.does.not.read=Package ''{0}'' is declared in module ''{1}'', but module ''{2}'' does not read it
module.does.not.read=Module ''{0}'' fails to read ''{1}''
module.access.not.in.graph=Package ''{0}'' is declared in module ''{1}'', which is not in the module graph
module.not.in.graph=Module ''{0}'' is missing from the module graph
module.access.bad.name=Package ''{0}'' is declared in module with an invalid name (''{1}'')
module.bad.name=Module ''{0}'' has an invalid name

restricted.identifier=''{0}'' is a restricted identifier and cannot be used for type declarations
record.canonical.constructor=Canonical constructor
record.compact.constructor=Compact constructor
record.component.not.initialized=Record component ''{0}'' might not be initialized in canonical constructor
insufficient.language.level={0} are not supported at language level ''{1}''

cannot.select.from.a.type.parameter=Cannot select from a type parameter
method.reference.expression.is.not.expected=Method reference expression is not expected here
not.a.functional.interface={0} is not a functional interface
cannot.find.class=Cannot find class {0}
cannot.infer.functional.interface.type=Cannot infer functional interface type
lambda.expression.not.expected=Lambda expression not expected here
lambda.parameters.consistency.message=Cannot mix 'var' and explicitly typed parameters in lambda expression
target.method.is.generic=Target method is generic
multiple.non.overriding.abstract.methods.found.in.0=Multiple non-overriding abstract methods found in {0}
multiple.non.overriding.abstract.methods.found.in.interface.0=Multiple non-overriding abstract methods found in interface {0}
no.target.method.found=No target method found
target.type.of.a.lambda.conversion.must.be.an.interface=Target type of a lambda conversion must be an interface
incompatible.parameter.types.in.lambda=Incompatible parameter types in lambda expression: expected {0} but found {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=Incompatible parameter types in lambda expression: wrong number of parameters: expected {0} but found {1}
an.enclosing.instance.of.type.not.in.scope.method.reference.context=An enclosing instance of type {0} is not in scope
parameterized.qualifier.on.static.method.reference.context=Parameterized qualifier on static method reference
static.method.referenced.through.receiver.method.reference.context=Static method referenced through receiver
static.method.referenced.through.non.static.qualifier.method.reference.context=Static method referenced through non-static qualifier
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=Non-static method cannot be referenced from a static context
abstract.method.0.cannot.be.accessed.directly.method.reference.context=Abstract method ''{0}'' cannot be accessed directly
bad.type.in.switch.expression=Bad type in switch expression: {0} cannot be converted to {1}
switch.expression.cannot.be.void=Target type for switch expression cannot be void
annotation.on.static.member.qualifying.type.family.name=Move type annotation
not.allowed.in.sealed.hierarchy=''{0}'' is not allowed in the sealed hierarchy
invalid.permits.clause.direct.implementation=Invalid permits clause: ''{0}'' must directly {1, choice, 1#extend|2#implement} ''{2}''
permitted.subclass.must.have.modifier=All sealed class subclasses must either be final, sealed or non-sealed
permits.list.generics.are.not.allowed=Generics are not allowed in permits list
sealed.cannot.be.functional.interface=Sealed class can not be used as functional interface
local.classes.must.not.extend.sealed.classes=Local classes must not extend sealed classes
class.not.allowed.to.extend.sealed.class.from.another.package={0} ''{1}'' from another package not allowed to extend sealed {2} ''{3}'' in unnamed module
class.not.allowed.to.extend.sealed.class.from.another.module=Class is not allowed to extend sealed class from another module
create.class.action.this.not.valid.java.qualified.name=This is not a valid Java qualified name
text.class.inherits.abstract.and.default={0} inherits abstract and default for {1} from types {2} and {3}
text.class.inherits.unrelated.defaults={0} inherits unrelated defaults for {1} from types {2}
text.class.is.not.accessible={0} is not accessible in current context
text.class.cannot.access=Cannot access {0}
error.cannot.infer.pattern.type=Cannot infer pattern type: {0}
error.extra.semicolons.between.import.statements.not.allowed=Extra semicolons between import statements are not allowed
remove.unused.imports.quickfix.text=Remove unused imports
incomplete.project.state.pending.reference=Not resolved until the project is fully loaded
implicit.class.with.explicit.constructor=Explicit constructor in implicitly declared class is not allowed