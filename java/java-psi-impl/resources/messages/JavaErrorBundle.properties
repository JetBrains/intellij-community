# @interface (annotation) related messages
annotation.not.allowed.here=Annotations are not allowed here
annotation.unknown.method=Cannot find @interface method ''{0}()''
# suppress inspection "UnusedProperty"
annotation.missing.method=Cannot find @interface method ''{0}()''
annotation.illegal.array.initializer=Illegal initializer for ''{0}''
annotation.duplicate.annotation=Duplicate annotation
annotation.duplicate.attribute=Duplicate attribute ''{0}''
annotation.missing.attribute={0} missing though required
annotation.not.applicable=''@{0}'' not applicable to {1}
annotation.non.constant.attribute.value=Attribute value must be constant
annotation.non.class.literal.attribute.value=Attribute value must be a class literal
annotation.non.enum.constant.attribute.value=Attribute value must be an enum constant
annotation.invalid.annotation.member.type=Invalid type ''{0}'' for annotation member
annotation.cyclic.element.type=Cyclic annotation element type
annotation.annotation.type.expected=Annotation type expected
annotation.members.may.not.have.throws.list='throws' not allowed on @interface method
annotation.may.not.have.extends.list='extends' not allowed on @interface
annotation.not.allowed.ref=Annotation not applicable to this kind of reference
annotation.not.allowed.static=Static member qualifying type may not be annotated
annotation.not.allowed.void='void' type may not be annotated
annotation.not.allowed.var='var' type may not be annotated
annotation.not.allowed.class=Class literal type may not be annotated
annotation.container.no.value=Invalid container annotation ''{0}'': no ''value'' method declared
annotation.container.bad.type=Invalid container annotation ''{0}'': ''value'' method should have type ''{1}''
annotation.container.low.retention=Container annotation ''{0}'' has shorter retention (''{1}'') than the contained annotation
annotation.container.wide.target=Target of container annotation ''{0}'' is not a subset of target of this annotation
annotation.container.abstract=Container annotation ''{0}'' does not have a default value for ''{1}''
annotation.container.missed.annotation=Container annotation ''{0}'' does not have required @{1} annotation
annotation.duplicate.explained=Duplicate annotation. {0}
annotation.non.repeatable=The declaration of ''{0}'' does not have a valid java.lang.annotation.Repeatable annotation
annotation.container.wrong.place=Container annotation ''{0}'' must not be present at the same time as the element it contains
annotation.container.not.applicable=Container annotation ''@{0}'' is not applicable to {1}
annotation.not.allowed.in.permit.list=Annotations not allowed in 'permits' list

receiver.wrong.context=Receivers are not allowed outside of method parameter list
receiver.static.context=The receiver cannot be used in a static context
receiver.wrong.position=The receiver should be the first parameter
receiver.type.mismatch=The receiver type does not match the enclosing class type
receiver.name.mismatch=The receiver name does not match the enclosing class type

# generics related messages
generics.holder.type=Type
generics.holder.method=Method

generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should extend ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should implement ''{1}''
generics.type.parameter.is.not.within.its.bound.extend=Type parameter ''{0}'' is not within its bound; should extend ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=Type parameter ''{0}'' is not within its bound; should implement ''{1}''

# {0} - Type (class) or Method
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' does not have type parameters
generics.wrong.number.of.type.arguments=Wrong number of type arguments: {0}; required: {1}
generics.cannot.be.inherited.with.different.type.arguments=''{0}'' cannot be inherited with different type arguments: ''{1}'' and ''{2}''
generics.cannot.be.inherited.as.raw.and.generic=''{0}'' cannot be inherited as a raw type and with generic type arguments ''{1}''
generics.select.static.class.from.parameterized.type=Type arguments are not allowed here because class ''{0}'' is static
generics.methods.have.same.erasure={0}; both methods have same erasure
generics.methods.have.same.erasure.override={0}; both methods have same erasure, yet neither overrides the other
generics.methods.have.same.erasure.hide={0}; both methods have same erasure, yet neither hides the other
generics.type.parameter.cannot.be.instantiated=Type parameter ''{0}'' cannot be instantiated directly
wildcard.type.cannot.be.instantiated=Wildcard type ''{0}'' cannot be instantiated directly
generics.wildcard.not.expected=No wildcard expected
generics.wildcards.may.be.used.only.as.reference.parameters=Wildcards may be used only as reference parameters
generics.type.argument.cannot.be.of.primitive.type=Type argument cannot be of primitive type
generics.unchecked.assignment=Unchecked assignment: ''{0}'' to ''{1}''
generics.unchecked.cast=Unchecked cast: ''{0}'' to ''{1}''
generics.unchecked.call.to.member.of.raw.type=Unchecked call to ''{0}'' as a member of raw type ''{1}''
generics.unchecked.call=Unchecked method ''{0}'' invocation
generics.diamond.not.applicable=Diamond operator is not applicable for non-parameterized types
generics.reference.parameters.not.allowed=Reference parameters are not allowed here
foreach.not.applicable=Foreach not applicable to type ''{0}''
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=Accessing {0, choice, 1#static field|2#enum constant} from enum {1, choice, 1#constructor|2#instance field initializer|3#instance initializer} is not allowed
enum.types.cannot.be.instantiated=Enum types cannot be instantiated
generic.array.creation=Generic array creation not allowed
cannot.create.array.with.empty.diamond=Array creation with '<>' not allowed
array.creation.with.type.arguments=Array creation with type arguments not allowed
diamond.operator.not.allowed.here=Diamond operator is not allowed here
generics.enum.may.not.have.type.parameters=Enum may not have type parameters
generics.annotation.members.may.not.have.type.parameters=@interface members may not have type parameters
annotation.may.not.have.type.parameters=@interface may not have type parameters
generics.duplicate.type.parameter=Duplicate type parameter: ''{0}''
generics.cannot.catch.type.parameters=Cannot catch type parameters
generics.cannot.instanceof.type.parameters=Class or array expected
illegal.generic.type.for.instanceof=Illegal generic type for instanceof
unsafe.cast.in.instanceof=''{0}'' cannot be safely cast to ''{1}''
instanceof.pattern.supertype=Pattern type ''{0}'' is a supertype of expression type ''{1}''
instanceof.pattern.equals=Pattern type ''{0}'' is the same as expression type
cannot.select.dot.class.from.type.variable=Cannot access class object of a type parameter
method.does.not.override.super=Method does not override method from its superclass
static.method.cannot.be.annotated.with.override=Static methods cannot be annotated with @Override
call.to.super.is.not.allowed.in.enum.constructor=Call to super is not allowed in enum constructor

bad.qualifier.in.super.method.reference.overridden=Bad type qualifier in default super call: method {0} is overridden in {1}
bad.qualifier.in.super.method.reference.extended=Bad type qualifier in default super call: redundant interface {0} is extended by {1}

vararg.not.last.parameter=Vararg parameter must be the last in the list
vararg.cstyle.array.declaration=C-style array declaration not allowed in vararg parameter
modifiers.for.enum.constants=No modifiers allowed for enum constants
generics.type.arguments.on.raw.type=Type arguments given on a raw type
generics.type.arguments.on.raw.method=Type arguments given on a raw method
classes.extends.prohibited.super=Classes cannot directly extend ''{0}''
unchecked.overriding.incompatible.return.type=Unchecked overriding: return type requires unchecked conversion. Found ''{0}'', required ''{1}''

interface.expected=Interface expected here
no.interface.expected=No interface expected here
class.expected=Class name expected here
implements.after.interface='implements' not allowed on interface
extends.after.enum='extends' not allowed on enum
permits.after.enum='permits' not allowed on enum
class.must.be.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
enum.constant.must.implement.method=Enum constant ''{0}'' must implement abstract method ''{1}'' in ''{2}''
class.must.implement.method=Class ''{0}'' must implement abstract method ''{1}'' in ''{2}''
abstract.cannot.be.instantiated=''{0}'' is abstract; cannot be instantiated
duplicate.class.in.other.file=Duplicate class found in the file ''{0}''
duplicate.class=Duplicate class: ''{0}''
duplicate.reference.in.list=Duplicate reference to ''{0}'' in ''{1}'' list
public.class.should.be.named.after.file=Class ''{0}'' is public, should be declared in a file named ''{0}.java''
inheritance.from.final.class=Cannot inherit from {1} ''{0}''
package.name.file.path.mismatch=Package name ''{0}'' does not correspond to the file path ''{1}''
missing.package.statement=Missing package statement: ''{0}''
missing.package.statement.package.name.invalid=Missing package statement but package name ''{0}'' which corresponds to the file path is invalid
cyclic.inheritance=Cyclic inheritance involving ''{0}''
class.already.imported=''{0}'' is already defined in this compilation unit
class.cannot.extend.multiple.classes=Class cannot extend multiple classes
not.allowed.in.interface=Not allowed in interface
qualified.new.of.static.class=Qualified new of static class
invalid.qualified.new=Invalid qualified new
class.name.expected=Class name expected
no.enclosing.instance.in.scope=No enclosing instance of type ''{0}'' is in scope
is.not.an.enclosing.class=''{0}'' is not an enclosing class
local.class.referenced.from.other.switch.branch=Local class ''{0}'' cannot be referenced from another switch branch
cannot.be.referenced.from.static.context=''{0}'' cannot be referenced from a static context
no.default.constructor.available=There is no parameterless constructor available in ''{0}''
missing.return.statement=Missing return statement
unreachable.statement=Unreachable statement
unreachable.statement.false.condition=Loop condition is always false making the loop body unreachable
variable.not.initialized=Variable ''{0}'' might not have been initialized
variable.already.assigned=Variable ''{0}'' might already have been assigned to
variable.assigned.in.loop=Variable ''{0}'' might be assigned in loop
assignment.to.final.variable=Cannot assign a value to final variable ''{0}''
variable.must.be.final=Variable ''{0}'' is accessed from within inner class, needs to be declared final
variable.must.be.final.or.effectively.final=Variable ''{0}'' is accessed from within inner class, needs to be final or effectively final
lambda.variable.must.be.final=Variable used in lambda expression should be final or effectively final
resource.variable.must.be.final=Variable used as a try-with-resources resource should be final or effectively final
guarded.pattern.variable.must.be.final=Variable used in guarded pattern should be final or effectively final
when.expression.is.false=This case label has a guard that is a constant expression with value 'false'
declaration.or.variable.expected=Declaration, final or effectively final variable expected
initializer.must.be.able.to.complete.normally=Initializer must be able to complete normally
weaker.privileges={0}; attempting to assign weaker access privileges (''{1}''); was ''{2}''
incompatible.return.type=attempting to use incompatible return type
final.method.override=''{0}'' cannot override ''{1}'' in ''{2}''; overridden method is final
overridden.method.does.not.throw={0}; overridden method does not throw ''{1}''
exception.is.never.thrown=Exception ''{0}'' is never thrown in the method
wrong.method.arguments=''{0}'' in ''{1}'' cannot be applied to ''{2}''
method.call.expected=Method call expected
ambiguous.method.call=Ambiguous method call: both ''{0}'' and ''{1}'' match
ambiguous.reference=Reference to ''{0}'' is ambiguous, both ''{1}'' and ''{2}'' match
cannot.resolve.method=Cannot resolve method ''{0}''
ambiguous.method.call.no.match=Cannot resolve method ''{0}'' in ''{1}''
missing.method.body=Missing method body, or declare abstract
abstract.method.in.non.abstract.class=Abstract method in non-abstract class
missing.return.type=Invalid method declaration; return type required
duplicate.method=''{0}'' is already defined in ''{1}''
constructor.call.must.be.first.statement=Call to ''{0}'' must be first statement in constructor body
constructor.call.only.allowed.in.constructor=Call to ''{0}'' only allowed in constructor body
constructor.call.must.be.top.level.statement=Call to ''{0}'' must be a top level statement in constructor body
only.one.constructor.call.allowed.in.constructor=Only one explicit constructor call allowed in constructor
direct.abstract.method.access=Abstract method ''{0}'' cannot be accessed directly
unrelated.overriding.methods.return.types=methods have unrelated return types
overrides.deprecated.method=Overrides deprecated method in ''{0}''
overrides.marked.for.removal.method=Overrides method that is deprecated and marked for removal in ''{0}''
deprecated.default.constructor=Default constructor in ''{0}'' is deprecated
marked.for.removal.default.constructor=Default constructor in ''{0}'' is deprecated and marked for removal
recursive.constructor.invocation=Recursive constructor call
wrong.constructor.arguments=''{0}'' cannot be applied to ''{1}''
cannot.resolve.constructor=Cannot resolve constructor ''{0}''
invalid.package.annotation.containing.file=Package annotations should be in file package-info.java
repeated.annotation.target=Repeated annotation target

clash.methods.message=''{0}'' clashes with ''{1}''
clash.methods.message.show.classes=''{0}'' in ''{2}'' clashes with ''{1}'' in ''{3}''

package.clashes.with.class=Package ''{0}'' clashes with class of same name
class.clashes.with.package=Class ''{0}'' clashes with package of same name

# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
ambiguous.method.html.tooltip=\
  <html><body><table border=0>\
  <tr><td colspan={0}>Ambiguous method call. Both</td></tr>\
  <tr>{1}<td>in <b>{2}</b>\\&nbsp;and</td></tr>\
  <tr>{3}<td>in <b>{4}</b>\\&nbsp;match</td></tr>\
  </table></body></html>

# {0} - left raw type, {1} - required type arguments row, {2} - right raw type, {3} - found type arguments row, {4} - reason, {5} - greyed title color
incompatible.types.html.tooltip=\
  <html><body><table>\
  <tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>Required type:</td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr>\
  <tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>Provided:</td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr>\
  </table>{4}</body></html>

interface.methods.cannot.have.body=Interface abstract methods cannot have body
abstract.methods.cannot.have.a.body=Abstract methods cannot have a body
native.methods.cannot.have.a.body=Native methods cannot have a body
static.methods.in.interfaces.should.have.body=Static methods in interfaces should have a body
private.methods.in.interfaces.should.have.body=Private methods in interfaces should have a body
extension.method.should.have.a.body=Extension method should have a body
extension.method.in.class=Extension methods can only be used within an interface

instance.method.cannot.override.static.method=Instance method ''{0}'' in ''{1}'' cannot override static method ''{2}'' in ''{3}''
static.method.cannot.override.instance.method=Static method ''{0}'' in ''{1}'' cannot override instance method ''{2}'' in ''{3}''
inconvertible.type.cast=Inconvertible types; cannot cast ''{0}'' to ''{1}''
variable.expected=Variable expected
binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
unary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}''
return.outside.method=Return outside method
return.from.void.method=Cannot return a value from a method with void result type
return.from.constructor=Cannot return a value from a constructor
missing.return.value=Missing return value
return.statement.not.allowed.before.explicit.constructor.call='return' not allowed before ''{0}'' call
return.outside.switch.expr=Return outside of enclosing switch expression
impossible.assign.declared.outside.guard=Cannot assign a value to variable ''{0}'', because it is declared outside the guard

#{0} - exceptions list (comma separated), {1} - exceptions count in the list, {2} - exception source
unhandled.exceptions=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
unhandled.close.exceptions=Unhandled {1, choice, 0#exception|2#exceptions} from {2}: {0}

variable.already.defined=Variable ''{0}'' is already defined in the scope
break.outside.switch.or.loop=Break outside switch or loop
yield.unexpected=Yield outside of switch expression
yield.void=Expression type should not be 'void'
break.outside.switch.expr=Break out of switch expression is not allowed
continue.outside.loop=Continue outside of loop
continue.outside.switch.expr=Continue outside of enclosing switch expression
class.member.declared.outside=Class member declared outside of a class
not.loop.label=Not a loop label: ''{0}''
incompatible.modifiers=Illegal combination of modifiers ''{0}'' and ''{1}''
repeated.modifier=Repeated modifier ''{0}''
modifier.not.allowed=Modifier ''{0}'' not allowed here
modifier.not.allowed.on.local.classes=Modifier ''{0}'' not allowed on local classes
modifier.not.allowed.on.classes.without.sealed.super=Modifier 'non-sealed' not allowed on classes that do not have a sealed superclass
exception.never.thrown.try=Exception ''{0}'' is never thrown in the corresponding try block
exception.already.caught.warn=Unreachable section: {1, choice, 0#exception|2#exceptions} ''{0}'' {1, choice, 0#has|2#have} already been caught
not.a.statement=Not a statement
invalid.statement=Invalid statement
incompatible.types=Incompatible types. Found: ''{1}'', required: ''{0}''
switch.pattern.expected=Pattern expected for switch selector type ''{0}''
unexpected.type=Unexpected type. Found: ''{1}'', required: ''{0}''
incompatible.types.reason.ambiguous.method.reference=<br/>reason: method reference is ambiguous: both ''{0}'' and ''{1}'' match
incompatible.switch.null.type=''{0}'' cannot be converted to ''{1}''
inaccessible.type=''{0}'' is inaccessible here
valid.switch.selector.types=byte, char, short or int
valid.switch.1_7.selector.types=char, byte, short, int, Character, Byte, Short, Integer, String, or an enum
switch.illegal.fall.through.from=Illegal fall-through from a pattern
switch.illegal.fall.through.to=Illegal fall-through to a pattern
invalid.case.label.combination.constants.and.patterns=Invalid case label combination: a case label must consist of either a list of case constants or a single case pattern
invalid.case.label.combination.constants.and.patterns.unnamed=Invalid case label combination: a case label must consist of either a list of case constants or a list of case patterns
invalid.case.label.combination.several.patterns.unnamed=Invalid case label combination: multiple patterns are allowed only if none of them declare any pattern variables
invalid.case.label.combination.several.patterns=Invalid case label combination: a case label must not consist of more than one case pattern
null.label.not.allowed.here=Invalid case label combination: 'null' can only be used as a single case label or paired only with 'default'
default.label.must.not.contains.case.keyword=The label for the default case must only use the 'default' keyword, without 'case'
invalid.default.and.null.order=Invalid case label order: 'null' must be first and 'default' must be second
default.label.not.allowed.here=Default label not allowed here: 'default' can only be used as a single case label or paired only with 'null'
multiple.switch.labels=Multiple switch labels are permitted for a switch labeled statement group only if none of them declare any pattern variables
switch.dominance.of.preceding.label=Label is dominated by a preceding case label ''{0}''
switch.unconditional.pattern.and.default.exist='switch' has both an unconditional pattern and a default label
switch.unconditional.boolean.and.default.exist='switch' has all boolean values and a default label
switch.unconditional.boolean.and.unconditional.exist='switch' has all boolean values and an unconditional pattern
switch.class.or.array.type.expected=class or array
switch.invalid.selector.types=Selector type of ''{0}'' is not supported
dot.expected.after.super.or.this='.' expected
unqualified.super.disallowed=Unqualified super reference is not allowed in extension method
static.interface.method.call.qualifier=Static method may only be called on its containing interface
non.static.symbol.referenced.from.static.context=Non-static {0} ''{1}'' cannot be referenced from a static context
private.symbol=''{0}'' has private access in ''{1}''
protected.symbol=''{0}'' has protected access in ''{1}''
package.local.symbol=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
visibility.access.problem=Cannot access ''{0}'' in ''{1}''
visibility.module.access.problem=Access to ''{0}'' in ''{1}'' is prevented by {2}
array.type.expected=Array type expected; found: ''{0}''
type.pattern.expected=Type pattern expected
expression.expected=Expression expected
array.initializer.not.allowed=Array initializer is not allowed here
case.statement.outside.switch=Case statement outside switch
qualified.enum.constant.in.switch=An enum switch case label must be the unqualified name of an enumeration constant
qualified.enum.constant.in.switch.remove.fix=Remove qualifier
constant.expression.required=Constant expression required
switch.constant.expression.required=Constant expression, pattern or null is required
deconstruction.pattern.requires.record=Deconstruction pattern can only be applied to a record, ''{0}'' is not a record
deconstruction.pattern.type.contain.annotation=Annotations are not allowed in deconstruction pattern types
error.raw.deconstruction=Raw deconstruction patterns are not allowed
raw.processor.type.not.allowed=Raw processor type is not allowed: {0}
duplicate.unconditional.pattern.label=Duplicate unconditional pattern
duplicate.default.switch.label=Duplicate default label
duplicate.switch.label=Duplicate label ''{0}''
switch.expr.empty='switch' expression does not have any case clauses
switch.statement.empty='switch' statement does not have any case clauses
switch.expr.incomplete='switch' expression does not cover all possible input values
switch.statement.incomplete='switch' statement does not cover all possible input values
switch.expr.no.result=Switch expression does not have any result expressions
switch.expr.should.produce.result=Switch expression should produce result in all execution paths
switch.expr.rule.should.produce.result=Switch expression rule should produce result in all execution paths
incorrect.number.of.nested.patterns=Incorrect number of nested patterns: expected {0} but found {1}
pattern.is.not.exhaustive=Pattern ''{0}'' is not exhaustive on ''{1}''
identifier.is.not.allowed.here=Identifier is not allowed here

illegal.forward.reference=Cannot read value of field ''{0}'' before the field''s definition
illegal.self.reference=Cannot read value of field ''{0}'' from inside the fields''s definition
illegal.forward.reference.enum=Cannot refer to enum constant ''{0}'' before its definition
illegal.self.reference.enum=Cannot refer to enum constant ''{0}'' from inside its own definition

unknown.class=Unknown class: ''{0}''
illegal.type.void=Illegal type: 'void'
member.referenced.before.constructor.called=Cannot reference ''{0}'' before superclass constructor is called
method.called.before.constructor.called=Cannot call ''{0}'' before superclass constructor is called
label.without.statement=Label without statement
duplicate.label=Label ''{0}'' already in use
unclosed.comment=Unclosed comment
exception.already.caught=Exception ''{0}'' has already been caught
exception.must.be.disjoint=Types in multi-catch must be disjoint: ''{0}'' is a subclass of ''{1}''
statement.must.be.prepended.with.case.label=Statement must be prepended with case label
different.case.kinds.in.switch=Different case kinds used in the switch
void.type.is.not.allowed='void' type is not allowed here
single.import.class.conflict=''{0}'' is already defined in a single-type import
numeric.overflow.in.expression=Numeric overflow in expression
static.member.accessed.via.instance.reference=Static member ''{0}.{1}'' accessed via instance reference
unresolved.label=Undefined label: ''{0}''
deprecated.symbol=''{0}'' is deprecated
deprecated.since.symbol=''{0}'' is deprecated since version {1}
marked.for.removal.symbol=''{0}'' is deprecated and marked for removal
marked.for.removal.symbol.since=''{0}'' is deprecated since version {1} and marked for removal
qualifier.must.be.expression=Qualifier must be an expression
cannot.resolve.symbol=Cannot resolve symbol ''{0}''
cannot.access.member.on.type=Cannot access member because ''{0}'' has primitive type {1}
implicit.class.can.not.be.referenced=Implicitly declared class ''{0}'' cannot be referenced
cannot.call.method.on.type=Cannot call method because ''{0}'' has primitive type {1}
class.is.already.defined.in.single.static.import=Class ''{0}'' is already defined in a single static import
class.is.ambiguous.in.single.static.import=Class ''{0}'' is ambiguous in a single static import
field.is.already.defined.in.single.static.import=Field ''{0}'' is already defined in a single static import
field.is.ambiguous.in.single.static.import=Field ''{0}'' is ambiguous in a single static import
annotation.interface.members.may.not.have.parameters=@interface members may not have parameters
class.in.default.package=Class ''{0}'' is in the default package

local.variable.is.never.used=Variable ''{0}'' is never used
local.variable.is.not.used.for.reading=Variable ''{0}'' is assigned but never accessed
local.variable.is.not.assigned=Variable ''{0}'' is never assigned
private.field.is.not.used=Private field ''{0}'' is never used
field.is.not.used=Field ''{0}'' is never used
field.is.not.used.for.reading={0} field ''{1}'' is assigned but never accessed
private.field.is.not.assigned=Private field ''{0}'' is never assigned
parameter.is.not.used=Parameter ''{0}'' is never used
parameter.excluding.hierarchy.disable.text=Do not highlight parameters for inherited methods
pattern.variable.is.not.used=Pattern variable ''{0}'' is never used
private.method.is.not.used=Private method ''{0}'' is never used
method.is.not.used=Method ''{0}'' is never used
constructor.is.not.used=Constructor ''{0}'' is never used
private.constructor.is.not.used=Private constructor ''{0}'' is never used
private.inner.class.is.not.used=Private inner class ''{0}'' is never used
private.inner.interface.is.not.used=Private inner interface ''{0}'' is never used
type.parameter.is.not.used=Type parameter ''{0}'' is never used
local.class.is.not.used=Local class ''{0}'' is never used
class.is.not.used=Class ''{0}'' is never used
interface.is.not.used=Interface ''{0}'' is never used
enum.is.not.used=Enum ''{0}'' is never used
annotation.interface.is.not.used=@Interface ''{0}'' is never used
record.is.not.used=Record ''{0}'' is never used

hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=Hexadecimal numbers must contain at least one hexadecimal digit
binary.numbers.must.contain.at.least.one.hexadecimal.digit=Binary numbers must contain at least one binary digit
integer.number.too.large=Integer number too large
long.number.too.large=Long number too large
malformed.floating.point.literal=Malformed floating point literal
illegal.escape.character.in.character.literal=Illegal escape character in character literal
too.many.characters.in.character.literal=Too many characters in character literal
empty.character.literal=Empty character literal
illegal.line.end.in.string.literal=Line end not allowed in string literals
unclosed.char.literal=Unclosed character literal
illegal.escape.character.in.string.literal=Illegal escape character in string literal
illegal.unicode.escape=Illegal Unicode escape sequence
floating.point.number.too.large=Floating point number too large
floating.point.number.too.small=Floating point number too small
illegal.underscore=Illegal underscore
text.block.new.line=Illegal text block start: missing new line after opening quotes
text.block.unclosed=Unclosed text block
processor.missing.from.string.template.expression=Processor missing from string template expression
expression.with.type.void.not.allowed.as.string.template.embedded.expression=Expression with type 'void' not allowed as string template embedded expression

# suppress inspection "UnusedProperty"
expected.identifier=Identifier expected
# suppress inspection "UnusedProperty"
unexpected.token=Unexpected token
expected.identifier.or.type=Identifier or type expected
# suppress inspection "UnusedProperty"
expected.rbracket=']' expected
# suppress inspection "UnusedProperty"
expected.expression=Expression expected
expected.semicolon=';' expected
# suppress inspection "UnusedProperty"
expected.lparen='(' expected
# suppress inspection "UnusedProperty"
expected.rparen=')' expected
# suppress inspection "UnusedProperty"
expected.rbrace='}' expected
# suppress inspection "UnusedProperty"
expected.lbrace='{' expected
expected.parameter=Parameter expected
expected.comma=',' expected
# suppress inspection "UnusedProperty"
expected.lparen.or.lbracket='(' or '[' expected
# suppress inspection "UnusedProperty"
else.without.if='else' without 'if'
# suppress inspection "UnusedProperty"
catch.without.try='catch' without 'try'
# suppress inspection "UnusedProperty"
finally.without.try='finally' without 'try'
# suppress inspection "UnusedProperty"
expected.statement=Statement expected
# suppress inspection "UnusedProperty"
expected.while='while' expected
# suppress inspection "UnusedProperty"
expected.catch.or.finally='catch' or 'finally' expected
# suppress inspection "UnusedProperty"
expected.boolean.expression=Boolean expression expected
# suppress inspection "UnusedProperty"
expected.switch.label='case', 'default' or '}' expected
# suppress inspection "UnusedProperty"
expected.switch.rule=Expression, block or throw statement expected
error.cannot.resolve.class=Cannot resolve class ''{0}''
error.cannot.resolve.class.or.package=Cannot resolve class or package ''{0}''
expected.class.or.package=Expected class or package
suspicious.name.assignment=''{0}'' should probably not be assigned to ''{1}''
suspicious.name.parameter=''{0}'' should probably not be passed as parameter ''{1}''
suspicious.name.return=''{0}'' should probably not be returned from method ''{1}''
type.parameter.cannot.be.followed.by.other.bounds=Type parameter cannot be followed by other bounds
generic.extend.exception=Generic class may not extend 'java.lang.Throwable'
illegal.initializer=Illegal initializer for ''{0}''
class.cannot.inherit.from.its.type.parameter=Class cannot inherit from its type parameter
cannot.resolve.package=Cannot resolve package {0}
declaration.not.allowed=Declaration not allowed here

underscore.identifier.error=Since Java 9, '_' is a keyword, and may not be used as an identifier
underscore.identifier.error.unnamed=Using '_' as a reference is not allowed
underscore.lambda.identifier=Use of '_' as a lambda parameter name is not allowed

assert.identifier.warn=Use of 'assert' as an identifier is not supported in releases since Java 1.4
enum.identifier.warn=Use of 'enum' as an identifier is not supported in releases since Java 1.5
underscore.identifier.warn=Use of '_' as an identifier is not supported in releases since Java 9
# {0} = restricted identifier, like 'var', {1} = java version like '10'
restricted.identifier.warn=Use of ''{0}'' as a class name is not supported in releases since Java {1}
module.unwanted.modifier.warn=Modifiers on 'requires java.base' are prohibited in releases since Java 10
yield.unqualified.method.warn=Unqualified call to 'yield' method is not supported in releases since Java 14
redundant.semicolon.warn=Redundant semicolons between import statements are prohibited starting from Java 21

module.no.package=A module file should not have 'package' statement
module.file.wrong.name=Module declaration should be in a file named 'module-info.java'
module.file.duplicate='module-info.java' already exists in the module
module.duplicate.requires=Duplicate ''requires'': {0}
module.duplicate.exports=Duplicate ''exports'': {0}
module.duplicate.opens=Duplicate ''opens'': {0}
module.duplicate.uses=Duplicate ''uses'': {0}
module.duplicate.provides=Duplicate ''provides'': {0}
module.duplicate.exports.target=Duplicate ''exports'' target: {0}
module.duplicate.opens.target=Duplicate ''opens'' target: {0}
module.duplicate.impl=Duplicate implementation: {0}
module.file.wrong.location=Module declaration should be located in a module's source root
module.open.duplicate.text=Go to duplicate
module.not.found=Module not found: {0}
module.ambiguous=Ambiguous module reference: {0}
module.not.on.path=Module is not in dependencies: {0}
module.cyclic.dependence=Cyclic dependence: {0}
module.opens.in.weak.module='opens' is not allowed in an open module
package.not.found=Package not found: {0}
package.is.empty=Package is empty: {0}
module.service.enum=The service definition is an enum: {0}
module.service.alien=The service implementation must be defined in the same module as the provides directive
module.service.impl=The service implementation type must be a subtype of the service interface type, or have a public static no-args 'provider' method
module.service.abstract=The service implementation is an abstract class: {0}
module.service.inner=The service implementation is an inner class: {0}
module.service.no.ctor=The service implementation does not have a public default constructor: {0}
module.service.provider.type=The ''provider'' method return type must be a subtype of the service interface type: {0}
module.service.unused=Service interface provided but not exported or used
module.conflicting.reads=Module ''{0}'' reads package ''{1}'' from both ''{2}'' and ''{3}''
module.conflicting.packages=Package ''{0}'' exists in another module: {1}
module.access.to.unnamed=Package ''{0}'' is declared in the unnamed module, but module ''{1}'' does not read it
module.access.from.named=Package ''{0}'' is declared in module ''{1}'', which does not export it to module ''{2}''
module.access.from.unnamed=Package ''{0}'' is declared in module ''{1}'', which does not export it to the unnamed module
module.access.does.not.read=Package ''{0}'' is declared in module ''{1}'', but module ''{2}'' does not read it
module.does.not.read=Module ''{0}'' fails to read ''{1}''
module.access.not.in.graph=Package ''{0}'' is declared in module ''{1}'', which is not in the module graph
module.not.in.graph=Module ''{0}'' is missing from the module graph
module.access.bad.name=Package ''{0}'' is declared in module with an invalid name (''{1}'')
module.bad.name=Module ''{0}'' has an invalid name

restricted.identifier=''{0}'' is a restricted identifier and cannot be used for type declarations
restricted.identifier.reference=Illegal reference to restricted type ''{0}''

lvti.no.initializer=Cannot infer type: 'var' on variable without initializer
lvti.lambda=Cannot infer type: lambda expression requires an explicit target type
lvti.method.ref=Cannot infer type: method reference requires an explicit target type
lvti.compound='var' is not allowed in a compound declaration
lvti.array='var' is not allowed as an element type of an array
lvti.null=Cannot infer type: variable initializer is 'null'
lvti.void=Cannot infer type: variable initializer is 'void'
lvti.selfReferenced=Cannot infer type for ''{0}'', it is used in its own variable initializer

record.no.header=Record has no header declared
record.header.regular.class=Record header declared for non-record
record.extends='extends' not allowed on record
record.component.vararg.not.last=Vararg record component must be the last in the list
record.component.cstyle.declaration=C-style array declaration not allowed in record component
record.component.restricted.name=Illegal record component name ''{0}''
record.instance.initializer=Instance initializer is not allowed in record
record.instance.field=Instance field is not allowed in record
record.accessor.wrong.return.type=Incorrect component accessor return type. Expected: ''{0}'', found: ''{1}''
record.canonical.constructor.wrong.parameter.type=Incorrect parameter type for record component ''{0}''. Expected: ''{1}'', found: ''{2}''
record.canonical.constructor.wrong.parameter.name=Canonical constructor parameter names must match record component names. Expected: ''{0}'', found: ''{1}''
record.constructor.call.in.canonical=Canonical constructor cannot delegate to another constructor
record.no.constructor.call.in.non.canonical=Non-canonical record constructor must delegate to another constructor
record.special.method.type.parameters={0} cannot have type parameters
record.special.method.non.public={0} must be ''public''
record.special.method.stronger.access={0} access level cannot be more restrictive than the record access level (''{1}'')
record.special.method.throws=''throws'' not allowed on {0}
record.canonical.constructor=Canonical constructor
record.compact.constructor=Compact constructor
record.accessor=Record component accessor
record.component.not.initialized=Record component ''{0}'' might not be initialized in canonical constructor
compact.constructor.in.regular.class=Parameter list expected
record.compact.constructor.return='return' statement is not allowed in compact constructor
record.permits='permits' not allowed on record

insufficient.language.level={0} are not supported at language level ''{1}''

cannot.select.from.a.type.parameter=Cannot select from a type parameter
method.reference.expression.is.not.expected=Method reference expression is not expected here
not.a.functional.interface={0} is not a functional interface
cannot.find.class=Cannot find class {0}
cannot.infer.functional.interface.type=Cannot infer functional interface type
lambda.expression.not.expected=Lambda expression not expected here
lambda.parameters.consistency.message=Cannot mix 'var' and explicitly typed parameters in lambda expression
target.method.is.generic=Target method is generic
multiple.non.overriding.abstract.methods.found.in.0=Multiple non-overriding abstract methods found in {0}
multiple.non.overriding.abstract.methods.found.in.interface.0=Multiple non-overriding abstract methods found in interface {0}
no.target.method.found=No target method found
target.type.of.a.lambda.conversion.must.be.an.interface=Target type of a lambda conversion must be an interface
incompatible.parameter.types.in.lambda=Incompatible parameter types in lambda expression: expected {0} but found {1}
incompatible.parameter.types.in.lambda.wrong.number.of.parameters=Incompatible parameter types in lambda expression: wrong number of parameters: expected {0} but found {1}
an.enclosing.instance.of.type.not.in.scope.method.reference.context=An enclosing instance of type {0} is not in scope
parameterized.qualifier.on.static.method.reference.context=Parameterized qualifier on static method reference
static.method.referenced.through.receiver.method.reference.context=Static method referenced through receiver
static.method.referenced.through.non.static.qualifier.method.reference.context=Static method referenced through non-static qualifier
non.static.method.cannot.be.referenced.from.a.static.context.method.reference.context=Non-static method cannot be referenced from a static context
abstract.method.0.cannot.be.accessed.directly.method.reference.context=Abstract method ''{0}'' cannot be accessed directly
error.interface.member.clashes=@interface member clashes with ''{0}'' in {1}
anonymous.class.implements.interface.cannot.have.type.arguments=Anonymous class implements interface; cannot have type arguments
formal.varargs.element.type.inaccessible.here=Formal varargs element type {0} is inaccessible here
unexpected.type.class.expected=Unexpected type: class is expected
repeated.interface=Repeated interface
class.cannot.be.inherited.with.different.arguments={0} cannot be inherited with different arguments: {1}
bad.type.in.switch.expression=Bad type in switch expression: {0} cannot be converted to {1}
switch.expression.cannot.be.void=Target type for switch expression cannot be void
annotation.on.static.member.qualifying.type.family.name=Move type annotation
not.inner.class=Qualifier is not allowed because superclass ''{0}'' is not a non-static inner class
anonymous.class.implements.interface.cannot.have.qualifier=Anonymous class implements interface; cannot have qualifier for new
qualified.class.reference.not.allowed.in.qualified.new=Qualified class reference is not allowed in qualified new
actual.type.argument.contradict.inferred.type=Actual type argument and inferred type contradict each other
default.method.overrides.object.member=Default method ''{0}'' overrides a member of ''java.lang.Object''
two.methods.are.inherited.with.same.signature=Methods {0} from {1} and {2} from {3} are inherited with the same signature
cannot.select.from.parameterized.type=Cannot access class object of parameterized type
safevarargs.not.allowed.non.final.instance.methods=@SafeVarargs is not allowed on non-final instance methods
safevarargs.not.suppress.potentially.unsafe.operations=@SafeVarargs do not suppress potentially unsafe operations
safevarargs.not.applicable.for.reifiable.types=@SafeVarargs is not applicable for reifiable types
type.parameter.has.incompatible.upper.bounds=Type parameter {0} has incompatible upper bounds: {1}
safevarargs.not.allowed.on.methods.with.fixed.arity=@SafeVarargs is not allowed on methods with fixed arity
safevararg.annotation.cannot.be.applied.for.record.component=@SafeVarargs is not allowed on a record component
functional.interface.must.not.be.sealed.error.description=Functional interface can''t be declared as ''{0}''
sealed.type.inheritor.expected.modifiers=Modifier ''{0}'', ''{1}'' or ''{2}'' expected
sealed.type.inheritor.expected.modifiers2=Modifier ''{0}'' or ''{1}'' expected
not.allowed.in.sealed.hierarchy=''{0}'' is not allowed in the sealed hierarchy
invalid.permits.clause=Invalid permits clause: ''{0}'' must be sealed
invalid.permits.clause.direct.implementation=Invalid permits clause: ''{0}'' must directly {1, choice, 1#extend|2#implement} ''{2}''
sealed.must.have.inheritors=Sealed class must have subclasses
permit.list.must.contain.outside.inheritors=Sealed class permits clause must contain all subclasses
permitted.subclass.must.have.modifier=All sealed class subclasses must either be final, sealed or non-sealed
permits.list.generics.are.not.allowed=Generics are not allowed in permits list
sealed.cannot.be.functional.interface=Sealed class can not be used as functional interface
local.classes.must.not.extend.sealed.classes=Local classes must not extend sealed classes
anonymous.classes.must.not.extend.sealed.classes=Anonymous classes must not extend sealed classes
class.not.allowed.to.extend.sealed.class.from.another.package=Class is not allowed to extend sealed class from another package
class.not.allowed.to.extend.sealed.class.from.another.module=Class is not allowed to extend sealed class from another module
annotation.cannot.be.local=Local annotations are not allowed
create.class.action.this.not.valid.java.qualified.name=This is not a valid Java qualified name
text.class.inherits.abstract.and.default={0} inherits abstract and default for {1} from types {2} and {3}
text.class.inherits.unrelated.defaults={0} inherits unrelated defaults for {1} from types {2}
text.improper.formed.type=Improperly formed type: ''{0}'' needs type arguments because its qualifier has type arguments
text.class.is.not.accessible={0} is not accessible in current context
text.class.cannot.access=Cannot access {0}
auto.closeable.resource=auto-closeable resource
annotation.type.permits='permits' not allowed on @interface
too.many.array.dimensions=Too many array dimensions
error.cannot.infer.pattern.type=Cannot infer pattern type: {0}
error.extra.semicolons.between.import.statements.not.allowed=Extra semicolons between import statements are not allowed
error.guard.allowed.after.patterns.only=Guard is allowed after patterns only
error.implicit.class.contains.no.main.method=Implicitly declared class contains no 'main' method
error.implicit.class.has.invalid.file.name=Implicitly declared class's file name is not a valid identifier
error.package.statement.not.allowed.for.implicit.class=Package statement is not allowed for implicitly declared class
error.initializers.are.not.allowed.in.implicit.classes=Initializers are not allowed in implicitly declared classes
remove.unused.imports.quickfix.text=Remove unused imports
incomplete.project.state.pending.reference=Not resolved until the project is fully loaded