# @interface (annotation) related messages
annotation.not.allowed.here=Annotations are not allowed here
# suppress inspection "UnusedProperty"
annotation.missing.method=Cannot find @interface method ''{0}()''
# suppress inspection "UnusedProperty"
annotation.unknown.method=Cannot find @interface method ''{0}()''
annotation.not.applicable=''@{0}'' not applicable to {1}
annotation.annotation.type.expected=Annotation type expected
generics.wrong.number.of.type.arguments=Wrong number of type arguments: {0}; required: {1}
generics.type.argument.cannot.be.of.primitive.type=Type argument cannot be of primitive type
generics.unchecked.assignment=Unchecked assignment: ''{0}'' to ''{1}''
generics.unchecked.cast=Unchecked cast: ''{0}'' to ''{1}''
generics.unchecked.call.to.member.of.raw.type=Unchecked call to ''{0}'' as a member of raw type ''{1}''
generics.unchecked.call=Unchecked method ''{0}'' invocation
unsafe.cast.in.instanceof=''{0}'' cannot be safely cast to ''{1}''
unchecked.overriding.incompatible.return.type=Unchecked overriding: return type requires unchecked conversion. Found ''{0}'', required ''{1}''

class.must.be.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
class.must.implement.method=Class ''{0}'' must implement abstract method ''{1}'' in ''{2}''
package.name.file.path.mismatch=Package name ''{0}'' does not correspond to the file path ''{1}''
missing.package.statement=Missing package statement: ''{0}''
missing.package.statement.package.name.invalid=Missing package statement but package name ''{0}'' which corresponds to the file path is invalid
missing.return.statement=Missing return statement
variable.not.initialized=Variable ''{0}'' might not have been initialized
exception.is.never.thrown=Exception ''{0}'' is never thrown in the method
cannot.resolve.method=Cannot resolve method ''{0}''
ambiguous.method.call.no.match=Cannot resolve method ''{0}'' in ''{1}''
overrides.deprecated.method=Overrides deprecated method in ''{0}''
overrides.marked.for.removal.method=Overrides method that is deprecated and marked for removal in ''{0}''
deprecated.default.constructor=Default constructor in ''{0}'' is deprecated
marked.for.removal.default.constructor=Default constructor in ''{0}'' is deprecated and marked for removal
cannot.resolve.constructor=Cannot resolve constructor ''{0}''
# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
# {0} - left raw type, {1} - required type arguments row, {2} - right raw type, {3} - found type arguments row, {4} - reason, {5} - greyed title color
incompatible.types.html.tooltip=\
  <html><body><table>\
  <tr><td style=''padding: 0px 16px 8px 4px;color: {5}''>Required type:</td><td style=''padding: 0px 4px 8px 0px;''>{0}</td>{1}</tr>\
  <tr><td style=''padding: 0px 16px 0px 4px;color: {5}''>Provided:</td><td style=''padding: 0px 4px 0px 0px;''>{2}</td>{3}</tr>\
  </table>{4}</body></html>

inconvertible.type.cast=Inconvertible types; cannot cast ''{0}'' to ''{1}''
binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'', ''{2}''
return.outside.method=Return outside method
return.from.void.method=Cannot return a value from a method with void result type
return.from.constructor=Cannot return a value from a constructor
#{0} - exceptions list (comma separated), {1} - exceptions count in the list, {2} - exception source
unhandled.exceptions=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
variable.already.defined=Variable ''{0}'' is already defined in the scope
not.a.statement=Not a statement
invalid.statement=Invalid statement
incompatible.types=Incompatible types. Found: ''{1}'', required: ''{0}''
switch.pattern.expected=Pattern expected for switch selector type ''{0}''
unexpected.type=Unexpected type. Found: ''{1}'', required: ''{0}''
incompatible.types.reason.ambiguous.method.reference=<br/>reason: method reference is ambiguous: both ''{0}'' and ''{1}'' match
incompatible.switch.null.type=''{0}'' cannot be converted to ''{1}''
inaccessible.type=''{0}'' is inaccessible from here
switch.illegal.fall.through.to=Illegal fall-through to a pattern
invalid.case.label.combination.constants.and.patterns=Invalid case label combination: a case label must consist of either a list of case constants or a single case pattern
invalid.case.label.combination.constants.and.patterns.unnamed=Invalid case label combination: a case label must consist of either a list of case constants or a list of case patterns
invalid.case.label.combination.several.patterns.unnamed=Invalid case label combination: multiple patterns are allowed only if none of them declare any pattern variables
invalid.case.label.combination.several.patterns=Invalid case label combination: a case label must not consist of more than one case pattern
null.label.not.allowed.here=Invalid case label combination: 'null' can only be used as a single case label or paired only with 'default'
default.label.must.not.contains.case.keyword=The label for the default case must only use the 'default' keyword, without 'case'
invalid.default.and.null.order=Invalid case label order: 'null' must be first and 'default' must be second
default.label.not.allowed.here=Default label not allowed here: 'default' can only be used as a single case label or paired only with 'null'
multiple.switch.labels=Multiple switch labels are permitted for a switch labeled statement group only if none of them declare any pattern variables
switch.dominance.of.preceding.label=Label is dominated by a preceding case label ''{0}''
switch.unconditional.pattern.and.default.exist='switch' has both an unconditional pattern and a default label
switch.unconditional.boolean.and.default.exist='switch' has all boolean values and a default label
switch.unconditional.boolean.and.unconditional.exist='switch' has all boolean values and an unconditional pattern
switch.class.or.array.type.expected=class or array
switch.invalid.selector.types=Selector type of ''{0}'' is not supported
non.static.symbol.referenced.from.static.context=Non-static {0} ''{1}'' cannot be referenced from a static context
private.symbol=''{0}'' has private access in ''{1}''
protected.symbol=''{0}'' has protected access in ''{1}''
package.local.symbol=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
visibility.access.problem=Cannot access ''{0}'' in ''{1}''
visibility.module.access.problem=Access to ''{0}'' in ''{1}'' is prevented by {2}
expression.expected=Expression expected
qualified.enum.constant.in.switch=An enum switch case label must be the unqualified name of an enumeration constant
qualified.enum.constant.in.switch.remove.fix=Remove qualifier
constant.expression.required=Constant expression required
switch.constant.expression.required=Constant expression, pattern or null is required
deconstruction.pattern.requires.record=Deconstruction pattern can only be applied to a record, ''{0}'' is not a record
duplicate.unconditional.pattern.label=Duplicate unconditional pattern
duplicate.default.switch.label=Duplicate default label
duplicate.switch.label=Duplicate label ''{0}''
switch.expr.empty='switch' expression does not have any case clauses
switch.statement.empty='switch' statement does not have any case clauses
switch.expr.incomplete='switch' expression does not cover all possible input values
switch.statement.incomplete='switch' statement does not cover all possible input values
incorrect.number.of.nested.patterns=Incorrect number of nested patterns: expected {0} but found {1}
identifier.is.not.allowed.here=Identifier is not allowed here

illegal.forward.reference=Cannot read value of field ''{0}'' before the field''s definition
unknown.class=Unknown class: ''{0}''
illegal.type.void=Illegal type: 'void'
numeric.overflow.in.expression=Numeric overflow in expression
static.member.accessed.via.instance.reference=Static member ''{0}.{1}'' accessed via instance reference
deprecated.symbol=''{0}'' is deprecated
deprecated.since.symbol=''{0}'' is deprecated since version {1}
marked.for.removal.symbol=''{0}'' is deprecated and marked for removal
marked.for.removal.symbol.since=''{0}'' is deprecated since version {1} and marked for removal
cannot.resolve.symbol=Cannot resolve symbol ''{0}''
local.variable.is.never.used=Variable ''{0}'' is never used
local.variable.is.not.used.for.reading=Variable ''{0}'' is assigned but never accessed
local.variable.is.not.assigned=Variable ''{0}'' is never assigned
private.field.is.not.used=Private field ''{0}'' is never used
field.is.not.used=Field ''{0}'' is never used
field.is.not.used.for.reading={0} field ''{1}'' is assigned but never accessed
private.field.is.not.assigned=Private field ''{0}'' is never assigned
parameter.is.not.used=Parameter ''{0}'' is never used
parameter.excluding.hierarchy.disable.text=Do not highlight parameters for inherited methods
pattern.variable.is.not.used=Pattern variable ''{0}'' is never used
private.method.is.not.used=Private method ''{0}'' is never used
method.is.not.used=Method ''{0}'' is never used
constructor.is.not.used=Constructor ''{0}'' is never used
private.constructor.is.not.used=Private constructor ''{0}'' is never used
private.inner.class.is.not.used=Private inner class ''{0}'' is never used
private.inner.interface.is.not.used=Private inner interface ''{0}'' is never used
type.parameter.is.not.used=Type parameter ''{0}'' is never used
local.class.is.not.used=Local class ''{0}'' is never used
class.is.not.used=Class ''{0}'' is never used
interface.is.not.used=Interface ''{0}'' is never used
enum.is.not.used=Enum ''{0}'' is never used
annotation.interface.is.not.used=@Interface ''{0}'' is never used
record.is.not.used=Record ''{0}'' is never used

# suppress inspection "UnusedProperty"
expected.identifier=Identifier expected
# suppress inspection "UnusedProperty"
unexpected.token=Unexpected token
expected.identifier.or.type=Identifier or type expected
# suppress inspection "UnusedProperty"
expected.rbracket=']' expected
# suppress inspection "UnusedProperty"
expected.expression=Expression expected
expected.semicolon=';' expected
# suppress inspection "UnusedProperty"
expected.lparen='(' expected
# suppress inspection "UnusedProperty"
expected.rparen=')' expected
# suppress inspection "UnusedProperty"
expected.rbrace='}' expected
# suppress inspection "UnusedProperty"
expected.lbrace='{' expected
expected.parameter=Parameter expected
expected.comma=',' expected
# suppress inspection "UnusedProperty"
expected.lparen.or.lbracket='(' or '[' expected
# suppress inspection "UnusedProperty"
else.without.if='else' without 'if'
# suppress inspection "UnusedProperty"
catch.without.try='catch' without 'try'
# suppress inspection "UnusedProperty"
finally.without.try='finally' without 'try'
# suppress inspection "UnusedProperty"
expected.statement=Statement expected
# suppress inspection "UnusedProperty"
expected.while='while' expected
# suppress inspection "UnusedProperty"
expected.catch.or.finally='catch' or 'finally' expected
# suppress inspection "UnusedProperty"
expected.boolean.expression=Boolean expression expected
# suppress inspection "UnusedProperty"
expected.switch.label='case', 'default' or '}' expected
# suppress inspection "UnusedProperty"
expected.switch.rule=Expression, block or throw statement expected
error.cannot.resolve.class=Cannot resolve class ''{0}''
error.cannot.resolve.class.or.package=Cannot resolve class or package ''{0}''
suspicious.name.assignment=''{0}'' should probably not be assigned to ''{1}''
suspicious.name.parameter=''{0}'' should probably not be passed as parameter ''{1}''
suspicious.name.return=''{0}'' should probably not be returned from method ''{1}''
cannot.resolve.package=Cannot resolve package {0}
declaration.not.allowed=Declaration not allowed here

assert.identifier.warn=Use of 'assert' as an identifier is not supported in releases since Java 1.4
enum.identifier.warn=Use of 'enum' as an identifier is not supported in releases since Java 1.5
underscore.identifier.warn=Use of '_' as an identifier is not supported in releases since Java 9
# {0} = restricted identifier, like 'var', {1} = java version like '10'
restricted.identifier.warn=Use of ''{0}'' as a class name is not supported in releases since Java {1}
module.unwanted.modifier.warn=Modifiers on 'requires java.base' are prohibited in releases since Java 10
yield.unqualified.method.warn=Unqualified call to 'yield' method is not supported in releases since Java 14
redundant.semicolon.warn=Redundant semicolons between import statements are prohibited starting from Java 21

module.open.duplicate.text=Go to duplicate
module.not.on.path=Module is not in dependencies: {0}
package.not.found=Package not found: {0}
package.is.empty=Package is empty: {0}
module.access.to.unnamed=Package ''{0}'' is declared in the unnamed module, but module ''{1}'' does not read it
module.access.from.named=Package ''{0}'' is declared in module ''{1}'', which does not export it to module ''{2}''
module.access.from.unnamed=Package ''{0}'' is declared in module ''{1}'', which does not export it to the unnamed module
module.access.does.not.read=Package ''{0}'' is declared in module ''{1}'', but module ''{2}'' does not read it
module.does.not.read=Module ''{0}'' fails to read ''{1}''
module.access.not.in.graph=Package ''{0}'' is declared in module ''{1}'', which is not in the module graph
module.not.in.graph=Module ''{0}'' is missing from the module graph
module.access.bad.name=Package ''{0}'' is declared in module with an invalid name (''{1}'')
module.bad.name=Module ''{0}'' has an invalid name

restricted.identifier=''{0}'' is a restricted identifier and cannot be used for type declarations
record.canonical.constructor=Canonical constructor
record.compact.constructor=Compact constructor
insufficient.language.level={0} are not supported at language level ''{1}''

annotation.on.static.member.qualifying.type.family.name=Move type annotation
create.class.action.this.not.valid.java.qualified.name=This is not a valid Java qualified name
text.class.inherits.abstract.and.default={0} inherits abstract and default for {1} from types {2} and {3}
text.class.inherits.unrelated.defaults={0} inherits unrelated defaults for {1} from types {2}
text.class.is.not.accessible={0} is not accessible in current context
text.class.cannot.access=Cannot access {0}
error.cannot.infer.pattern.type=Cannot infer pattern type: {0}
remove.unused.imports.quickfix.text=Remove unused imports
incomplete.project.state.pending.reference=Not resolved until the project is fully loaded
