readonly.occurences.found=Occurrences found in read-only files
progress.text=Looking for Usages
usageView.tabText=Refactoring Preview
usageView.usagesText=usages
usageView.need.reRun=Cannot perform refactoring operation.\nThere were changes in code after usages have been found.\nPlease perform usage search again.
usageView.doAction=&Do Refactor
statusBar.refactoring.result={0, choice, 1#1 occurrence|2#{0,number} occurrences} changed
statusBar.noUsages=No occurrences found
inner.class.exists=Inner class named ''{0}'' is already defined\nin class ''{1}''
error.wrong.caret.position.method.or.class.name=Caret should be positioned at the name of method or class to be refactored
error.wrong.caret.position.method.or.variable.name=Caret should be positioned at the name of method or variable to be refactored
error.wrong.caret.position.class=Caret should be positioned inside class to be refactored
error.wrong.caret.position.method.or.local.name=Caret should be positioned at the name of element to be refactored
error.wrong.caret.position.symbol.to.rename=Caret should be positioned at symbol to be renamed
error.wrong.caret.position.symbol.to.refactor=Caret should be positioned at symbol to be refactored
error.out.of.project.element=Selected {0} is not located inside the project
error.out.of.project.element.default=Selected element is not located inside the project
error.in.injected.lang.prefix.suffix=Selected {0} is located in the read-only part of injected language document
error.cannot.be.renamed=This element cannot be renamed
to.refactor=to refactor
changeSignature.no.type.for.parameter=Specify {0} type for parameter ''{1}''
changeSignature.refactoring.name=Change Signature
column.name.name=Name:
changeSignature.default.value.label=Default value:
parameters.border.title=Parameters
changeSignature.propagate.parameters.title=Propa&gate Parameters...
changeSignature.parameter.caller.chooser=Select Methods To Propagate New Parameters
changeSignature.return.type.prompt=Return &type:
changeSignature.name.prompt=&Name:
name.prompt=&Name
signature.preview.border.title=Signature Preview
changeSignature.parameters.wont.propagate=Recursive propagation of parameter changes won't be performed
changeSignature.wrong.return.type=Wrong return type: ''{0}''
changeSignature.no.return.type=Return type is not specified
changeSignature.wrong.type.for.parameter=Wrong type: ''{0}'' for parameter ''{1}''
changeSignature.no.default.value=New parameter ''{0}'' has been added.\nSpecify default value to be used in all existing calls of this method.
changeSignature.cannot.resolve.parameter.type=Type ''{0}'' for parameter ''{1}'' cannot be resolved.\nContinue?
move.classes.destination.package.prompt=To package:
search.in.comments.and.strings=Search in &comments and strings
search.for.text.occurrences=Search for &text occurrences
visibility.as.is=&As is
visibility.escalate=&Escalate
visibility.public=Pu&blic
visibility.protected=Pr&otected
visibility.private=Pri&vate
visibility.package.local=Pac&kage local
visibility.border.title=Visibility
default.visibility.border.title=Default Visibility
visibility.combo.title=&Visibility:
moveInstanceMethod.select.an.instance.parameter=Select an &instance expression:
destination.package=Destination &package:
choose.destination.package=Choose Destination Package
interface.name.prompt=&Interface name:
package.for.new.interface=&Package for new interface:
no.class.name.specified=No class name specified
no.parameter.name.specified=No parameter name specified
pull.up.members.to=P&ull up members of {0} to:
members.to.be.pulled.up=Mem&bers to be pulled up
make.abstract=Make abstract
javadoc.for.abstracts=JavaDoc for abstracts
extractIncludeFile.name=Extract Include File
file.already.exist=File {0} already exists
file.already.exist.title=Extract Include File
name.for.extracted.include.file=&Name for extracted include file (default extension: {0})
extract.to.directory=Extract to &directory:
select.target.directory=Select Target Directory
select.target.directory.description=The file will be created in this directory
create.directory=Create directory
superclass.name=&Superclass name:
package.for.new.superclass=&Package for new superclass:
package.for.original.class=&Package for original class:
package.for.original.interface=&Package for original interface:
ExtractSuperClass.superclass=Superclass
members.to.form.superclass=Mem&bers to form superclass
no.superclass.name.specified=No superclass name specified
extract.superclass.from=Extract superclass from:
extractSuper.extract=E&xtract {0}
extractSuper.rename.original.class=R&ename original class and use {0} where possible
extractSuper.rename.original.class.to=&Rename original class to:
extractSuperInterface.interface=Interface
members.to.form.interface=Mem&bers to form interface
extract.interface.from=Extract interface from:
rename.implementation.class.to=Rename implementation class to:
rename.original.interface.to=Rename original interface to:
extractSuperInterface.javadoc=JavaDoc
no.interface.name.specified=No interface name specified
replace.all.occurences=Replace &all occurrences ({0} occurrences)
introduce.parameter.title=Introduce Parameter
no.field.name.specified=No field name specified
field.exists=Field with name {0}\nalready exists in class ''{1}''.\nContinue?
choose.destination.class=Choose Destination Class
# introduce variable
introduce.variable.title=Introduce Variable
refactoring.introduce.context.error=Cannot perform refactoring in this context
refactoring.introduceVariable=Introduce Variable refactoring
refactoring.introduce.selection.error=Cannot perform refactoring using selected element(s)
refactoring.introduce.name.error=Incorrect name
refactoring.introduce.name.used.error=This name is already used
refactoring.introduce.variable.scope.error=Name clashes with existing variable
refactoring.introduce.placing.error=Cannot extract {0} variable

cannot.perform.refactoring=Cannot perform refactoring.
move.instance.method.title=Move Instance Method
move.method.is.not.supported.when.method.is.part.of.inheritance.hierarchy=Move method is not supported when method is a part of inheritance hierarchy
extract.interface.title=Extract Interface
extract.interface.command.name=Extracting interface {0} from {1}
extract.method.title=Extract Method
selected.block.contains.invocation.of.another.class.constructor=Selected block contains invocation of another class constructor
selected.block.should.represent.a.set.of.statements.or.an.expression=Selected block should represent a set of statements or an expression
press.escape.to.remove.the.highlighting=Press Escape to remove the highlighting
extract.superclass.title=Extract Superclass
extract.superclass.command.name=Extracting superclass {0} from {1}
superclass.cannot.be.extracted.from.an.interface=Superclass cannot be extracted from interface
superclass.cannot.be.extracted.from.an.enum=Superclass cannot be extracted from enum
inline.title=Inline
introduce.constant.title=Introduce Constant
introduce.selection.error=Cannot perform refactoring using selected element(s)
introduce.field.title=Introduce Field
selected.block.should.represent.an.expression=Selected block should represent an expression
is.not.supported.in.the.current.context={0} is not supported in current context
to.rename=to rename
refactoring.is.not.supported.in.the.current.context={0} refactoring is not supported in the current context
cannot.introduce.variable.in.super.constructor.call=Cannot extract variable in super constructor call
no.selection=No selection.
selection.does.not.form.a.fragment.for.extraction=Selection does not form a fragment for extraction
cannot.extract.selected.elements.into.include.file=Cannot extract selected elements into include file
the.language.for.selected.elements.has.no.associated.file.type=The language for selected elements has no associated file type
extract.include.file.title=Extract include file
replace.fragment=Replace Fragment
idea.has.found.fragments.that.can.be.replaced.with.include.directive={0} has found fragments that can be replaced with include directive\nDo you want to review them?
remove.duplicates.command=Remove Duplicates
constructor.cannot.be.made.static=Constructor cannot be made static
this.member.does.not.seem.to.belong.to.any.class=This member does not seem to belong to any class
member.is.already.static=Member is already static
cannot.make.abstract.method.static=Cannot make abstract method static
inner.classes.cannot.have.static.members=Inner classes cannot have static members
pull.members.up.title=Pull Members Up
the.caret.should.be.positioned.inside.a.class.to.pull.members.from=Caret should be positioned inside a class to pull members from
class.does.not.have.base.classes.interfaces.in.current.project={0} does not have base classes/interfaces in current project
pullUp.command=Pulling members up from {0}
push.members.down.title=Push Members Down
the.caret.should.be.positioned.inside.a.class.to.push.members.from=Caret should be positioned inside a class to push members from
move.title=Move
ask.to.move.related.file=<html>Related file found: <code>{0}</code>.<br/>Move it as well?</html>
ask.to.move.related.files=<html>Related files found: <br/><code>{0}</code><br/><br/>Move them as well?</html>
the.caret.should.be.positioned.at.the.class.method.or.field.to.be.refactored=Caret should be positioned at the class, method or field to be refactored
select.refactoring.title=Select Refactoring
what.would.you.like.to.do=What would you like to do?
package.occurs.in.package.prefixes.of.the.following.source.folders.n=Package {0} occurs in package prefixes of the following source folders:\n
these.package.prefixes.will.be.changed=These package prefixes will be changed.
rename.title=Rename
rename.not.supported=Operation is not supported
related.file=Related file
rename.related.file.dialog.description=Rename related files to:
multiple.directories.correspond.to.package=Multiple directories correspond to package\n
directories.and.all.references.to.package.will.be.renamed=\n\nDo you want to rename the whole package or directory \n{0} only?
rename.package.button.text=Rename &package
rename.directory.button.text=Rename &directory
rename.directories= Rename &all
rename.current.directory= Rename &current
warning.title=Warning
safe.delete.title=Safe Delete
variable.has.no.initializer=Variable {0} has no initializer
variable.has.no.dominating.definition=Cannot find a single definition to inline
variable.is.never.used=Variable {0} is never used
variable.is.accessed.for.writing.and.used.with.inlined=Another variable ''{0}'' definition is used together with inlined one
0.with.1.visibility.is.not.accessible.from.2={0} with {1} visibility won''t be accessible from {2}
no.members.selected=No members selected
0.already.exists.in.the.target.class={0} already exists in the target class.
there.is.already.a.0.in.the.1.it.will.conflict.with.the.renamed.parameter=There is already a {0} in the {1}. It will conflict with the renamed parameter.
changing.signature.of.0=Changing signature of {0}
there.is.already.a.0.in.1.it.will.conflict.with.the.new.parameter=There is already a {0} in {1}. It will conflict with the new parameter.
0.to.change.signature={0} to change signature
New.name.of.method.is.not.java.identifier=New name of method is not Java identifier
references.to.be.changed=References to be changed {0}
javadoc.as.is=&As is
javadoc.copy=&Copy
javadoc.move=&Move
add.object.as.a.parameter.with.name=Add &object as a parameter with name:
0.already.contains.field.1={0} already contains field {1}
0.is.already.overridden.in.1={0} is already overridden in {1}. Method will not be pushed down to that class.
0.already.contains.inner.class.named.1={0} already contains inner class named {1}
0.uses.1.which.is.pushed.down={0} uses {1}, which is pushed down
refactoring.cannot.be.performed=Refactoring cannot be performed
column.name.type=Type:
column.name.any.var=Any var
column.name.default.value=Default value
caller.chooser.caller.method=Caller Method
caller.chooser.callee.method=Callee Method
caller.chooser.looking.for.callers=Looking For Callers...
copy.class.copy.0.1=Copy {0} {1}
invalid.target.package.name.specified=Invalid target package name specified
invalid.target.package.name.default.package=Cannot move classes to default package
error.title=Error
cannot.create.directory=Cannot create directory
no.target.directory.specified=No target directory specified
copy.files.new.name.label=&New name:
no.new.name.specified=No new name specified
copy.files.copy.specified.files.label=Copy specified files
copy.files.copy.specified.directories.label=Copy specified directories
copy.files.copy.specified.mixed.label=Copy specified files and directories
copy.files.to.directory.label=To &directory:
the.file.will.be.copied.to.this.directory=File will be copied to this directory
copy.files.clone.title=Clone
copy.files.copy.title=Copy
copy.files.clone.file.0=Clone file {0}
copy.files.copy.file.0=Copy file {0}
copy.files.clone.directory.0=Clone directory {0}
copy.files.copy.directory.0=Copy directory {0}
copy.handler.copy.class=Copy Class
copy.handler.clone.files.directories=Clone files/directories
copy.handler.copy.files.directories=Copy files/directories
encapsulate.fields.options.border.title=Options
encapsulate.fields.no.fields.selected=No fields selected
invocations.to.be.inlined=Invocations to be inlined {0}
classes.to.push.down.members.to=Classes to push down members to {0}
references.in.code.to.elements.from.migration.map=References in code to elements from migration map "{0}" {1}
press.the.do.migrate.button=Press the "Do Migrate" button at the bottom of the search results panel\nto migrate using the migration map "{0}"\n
references.in.code=References in code {0}
safe.delete.comment.occurences.header=Occurrences found in comments, strings and non-code files {0}. Those occurrences will not be changed
move.single.element.elements.header={0} to be moved to {1}
references.in.code.to.0.1=References in code to {0} {1}
move.classes.elements.header=Classes to be moved to {0}
move.packages.elements.header=Packages to be moved to {0}
references.found.in.code=References found in code
references.found.in.generated.code=References found in generated code
comments.elements.header=Occurrences found in comments, strings and non-code files {0}
move.files.elements.header=Files to be moved to {0}
move.directories.elements.header=Directories to be moved to {0}
replace.all.occurences.checkbox=Replace &all occurrences
initialize.in.border.title=Initialize in
setup.method.radio=&setUp method
current.method.radio=Current &method
class.constructors.radio=Class &constructor(s)
extract.subclass.command=Extract Subclass
extract.superclass.elements.header=Extract superclass with members to directory
declare.static.checkbox=Declare &static
declare.static.pass.fields.checkbox=Declare &static (pass fields as params)
declare.folded.parameters=&Fold parameters
extract.method.method.panel.border=Method
move.members.elements.header=Members to be moved
move.members.move.members.from.label=Move members from:
move.members.to.fully.qualified.name.label=To (fully qualified name):
move.members.members.to.be.moved.border.title=Mem&bers to be moved (static only)
no.destination.class.specified=No destination class specified
0.is.not.a.legal.fq.name=''{0}'' is not a legal FQ-name
create.class.command=Create class {0}
source.and.destination.classes.should.be.different=Source and destination classes should be different
class.0.does.not.exist=Class {0} does not exist.\nDo you want to create it?
move.members.title=Move Static Members
members.to.be.moved.should.belong.to.the.same.class=Members to be moved should belong to the same class
field.0.is.not.static=Field {0} is not static.\n{1} refactoring is supported for static members only.
0.refactoring.cannot.be.applied.to.constructors={0} refactoring cannot be applied to constructors
method.0.is.not.static=Method {0} is not static.\n{1} refactoring is supported for static members only.
inline.field.border.title=Inline
all.references.and.remove.the.local=Inline &all references and remove the variable
this.reference.only.and.keep.the.variable=Inline this reference only and &keep the variable
inline.variable.title=Inline Variable
variable.is.referenced.in.multiple.files=Variable {0} is referenced in multiple files
inline.command=Inline {0}
inline.local.variable.prompt=Inline local variable ''{0}''?
inline.local.variable.definition.prompt=Inline local variable ''{0}'' definition?
occurences.string=({0,choice,1#1 occurrence|2#{0,number} occurrences})
occurrences.string=({0,choice,1#1 occurrence|2#{0,number} occurrences})
inline.method.title=Inline Method
inline.method.method.label=Method {0} {1}
inline.method.border.title=Inline
all.invocations.and.remove.the.method=Inline &all and remove the method
all.invocations.in.project=&All invocations in project
this.invocation.only.and.keep.the.method=Inline this only and &keep the method
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow={0} refactoring is not supported when return statement interrupts the execution flow
refactoring.is.not.supported.for.recursive.methods={0} refactoring may not be applied to remove recursive methods.\nYou can inline only individual method calls.
refactoring.cannot.be.applied={0} refactoring cannot be applied
inline.method.command=Inlining method {0}
0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1={0} that is used in inlined method is not accessible from call site(s) in {1}
interface.has.been.successfully.created=Interface {0} has been successfully created
class.has.been.successfully.created=Class {0} has been successfully created
use.super.references.prompt=At this stage {0} can analyze usages of {1} \nand replace them with usages of {2} where possible.\nDo you want to proceed?
analyze.and.replace.usages=Analyze and Replace Usages
there.are.multiple.output.values.for.the.selected.code.fragment=There are multiple output values for the selected code fragment:
fields.0.are.not.accessible=Fields {0} are not accessible from {1}
0.is.not.static.it.cannot.be.moved.to.the.interface={0} is not static. It cannot be moved to the interface
0.is.not.initialized.in.declaration.such.fields.are.not.allowed.in.interfaces={0} is not initialized in declaration. Such fields are not allowed in interfaces.
0.already.contains.a.1={0} already contains a {1}
0.uses.1.which.is.not.accessible.from.the.superclass={0} uses {1}, which is not accessible from the superclass
0.uses.1.which.is.not.moved.to.the.superclass={0} uses {1}, which is not moved to the superclass
push.members.from.0.down.label=Push members from {0} down
members.to.be.pushed.down.panel.title=Mem&bers to be pushed down
keep.abstract.column.header=Keep abstract
push.down.javadoc.panel.title=JavaDoc for abstracts
push.down.members.elements.header=Push down members from {0}
interface.0.does.not.have.inheritors=Interface {0} does not have inheritors
functional.interface.broken=Functional expression demands functional interface to have exact one method
class.0.does.not.have.inheritors=Class {0} does not have inheritors
push.down.will.delete.members=Pushing members down will result in them being deleted. Would you like to create a new subclass?
edit.migration.map.title=Edit Migration Map
migration.map.name.prompt=Map name:
migration.map.description.label=Map description:
migration.add.button=Add...
migration.move.up.button=Move Up
migration.move.down.button=Move Down
migration.type.column.header=Type
migration.old.name.column.header=Old name
migration.new.name.column.header=New name
migration.class=Class
edit.migration.entry.title=Edit Class/Package Migration Description
migration.entry.class=Class
migration.entry.old.name=Old name:
migration.entry.new.name=New name:
migration.new.button=New...
migration.map.set.migration.maps=Migration maps
migration.no.usages.found.in.the.project=No Usages Found in the Project
migration.title=Migration
move.classes.move.to.another.source.folder=Move to another source &folder
do.you.wish.to.continue=Do you wish to continue?
moving.directories.command=Moving directories
move.instance.method.command=Move Instance method
move.inner.to.upper.level.title=Move Inner to Upper Level
move.specified.files=Move specified files
move.specified.directories=Move specified directories
move.file.0=Move file {0}
move.directory.0=Move directory {0}
move.files.to.directory.label=To directory:
the.file.will.be.moved.to.this.directory=File will be moved to this directory
searching.for.variables=Searching for Variables
searching.for.duplicates=Searching for Duplicates...
factory.method.name.label=Factory method name:
replace.constructor.with.factory.target.fq.name=In (fully qualified name):
class.0.not.found=Class {0} not found.
occurrences.found.in.comments.strings.and.non.java.files=Occurrences found in comments, strings and non-code files
occurrences.found.in.comments.strings.non.java.files.and.generated.code=Occurrences found in comments, strings, non-code files and generated code
0.referenced.in.1.will.not.be.accessible.in.module.2={0}, referenced in {1}, will not be accessible in module {2}
0.referenced.in.1.will.not.be.accessible.from.module.2={0}, referenced in {1}, will not be accessible from module {2}
0.referenced.in.1.will.not.be.accessible.from.production.of.module.2={0}, referenced in {1}, will not be accessible from the production sources of module {2}
choose.destination.directory=Choose Destination Directory
directory.chooser.hide.non.existent.checkBox.text=&Hide non-existent
safe.delete.command=Deleting {0}
select.all.button=Select &all
unselect.all.button=&Unselect all
automatic.renamer.entity.name.column={0} name
automatic.renamer.rename.to.column=Rename to
rename.0.and.its.usages.to=Rename {0} and its usages to:
rename.variables=Rename &variables
rename.inheritors=Rename &inheritors
rename.parameters.hierarchy=Rename parameters in hier&archy
rename.overloads=Rename &overloads
rename.bound.forms=Rename bound &forms
inner.class.0.is.already.defined.in.class.1=Inner class {0} is already defined in class {1}.\nContinue anyway?
class.0.already.exists=Class {0} already exists
renaming.something=Renaming something
renaming.0.1.to.2=Renaming {0} {1} to {2}
renaming.command.name=Renaming {0}
0.to.be.renamed.to.1.2={0} to be renamed to {1}{2}
references.in.code.to.0=References in code to {0}
rename.variables.title=Rename Variables
rename.variables.with.the.following.names.to=Rename variables with the following names to:
entity.name.variable=Variable
rename.bound.forms.title=Rename Bound Forms
rename.forms.with.the.following.names.to=Rename forms with the following names to:
entity.name.form=Form
rename.inheritors.title=Rename Inheritors
rename.inheritors.with.the.following.names.to=Rename inheritors with the following names to:
entity.name.inheritor=Inheritor
attempting.to.delete.targets.node.text=Attempting to delete
retry.command=Retry
rerun.safe.delete=&Rerun Safe Delete
delete.title=Delete
items.to.be.deleted=Items to be deleted
usages.detected=Usages Detected
delete.anyway.button=&Delete Anyway
ask.to.delete.related.file=<html>Related file found: <code>{0}</code>.<br/>Delete it as well?</html>
ask.to.delete.related.files=<html>Related files found: <br/><code>{0}</code><br/><br/>Delete them as well?</html>
the.following.problems.were.found=The following problems were found:
cancel.button=Ca&ncel
view.usages=&View Usages
anonymous.class.text=Anonymous class
problems.detected.title=Problems Detected
continue.button=&Continue
do.you.wish.to.ignore.them.and.continue=Do you wish to ignore them and continue?
delegation.panel.method.calls.label=Method calls:
delegation.panel.modify.radio=&Modify
delegation.panel.delegate.via.overloading.method=De&legate via overloading method
member.column=Member
refactor.button=&Refactor
preview.button=&Preview
yes.button=&Yes
no.button=&No
replace.this.code.fragment=Replace this code fragment?
process.duplicates.title=Process Duplicates
process.methods.duplicates.title=Process Method {2} Duplicate ({0} of {1})
0.has.detected.1.code.fragments.in.this.file.that.can.be.replaced.with.a.call.to.extracted.method={0} has detected {1} code {1,choice,1#fragment|2#fragments} in this file that can be replaced with a call to extracted method. Would you like to review and replace {1,choice,1#it|2#them}?
replace.button=Replace
method.duplicates.method.label=Method {0}
interface.member.dependency.required.by.interfaces=required by {0,choice,1#interface|2#interfaces}
member.info.implements.0=implements {0}
member.info.extends.0=extends {0}
used.by.0=used by {0}
uses.0=uses {0}
file.description=File {0}
directory.description=Directory {0}
0.is.located.in.a.jar.file={0} is located in a read-only container.
0.is.read.only={0} is read-only.
method.0.is.already.defined.in.the.1=Method {0} is already defined in the {1}
current.class=current class
0.has.1.usages.that.are.not.safe.to.delete={0} has {1,choice,1#1 usage that is|2#{1,number} usages that are} not safe to delete.
safe.delete.of.those.0.in.comments.strings.non.code=Of those {0,choice,1#1 usage is|2#{0,number} usages are} in strings, comments, non-code files or generated code.
safe.delete.conflict.title=Potentially unsafe to delete references found in code
pushed.members.will.not.be.visible.from.certain.call.sites=Pushed members will not be visible from certain call sites
invert.boolean.title=Invert Boolean
invert.boolean.refs.to.invert=References to be inverted {0}
invert.boolean.elements.header={0} to invert
please.enter.a.valid.name.for.inverted.element=Please enter a valid name for inverted {0}
invert.boolean.name.of.inverted.element=&Name of inverted {0}:
invert.0.1=Invert {0} {1} and its usages
inline.to.anonymous.no.inheritors=Classes which have subclasses cannot be inlined
unsupported.refs.found=Unsupported references found in {0} files
inline.parameter.command.name=Inline Parameter {0}
move.to.different.language=Target class {2} has different language than {0} {1}
dont.support.inner.classes=Refactoring ''Make inner class of'' is not available in {0}
move.specified.elements=Move specified elements
rename.directory.title=Rename &Directory
rename.module.title=Rename &Module
# extract method
refactoring.extract.method.dialog.title=Extract Method
refactoring.extract.method.dialog.method.name=Method name:
refactoring.extract.method.dialog.parameters=Parameters
refactoring.extract.method.dialog.output.variables=Output variables
refactoring.extract.method.dialog.signature.preview=Signature preview
refactoring.extract.method.dialog.empty=Empty
change.signature.leave.blank.default.value=Leave &blank
change.signature.feel.lucky=Feel &lucky
change.signature.use.selected.value=Use selected &value
refactoring.extract.method.from.duplicate.code=Extract method from duplicate code
search.for.references=Search for re&ferences
0.is.not.an.identifier=<b><code>{0}</code></b> is not a correct identifier to use in <b><code>{1}</code></b>
rename.directory.command.name=Rename directory
rename.directories.command.name=Rename directories
target.destination.folder=Target &destination directory:
detecting.possible.conflicts=Detecting Possible Conflicts...
path.completion.shortcut=Use {0} for path completion

rename.project.action.title=Rename Project...
rename.project.handler.title=Rename &project
enter.new.project.name=Enter new project name:
rename.project=Rename Project
renames.project=Renames project
introduce.functional.parameter.title=Introduce Functional Parameter
introduce.functional.variable.title=Introduce Functional Variable
refactoring.introduce.parameter.object.references.to.be.modified=References to be modified
refactoring.introduce.parameter.object.method.whose.parameters.are.to.wrapped=Method whose parameters are to wrapped
refactoring.introduce.parameter.object.command.name=Introduced parameter class {0} for {1}()
refactoring.introduce.parameter.object.method.to.extract.parameters.from.label=Method to extract parameters from
refactoring.introduce.parameter.object.title=Introduce Parameter Object

copy.files.and.directories=Copy Files and Directories...
copy.directories=Copy Directories...
copy.directory=Copy Directory...
copy.files=Copy Files...
copy.file=Copy File...
move.files.and.directories=Move Files and Directories...
move.directory=Move Directory...
move.directories.with.dialog= Move Directories...
move.files=Move Files...
move.file=Move File...

open.copy.in.editor=Open copy in editor
open.in.editor.label=&Open in editor
name.is.not.a.valid.file.name=Name is not a valid file name

introduce.target.chooser.expressions.title=Expressions
suggested.refactoring.usages=usages
suggested.refactoring.overrides=overrides
suggested.refactoring.implementations=implementations
suggested.refactoring.update.button.text=Update
suggested.refactoring.next.button.text=Next
suggested.refactoring.rename.button.text=Rename
suggested.refactoring.rename.with.preview.button.text=Rename with Preview
suggested.refactoring.ignore.button.text=Ignore
suggested.refactoring.rename.gutter.icon.tooltip=Rename usages of ''{0}'' to ''{1}''... {2}
suggested.refactoring.rename.intention.text=Rename usages of ''{0}'' to ''{1}''
suggested.refactoring.rename.popup.text=Rename usages of ''{0}'' to ''{1}''
suggested.refactoring.rename.text.occurrences=Found occurrences in comments and strings while renaming ''{0}'' to ''{1}''. Would you like to rename them as well?
suggested.refactoring.rename.text.occurrences.title=Rename text occurrences
suggested.refactoring.change.signature.intention.text=Update {0} to reflect signature change...
suggested.refactoring.change.signature.gutter.icon.tooltip=Update {0} of ''{1}'' to reflect signature change... {2}
suggested.refactoring.change.signature.label.text=Update {0} to reflect signature changes:
suggested.refactoring.parameter.values.label.text=Add values for new parameters:
suggested.refactoring.parameter.values.placeholder=Optional value
suggested.refactoring.use.any.variable.checkbox.text=Use any variable
suggested.refactoring.use.any.variable.checkbox.hint=If a single variable of suitable type exists at the call place, it will be used as argument value
suggested.refactoring.disabled.gutter.icon.tooltip=There are changes in signature but nothing can be updated in usages
suggested.refactoring.rename.command.name=Rename usages
suggested.refactoring.change.signature.command.name=Update {0}

automatic.renaming.dialog.rename.selected.title=Rename Selected
automatic.renaming.dialog.new.name.label=New name
automatic.renaming.dialog.identifier.invalid.error=Identifier ''{0}'' is invalid
refactoring.prepare.progress=Prepare ...
refactoring.preprocess.usages.progress=Preprocess Usages
refactoring.index.corruption.notifiction=Index corruption detected. Please retry the refactoring - indexes will be rebuilt automatically
refactoring.dumb.mode.notification=Refactoring is not available until indices are ready
action.show.conflicts.in.view.text=Show Conflicts in View
conflicts.tab.name=Conflicts
change.signature.default.value.description=In calls to this method, if exactly one variable of the correct type is found, use it. Otherwise leave blank.
change.signature.default.value.chooser.title=Default value for parameter "{0}" needed
rename.package.with.lib.message=Package ''{0}'' contains directories in libraries which cannot be renamed. Do you want to rename current \
  {1,choice,1#directory|2#module directories}?
rename.package.with.lib.multiple.message=Package ''{0}'' contains directories in libraries which cannot be renamed. Do you want to rename current \
  {1,choice,1#directory|2#module directories} or all directories in project?
refactor.this.title=Refactor This
safe.delete.not.available.indexing=Safe delete refactoring is not available while indexing is in progress
rename.not.all.usages.title=Not All Usages Were Renamed
rename.not.all.usages.message=<html>Following usages were safely skipped:<br>{0}</html>
rename.string.occurrences.found.title=String occurrences found
rename.related.files.option.name=Rename related files (with the same name)
refactoring.indexing.warning.title=Indexing
refactoring.not.available.indexing=Refactoring is not available while indexing is in progress
introduce.normalize.declaration.command.name=Normalize declaration
inplace.refactoring.cancel.current=Cancel Current
inplace.refactoring.abandon.started=Abandon Started
inplace.refactoring.navigate.to.started=Navigate to Started
inplace.refactoring.continue.started=Continue Started
inplace.change.signature.preview.label=Performed signature modifications:
extract.method.replace.duplicate.command.name=Replace duplicate
extract.include.file.action.title=Extract Include File...
label.change.signature.in.all.calls.to.this.method.leave.the.parameter.blank=In all calls to this method leave the parameter blank
checkbox.introduce.parameter.object.keep.method.as.delegate=Keep method as &delegate
border.title.introduce.parameter.class=Parameter Class
border.title.introduce.parameters.to.extract=Parameters to Extract

replace.this.occurrence.only=Replace this occurrence only
replace.all.occurrences.but.write=Replace all occurrences but write
replace.all.occurrences=Replace all {0} occurrences
replace.multiple.occurrences.found=Multiple occurrences found