// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
/**
 * This file is generated by [com.intellij.platform.eel.codegen.BuildersGeneratorTest].
 */
package com.intellij.platform.eel

import com.intellij.platform.eel.*
import com.intellij.platform.eel.EelExecApi.ExecuteProcessOptions
import com.intellij.platform.eel.EelExecApi.InteractionOptions
import com.intellij.platform.eel.EelExecApi.PtyOrStdErrSettings
import com.intellij.platform.eel.path.EelPath
import org.jetbrains.annotations.ApiStatus
import org.jetbrains.annotations.CheckReturnValue


/**
 * Executes the process, returning either an [EelProcess] or an error provided by the remote operating system.
 *
 * stdin, stdout and stderr of the process are always forwarded, if there are.
 *
 * The method may throw a RuntimeException only in critical cases like connection loss or a bug.
 *
 * See [executeProcessBuilder]
 *
 * @param exe An **absolute** path to the executable.
 *  TODO Or do relative paths also work?
 *
 *  All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
 *  [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
 */
@GeneratedBuilder.Result
@Deprecated("Use spawnProcess instead")
@ApiStatus.Internal
fun EelExecApi.execute(
  exe: String,
): EelExecApiHelpers.Execute =
  EelExecApiHelpers.Execute(
    owner = this,
    exe = exe,
  )

/**
 * @param exe An **absolute** path to the executable.
 *  TODO Or do relative paths also work?
 *
 *  All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
 *  [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
 */
@GeneratedBuilder.Result
@ApiStatus.Experimental
fun EelExecApi.spawnProcess(
  exe: String,
): EelExecApiHelpers.SpawnProcess =
  EelExecApiHelpers.SpawnProcess(
    owner = this,
    exe = exe,
  )

@ApiStatus.Experimental
object EelExecApiHelpers {
  /**
   * Create it via [com.intellij.platform.eel.EelExecApi.execute].
   */
  @GeneratedBuilder.Result
  @Deprecated("Use spawnProcess instead")
  @ApiStatus.Internal
  class Execute(
    private val owner: EelExecApi,
    private var exe: String,
  ) : OwnedBuilder<EelResult<EelProcess, EelExecApi.ExecuteProcessError>> {
    private var args: List<String> = listOf()

    private var env: Map<String, String> = mapOf()

    private var interactionOptions: InteractionOptions? = null

    private var ptyOrStdErrSettings: PtyOrStdErrSettings? = interactionOptions

    private var workingDirectory: EelPath? = null

    @ApiStatus.Experimental
    fun args(arg: List<String>): Execute = apply {
      this.args = arg
    }

    fun args(vararg arg: String): Execute = apply {
      this.args = listOf(*arg)
    }

    /**
     * By default, environment is always inherited, which may be unwanted. [ExecuteProcessOptions.env] allows
     * to alter some environment variables, it doesn't clear the variables from the parent. When the process should be started in an
     * environment like in a terminal, the response of [fetchLoginShellEnvVariables] should be put into [ExecuteProcessOptions.env].
     */
    @ApiStatus.Experimental
    fun env(arg: Map<String, String>): Execute = apply {
      this.env = arg
    }

    /**
     * An **absolute** path to the executable.
     * TODO Or do relative paths also work?
     *
     * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
     * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
     */
    @ApiStatus.Experimental
    fun exe(arg: String): Execute = apply {
      this.exe = arg
    }

    /**
     * When set pty, be sure to accept esc codes for a terminal you are emulating.
     * This terminal should also be set in `TERM` environment variable, so setting it in [env] worth doing.
     * If not set, `xterm` will be used as a most popular one.
     *
     * See `termcap(2)`, `terminfo(2)`, `ncurses(3X)` and ISBN `0937175226`.
     */
    @ApiStatus.Experimental
    fun interactionOptions(arg: InteractionOptions?): Execute = apply {
      this.interactionOptions = arg
    }

    @Deprecated("Switch to interactionOptions", replaceWith = ReplaceWith("interactionOptions"))
    @ApiStatus.Internal
    fun ptyOrStdErrSettings(arg: PtyOrStdErrSettings?): Execute = apply {
      this.ptyOrStdErrSettings = arg
    }

    /**
     * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
     * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
     */
    @ApiStatus.Experimental
    fun workingDirectory(arg: EelPath?): Execute = apply {
      this.workingDirectory = arg
    }

    /**
     * Complete the builder and call [com.intellij.platform.eel.EelExecApi.execute]
     * with an instance of [com.intellij.platform.eel.EelExecApi.ExecuteProcessOptions].
     */
    @CheckReturnValue
    override suspend fun eelIt(): EelResult<EelProcess, EelExecApi.ExecuteProcessError> =
      owner.execute(
        ExecuteProcessOptionsImpl(
          args = args,
          env = env,
          exe = exe,
          interactionOptions = interactionOptions,
          ptyOrStdErrSettings = ptyOrStdErrSettings,
          workingDirectory = workingDirectory,
        )
      )
  }

  /**
   * Create it via [com.intellij.platform.eel.EelExecApi.spawnProcess].
   */
  @GeneratedBuilder.Result
  @ApiStatus.Experimental
  class SpawnProcess(
    private val owner: EelExecApi,
    private var exe: String,
  ) : OwnedBuilder<EelProcess> {
    private var args: List<String> = listOf()

    private var env: Map<String, String> = mapOf()

    private var interactionOptions: InteractionOptions? = null

    private var ptyOrStdErrSettings: PtyOrStdErrSettings? = interactionOptions

    private var workingDirectory: EelPath? = null

    @ApiStatus.Experimental
    fun args(arg: List<String>): SpawnProcess = apply {
      this.args = arg
    }

    fun args(vararg arg: String): SpawnProcess = apply {
      this.args = listOf(*arg)
    }

    /**
     * By default, environment is always inherited, which may be unwanted. [ExecuteProcessOptions.env] allows
     * to alter some environment variables, it doesn't clear the variables from the parent. When the process should be started in an
     * environment like in a terminal, the response of [fetchLoginShellEnvVariables] should be put into [ExecuteProcessOptions.env].
     */
    @ApiStatus.Experimental
    fun env(arg: Map<String, String>): SpawnProcess = apply {
      this.env = arg
    }

    /**
     * An **absolute** path to the executable.
     * TODO Or do relative paths also work?
     *
     * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
     * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
     */
    @ApiStatus.Experimental
    fun exe(arg: String): SpawnProcess = apply {
      this.exe = arg
    }

    /**
     * When set pty, be sure to accept esc codes for a terminal you are emulating.
     * This terminal should also be set in `TERM` environment variable, so setting it in [env] worth doing.
     * If not set, `xterm` will be used as a most popular one.
     *
     * See `termcap(2)`, `terminfo(2)`, `ncurses(3X)` and ISBN `0937175226`.
     */
    @ApiStatus.Experimental
    fun interactionOptions(arg: InteractionOptions?): SpawnProcess = apply {
      this.interactionOptions = arg
    }

    @Deprecated("Switch to interactionOptions", replaceWith = ReplaceWith("interactionOptions"))
    @ApiStatus.Internal
    fun ptyOrStdErrSettings(arg: PtyOrStdErrSettings?): SpawnProcess = apply {
      this.ptyOrStdErrSettings = arg
    }

    /**
     * All argument, all paths, should be valid for the remote machine. F.i., if the IDE runs on Windows, but IJent runs on Linux,
     * [ExecuteProcessOptions.workingDirectory] is the path on the Linux host. There's no automatic path mapping in this interface.
     */
    @ApiStatus.Experimental
    fun workingDirectory(arg: EelPath?): SpawnProcess = apply {
      this.workingDirectory = arg
    }

    /**
     * Complete the builder and call [com.intellij.platform.eel.EelExecApi.spawnProcess]
     * with an instance of [com.intellij.platform.eel.EelExecApi.ExecuteProcessOptions].
     */
    @Throws(ExecuteProcessException::class)
    @ThrowsChecked(ExecuteProcessException::class)
    override suspend fun eelIt(): EelProcess =
      owner.spawnProcess(
        ExecuteProcessOptionsImpl(
          args = args,
          env = env,
          exe = exe,
          interactionOptions = interactionOptions,
          ptyOrStdErrSettings = ptyOrStdErrSettings,
          workingDirectory = workingDirectory,
        )
      )
  }
}