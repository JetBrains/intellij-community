// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
/**
 * This file is generated by [com.intellij.platform.eel.codegen.BuildersGenerator].
 */
package com.intellij.platform.eel

import com.intellij.platform.eel.*
import com.intellij.platform.eel.EelTunnelsApi.Connection
import kotlinx.coroutines.channels.SendChannel
import org.jetbrains.annotations.CheckReturnValue
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds


/**
 * **For applied usages, please consider [withConnectionToRemotePort]**.
 *
 * Accepts remote connections to a named host specified by [address].
 *
 * If the result is [EelNetworkResult.Error], then there was an error during creation of the server.
 * Otherwise, the result is [EelNetworkResult.Ok], which means that the server was created successfully.
 *
 * Locally, the server exists as a channel of [Connection]s, which allows imitating a server on the IDE side.
 *
 * Packets sent to the channels and received from the channel may be split and/or concatenated.
 * The packets may be split only if their size exceeds [com.intellij.platform.ijent.spi.RECOMMENDED_MAX_PACKET_SIZE].
 *
 * If the connections get closed, then the channels also get closed in the sense of [SendChannel.close].
 *
 * If an exception happens during sending, then [Connection.sendChannel] gets closed exceptionally with [RemoteNetworkException].
 *
 * [Connection.sendChannel] can be closed separately with [SendChannel.close]. In this case, the EOF is sent to the server.
 * Note, that [Connection.receiveChannel] is __not__ closed in this case.
 *
 * One should not forget to invoke [Connection.close] when the connection is not needed.
 */
@GeneratedBuilder.Result
fun EelTunnelsApi.getAcceptorForRemotePort(): EelTunnelsApiHelpers.GetAcceptorForRemotePort =
  EelTunnelsApiHelpers.GetAcceptorForRemotePort(
    owner = this,
  )

/**
 * **For applied usages, consider using [withConnectionToRemotePort]**.
 *
 * Creates a connection to a TCP socket to a named host specified by [address].
 *
 * If the result is [EelNetworkResult.Error], then there was an error during establishment of the connection.
 * Otherwise, the result is [EelNetworkResult.Ok], which means that the connection is ready to use.
 *
 * The connection exists as a pair of channels [Connection.sendChannel] and [Connection.receiveChannel],
 * which allow communicating to a remote server from the IDE side.
 *
 * Packets sent to the channel and received from the channel may be split and/or concatenated.
 * The packets may be split only if their size exceeds [com.intellij.platform.ijent.spi.RECOMMENDED_MAX_PACKET_SIZE].
 *
 * If the connection gets closed from the server, then the channels also get closed in the sense of [SendChannel.close].
 *
 * If an exception happens during sending, then [Connection.receiveChannel] gets closed exceptionally with [RemoteNetworkException].
 *
 * [Connection.sendChannel] can be closed separately with [SendChannel.close]. In this case, the EOF is sent to the server.
 * Note, that [Connection.receiveChannel] is __not__ closed in this case.
 *
 * One should not forget to invoke [Connection.close] when the connection is not needed.
 */
@GeneratedBuilder.Result
fun EelTunnelsApi.getConnectionToRemotePort(): EelTunnelsApiHelpers.GetConnectionToRemotePort =
  EelTunnelsApiHelpers.GetConnectionToRemotePort(
    owner = this,
  )

object EelTunnelsApiHelpers {
  /**
   * Create it via [com.intellij.platform.eel.EelTunnelsApi.getAcceptorForRemotePort].
   */
  @GeneratedBuilder.Result
  class GetAcceptorForRemotePort(
    private val owner: EelTunnelsApi,
  ) : OwnedBuilder<EelResult<EelTunnelsApi.ConnectionAcceptor, EelConnectionError>> {
    private var hostname: String = "localhost"

    private var port: UShort = 0u

    private var protocolPreference: EelIpPreference = EelIpPreference.USE_SYSTEM_DEFAULT

    private var timeout: Duration = 10.seconds

    fun hostname(arg: String): GetAcceptorForRemotePort = apply {
      this.hostname = arg
    }

    fun port(arg: UShort): GetAcceptorForRemotePort = apply {
      this.port = arg
    }

    /**
     * @see [Builder.preferIPv4]
     */
    fun protocolPreference(arg: EelIpPreference): GetAcceptorForRemotePort = apply {
      this.protocolPreference = arg
    }

    fun preferV4(): GetAcceptorForRemotePort =
      protocolPreference(EelIpPreference.PREFER_V4)

    fun preferV6(): GetAcceptorForRemotePort =
      protocolPreference(EelIpPreference.PREFER_V6)

    fun useSystemDefault(): GetAcceptorForRemotePort =
      protocolPreference(EelIpPreference.USE_SYSTEM_DEFAULT)

    /**
     * @see [Builder.connectionTimeout]
     */
    fun timeout(arg: Duration): GetAcceptorForRemotePort = apply {
      this.timeout = arg
    }

    /**
     * Complete the builder and call [com.intellij.platform.eel.EelTunnelsApi.getAcceptorForRemotePort]
     * with an instance of [com.intellij.platform.eel.EelTunnelsApi.HostAddress].
     */
    @org.jetbrains.annotations.CheckReturnValue
    override suspend fun eelIt(): EelResult<EelTunnelsApi.ConnectionAcceptor, EelConnectionError> =
      owner.getAcceptorForRemotePort(
        HostAddressImpl(
          hostname = hostname,
          port = port,
          protocolPreference = protocolPreference,
          timeout = timeout,
        )
      )
  }

  /**
   * Create it via [com.intellij.platform.eel.EelTunnelsApi.getConnectionToRemotePort].
   */
  @GeneratedBuilder.Result
  class GetConnectionToRemotePort(
    private val owner: EelTunnelsApi,
  ) : OwnedBuilder<EelResult<Connection, EelConnectionError>> {
    private var hostname: String = "localhost"

    private var port: UShort = 0u

    private var protocolPreference: EelIpPreference = EelIpPreference.USE_SYSTEM_DEFAULT

    private var timeout: Duration = 10.seconds

    fun hostname(arg: String): GetConnectionToRemotePort = apply {
      this.hostname = arg
    }

    fun port(arg: UShort): GetConnectionToRemotePort = apply {
      this.port = arg
    }

    /**
     * @see [Builder.preferIPv4]
     */
    fun protocolPreference(arg: EelIpPreference): GetConnectionToRemotePort = apply {
      this.protocolPreference = arg
    }

    fun preferV4(): GetConnectionToRemotePort =
      protocolPreference(EelIpPreference.PREFER_V4)

    fun preferV6(): GetConnectionToRemotePort =
      protocolPreference(EelIpPreference.PREFER_V6)

    fun useSystemDefault(): GetConnectionToRemotePort =
      protocolPreference(EelIpPreference.USE_SYSTEM_DEFAULT)

    /**
     * @see [Builder.connectionTimeout]
     */
    fun timeout(arg: Duration): GetConnectionToRemotePort = apply {
      this.timeout = arg
    }

    /**
     * Complete the builder and call [com.intellij.platform.eel.EelTunnelsApi.getConnectionToRemotePort]
     * with an instance of [com.intellij.platform.eel.EelTunnelsApi.HostAddress].
     */
    @org.jetbrains.annotations.CheckReturnValue
    override suspend fun eelIt(): EelResult<Connection, EelConnectionError> =
      owner.getConnectionToRemotePort(
        HostAddressImpl(
          hostname = hostname,
          port = port,
          protocolPreference = protocolPreference,
          timeout = timeout,
        )
      )
  }
}