#!/bin/sh
#########################################################################################
# Description: Mother of all Start
#########################################################################################

export CSIMUL_MODE=NO

full=`readlink -f $0`
. `dirname $full`/setenv
. ${BASEPATH}/scripts/utilities_for_starts.sh

setTerminal
setStartTime
setTerminationHandler
setPathAndLDPath

print_header "COMACT Softwares now starting"

VISION_ONLY=0
CHECK_FOR_PC_AUX=1

TAB_DIR=tab
FORCED_START=0
RUN_ANYWAY=0
NO_SLEEP=0
MODE_MONTAGE=""
export DATAIO_WITHOUTHARDWARE=""

# file generated by software to notify that firmware update is required
FIRMWARE_UPDATE_TEST_FILE=/${BASEPATH}/${TAB_DIR}/Status/firmware_update.tmp

# Recuperation des parametres
while getopts VHGFhR:Su:KIM opt
do
	case $opt in
	
		V)	VISION_ONLY=1
			echo "Restart Only Vision"
			;;
    H)	DATAIO_WITHOUTHARDWARE=-n
			echo "No hardware mode"
			;;
		G)	export FLOW_ARG="-G"
			echo "Forcing Line Flow Generator mode"
			;;
		R)	export TAB_DIR_OPT=-R$OPTARG
			export TAB_DIR=$OPTARG
			;;
		h)	printf "Start - Demarage des logiciels (COMACT)\n"
			printf "\n"
			printf "Start [-V] [-H] [-Rtab] [-G] [-Rtab] [-S] [-K] [-F hostname] [-I] [-u] [-M]\n"
			printf "Options:\n"
			printf " -V           Redemarrage de la vision\n"
			printf " -H           On force le mode dataio no hardware\n"
			printf " -G           Mode lineflow\n"
			printf " -R           Repertoire du tab\n"
			printf " -S           No sleep activated\n"
			printf " -K           Garder les terminaux ouverts meme après l'exit\n"
			printf " -F           Forcing start on node `hostname`\n"
			printf " -I           Run even if on a simulator\n"
			printf " -u           On permet la mise a jour du firmware\n"
			printf " -M           Mode montage\n"
			exit
			;;
		S)	export NO_SLEEP=1
			;;
		K)  export KEEP_TERM_OPEN_ON_EXIT=1
			;;
		F)  FORCED_START=1
			echo "Forcing start on node `hostname`"
			;;
		I)  RUN_ANYWAY=1
			echo "Running even if on a simulator"
			;;
		u)	export FIRMWARE_UPDATE_ALLOWED=1
			;;
	  M)MODE_MONTAGE="-M"
			echo "Mode montage"
	    export MODE_MONTAGE
    	;;
	esac
done

if test "$DISPLAY" != ":0.0" -a -z "${FLOW_ARG}"; then
	echo "Can only be launched on DISPLAY 0"
	exit
fi

if [ "$RUN_ANYWAY" -eq "0" ]  ; then
	lowercaseHostname=$(hostname | awk '{ print tolower($1) }')
  case "$lowercaseHostname" in
		"simul"*) 
			echo "ATTENTION: Attempting to start on non-controller machine, if this is intentionnal, use -I to force"
			echo "ATTENTION: Start can only be use on a controller, maybe you meant StartSim, or you though "
			echo "ATTENTION: you are on the controller, or maybe you are hung over?"
			exit;;
		*) ;;
	esac
fi

if ! validateSettingsInTabs ${BASEPATH}/${TAB_DIR}/System/StartConfig; then
	exit 1
fi

handleActifFolders
if [ $? != 0 ] 
then 
	exit 1
fi

# Elimine variables qui sont "export" mais pas necessaire au fonctionnement des applications
# Trop de variables d'environment causent des problèmes.
unset GNSSERVER
unset EDITOR
unset DOMMACH
unset DOMCLIENT
unset ENV

#########################################################################################
WAIT_IP_FILE=/${BASEPATH}/${TAB_DIR}/System/waitip.txt
if [ -e ${WAIT_IP_FILE} ]
then
	waitip -f${WAIT_IP_FILE}
	# Dont want to have the duration of the wait show up as the time
	# it took for the ips to become reachable.  I think it would be confusing as I beleive
	# waiting for the ip is not really part of software startup.
	STARTTIME=`getDate`
fi

rm /${BASEPATH}/${TAB_DIR}/Status/Monitoring/processes.* 2>/dev/null
rm ${FIRMWARE_UPDATE_TEST_FILE} 2>/dev/null

cd /${BASEPATH}/scripts

. /${BASEPATH}/${TAB_DIR}/System/StartConfig
MACHINE_TYPE=`getxmlval.exe /${BASEPATH}/${TAB_DIR}/System/env.xml ModeleMachine[@Value]`

if [ "${MACHINE_TYPE}" = "SORTER_STANDALONE" ]; then
	StartSorterStandalone $@ -n
fi

VISION=`getxmlval.exe  /${BASEPATH}/${TAB_DIR}/System/env.xml SystemUseVision[@Value]`
USE_AI=`getxmlval.exe  /${BASEPATH}/${TAB_DIR}/System/machine.xml AI.useBrainUnit[@Value]`

# Gestion de la vision pour le line_flow linéaire
if [ "${SCANNER_TYPE}" = "C1_SCAN" ] && [ "${FLOW_ARG}" = "-G" ];
then
  if [ -r /${BASEPATH}/${TAB_DIR}/System/line_flow_gen.xml  ];
  then
    FLOW_GEN_VISION=`getxmlval.exe  /${BASEPATH}/${TAB_DIR}/System/line_flow_gen.xml SawLine.useVision[@Value]`
    if [ "${FLOW_GEN_VISION}" = "0" ];
    then
        VISION=$FLOW_GEN_VISION
        USE_AI=$FLOW_GEN_VISION
    fi
    CHECK_FOR_PC_AUX=`getxmlval.exe  /${BASEPATH}/${TAB_DIR}/System/line_flow_gen.xml SawLine.useMultiMachine[@Value]`
  else
    VISION="0"
    USE_AI="0"
  fi
fi

if [ "$END_ANALYZER_NODE" = "localhost" ]; then
	END_ANALYZER_NODE=$NODE
fi

if [ "$CHECK_FOR_PC_AUX" = "1" ]; then
  waitnodes.py $DESTROY_NODES
fi

if [ "${MACHINE_LINEAIRE}" != "3" ]
then
  if ! destroy_it_all ; then
    # because of shell speed, after the destroy_it_all, there could still be some
    # stuff running in the other Start, mainly the termination handler still running.
    # That mean if we keep going the termination handler of the other Start might
    # kill some of our program, that we will be starting. Nasty.
    waitForOtherStartToBeTerminated
  fi
fi
## else do nothing, there is a destroy inside StartGap anyways that will take care of everything	

# Leave trace of our startup
mkdir -p /ramdisk/pids/
export COMACT_PIDFILE="/ramdisk/pids/Start.$$"
# Put BASEPATH in the pidfile so waitForOtherStartToBeTerminated() can check if it's
# the same Start or not,
echo "$BASEPATH/$TAB_DIR" > $COMACT_PIDFILE

startGns ${BASEPATH}/${TAB_DIR}

if [ "$CHECK_FOR_PC_AUX" = "1" ];
then
  validateMainNetwork $DESTROY_NODES
  if [ $? != 0 ] ; then
	  exit
  fi
fi

if [ "${USE_STREAM_ANALYZER}" = "1" ]
then
	StartStream ${TAB_DIR_OPT}
elif [ "${MACHINE_LINEAIRE}" = "8" ]
then
	StartControl ${TAB_DIR_OPT}
elif [ "${MACHINE_LINEAIRE}" = "7" ]
then
	StartLCGE ${TAB_DIR_OPT}
elif [ "${MACHINE_LINEAIRE}" = "4" ]
then
	StartMV ${TAB_DIR_OPT}
elif [ "${MACHINE_LINEAIRE}" = "3" ]
then
	echo "Gap Control is no longer supported. You will need to use an older version"
elif [ "${MACHINE_LINEAIRE}" = "2" ]
then
	Start_t  ${TAB_DIR_OPT}
	Start_l -a ${TAB_DIR_OPT}
elif [ "${MACHINE_LINEAIRE}" = "1" ]
then
	Start_l ${TAB_DIR_OPT} ${FLOW_ARG}
	
	if [ "${VISION}" = "1" -a "${DONT_START_VISION}" != "1" ]
	then
		StartScan_v ${TAB_DIR_OPT} ${FLOW_ARG}
		Start_v -a -g ${TAB_DIR_OPT} ${FLOW_ARG}
	fi
elif [ "${MACHINE_LINEAIRE}" = "0" ]
then
	StartUtilApp2 ${TAB_DIR_OPT}

	if [ "${USE_PLC}" = "1" ]
	then
		StartPLC -n${NODE} ${TAB_DIR_OPT}
	
		print_fill "Loading:  dataio.exe"
		if [ ${DATAIO_READ_PERIOD} != "" ]; then
			_DATAIO_READ_PERIOD=-r${DATAIO_READ_PERIOD}
		fi
		if [ ${DATAIO_WRITE_PERIOD} != "" ]; then
			_DATAIO_WRITE_PERIOD=-w${DATAIO_WRITE_PERIOD}
		fi
		if [ ${DATAIO_SCHEDULED_READ_PERIOD} != "" ]; then
			_DATAIO_SCHEDULED_READ_PERIOD=-i${DATAIO_SCHEDULED_READ_PERIOD}
		fi
		if [ ${DATAIO_SCHEDULED_WRITE_PERIOD} != "" ]; then
			_DATAIO_SCHEDULED_WRITE_PERIOD=-I${DATAIO_SCHEDULED_WRITE_PERIOD}
		fi
		
		on $PTERM dataio.exe  ${TAB_DIR_OPT} ${DATAIO_WITHOUTHARDWARE} ${_DATAIO_READ_PERIOD} ${_DATAIO_WRITE_PERIOD} ${_DATAIO_SCHEDULED_READ_PERIOD} ${_DATAIO_SCHEDULED_WRITE_PERIOD} &
		cherche.exe ${TAB_DIR_OPT} dataio.exe
	fi
	


	if [ "${VISION_ONLY}" = "1" ]
	then
		StartScan_v ${TAB_DIR_OPT} ${LINEFLOWGEN_ARG}
		
				
		print_fill "Loading:  lug_sync.exe on node ${SCANNER_NODE}"
		on $PTERM lug_sync.exe ${TAB_DIR_OPT} &
		cherche.exe ${TAB_DIR_OPT} lug_sync.exe
		
		print_fill "Loading:  commandes.exe on node ${NODE_ALL}"
		on -f${NODE_ALL} $PTERM commandes.exe -m0 ${TAB_DIR_OPT} -c"${NODE_ALL} 0 0" -C"${NODE_ALL} 0" &
		cherche.exe -m0 commandes.exe

		print_fill "Loading:  diag_server.exe"
		on $PTERM diag_server.exe ${TAB_DIR_OPT} &
		cherche.exe ${TAB_DIR_OPT} diag_server.exe
		
		ENDTIME=$((`getDate`-$STARTTIME))
		
					
		print_fill "Loading:  osd.exe"
		on $PTERM osd.exe ${TAB_DIR_OPT} -p${OSD_WEB_PORT_LIVE} &
		cherche.exe ${TAB_DIR_OPT} osd.exe
		 
		print_fill "Loading:  cms_server.exe"
		on $PTERM cms_server.exe ${TAB_DIR_OPT} ${CMS_OPTIONS} &
		cherche.exe ${TAB_DIR_OPT} cms_server.exe
				
				
		printf "Started in $ENDTIME secs\n"
		sleep 100000000
		exit
	fi
	if [ "${VISION}" = "1" ]
	then
		if [ $FORCED_START -ne "0" ]; then
			StartScan_v -F ${FLOW_ARG} ${TAB_DIR_OPT}
			exit 0
		else
			StartScan_v ${FLOW_ARG} ${TAB_DIR_OPT}
		fi
	fi

	Start_t -a ${FLOW_ARG} ${TAB_DIR_OPT}
	
	USE_EA=`getxmlval.exe  /${BASEPATH}/${TAB_DIR}/System/machine.xml Vision.active_vision_bout[@Value]`
	
	if [ "${VISION}" = "1" ]; then
		Start_v -a -g ${FLOW_ARG} ${TAB_DIR_OPT}
	elif [ "${USE_EA}" != "0" ]; then
		StartEndAnalyzer -n${END_ANALYZER_NODE} ${FLOW_ARG} ${TAB_DIR_OPT}
	fi
	
	if  [ "${MODE_LINEARGRADER}" = "1" ]; then
		echo "StartTracking -R${TAB_DIR_LINEARGRADER} -N${NODE_TRACKING}"
		StartTracking -R${TAB_DIR_LINEARGRADER} -N${NODE_TRACKING}
	fi
	
	USE_CORRECTION_SCANNER=`getxmlval.exe  /${BASEPATH}/${TAB_DIR}/System/machine.xml mode.mode_cantcorrection_permission[@Value]`
	if [ "${USE_CORRECTION_SCANNER}" = "1" ]
	then
		StartScan_l -m7
	fi
	
	if [ "${SCANNER_TYPE}" = "C1_SCAN" ]
	then
		StartScan_l -n${SCANNER_NODE_ROTATION} -m0 ${FLOW_ARG} ${TAB_DIR_OPT}
	fi
	
else
	StartEndAnalyzer -n${END_ANALYZER_NODE} ${TAB_DIR_OPT}
fi

USE_DRIVER_1198=`getxmlval.exe  /${BASEPATH}/${TAB_DIR}/System/machine.xml usingDriver1198[@Value]`
if [ "${USE_DRIVER_1198}" = "1" ]; then
  print_fill "Loading:  Driver1198.exe"
  on $PTERM driver_1198.exe -R${TAB_DIR} &
  cherche.exe -R${TAB_DIR} $CHERCHE driver_1198.exe
fi

print_fill "Loading:  diag_server.exe"
on $PTERM diag_server.exe ${TAB_DIR_OPT} &
cherche.exe ${TAB_DIR_OPT} diag_server.exe

if [ -z "$OSD_WEB_PORT_LIVE" ]; then
	OSD_WEB_PORT_LIVE=2000
fi

print_fill "Loading:  osd.exe"
on $PTERM osd.exe ${TAB_DIR_OPT} -p${OSD_WEB_PORT_LIVE} &
cherche.exe ${TAB_DIR_OPT} osd.exe
 
print_fill "Loading:  cms_server.exe"
on $PTERM cms_server.exe ${TAB_DIR_OPT} ${CMS_OPTIONS} &
cherche.exe ${TAB_DIR_OPT} cms_server.exe

if [ -e "${FIRMWARE_UPDATE_TEST_FILE}" ]	
then
	printf "\n"
   	printf "!!!!!!!!!! firmware update required !!!!!!!!!!\n"
   	cat ${FIRMWARE_UPDATE_TEST_FILE}
   	printf "run script with -u1 option: ./Start -u1\n"
   	printf "!!!!!!!!!! firmware update required !!!!!!!!!!\n"
	sleep 100000000
fi

PRIMARY_SCANNER_MODE=`getxmlval.exe  /${HOMEBASE}/${CLIENT}/${MACHINE}/${TAB_DIR}/System/scannerconfig_0.xml scanner_mode[@Value]`

if [ "${FLOW_ARG}" = "-G" ] && [ "${PRIMARY_SCANNER_MODE}" != "2" ]
then
	print_fill "Loading:  line_flow_gen.exe"
	on $PTERM line_flow_gen.exe ${TAB_DIR_OPT} &
	cherche.exe ${TAB_DIR_OPT} -t 30 line_flow_gen.exe
fi

mv /${BASEPATH}/${TAB_DIR}/Status/Monitoring/processes.tmp /${BASEPATH}/${TAB_DIR}/Status/Monitoring/processes.txt
	
if [ "$NO_SLEEP" = "0" ]; then	
	ENDTIME=$((`getDate`-$STARTTIME))
	traceme.exe -T"Startup" -M"Start done in $ENDTIME sec"
	print_footer $ENDTIME $OSD_WEB_PORT_LIVE
	CaptureSession -q ${TAB_DIR_OPT}
	sleep 100000000
fi
