// Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
package com.intellij.ide.plugins

import com.intellij.ide.plugins.cl.PluginClassLoader
import com.intellij.openapi.util.BuildNumber
import com.intellij.testFramework.assertions.Assertions.assertThat
import com.intellij.testFramework.assertions.Assertions.assertThatThrownBy
import com.intellij.testFramework.rules.InMemoryFsRule
import com.intellij.util.io.directoryStreamIfExists
import org.junit.Rule
import org.junit.Test
import java.nio.file.Path
import java.util.function.Consumer
import java.util.function.Supplier

private val buildNumber = BuildNumber.fromString("2042.0")

internal class ClassLoaderConfiguratorTest {
  @Rule
  @JvmField
  val inMemoryFs = InMemoryFsRule()

  @Test
  fun packageForOptionalMustBeSpecified() {
    assertThatThrownBy {
      loadPlugins {
        PluginBuilder().noDepends()
      }
    }.hasMessageStartingWith("Sub descriptor must specify package if it is specified for main plugin descriptor ")
  }

  @Test
  fun packageForOptionalMustBeDifferent() {
    assertThatThrownBy {
      loadPlugins {
        PluginBuilder().noDepends().packagePrefix("com.example")
      }
    }.hasMessageStartingWith("Sub descriptor must not specify the same package as main plugin descriptor [")
  }

  @Test
  fun packageMustBeUnique() {
    assertThatThrownBy {
      loadPlugins {
        PluginBuilder().noDepends().packagePrefix("com.bar")
      }
    }.hasMessageStartingWith("Package prefix com.bar is already used [")
  }

  @Test
  fun regularPluginClassLoaderIsUsedIfPackageSpecified() {
    loadPlugins {
      PluginBuilder().noDepends().packagePrefix("com.example.extraSupportedFeature")
    }.enabledPlugins.get(1).pluginDependencies!!.get(0).subDescriptor!!.classLoader!!.javaClass === PluginClassLoader::class.java
  }

  private fun loadPlugins(dependent: () -> PluginBuilder): PluginLoadingResult {
    val rootDir = inMemoryFs.fs.getPath("/")

    val pluginDependency = PluginBuilder()
      .noDepends()
      .packagePrefix("com.bar")
      .extensionPoints(
        """<extensionPoint qualifiedName="bar.barExtension" beanClass="com.intellij.util.KeyedLazyInstanceEP" dynamic="true"/>""")
      .buildToAutoGeneratedSubDir(rootDir)

    PluginBuilder()
      .noDepends()
      .packagePrefix("com.example")
      // dependent must not be empty, add some extension
      .depends(pluginDependency.buildToAutoGeneratedSubDir(rootDir).id,
               dependent().extensions("""<barExtension key="foo" implementationClass="y"/>""", "bar"))
      .buildToAutoGeneratedSubDir(rootDir)
    val loadResult = loadDescriptors(rootDir)
    val plugins: List<IdeaPluginDescriptorImpl> = loadResult.enabledPlugins
    assertThat(plugins).hasSize(2)

    val classLoaderConfigurator = ClassLoaderConfigurator(true, PluginManagerCore::class.java.classLoader, loadResult.idMap, emptyMap())
    plugins.forEach(Consumer(classLoaderConfigurator::configure))
    return loadResult
  }
}

private fun loadDescriptors(dir: Path): PluginLoadingResult {
  val result = PluginLoadingResult(emptyMap(), Supplier { buildNumber })
  val context = DescriptorListLoadingContext(0, emptySet(), result)

  // constant order in tests
  val paths: List<Path> = dir.directoryStreamIfExists { it.sorted() }!!
  context.use {
    for (file in paths) {
      result.add(PluginDescriptorLoader.loadDescriptor(file, false, context) ?: continue, false)
    }
  }
  result.finishLoading()
  return result
}
