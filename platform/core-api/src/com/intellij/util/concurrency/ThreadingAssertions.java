// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.util.concurrency;

import com.intellij.concurrency.ThreadContext;
import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.diagnostic.RuntimeExceptionWithAttachments;
import com.intellij.util.ui.EDT;
import org.jetbrains.annotations.ApiStatus.Internal;
import org.jetbrains.annotations.ApiStatus.Obsolete;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import java.awt.*;

/**
 * This class contains various threading assertions.
 * Calls to these functions are generated by {@link org.jetbrains.jps.devkit.threadingModelHelper.TMHInstrumenter TMHInstrumenter}
 * if a function is annotated with a respective annotation and annotation's {@code generateAssertion} is set to {@code true}.
 * These functions are also allowed to be used directly.
 */
public final class ThreadingAssertions {

  private ThreadingAssertions() { }

  private static @NotNull Logger getLogger() {
    return Logger.getInstance(ThreadingAssertions.class);
  }

  private static final String DOCUMENTATION_URL = "https://jb.gg/ij-platform-threading";

  @Internal
  @VisibleForTesting
  public static final String MUST_EXECUTE_IN_READ_ACTION =
    "Read access is allowed from inside read-action only (see Application.runReadAction())";
  @Internal
  @VisibleForTesting
  public static final String READ_ACCESS_REQUIRED_WHILE_LOCKS_ARE_FORBIDDEN =
    "This thread requested read access, but it does not have permission to use locks.";
  @Internal
  @VisibleForTesting
  public static final String WRITE_ACCESS_REQUIRED_WHILE_LOCKS_ARE_FORBIDDEN =
    "This thread requested write access, but it does not have permission to use locks.";
  @Internal
  @VisibleForTesting
  public static final String WRITE_INTENT_ACCESS_REQUIRED_WHILE_LOCKS_ARE_FORBIDDEN =
    "This thread requested write-intent access, but it does not have permission to use locks.";
  @Internal
  @VisibleForTesting
  public static final String MUST_NOT_EXECUTE_IN_READ_ACTION =
    "Must not execute inside read action";
  private static final String MUST_EXECUTE_IN_WRITE_INTENT_READ_ACTION =
    "Access is allowed from write thread only";
  @Internal
  @VisibleForTesting
  public static final String MUST_EXECUTE_IN_WRITE_ACTION =
    "Write access is allowed inside write-action only (see Application.runWriteAction())";
  @Internal
  @VisibleForTesting
  public static final String MUST_EXECUTE_IN_EDT =
    "Access is allowed from Event Dispatch Thread (EDT) only";
  @Internal
  @VisibleForTesting
  public static final String MUST_NOT_EXECUTE_IN_EDT =
    "Access from Event Dispatch Thread (EDT) is not allowed";

  /**
   * Asserts that the current thread is the event dispatch thread.
   *
   * @see com.intellij.util.concurrency.annotations.RequiresEdt
   */
  public static void assertEventDispatchThread() {
    if (!EDT.isCurrentThreadEdt() && !EDT.isDisableEdtChecks()) {
      throwThreadAccessException(MUST_EXECUTE_IN_EDT);
    }
  }

  /**
   * Asserts that the current thread is the event dispatch thread <b>without throwing</b> an exception.
   *
   * @see com.intellij.util.concurrency.annotations.RequiresEdt
   */
  @Obsolete
  public static void softAssertEventDispatchThread() {
    if (!EDT.isCurrentThreadEdt() && !EDT.isDisableEdtChecks()) {
      getLogger().error(createThreadAccessException(MUST_EXECUTE_IN_EDT));
    }
  }

  /**
   * Asserts that the current thread is <b>not</b> the event dispatch thread.
   *
   * @see com.intellij.util.concurrency.annotations.RequiresBackgroundThread
   */
  public static void assertBackgroundThread() {
    if (EDT.isCurrentThreadEdt() && !EDT.isDisableEdtChecks()) {
      throwThreadAccessException(MUST_NOT_EXECUTE_IN_EDT);
    }
  }

  /**
   * Asserts that the current thread is <b>not</b> the event dispatch thread <b>without throwing</b> an exception.
   *
   * @see com.intellij.util.concurrency.annotations.RequiresBackgroundThread
   */
  @Obsolete
  public static void softAssertBackgroundThread() {
    if (EDT.isCurrentThreadEdt() && EDT.isDisableEdtChecks()) {
      getLogger().error(createThreadAccessException(MUST_NOT_EXECUTE_IN_EDT));
    }
  }

  /**
   * Asserts that the current thread has read access.
   * <p/>
   * For consistency with other assertions, this function <b>throws</b> an error when called without holding the read lock.
   *
   * @see #softAssertReadAccess
   * @see com.intellij.util.concurrency.annotations.RequiresReadLock
   */
  public static void assertReadAccess() {
    Application application = ApplicationManager.getApplication();
    if (application != null) {
      if (!application.isReadAccessAllowed()) {
        throwThreadAccessException(MUST_EXECUTE_IN_READ_ACTION);
      }
      else {
        trySoftAssertReadAccessWhenLocksAreForbidden(application);
      }
    }
  }

  private static void trySoftAssertReadAccessWhenLocksAreForbidden(@NotNull Application application) {
    String advice = application.isLockingProhibited();
    if (advice != null) {
      getLogger().error(createLockingForbiddenException(READ_ACCESS_REQUIRED_WHILE_LOCKS_ARE_FORBIDDEN + "\n" + advice));
    }
  }

  /**
   * Asserts that the current thread has read access <b>without throwing</b> an exception.
   * <p/>
   * Historically, it was not possible to throw everywhere,
   * so this function logs an error without throwing, but then proceeds normally.
   * When writing the new code, please prefer throwing {@link #assertReadAccess} instead,
   * because only it can guarantee that the caller holds the read lock.
   *
   * @see com.intellij.util.concurrency.annotations.RequiresReadLock
   */
  @Obsolete
  public static void softAssertReadAccess() {
    Application application = ApplicationManager.getApplication();
    if (application != null) {
      if (!application.isReadAccessAllowed()) {
        getLogger().error(createThreadAccessException(MUST_EXECUTE_IN_READ_ACTION));
      }
      else {
        trySoftAssertReadAccessWhenLocksAreForbidden(application);
      }
    }
  }

  /**
   * Asserts that the current thread has <b>no</b> read access.
   *
   * @see com.intellij.util.concurrency.annotations.RequiresReadLockAbsence
   */
  public static void assertNoReadAccess() {
    Application application = ApplicationManager.getApplication();
    if (application != null && application.isReadAccessAllowed()) {
      throwThreadAccessException(MUST_NOT_EXECUTE_IN_READ_ACTION);
    }
  }

  /**
   * Asserts that the current thread has <b>no</b> read access local to this thread (non-inherited).
   */
  public static void assertNoOwnReadAccess() {
    Application application = ApplicationManager.getApplication();
    if (application != null && application.holdsReadLock()) {
      throwThreadAccessException(MUST_NOT_EXECUTE_IN_READ_ACTION);
    }
  }

  /**
   * Asserts that the current thread has write-intent read access.
   */
  public static void assertWriteIntentReadAccess() {
    Application application = ApplicationManager.getApplication();
    if (application != null) {
      if (!application.isWriteIntentLockAcquired()) {
        throwWriteIntentReadAccess();
      }
      else {
        trySoftAssertWriteIntentAccessWhenLocksAreForbidden(application);
      }
    }
  }

  private static void trySoftAssertWriteIntentAccessWhenLocksAreForbidden(@NotNull Application application) {
    String advice = application.isLockingProhibited();
    if (advice != null) {
      getLogger().error(createLockingForbiddenException(WRITE_INTENT_ACCESS_REQUIRED_WHILE_LOCKS_ARE_FORBIDDEN + "\n" + advice));
    }
  }

  /**
   * Throw error that current thread hasn't write-intent read access.
   */
  public static void throwWriteIntentReadAccess() {
    throwThreadAccessException(MUST_EXECUTE_IN_WRITE_INTENT_READ_ACTION);
  }

  /**
   * Asserts that the current thread has write access.
   *
   * @see com.intellij.util.concurrency.annotations.RequiresWriteLock
   */
  public static void assertWriteAccess() {
    Application application = ApplicationManager.getApplication();
    if (application != null) {
      if (!application.isWriteAccessAllowed()) {
        throwThreadAccessException(MUST_EXECUTE_IN_WRITE_ACTION);
      }
      else {
        trySoftAssertWriteAccessWhenLocksAreForbidden(application);
      }
    }
  }

  private static void trySoftAssertWriteAccessWhenLocksAreForbidden(@NotNull Application application) {
    String advice = application.isLockingProhibited();
    if (advice != null) {
      getLogger().error(createLockingForbiddenException(WRITE_ACCESS_REQUIRED_WHILE_LOCKS_ARE_FORBIDDEN + "\n" + advice));
    }
  }

  private static void throwThreadAccessException(@NotNull @NonNls String message) {
    throw createThreadAccessException(message);
  }

  private static @NotNull RuntimeExceptionWithAttachments createThreadAccessException(@NonNls @NotNull String message) {
    // Don't suggest Read Action on EDT with coroutines, as it rescheduled code
    boolean skipReadAction = EDT.isCurrentThreadEdt() && ThreadContext.currentThreadContextOrNull() != null;
    return new RuntimeExceptionWithAttachments(
      message + "; If you access or modify model on EDT consider wrapping your code in WriteIntentReadAction " +
      (skipReadAction ? "" : " or ReadAction") +
      "; see " + DOCUMENTATION_URL + " for details" + "\n" + getThreadDetails()
    );
  }

  private static @NotNull RuntimeExceptionWithAttachments createLockingForbiddenException(@NonNls @NotNull String advice) {
    return new RuntimeExceptionWithAttachments(advice + "\nSee " + DOCUMENTATION_URL + " for details" + "\n" + getThreadDetails());
  }

  private static @NotNull String getThreadDetails() {
    Thread current = Thread.currentThread();
    Thread edt = EDT.getEventDispatchThreadOrNull();
    return "Current thread: " + describe(current) + " (EventQueue.isDispatchThread()=" + EventQueue.isDispatchThread() + ")\n" +
           "SystemEventQueueThread: " + (edt == current ? "(same)" : describe(edt));
  }

  private static @NotNull String describe(@Nullable Thread o) {
    return o == null ? "null" : o + " " + System.identityHashCode(o);
  }
}
