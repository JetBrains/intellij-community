package org.jetbrains.jewel.buildlogic.theme

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.joinToCode
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive

internal object IntUiThemeDescriptorReader {

    private val colorGroups = setOf("Gray", "Blue", "Green", "Red", "Yellow", "Orange", "Purple", "Teal")
    private val colorClassName = ClassName("androidx.compose.ui.graphics", "Color")

    fun readThemeFrom(
        themeDescriptor: IntellijThemeDescriptor,
        className: ClassName,
        ideaVersion: String,
        descriptorUrl: String,
    ) =
        FileSpec.builder(className)
            .apply {
                indent("    ")
                addFileComment("Generated by the Jewel Int UI Palette Generator\n")
                addFileComment("Generated from the IntelliJ Platform version $ideaVersion\n")
                addFileComment("Source: $descriptorUrl")

                addImport(colorClassName.packageName, colorClassName.simpleName)

                addType(
                    TypeSpec.objectBuilder(className)
                        .apply {
                            addSuperinterface(
                                ClassName.bestGuess("org.jetbrains.jewel.foundation.theme.ThemeDescriptor")
                            )

                            addProperty(
                                PropertySpec.builder("isDark", Boolean::class, KModifier.OVERRIDE)
                                    .initializer("%L", themeDescriptor.dark)
                                    .build()
                            )

                            addProperty(
                                PropertySpec.builder("name", String::class, KModifier.OVERRIDE)
                                    .initializer("\"%L (Int UI)\"", themeDescriptor.name)
                                    .build()
                            )

                            readColors(themeDescriptor.colors)
                            readIcons(themeDescriptor)
                        }
                        .build()
                )
            }
            .build()

    private val colorPaletteClassName = ClassName.bestGuess("org.jetbrains.jewel.foundation.theme.ThemeColorPalette")
    private val iconDataClassName = ClassName.bestGuess("org.jetbrains.jewel.foundation.theme.ThemeIconData")

    private fun TypeSpec.Builder.readColors(colors: Map<String, String>) {
        val colorGroups =
            colors.entries
                .groupBy { it.key.replace("""\d+""".toRegex(), "") }
                .filterKeys { colorGroups.contains(it) }
                .map { (groupName, colors) ->
                    // We assume color lists are in the same order as in colorGroups
                    colors
                        .map { (_, value) ->
                            val colorHexString = value.replace("#", "0xFF")
                            CodeBlock.of("Color(%L)", colorHexString)
                        }
                        .joinToCode(
                            prefix = "\n${groupName.lowercase()} = listOf(\n",
                            separator = ",\n",
                            suffix = "\n)",
                        )
                }

        val rawMap =
            colors
                .map { (key, value) ->
                    val colorHexString = value.replace("#", "0xFF")
                    CodeBlock.of("%S to Color(%L)", key, colorHexString)
                }
                .joinToCode(prefix = "\nrawMap = mapOf(\n", separator = ",\n", suffix = "\n)")

        addProperty(
            PropertySpec.builder("colors", colorPaletteClassName, KModifier.OVERRIDE)
                .initializer("ThemeColorPalette(%L,\n%L\n)", colorGroups.joinToCode(","), rawMap)
                .build()
        )
    }

    private fun TypeSpec.Builder.readIcons(theme: IntellijThemeDescriptor) {
        val iconOverrides = mutableMapOf<String, String>()
        val colorPalette = mutableMapOf<String, String>()

        for ((key, value) in theme.icons) {
            if (value is JsonPrimitive && value.isString) {
                iconOverrides += key to value.content
            } else if (value is JsonObject && key == "ColorPalette") {
                value.entries
                    .mapNotNull {
                        val pairValue = it.value
                        if (pairValue is JsonPrimitive && pairValue.isString) {
                            it.key to pairValue.content
                        } else null
                    }
                    .forEach { colorPalette[it.first] = it.second }
            }
        }

        val iconOverridesBlock = iconOverrides.toMapCodeBlock()
        val selectionColorPaletteBlock = theme.iconColorsOnSelection.toMapCodeBlock()

        addProperty(
            PropertySpec.builder("iconData", iconDataClassName, KModifier.OVERRIDE)
                .initializer(
                    CodeBlock.of(
                        "ThemeIconData(iconOverrides = \n%L,colorPalette = \n%L,\nselectionColorPalette = %L\n)",
                        iconOverridesBlock,
                        colorPalette.toMapCodeBlock(),
                        selectionColorPaletteBlock,
                    )
                )
                .build()
        )
    }

    private inline fun <reified K, reified V> Map<K, V>.toMapCodeBlock() =
        entries
            .map { (key, value) -> CodeBlock.of("\"%L\" to \"%L\"", key, value) }
            .joinToCode(prefix = "mapOf(", separator = ",\n", suffix = ")")
}
