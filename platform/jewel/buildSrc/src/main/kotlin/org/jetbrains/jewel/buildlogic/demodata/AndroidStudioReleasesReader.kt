package org.jetbrains.jewel.buildlogic.demodata

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asClassName
import com.squareup.kotlinpoet.joinToCode
import java.io.File
import java.time.LocalDate
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.util.Locale

private val ContentItemClassName =
    ClassName.bestGuess("org.jetbrains.jewel.samples.ideplugin.releasessample.ContentItem.AndroidStudio")

internal object AndroidStudioReleasesReader {

    fun readFrom(releases: ApiAndroidStudioReleases, className: ClassName, url: String, resourceDirs: Set<File>) =
        FileSpec.builder(className)
            .apply {
                indent("    ")
                addFileComment("Generated by the Jewel Android Studio Releases Generator\n")
                addFileComment("Generated from $url on ${ZonedDateTime.now()}")

                addImport("org.jetbrains.jewel.samples.ideplugin.releasessample", "ContentItem.AndroidStudio")
                addImport("kotlinx.datetime", "LocalDate")

                addType(createBaseTypeSpec(className, releases, resourceDirs))
            }
            .build()

    private fun createBaseTypeSpec(className: ClassName, releases: ApiAndroidStudioReleases, resourceDirs: Set<File>) =
        TypeSpec.objectBuilder(className)
            .addModifiers(KModifier.INTERNAL)
            .superclass(
                ClassName.bestGuess("org.jetbrains.jewel.samples.ideplugin.releasessample.ContentSource")
                    .parameterizedBy(ContentItemClassName)
            )
            .apply {
                addProperty(
                    PropertySpec.builder(
                            name = "items",
                            type = List::class.asClassName().parameterizedBy(ContentItemClassName),
                            KModifier.OVERRIDE,
                        )
                        .initializer(readReleases(releases, resourceDirs))
                        .build()
                )

                addProperty(
                    PropertySpec.builder("displayName", type = String::class.asClassName(), KModifier.OVERRIDE)
                        .initializer("\"%L\"", "Android Studio releases")
                        .build()
                )
            }
            .build()

    private fun readReleases(releases: ApiAndroidStudioReleases, resourceDirs: Set<File>) =
        releases.content.item
            .map { readRelease(it, resourceDirs) }
            .joinToCode(prefix = "listOf(\n", separator = ",\n", suffix = ")")

    private fun readRelease(release: ApiAndroidStudioReleases.Content.Item, resourceDirs: Set<File>) =
        CodeBlock.builder()
            .apply {
                add("AndroidStudio(\n")
                add("    displayText = \"%L\",\n", release.name)
                add("    imagePath = %L,\n", imagePathForOrNull(release, resourceDirs))
                add("    versionName = \"%L\",\n", release.version)
                add("    build = \"%L\",\n", release.build)
                add("    platformBuild = \"%L\",\n", release.platformBuild)
                add("    platformVersion = \"%L\",\n", release.platformVersion ?: "N/A")
                add("    channel = %L,\n", readChannel(release.channel))
                add("    releaseDate = LocalDate(%L),\n", translateDate(release.date))
                add("    key = \"%L\",\n", release.build)
                add(")")
            }
            .build()

    private fun imagePathForOrNull(release: ApiAndroidStudioReleases.Content.Item, resourceDirs: Set<File>): String? {
        // Take the release animal from the name, remove spaces and voila'
        val releaseAnimal = release.name.substringBefore(" | ").substringAfter("Android Studio").trim().replace(" ", "")

        if (releaseAnimal.isEmpty() || releaseAnimal.any { it.isDigit() }) return null

        // We only have stable and canary splash screens. Betas use the stable ones.
        val channel =
            release.channel.lowercase().let {
                when (it) {
                    "release",
                    "rc",
                    "stable",
                    "beta",
                    "patch" -> "stable"
                    "canary",
                    "preview",
                    "alpha" -> "canary"
                    else -> {
                        println("  Note: channel '${it}' isn't supported for splash screens")
                        null
                    }
                }
            } ?: return null

        val splashPath = "/studio-splash-screens/$releaseAnimal-$channel.png"
        val splashFiles = resourceDirs.map { dir -> File(dir, splashPath) }
        if (splashFiles.none { it.isFile }) {
            println("  Note: expected splash screen file doesn't exist: '${splashPath}'")
            return null
        }

        return "\"$splashPath\""
    }

    private fun translateDate(rawDate: String): String {
        val formatter = DateTimeFormatter.ofPattern("MMMM d, uuuu")
        val parsedDate = LocalDate.parse(rawDate, formatter)

        return "${parsedDate.year}, ${parsedDate.monthValue}, ${parsedDate.dayOfMonth}"
    }

    private fun readChannel(rawChannel: String) =
        when (rawChannel.lowercase().trim()) {
            "stable",
            "patch",
            "release" -> "ReleaseChannel.Stable"
            "beta" -> "ReleaseChannel.Beta"
            "canary" -> "ReleaseChannel.Canary"
            else -> "ReleaseChannel.Other"
        }
}
