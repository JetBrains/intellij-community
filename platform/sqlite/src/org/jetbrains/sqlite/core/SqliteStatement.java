// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.sqlite.core;

import com.intellij.util.ArrayUtilRt;
import org.jetbrains.sqlite.ExtendedCommand;
import org.jetbrains.sqlite.SQLiteConnectionConfig;

import java.sql.BatchUpdateException;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;

public class SqliteStatement implements Codes, AutoCloseable {
  protected final SqliteResultSet rs;
  final SqliteConnection conn;
  SafeStmtPtr pointer;
  protected long updateCount;
  protected String sql = null;
  protected int batchPos;
  protected Object[] batch = null;
  protected boolean resultsWaiting = false;
  boolean closeOnCompletion;
  private boolean closed = false;
  private int queryTimeout; // in seconds, as per the JDBC spec
  private boolean exhaustedResults = false;

  public SqliteStatement(SqliteConnection conn) {
    this.conn = conn;
    rs = new SqliteResultSet(this);
    queryTimeout = 0;
  }

  @Override
  public void close() throws SQLException {
    internalClose();
    closed = true; // isClosed() should only return true when close() happened
  }

  public boolean isClosed() {
    return closed;
  }

  public void closeOnCompletion() throws SQLException {
    if (closed) throw new SQLException("statement is closed");
    closeOnCompletion = true;
  }

  public boolean isCloseOnCompletion() throws SQLException {
    if (closed) throw new SQLException("statement is closed");
    return closeOnCompletion;
  }

  /** @see Statement#execute(String) */
  public boolean execute(final String sql) throws SQLException {
    internalClose();

    return withConnectionTimeout(() -> {
      ExtendedCommand.SQLExtension ext = ExtendedCommand.parse(sql);
      DB database = conn.getDatabase();
      if (ext != null) {
        ext.execute(database);
        return false;
      }

      this.sql = sql;

      database.prepare(this, sql);
      boolean result = exec();
      updateCount = database.changes();
      exhaustedResults = false;
      return result;
    });
  }

  /** @see Statement#execute(String, int) */
  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
    return execute(sql);
  }

  /**
   * @param closeStmt Whether to close this statement when the resultset is closed.
   * @see Statement#executeQuery(String)
   */
  public SqliteResultSet executeQuery(String sql, boolean closeStmt) throws SQLException {
    rs.closeStmt = closeStmt;

    return executeQuery(sql);
  }

  /** @see Statement#executeQuery(String) */
  public SqliteResultSet executeQuery(String sql) throws SQLException {
    internalClose();
    this.sql = sql;

    return withConnectionTimeout(() -> {
      conn.getDatabase().prepare(this, sql);

      if (!exec()) {
        internalClose();
        throw new SQLException("query does not return ResultSet", "SQLITE_DONE", SQLITE_DONE);
      }
      exhaustedResults = false;

      return getResultSet();
    });
  }

  /** @see Statement#executeUpdate(String) */
  public int executeUpdate(final String sql) throws SQLException {
    return (int)executeLargeUpdate(sql);
  }

  /** @see Statement#executeUpdate(String, int) */
  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
    return executeUpdate(sql);
  }

  /** @see Statement#executeLargeUpdate(String) */
  public long executeLargeUpdate(String sql) throws SQLException {
    internalClose();
    this.sql = sql;

    return withConnectionTimeout(() -> {
      DB db = conn.getDatabase();
      long changes = 0;
      ExtendedCommand.SQLExtension ext = ExtendedCommand.parse(sql);
      if (ext != null) {
        // execute extended command
        ext.execute(db);
      }
      else {
        try {
          changes = db.total_changes();

          // directly invokes the exec API to support multiple SQL statements
          int statusCode = db._exec(sql);
          if (statusCode != SQLITE_OK) {
            throw DB.newSQLException(statusCode, "", null);
          }

          changes = db.total_changes() - changes;
        }
        finally {
          internalClose();
        }
      }
      return changes;
    });
  }

  /** @see Statement#getResultSet() */
  final SqliteResultSet getResultSet() throws SQLException {
    checkOpen();

    if (exhaustedResults) {
      return null;
    }

    if (rs.isOpen()) {
      throw new SQLException("ResultSet already requested");
    }

    if (pointer.safeRunInt(DB::column_count) == 0) {
      return null;
    }

    if (rs.colsMeta == null) {
      rs.colsMeta = pointer.safeRun(DB::column_names);
    }

    rs.cols = rs.colsMeta;
    rs.emptyResultSet = !resultsWaiting;
    rs.open = true;
    resultsWaiting = false;

    return rs;
  }

  /**
   * This function has a complex behaviour best understood by carefully reading the JavaDoc for
   * getMoreResults() and considering the test StatementTest.execute().
   *
   * @see Statement#getUpdateCount()
   */
  public int getUpdateCount() throws SQLException {
    return (int)getLargeUpdateCount();
  }

  /**
   * This function has a complex behaviour best understood by carefully reading the JavaDoc for
   * getMoreResults() and considering the test StatementTest.execute().
   *
   * @see Statement#getLargeUpdateCount()
   */
  public long getLargeUpdateCount() throws SQLException {
    if (!pointer.isClosed()
        && !rs.isOpen()
        && !resultsWaiting
        && pointer.safeRunInt(DB::column_count) == 0) {
      return updateCount;
    }
    return -1;
  }

  /** @see Statement#addBatch(String) */
  public void addBatch(String sql) throws SQLException {
    internalClose();
    if (batch == null || batchPos + 1 >= batch.length) {
      Object[] nb = new Object[Math.max(10, batchPos * 2)];
      if (batch != null) System.arraycopy(batch, 0, nb, 0, batch.length);
      batch = nb;
    }
    batch[batchPos++] = sql;
  }

  /** @see Statement#clearBatch() */
  public void clearBatch() throws SQLException {
    batchPos = 0;
    if (batch != null) {
      Arrays.fill(batch, null);
    }
  }

  /** @see Statement#executeLargeBatch() */
  public long[] executeBatch(boolean collectChanges) throws SQLException {
    // TODO: optimize
    internalClose();
    if (batch == null || batchPos == 0) {
      return ArrayUtilRt.EMPTY_LONG_ARRAY;
    }

    long[] changes = new long[batchPos];
    DB db = conn.getDatabase();
    synchronized (db) {
      try {
        for (int i = 0; i < changes.length; i++) {
          try {
            sql = (String)batch[i];
            db.prepare(this, sql);
            changes[i] = db.executeUpdate(this, null, collectChanges);
          }
          catch (SQLException e) {
            throw new BatchUpdateException("batch entry " + i + ": " + e.getMessage(), null, 0, changes, e);
          }
          finally {
            if (pointer != null) {
              pointer.close();
            }
          }
        }
      }
      finally {
        clearBatch();
      }
    }

    return changes;
  }

  /** @see Statement#cancel() */
  public void cancel() throws SQLException {
    conn.getDatabase().interrupt();
  }

  /** @see Statement#getQueryTimeout() */
  public int getQueryTimeout() {
    return queryTimeout;
  }

  /** @see Statement#setQueryTimeout(int) */
  public void setQueryTimeout(int seconds) throws SQLException {
    if (seconds < 0) {
      throw new SQLException("query timeout must be >= 0");
    }
    queryTimeout = seconds;
  }

  /** @see Statement#getMaxRows() */
  public int getMaxRows() {
    // checkOpen();
    return (int)rs.maxRows;
  }

  /** @see Statement#setMaxRows(int) */
  public void setMaxRows(int max) throws SQLException {
    setLargeMaxRows(max);
  }

  /** @see Statement#getLargeMaxRows() */
  public long getLargeMaxRows() {
    // checkOpen();
    return rs.maxRows;
  }

  /** @see Statement#setLargeMaxRows(long) */
  public void setLargeMaxRows(long max) throws SQLException {
    // checkOpen();
    if (max < 0) throw new SQLException("max row count must be >= 0");
    rs.maxRows = max;
  }

  /** @see Statement#getMaxFieldSize() */
  public int getMaxFieldSize() {
    return 0;
  }

  /** @see Statement#setMaxFieldSize(int) */
  public void setMaxFieldSize(int max) throws SQLException {
    if (max < 0) throw new SQLException("max field size " + max + " cannot be negative");
  }

  /** @see Statement#getFetchSize() */
  public int getFetchSize() throws SQLException {
    return rs.getFetchSize();
  }

  /** @see Statement#setFetchSize(int) */
  public void setFetchSize(int r) throws SQLException {
    rs.setFetchSize(r);
  }

  protected final <T> T withConnectionTimeout(SQLCallable<T> callable) throws SQLException {
    if (queryTimeout <= 0) {
      return callable.call();
    }

    int origBusyTimeout = conn.getBusyTimeout();
    // SQLite handles busy timeout in milliseconds, JDBC in seconds
    conn.setBusyTimeout(1000 * queryTimeout);
    try {
      return callable.call();
    }
    finally {
      // reset connection timeout to the original value
      conn.setBusyTimeout(origBusyTimeout);
    }
  }

  public DB getDatabase() {
    return conn.getDatabase();
  }

  public SQLiteConnectionConfig getConnectionConfig() {
    return conn.getConnectionConfig();
  }

  /** @throws SQLException If the database is not opened. */
  protected final void checkOpen() throws SQLException {
    if (pointer.isClosed()) {
      throw new SQLException("statement is not executing");
    }
  }

  /**
   * @return True if the database is opened; false otherwise.
   */
  boolean isOpen() {
    return !pointer.isClosed();
  }

  /**
   * Calls sqlite3_step() and sets up results. Expects a clean stmt.
   *
   * @return True if the ResultSet has at least one row; false otherwise.
   * @throws SQLException If the given SQL statement is null or no database is open.
   */
  protected boolean exec() throws SQLException {
    if (sql == null) throw new SQLException("SQLiteJDBC internal error: sql==null");
    if (rs.isOpen()) throw new SQLException("SQLite JDBC internal error: rs.isOpen() on exec.");

    conn.tryEnforceTransactionMode();

    boolean success = false;
    boolean rc = false;
    try {
      rc = conn.getDatabase().execute(this, null, sql);
      success = true;
    }
    finally {
      notifyFirstStatementExecuted();
      resultsWaiting = rc;
      if (!success) {
        pointer.close();
      }
    }

    return pointer.safeRunInt(DB::column_count) != 0;
  }

  /**
   * Executes SQL statement and throws SQLExceptions if the given SQL statement is null or no
   * database is open.
   *
   * @param sql SQL statement.
   * @return True if the ResultSet has at least one row; false otherwise.
   * @throws SQLException If the given SQL statement is null or no database is open.
   */
  protected boolean exec(String sql) throws SQLException {
    if (sql == null) throw new SQLException("SQLiteJDBC internal error: sql==null");
    if (rs.isOpen()) throw new SQLException("SQLite JDBC internal error: rs.isOpen() on exec.");

    conn.tryEnforceTransactionMode();

    boolean rc = false;
    boolean success = false;
    try {
      rc = conn.getDatabase().execute(sql);
      success = true;
    }
    finally {
      notifyFirstStatementExecuted();
      resultsWaiting = rc;
      if (!success && pointer != null) {
        pointer.close();
      }
    }

    return pointer.safeRunInt(DB::column_count) != 0;
  }

  protected void internalClose() throws SQLException {
    if (pointer != null && !pointer.isClosed()) {
      if (conn.isClosed()) {
        throw DB.newSQLException(SQLITE_ERROR, "Connection is closed", null);
      }

      rs.close();

      batch = null;
      batchPos = 0;
      int resp = pointer.close();

      if (resp != SQLITE_OK && resp != SQLITE_MISUSE) {
        conn.getDatabase().throwex(resp);
      }
    }
  }

  protected void notifyFirstStatementExecuted() {
    conn.setFirstStatementExecuted(true);
  }

  @FunctionalInterface
  protected interface SQLCallable<T> {

    T call() throws SQLException;
  }
}
