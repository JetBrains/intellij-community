inspection.diff.format.error=Required parameters: <old_file> <new_file> [<delta_file_name>]
inspection.command.line.explanation=Expected parameters: <project_file_path> <inspection_profile> <output_path> \
  <inspections_profile> -- use here profile name configured in the project or locally or path to the inspection profile; can be stabbed when one of the -e|-profileName|-profilePath is used\n\
  [<options>]\n \
  Available options are:\n \
  -d <directory_path>  --  directory to be inspected. Optional. Whole project is inspected by default.\n \
  -e                   --  skip  \n\
  -v[0|1|2]            --  verbose level. 0 - silent, 1 - verbose, 2 - most verbose. \n\
  -profileName         --  name of a profile defined in project \n \
  -profilePath         --  absolute path to the profile file

inspection.action.title=Inspection
inspection.action.noun=Inspection
inspection.action.profile.label=Inspection profile

inspection.disabled.title=Inspection disabled
inspection.disabled.wrong.id=Inspection ''{0}'' is disabled: ID ''{1}'' not matches ''{2}'' pattern.
inspection.disabled.error=Inspection ''{0}'' is disabled: {1}.

inspection.problem.synopsis=Problem synopsis

#export results view
inspection.export.results.description.tag=description
inspection.export.results.problem.element.tag=problem_class
inspection.export.results.can.be.final.description=Declaration can have final modifier

inspection.export.results.package=package
inspection.export.results.class=class
inspection.export.results.constructor=constructor
inspection.export.results.method=method
inspection.export.results.field=field
inspection.export.results.file=file
inspection.export.results.interface=interface

#can be final
inspection.can.be.final.display.name=Declaration can have final modifier
inspection.can.be.final.accept.quickfix=Make final
inspection.can.be.final.option=Report classes
inspection.can.be.final.option1=Report methods
inspection.can.be.final.option2=Report fields

#dataflow
inspection.data.flow.display.name=Constant conditions \\& exceptions
inspection.contract.display.name=Contract issues
inspection.data.flow.nullable.quickfix.option=Suggest @Nullable annotation for methods/fields/parameters where nullable values are used
inspection.data.flow.true.asserts.option=Don't report assertions with condition statically proven to be always <code>true</code>
inspection.data.flow.turn.off.true.asserts.quickfix=Don't report always true assertions
inspection.data.flow.turn.off.constant.references.quickfix=Don't report values which are guaranteed to be constant
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix=Don't report nullable methods which always return not-null value
inspection.data.flow.redundant.instanceof.quickfix=Replace with a null check
inspection.data.flow.simplify.boolean.expression.quickfix=Simplify boolean expression
inspection.data.flow.simplify.to.assignment.quickfix.name=Simplify to normal assignment
inspection.data.flow.filter.notnull.quickfix=Insert 'filter(Objects::nonNull)' step
inspection.data.flow.use.computeifpresent.quickfix=Replace 'compute' with 'computeIfPresent'
configure.annotations.option=Configure annotations

#messages from dataflow inspection
dataflow.message.npe.method.invocation=Method invocation <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.method.invocation.sure=Method invocation <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction=Inner class construction may produce <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure=Inner class construction will produce <code>NullPointerException</code>
dataflow.message.npe.methodref.invocation=Method reference invocation <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.array.access=Array access <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.npe.array.access.sure=Array access <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.field.access.sure=Dereference of <code>#ref</code> #loc will produce <code>NullPointerException</code>
dataflow.message.npe.field.access=Dereference of <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.cce=Casting <code>{0}</code> to <code>#ref</code> #loc may produce <code>ClassCastException</code>
dataflow.message.arraystore=Storing element of type <code>{0}</code> to array of <code>{1}</code> elements may produce <code>ArrayStoreException</code>
dataflow.message.redundant.instanceof=Condition <code>#ref</code> #loc is redundant and can be replaced with a null check
dataflow.message.contract.fail=The call to '#ref' always fails, according to its method contracts
dataflow.message.contract.fail.index=The call to '#ref' always fails as index is out of bounds
dataflow.message.constant.condition=Condition <code>#ref</code> #loc is always <code>{0}</code>
dataflow.message.constant.condition.when.reached=Condition <code>#ref</code> #loc is always <code>{0}</code> when reached
dataflow.message.unreachable.switch.label=Switch label <code>#ref</code> #loc is unreachable
dataflow.message.only.switch.label=Switch label <code>#ref</code> #loc is the only reachable in the whole switch
dataflow.message.pointless.assignment.expression=Condition <code>#ref</code> #loc at the left side of assignment expression is always <code>{0}</code>. Can be simplified
dataflow.message.passing.null.argument=Passing <code>null</code> argument to parameter annotated as @NotNull
dataflow.message.passing.nullable.argument=Argument <code>#ref</code> #loc might be null
dataflow.message.passing.nullable.argument.methodref=Method reference argument might be null
dataflow.message.passing.null.argument.nonannotated=Passing <code>null</code> argument to non-annotated parameter
dataflow.message.passing.nullable.argument.nonannotated=Argument <code>#ref</code> #loc might be null but passed to non-annotated parameter
dataflow.message.passing.nullable.argument.methodref.nonannotated=Method reference argument might be null but passed to non-annotated parameter
dataflow.message.assigning.null=<code>null</code> is assigned to a variable that is annotated with @NotNull
dataflow.message.assigning.nullable=Expression <code>#ref</code> might evaluate to null but is assigned to a variable that is annotated with @NotNull
dataflow.message.assigning.null.notannotated=Assigning <code>null</code> value to non-annotated field
dataflow.message.assigning.nullable.notannotated=Expression <code>#ref</code> #loc might be null but is assigned to non-annotated field
dataflow.message.storing.array.null=<code>null</code> is stored to an array of @NotNull elements
dataflow.message.storing.array.nullable=Expression <code>#ref</code> might evaluate to null but is stored to an array of @NotNull elements
dataflow.message.return.null.from.notnull=<code>null</code> is returned by the method declared as @{0}
dataflow.message.return.nullable.from.notnull=Expression <code>#ref</code> might evaluate to null but is returned by the method declared as @{0}
dataflow.message.return.null.from.notnullable=<code>null</code> is returned by the method which is not declared as @{0}
dataflow.message.return.nullable.from.notnullable=Expression <code>#ref</code> might evaluate to null but is returned by the method which is not declared as @{0}
dataflow.message.return.nullable.from.notnull.function=Function may return null, but it's not allowed here
dataflow.message.unboxing=Unboxing of <code>#ref</code> #loc may produce <code>NullPointerException</code>
dataflow.message.unboxing.method.reference=Use of <code>#ref</code> #loc would need unboxing which may produce <code>NullPointerException</code>
dataflow.too.complex={0} is too complex to analyze by data flow algorithm
dataflow.not.precise={0} is complex: data flow results could be imprecise
dataflow.method.fails.with.null.argument=Method will throw an exception when parameter is null
dataflow.message.constant.method.reference=Method reference result is always ''{0}''
dataflow.message.array.index.out.of.bounds=Array index is out of bounds
dataflow.message.immutable.modified=Immutable object is modified
dataflow.message.immutable.passed=Immutable object is passed where mutable is expected
dataflow.message.redundant.update=Variable update does nothing
dataflow.message.redundant.assignment=Variable is already assigned to this value
dataflow.message.pointless.same.arguments=Arguments of '#ref' are the same. Calling this method with the same arguments is meaningless.

inspection.optional.get.without.is.present.message=<code>{0}.#ref()</code> without ''isPresent()'' check

#deprecated
inspection.deprecated.display.name=Deprecated API usage
inspection.marked.for.removal.display.name=Usage of API marked for removal
#empty method
inspection.empty.method.display.name=Empty method
inspection.empty.method.delete.quickfix=Delete unnecessary method(s)
inspection.empty.method.problem.descriptor=Method only calls its super
inspection.empty.method.problem.descriptor1=Empty method overrides empty method
inspection.empty.method.problem.descriptor2=The method is empty
inspection.empty.method.problem.descriptor3=The method and all its derivables are empty
inspection.empty.method.problem.descriptor4=All implementations of this method are empty

#redundant cast
inspection.redundant.cast.display.name=Redundant type cast
inspection.redundant.cast.remove.quickfix=Remove redundant cast(s)
inspection.redundant.cast.problem.descriptor=Casting {0} to {1} is redundant

#redundant throws
inspection.redundant.throws.display.name=Redundant 'throws' clause
inspection.redundant.throws.remove.quickfix=Remove unnecessary 'throws' declarations
inspection.redundant.throws.problem.descriptor=The declared exception {0} is never thrown in method implementations
inspection.redundant.throws.problem.descriptor1=The declared exception {0} is never thrown in this method, nor in its derivables
inspection.redundant.throws.problem.descriptor2=The declared exception {0} is never thrown

inspection.equals.hashcode.display.name='equals()' and 'hashCode()' not paired
inspection.equals.hashcode.only.one.defined.problem.descriptor=Class has {0} defined but does not define {1}
inspection.equals.hashcode.generate.equals.quickfix=Generate 'equals()'
inspection.equals.hashcode.generate.hashcode.quickfix=Generate 'hashCode()'

inspection.1.5.display.name=Usages of API which isn't available at the configured language level
inspection.1.5.problem.descriptor=Usage of API documented as @since {0}+
inspection.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
inspection.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
inspection.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}

inspection.local.can.be.final.display.name=Local variable or parameter can be final
inspection.local.can.be.final.option=Report local variables
inspection.local.can.be.final.option1=Report method parameters
inspection.local.can.be.final.option2=Report catch parameters
inspection.local.can.be.final.option3=Report foreach parameters
inspection.local.can.be.final.option4=Report variables which are implicit final
inspection.can.be.local.parameter.problem.descriptor=Parameter <code>#ref</code> can have <code>final</code> modifier
inspection.can.be.local.variable.problem.descriptor=Variable <code>#ref</code> can have <code>final</code> modifier

inspection.return.separated.from.computation.name='return' separated from the result computation
inspection.return.separated.from.computation.descriptor=Return separated from computation of value of ''{0}''
inspection.return.separated.from.computation.quickfix=Move ''return'' closer to computation of the value of ''{0}''
inspection.return.separated.from.computation.family.quickfix=Move 'return' closer to computation of the result

inspection.nullable.problems.display.name=@NotNull/@Nullable problems
#check box options
inspection.nullable.problems.method.overrides.notnull.option=<html>Report @NotNull &parameters overriding @Nullable and <br>@Nullable methods overriding @NotNull</html>
inspection.nullable.problems.method.overrides.option=Report non-&annotated parameters or methods overriding @NotNull
inspection.nullable.problems.not.annotated.getters.for.annotated.fields=Report non-annotated &setter parameters or getters of annotated fields

#problem descriptor messages
inspection.nullable.problems.Nullable.NotNull.conflict=Cannot annotate with both @{0} and @{1}
inspection.nullable.problems.Nullable.method.overrides.NotNull=Method annotated with @{0} must not override @{1} method
inspection.nullable.problems.method.overrides.NotNull=Not annotated method overrides method annotated with @{0}
inspection.nullable.problems.annotated.field.getter.not.annotated=Getter for @{0} field might be annotated @{0} itself
inspection.nullable.problems.annotated.field.getter.conflict=Getter for @{0} field is annotated @{1}
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated=Setter parameter for @{0} field might be annotated @{0} itself
inspection.nullable.problems.annotated.field.setter.parameter.conflict=Setter parameter for @{0} field is annotated @{1}
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated=Constructor parameter for @{0} field might be annotated @{0} itself
inspection.nullable.problems.NotNull.parameter.overrides.Nullable=Parameter annotated @{0} must not override @{1} parameter
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated=Parameter annotated @{0} should not override non-annotated parameter
inspection.nullable.problems.parameter.overrides.NotNull=Not annotated parameter overrides @{0} parameter
inspection.nullable.problems.primitive.type.annotation=Primitive type members cannot be annotated
inspection.nullable.problems.NotNull.parameter.receives.null.literal=Parameter annotated @{0} should not receive ''null'' as an argument

inspection.test.only.problems.display.name=Test-only class or method call in production code
inspection.test.only.problems.test.only.method.call=Test-only method is called in production code
inspection.test.only.problems.test.only.class.reference=Test-only class is referenced in production code
inspection.test.only.problems.test.only.field.reference=Test-only field is referenced in production code

inspection.visibility.display.name=Declaration access can be weaker
inspection.visibility.option.constants=Suggest weaker visibility for constants
inspection.visibility.option.package.private.members=Suggest package-private visibility level for class members
inspection.visibility.package.private.top.level.classes=Suggest package-private visibility level for top-level classes
inspection.visibility.private.inner.members=<html>Suggest private for inner class members when referenced from outer class only</html>

#can be private|package-private|protected|public
inspection.visibility.compose.suggestion=Can be {0}

inspection.visibility.accept.quickfix=Accept suggested access level
inspection.field.can.be.local.display.name=Field can be local
inspection.field.can.be.local.problem.descriptor=Field can be converted to a local variable
inspection.parameter.can.be.local.display.name=Parameter can be local
inspection.parameter.can.be.local.problem.descriptor=Parameter can be converted to a local variable
inspection.convert.to.local.quickfix=Convert to local
inspection.field.can.be.local.quickfix.initializer=Convert field to local variable in initializer section
inspection.field.can.be.local.quickfix.constructor=Convert field to local variable in constructor
inspection.field.can.be.local.quickfix.one.method=Convert field to local variable in method ''{0}''

inspection.unused.return.value.display.name=Method can be void
inspection.unused.return.value.problem.descriptor=Return value of the method is never used
inspection.unused.return.value.make.void.quickfix=Make method 'void'

inspection.same.return.value.display.name=Method returns the same value
inspection.same.return.value.problem.descriptor=Method always returns {0}
inspection.same.return.value.problem.descriptor1=Method and all its derivables always return {0}
inspection.same.return.value.problem.descriptor2=All implementations of this method always return {0}

inspection.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

inspection.same.parameter.display.name=Actual method parameter is the same constant
inspection.same.parameter.problem.descriptor=Actual value of parameter ''{0}'' is always ''{1}''

inspection.unused.assignment.display.name=Unused assignment
inspection.unused.assignment.option=Report ++i when may be replaced with (i + 1)
inspection.unused.assignment.option1=Report i++ when changed value is not used afterwards
inspection.unused.assignment.option2=Report redundant initializers
inspection.unused.assignment.remove.quickfix=Remove redundant initializer
inspection.unused.assignment.remove.assignment.quickfix=Remove redundant assignment
inspection.unused.assignment.problem.descriptor1=Variable {0} is never used
inspection.unused.assignment.problem.descriptor2=Variable {0} initializer {1} is redundant
inspection.unused.assignment.problem.descriptor3=The value {0} assigned to {1} is never used
inspection.unused.assignment.problem.descriptor4=The value changed at {0} is never used

inspection.unused.parameter.composer=Parameter <code>#ref</code> is not used in any implementation
inspection.unused.parameter.composer1=Parameter <code>#ref</code> is not used in either this method or any of its derived methods
inspection.unused.parameter.display.name=Unused method parameters
inspection.unused.parameter.delete.quickfix=Delete unused parameter(s)
inspection.redundant.type.display.name=Redundant type arguments
inspection.redundant.type.remove.quickfix=Remove type arguments
inspection.redundant.type.problem.descriptor=Explicit type arguments can be inferred
inspection.redundant.type.no.generics.problem.descriptor=Type arguments are redundant for the non-generic method call
inspection.redundant.type.no.generics.method.reference.problem.descriptor=Type arguments are redundant for the non-generic method reference

inspection.redundant.array.creation.display.name=Redundant array creation
inspection.redundant.array.creation.quickfix=Remove explicit array creation
inspection.redundant.array.creation.for.varargs.call.descriptor=Redundant array creation for calling varargs method

inspection.suspicious.collections.method.calls.display.name=Suspicious collections method calls
inspection.suspicious.collections.method.calls.problem.descriptor=''{0}'' may not contain {2} of type ''{1}''
inspection.suspicious.collections.method.calls.problem.descriptor1=Suspicious call to ''{0}''

inspection.suspicious.array.method.call.display.name=Suspicious Arrays method calls
inspection.suspicious.array.method.call.problem.element=Element type is not compatible with array type
inspection.suspicious.array.method.call.problem.arrays=Array types are incompatible: arrays are always different

inspection.raw.variable.type.can.be.generic.name=Raw type can be generic
inspection.raw.variable.type.can.be.generic.quickfix=Change type of {0} to {1}
inspection.raw.variable.type.can.be.generic.family.quickfix=Add generic parameters to the type

inspection.reference.invalid=element no longer exists
inspection.reference.default.package=<default>
inspection.reference.implicit.constructor.name=implicit constructor of {0}
inspection.reference.anonymous.name=anonymous ({0})
inspection.reference.jsp.holder.method.anonymous.name=<% page content %>
inspection.reference.anonymous=anonymous
inspection.export.save.button=Save
inspection.export.dialog.title=Export
inspection.export.options.panel.title=Options
inspection.export.open.option=Open generated HTML in &browser
inspection.export.title=Code Inspection results
inspection.export.generating.html.for=Generating HTML:{0}
inspection.export.error.writing.to=Error writing to {0}: {1}

inspection.common.if.parts.family=Extract common parts of 'if' statement
inspection.common.if.parts.family.else.if=Merge 'else if' statement
inspection.common.if.parts.family.else.if.description='else if' can be merged
inspection.common.if.parts.message.variables.only=Extract variables from ''if''{0}
inspection.common.if.parts.message.with.variables.extract=Extract common part with variables from ''if''{0}
inspection.common.if.parts.message.without.variables.extract=Extract common part from ''if''{0}
inspection.common.if.parts.message.whole.branch=Extract common part removing branch{0}
inspection.common.if.parts.message.complete.duplicate=Collapse ''if'' statement{0}
inspection.common.if.parts.message.complete.duplicate.side.effect=Collapse 'if' statement and extract side effect

inspection.common.if.parts.description.variables.only=Variables can be extracted from ''if''{0}
inspection.common.if.parts.description.with.variables.extract=Common parts with variables can be extracted from ''if''{0}
inspection.common.if.parts.description.without.variables.extract=Common part can be extracted from ''if''{0}
inspection.common.if.parts.description.whole.branch=Common part can be extracted removing branch{0}
inspection.common.if.parts.description.complete.duplicate=''if'' statement can be collapsed{0}
inspection.common.if.parts.description.complete.duplicate.side.effect='if' statement can be collapsed with side effect extraction


inspection.common.if.parts.description='if' statement with common parts

inspection.export.results.error.title=Inspection Results Export
inspection.export.inspections.link.text=Inspections
inspection.export.open.source.link.text=Open source
inspection.offline.view.empty.browser.text=<HTML><BODY>Select inspection result on the left to see details</BODY></HTML>
inspection.offline.view.tool.display.name.title=Name
inspection.generating.html.progress.title=Generating HTML...
inspection.generating.xml.progress.title=Dumping XML...
inspection.action.export.html=Export
inspection.action.export.popup.title=Export To
inspection.tool.description.under.construction.text=Under construction
inspection.tool.in.browser.id.title=ID
inspection.tool.in.browser.description.title=Description
inspection.action.edit.settings=Edit Settings
inspection.action.apply.quickfix=Apply a quickfix
inspection.action.apply.quickfix.description=Apply an inspection quickfix
inspection.tree.popup.title=Accept Resolution
inspection.action.rerun=Rerun Inspection
inspection.general.tools.group.name=General
inspection.invalid.node.text=(INVALID)
inspection.problem.descriptor.count={0, choice, 0#|1#(1 item)|2#({0,number,integer} items)}
inspection.action.go.next=Go Next Problem
inspection.action.go.prev=Go Prev Problem
inspection.action.suppress=Suppressing inspection ''{0}''
inspection.action.group.by.directory=Group by Directory

inspection.javadoc.display.name=Declaration has Javadoc problems
inspection.javadoc.ref.display.name=Declaration has problems in Javadoc references
inspection.javadoc.lint.display.name=HTML problems in Javadoc (DocLint)
inspection.javadoc.option.tab.title.package=Package
inspection.javadoc.option.tab.title.module=Module
inspection.javadoc.option.tab.title=Class
inspection.javadoc.option.tab.title.method=Method
inspection.javadoc.option.tab.title.field=Field
inspection.javadoc.option.tab.title.inner.class=Inner class
inspection.javadoc.option.ignore.deprecated=Ignore elements marked as @deprecated
inspection.javadoc.option.ignore.period=Ignore period problems
inspection.javadoc.option.ignore.throws=Ignore duplicate 'throws' tag
inspection.javadoc.option.ignore.self.ref=Ignore Javadoc pointing to itself
inspection.javadoc.option.ignore.simple=Ignore simple property accessors

inspection.scope.for.title=Scope

inspection.javadoc.required.tags.option.title=Required Tags
inspection.javadoc.problem.descriptor=Required Javadoc is absent
inspection.javadoc.problem.descriptor1=Period in the documentation is missing. The period is used by the Javadoc tool to generate the comment for the overview page
inspection.javadoc.problem.missing.tag=Required tag {0} is missing
inspection.javadoc.problem.missing.tag.description={0} is missing after @{1} tag
inspection.javadoc.problem.see.tag.expecting.ref=Class/method reference, quoted text, or HTML link are expected after @see tag
inspection.javadoc.problem.cannot.resolve=Cannot resolve symbol {0}
inspection.javadoc.problem.inaccessible=Symbol {0} is inaccessible from here
inspection.javadoc.problem.name.expected=Name expected
inspection.javadoc.problem.wrong.tag=Wrong tag {0}
inspection.javadoc.problem.disallowed.tag=Tag {0} is not allowed here
inspection.javadoc.method.problem.descriptor=Description is missing in {0} tag for parameter {1}
inspection.javadoc.method.problem.missing.tag.description={0} tag description is missing
inspection.javadoc.method.problem.missing.param.tag=Required tag <code>@param</code> is missing for parameter {0}
inspection.javadoc.problem.duplicate.param=Duplicate @param tag for parameter ''{0}''
inspection.javadoc.problem.duplicate.throws=Duplicate @throws or @exception tag for exception ''{0}''
inspection.javadoc.problem.duplicate.tag=Duplicate @{0} tag
inspection.javadoc.problem.add.tag=Add tag @{0} {1}
inspection.javadoc.problem.add.tag.family=Add missing Javadoc tag
inspection.javadoc.problem.add.param.tag.family=Add missing Javadoc param tag
inspection.javadoc.problem.add.param.tag=Add tag @param for parameter ''{0}''

inspection.export.results.abstract=abstract
inspection.export.results.static=static
inspection.export.results.capitalized.class=Class
inspection.export.results.initializer=initializer
inspection.export.results.capitalized.interface=Interface
inspection.export.results.capitalized.abstract.class=Abstract\\&nbsp;class
inspection.export.results.abstract.class=abstract\\&nbsp;class
inspection.export.results.implicit.constructor=implicit constructor of

inspection.problem.resolution=Problem resolution
inspection.quickfix.assert.family=Assert
inspection.assert.quickfix=Assert ''{0}''
inspection.surround.if.quickfix=Surround with ''if ({0} != null)''
inspection.replace.ternary.quickfix=Replace with ''{0} != null ?:''
inspection.replace.methodref.ternary.quickfix=Replace with null-checking lambda
inspection.surround.if.family=Surround with if
inspection.dependency.configure.button.text=Configure dependency rules
inspection.surround.requirenonnull.quickfix=Replace with ''Objects.requireNonNull({0})''

inspection.javadoc.label.text=Additional Javadoc Tags:
inspection.javadoc.dialog.title=Edit Additional Javadoc Tags
inspection.javadoc.html.not.required.label.text=Additional Not Required Html Attributes:
inspection.javadoc.html.not.required.dialog.title=Edit Additional Not Required Html Attributes
inspection.required.attributes.display.name=Missing required attribute

inspection.unused.symbol.check.localvars=Local variables
inspection.unused.symbol.check.fields=Fields:
inspection.unused.symbol.check.methods=Methods:
inspection.unused.symbol.check.accessors=Getters/setters
inspection.unused.symbol.check.classes=Classes:
inspection.unused.symbol.check.inner.classes=Inner classes:
inspection.unused.symbol.check.parameters=Parameters in

inspection.results.for.profile.toolwindow.title=''{0}'' Profile on {1}
inspection.results.for.inspection.toolwindow.title=''{0}'' Inspection on {1}
inspection.export.results.invalidated.item=invalidated item
inspection.export.results.at.line=at line

inspection.export.results.capitalized.location=Location
inspection.export.results.extends.implements=Extends/implements
inspection.export.results.extended.implemented=Extended/implemented by
inspection.export.results.extended=Extended by
inspection.export.results.overrides.library.methods=Overrides library methods
inspection.export.results.overrides.implements=Overrides/implements
inspection.export.results.derived.methods=Derived methods
inspection.export.results.type.references=The following uses this type
inspection.export.results.used.from=Used from
inspection.export.results.uses=Uses the following
inspection.export.results.no.problems.found=No problems found
inspection.export.results.suppress=Suppress
inspection.export.results.callees=Call chain
inspection.export.results.anonymous.ref.in.owner=in

inspection.processing.job.descriptor=Processing project usages in
inspection.processing.job.descriptor1=Processing external usages of
inspection.processing.job.descriptor2=Analyzing code in

inspection.display.name=Analyzing code ...

inspection.action.group.by.severity=Group by Severity
inspection.action.group.by.severity.description=Group Inspections By Severity
inspection.no.jdk.error.message=The JDK is not configured properly for this project. Inspection cannot proceed.
inspection.progress.title=Inspecting Code...
inspection.no.problems.dialog.title=Code Inspection
inspection.no.problems.message=No suspicious code found. {0} files processed in ''{1}''.
inspection.view.invalid.scope.message=Inspection scope is invalid.
inspection.error.loading.message=Error reading inspection profile {0, choice, 0#from {1}|1#}
inspection.errors.occurred.dialog.title=Errors Occurred
inspection.severity=Se&verity:
inspection.scopes.and.severities=Severity by Scope
inspection.description.title=Description
inspection.as=As {0}
inspection.new.profile.dialog.title=Create new profile
inspection.unable.to.create.profile.dialog.title=Unable to Create Profile.
inspection.unable.to.create.profile.message=Inspection profile with name ''{0}'' already exists.
inspection.profile.unnamed=Unnamed
inspection.tool.availability.in.tree.node=(available for editor highlighting)
inspection.tool.availability.in.tree.node1=(available for Analyze|Inspect Code)
inspection.error.level.popup.menu.title=Choose Error Level
inspection.edit.severities.text=Edit severities...

inspection.application.starting.up=Starting up {0} ...
inspection.done=done.
inspection.capitalized.done=Done.
inspection.application.file.cannot.be.found=File {0} cannot be found
inspection.application.opening.project=Opening project...
inspection.application.initializing.project=Initializing project...
inspection.application.directory.cannot.be.found=Directory {0} cannot be found
inspection.application.project.has.older.format.and.will.be.converted=Project has an older format and will be converted.
inspection.application.project.was.succesfully.converted.old.project.files.were.saved.to.0=Project was succesfully converted. Old project files were saved to {0}
inspection.application.cannot.convert.project.0=Cannot convert project: {0}
inspection.application.cannot.convert.the.project.the.following.files.are.read.only.0=Cannot convert the project. The following files are read only: {0}

inspection.comparing.references.display.name=== used instead of equals()
inspection.comparing.references.use.quickfix=Use equals()
inspection.comparing.references.problem.descriptor=Suspicious comparison #ref #loc

inspection.dead.code.display.name=Unused declaration
inspection.dead.code.option.main=<html><code>void main(String args[])</code> methods</html>
inspection.dead.code.option.applet=Applets
inspection.dead.code.option.servlet=Servlets
inspection.dead.code.option.external=Classes with usages in non-Java files
inspection.export.results.dead.code=unused declaration
inspection.dead.code.comment=// --Commented out by Inspection
inspection.dead.code.date.comment=// --Commented out by Inspection ({0}):
inspection.dead.code.stop.comment=// --Commented out by Inspection STOP ({0})\n
inspection.dead.code.start.comment=// --Commented out by Inspection START ({0}):\n
inspection.dead.code.safe.delete.quickfix=Safe delete
inspection.dead.code.comment.quickfix=Comment out
inspection.dead.code.entry.point.quickfix=Add as Entry Point
inspection.dead.code.remove.user.defined.entry.point.quickfix=Remove User Defined Entry Points
inspection.dead.code.entry.points.display.name=Entry Points
inspection.dead.code.export.results.no.instantiations.found=No instantiations found.
inspection.dead.code.export.results.instantiated.from.heading=Instantiated from
inspection.dead.code.problem.synopsis=Field is never assigned.
inspection.dead.code.problem.synopsis1=Field has no usages.
inspection.dead.code.problem.synopsis2=Field is assigned but never accessed.
inspection.dead.code.problem.synopsis3=Field has one usage but it is not reachable from entry points.
inspection.dead.code.problem.synopsis4=Field has {0, choice, 1#1 usage|2#{0,number} usages} but they are not reachable from entry points.
inspection.dead.code.problem.synopsis6=Reachable. {0, choice, 1#1 usage|2#{0, number} usages} found in the project code.
inspection.dead.code.problem.synopsis6.suspicious=Not Reachable. {0, choice, 1#1 usage|2#{0, number} usages} found in the project code.
inspection.dead.code.problem.synopsis7.suspicious=Has no reachable instantiations. {0, choice, 0#No instantiations|1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis8.suspicious=Has no reachable implementation instantiations. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis9.suspicious=Anonymous class context is not reachable. Class is not instantiated. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis7=Has reachable instantiations. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis8=Has reachable implementation instantiations. {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis9=Instantiated {0, choice, 1#1 instantiation|2#{0, number} instantiations} found in the project code.
inspection.dead.code.problem.synopsis10=Anonymous class declaration context is not reachable from entry points. Class is never instantiated.
inspection.dead.code.problem.synopsis11=No class references has been found. Class static initializer is not reachable.
inspection.dead.code.problem.synopsis12=Class has one instantiation but it is not reachable from entry points.
inspection.dead.code.problem.synopsis13=Class is not instantiated.
inspection.dead.code.problem.synopsis14=<ul><li>Abstract method is not implemented OR</li><li>Implementation class is never instantiated OR</li><li>An instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis15=<ul><li>Method owner class is never instantiated OR</li><li>An instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis16=Method is never used.
inspection.dead.code.problem.synopsis17=Method has usage(s) but they all belong to calls chain that has no members reachable from entry points.
inspection.dead.code.problem.synopsis18=Method is not reachable from entry points.
inspection.dead.code.problem.synopsis19=Neither the class nor {0, choice, 1#its implementation|2#{0,number} its implementations} are ever instantiated.
inspection.dead.code.problem.synopsis20=Class has {0, choice, 1#instantiation|2#{0,number} instantiations} but they are not reachable from entry points.

#{0} is class or interface (translated)
inspection.dead.code.problem.synopsis21=Method is never used as a member of this {0}, but only as a member of the implementation class(es). The project will stay compilable if the method is removed from the {0}.
inspection.dead.code.problem.synopsis22=Method overrides a library method but<ul><li>its {0} is never instantiated OR</li><li>its {0} instantiation is not reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis23={0} is not implemented.
inspection.dead.code.problem.synopsis24={0} has an implementation but <ul><li>it is never instantiated OR</li><li>no instantiations are reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis25={0} has {1, choice, 1#direct or indirect implementation|2#{1,number} direct or indirect implementations} but <ul><li>\u2014they are never instantiated OR</li><li>\u2014no instantiations are reachable from entry points.</li></ul>
inspection.dead.code.problem.synopsis26.constructor=Constructor is never used.
inspection.dead.code.problem.synopsis27.constructor=Constructor has usage(s) but they all belong to calls chain that has no members reachable from entry points.
inspection.dead.code.problem.synopsis28.constructor=Constructor has one usage but it is not reachable from entry points.
inspection.dead.code.problem.synopsis29.constructor=Constructor has {0, choice, 1#usage|2#{0,number} usages} but they are not reachable from entry points.

inspection.dead.code.problem.synopsis26.method=Method is never used.
inspection.dead.code.problem.synopsis27.method=Method has usage(s) but they all belong to calls chain that has no members reachable from entry points.
inspection.dead.code.problem.synopsis28.method=Method has one usage but it is not reachable from entry points.
inspection.dead.code.problem.synopsis29.method=Method has {0, choice, 1#usage|2#{0,number} usages} but they are not reachable from entry points.
inspections.dead.code.entry.points.annotations.list.title=Additional entry points annotations

inspection.duplicates.display.name=Duplicate string literal
inspection.duplicates.replace.family.quickfix=Replace
inspection.duplicates.replace.quickfix=Replace with ''{0}''
inspection.duplicates.navigate.to.occurrences=Navigate to occurrences
inspection.duplicates.option=&Min string length:
inspection.duplicates.occurrences.view.title=Duplicates for ''{0}''

inspection.duplicates.message.in.this.file=(in this file)
inspection.duplicates.message.more=... ({0} more)
inspection.duplicates.message=<html><body>Duplicate string literal found in<br>{0}</body></html>

inspection.compiler.javac.quirks.name=Javac quirks
inspection.compiler.javac.quirks.anno.array.comma.problem=Trailing comma in annotation array initializer may cause compilation error in some Javac versions (e.g. JDK 5 and JDK 6).
inspection.compiler.javac.quirks.anno.array.comma.fix=Remove trailing comma
inspection.compiler.javac.quirks.qualifier.type.args.problem=Generics in qualifier reference may cause compilation error in some Javac versions (e.g. JDK 5 and JDK 6).
inspection.compiler.javac.quirks.qualifier.type.args.fix=Remove generic parameter

inspection.redundant.requires.statement.name=Redundant 'requires' directive in module-info
inspection.redundant.requires.statement.description=Redundant directive ''requires {0}''
inspection.redundant.requires.statement.fix.family=Delete redundant 'requires' directive
inspection.redundant.requires.statement.fix.name=Delete directive ''requires {0}''

inspection.root.node.title=Inspections

# inspection tools list actions:
inspection.tools.action.show.global.inspections.text=Hide Global Inspections
inspection.tools.action.show.global.inspections.description=Hide Global Inspections Settings
# hardcoded inspection tools
deprecated.symbol=Deprecated symbol
unused.import=Unused import (editor light)
unused.import.statement=Unused import statement
unused.symbol=Unused symbol
redundant.throws.declaration=Redundant throws declaration
access.static.via.instance=Access static member via instance reference
wrong.package.statement=Wrong package statement
illegal.package.dependencies=Illegal package dependencies
unchecked.warning=Unchecked warning

# suppression stuff
suppress.all.for.class=Suppress all inspections for class
suppress.inspection.family=Suppress inspection
suppress.inspection.statement=Suppress for statement
suppress.inspection.module=Suppress for module declaration
suppress.inspection.class=Suppress for class
suppress.inspection.field=Suppress for field
suppress.inspection.method=Suppress for method
suppress.inspection.member=Suppress for member
inspection.options.action.text=Inspection ''{0}'' options
edit.dependency.rules.family=Edit dependency rules
edit.dependency.rules.text=Edit dependency rule \"{0} \"
error.analysis.is.in.progress=Error analysis is in progress
no.errors.found.in.this.file=No errors found in this file
edit.options.of.reporter.inspection.family=Edit options of reporter inspection
edit.options.of.reporter.inspection.text=Edit inspection profile setting

#Inspection group names
group.names.abstraction.issues=Abstraction issues
group.names.assignment.issues=Assignment issues
group.names.probable.bugs=Probable bugs
group.names.bitwise.operation.issues=Bitwise operation issues
group.names.class.structure=Class structure
group.names.class.metrics=Class metrics
group.names.compiler.issues=Compiler issues
group.names.potentially.confusing.code.constructs=Potentially confusing code constructs
group.names.encapsulation.issues=Encapsulation
group.names.error.handling=Error handling
group.names.logging.issues=Logging
group.names.finalization.issues=Finalization
group.names.imports=Imports
group.names.initialization.issues=Initialization
group.names.internationalization.issues=Internationalization
group.names.junit.issues=JUnit
group.names.code.maturity.issues=Code maturity
group.names.method.metrics=Method metrics
group.names.naming.conventions=Naming conventions
group.names.performance.issues=Performance
group.names.memory.issues=Memory
group.names.java.language.level.issues=Java language level issues
group.names.portability.issues=Portability
group.names.security.issues=Security
group.names.serialization.issues=Serialization issues
group.names.code.style.issues=Code style issues
group.names.threading.issues=Threading issues
group.names.verbose.or.redundant.code.constructs=Verbose or redundant code constructs
group.names.visibility.issues=Visibility
group.names.cloning.issues=Cloning issues
group.names.resource.management.issues=Resource management
group.names.j2me.issues=J2ME issues
group.names.control.flow.issues=Control flow issues
group.names.numeric.issues=Numeric issues
group.names.language.level.specific.issues.and.migration.aids=Java language level migration aids
group.names.language.level.specific.issues.and.migration.aids7=Java 7
group.names.language.level.specific.issues.and.migration.aids8=Java 8
group.names.language.level.specific.issues.and.migration.aids9=Java 9
group.names.language.level.specific.issues.and.migration.aids5=Java 5
group.names.language.level.specific.issues.and.migration.aids10=Java 10
group.names.language.level.specific.issues.and.migration.aids11=Java 11
group.names.language.level.specific.issues.and.migration.aids12=Java 12
group.names.javabeans.issues=JavaBeans issues
group.names.inheritance.issues=Inheritance issues
group.names.data.flow.issues=Data flow
group.names.declaration.redundancy=Declaration redundancy
group.names.javadoc.issues=Javadoc
group.names.concurrency.annotation.issues=Concurrency annotation issues
group.names.javaee.issues=Java EE
group.names.properties.files=Properties Files
group.names.xml=XML
group.names.toString.issues=toString() issues
group.names.reflective.access.issues=Reflective access

duplicate.property.display.name=Duplicate Property
duplicate.property.diff.key.problem.descriptor=Duplicate Property Key ''{0}'' With Different Values #treeend :<br>
duplicate.property.diff.key.progress.indicator.text=Processing duplicate property key: {0}
duplicate.property.key.problem.descriptor=Duplicate Property Key ''{0}'' #treeend With Values:<br>
duplicate.property.key.progress.indicator.text=Processing duplicate property key:{0}
duplicate.property.value.problem.descriptor=Duplicate Property Value ''{0}'' #treeend With Keys:<br>
duplicate.property.value.progress.indicator.text=Processing duplicate property value: {0}
duplicate.property.diff.key.option=&Duplicate keys with different values
duplicate.property.value.option=Duplicate &values
duplicate.property.key.option=Duplicate &keys
duplicate.property.file.scope.option=&File scope
duplicate.property.module.scope.option=&Module Scope
duplicate.property.project.scope.option=&Project Scope
inspection.javadoc.throws.or.exception.option=@throws or @exception

suppress.inspection.annotation.syntax.error=Incorrect annotation syntax: {0}

default.file.template.report.file.header=Report Default file header
default.file.template.report.method.body=Report default created/overridden/implemented method body
default.file.template.report.catch.section=Report default catch section
default.file.template.description=Default File template
default.file.template.display.name=Default File Template Usage
default.file.template.edit.template=Edit template...
default.file.template.replace.with.actual.file.template=Replace with actual file template

#profile stuff
profile.assignments.display.name=Errors
profile.mapping.inspection.profile.column.title=inspection profile
profile.mapping.scope.column.title=scope
boolean.method.is.always.inverted.display.name=Boolean method is always inverted
boolean.method.is.always.inverted.problem.descriptor=Boolean method <code>#ref</code> is always inverted
inspection.results.title=Results By Editor Settings
unnecessary.module.dependency.display.name=Unnecessary module dependency
unnecessary.module.dependency.problem.descriptor=Module ''{0}'' sources do not depend on module ''{1}'' sources
unnecessary.module.dependency.exported.problem.descriptor1=Module ''{0}'' does not depend on ''{1}''. Though ''{0}'' depends on ''{2}'' through exported dependencies of ''{1}''
suspected.module.dependency.problem.descriptor=Module ''{0}'' does not depend on module ''{1}''. Though ''{1}'' was not inspected for exported dependencies needed for scope ''{2}''
run.with.editor.settings.dialog.option=Run with &editor settings
inspection.new.profile.text=New Profile Name
profile.save.as.project.checkbox.title=Save as project profile
profile.save.as.ide.checkbox.title=Save as IDE profile
profile.assignment.repeatable.scope.warning=Repeatable scope. Correct assignments.
profile.ide.profile.radiobutton.title=IDE Profile
profile.project.radiobutton.title=Project Profile
profile.default.profile.title=Default Project Profile
profile.assignments.table.title=Project Inspection Profile Assignments
profile.assignments.browse.scope.button.title=&Browse ...
profile.assignments.browse.profile.scopes.dialog.title=Profiles Scopes
profile.quick.change.suggestion.message=<html>There are a few scopes configured for the project. Do you want to edit profile assignments on them?</html>
profile.quick.change.suggestion.dialog.title=Unable to switch profile
unhandled.exception.in.jsp.name=Unhandled Exception in JSP
inspection.no.modules.error.message=This project contains no modules. Inspection cannot proceed.
inspection.redundant.suppression.name=Redundant suppression
inspection.redundant.suppression.description=Redundant suppression
run.with.choosen.profile.dialog.option=Run with &chosen profile
disable.inspection.action.name=Disable inspection
group.names.packaging.issues=Packaging issues
group.names.dependency.issues=Dependency issues
group.names.modularization.issues=Modularization issues
run.inspection.on.file.intention.text=Run inspection on ...
severities.editor.dialog.title=Severities Editor
highlight.severity.create.dialog.title=New Highlight Severity
highlight.severity.create.dialog.name.label=Name
suspicious.name.combination.display.name=Suspicious variable/parameter name combination
suspicious.name.combination.options.title=Groups of names
suspicious.name.combination.options.prompt=Enter a comma-separated list of names:
suspicious.name.combination.add.titile=Add Group of Names
suspicious.name.combination.edit.title=Edit Group of Names

special.annotations.list.add.annotation.class=Add Annotation Class
special.annotations.list.annotation.class=Annotation Class
special.annotations.list.remove.annotation.class=Remove Annotation Class
dependency.injection.annotations.list=Additional Dependency Injection Annotations
special.annotations.annotations.list=Additional Special Annotations

inspection.filter.resolved.action.text=Filter resolved items
inspection.filter.show.diff.action.text=Show diff
inspection.duplicate.throws.display.name=Duplicate throws
inspection.duplicate.throws.problem=Duplicate throws
inspection.duplicate.throws.more.general.problem=There is a more general exception, ''{0}'', in the throws list already.
inspection.duplicate.throws.ignore.subclassing.option=Ignore exceptions subclassing others
inspection.filter.show.diff.only.action.text=Show diff only
inspection.new.profile.ide.to.project.warning.message=Do you want to save selected IDE profile as project profile?
inspection.new.profile.ide.to.project.warning.title=Unable to set up IDE profile for scope
profile.project.settings.banner=Project Profiles Settings
profile.project.display.name=Project Profiles
profile.banner.text=Inspection profile: {0} {1, choice, 0#(inactive)|1#}
profile.ide.tree.text=IDE Profiles
profile.ide.settings.banner=IDE Profiles Settings
profile.project.settings.disable.text=< Use IDE Profile >
errors.single.profile.title=Errors: ''{0}'' inspection profile
rename.inspection.profile=Rename inspection profile
rename.message.prefix.inspection.profile=Inspection profile
default.ide.profile.label.text=Default IDE profile:
profile.lock.action.text=Lock
profile.unlock.action.text=Unlock
profile.activate.action.text=Set as project default
profile.project.activate.action.text=Set as IDE default
inspection.annotate.quickfix.overridden.method.messages=Method {0} {1} method {2}.\nAnnotate the base method as well?
inspection.annotate.quickfix.overridden.method.warning=Overridden Method Warning
inspection.annotate.quickfix.implements=implements
inspection.annotate.quickfix.overrides=overrides
offline.inspections.jdk.not.found={0} not found
offline.inspections.module.jdk.not.found=Please, specify sdk ''{0}'' for module ''{1}''
inconsistent.resource.bundle.display.name=Inconsistent Resource Bundle
inconsistent.bundle.property.error=Inconsistent property ''{0}''. Must be defined in the parent file ''{1}''.
inconsistent.bundle.untranslated.property.error=Untranslated property ''{0}''. Should be overridden in the ''{1}''.
inconsistent.bundle.report.missing.translations=Report &missing translations
inconsistent.bundle.report.inconsistent.properties=Report &inconsistent properties
inconsistent.bundle.report.duplicate.properties.values=Report properties &overridden with the same value
inconsistent.bundle.report.inconsistent.properties.placeholders=Report properties with inconsistent &placeholders
inconsistent.bundle.report.inconsistent.properties.ends=Report properties with inconsistent &ends
inconsistent.bundle.property.inconsistent.placeholders=Inconsistent count of placeholders: found {0} in ''{1}''
inconsistent.bundle.property.inconsistent.end.parent.end.from.check.symbols=Inconsistent property value end ''{0}'' but found ''{1}'' in ''{2}''
inconsistent.bundle.property.inconsistent.end=Inconsistent property value end ''{0}''
inconsistent.bundle.property.inherited.with.the.same.value=Property inherited from the ''{0}'' file with the same value
edit.inspection.options=Edit ''{0}'' Options
offline.view.title=Offline View
offline.view.editor.settings.title=Editor Settings
offline.view.parse.exception.title=An Error Occurred While Parsing XML
parsing.inspections.dump.progress.title=Parsing Inspections XML Dump

suppress.inspection.problem=Suppress
inspections.view.options.title=Inspection {0} options
xml.suppressable.for.tag.title=Suppress for tag
xml.suppressable.for.file.title=Suppress for file
xml.suppressable.all.for.file.title=Suppress all for file
nullable.stuff.problems.overridden.methods.are.not.annotated=Overridden methods are not annotated
nullable.stuff.problems.overridden.method.parameters.are.not.annotated=Overridden method parameters are not annotated
annotate.overridden.methods.parameters=Annotate overridden method parameters as ''@{0}''
annotate.overridden.methods.parameters.family.name=Annotate overridden method parameters
offline.inspections.library.was.not.resolved=Please configure library ''{0}'' which is used in module ''{1}''
offline.inspections.library.urls.were.not.resolved=Roots {0} of the library ''{1}'' from module ''{2}'' were not resolved
report.suspicious.but.possibly.correct.method.calls=&Report suspicious but possibly correct method calls
unused.library.display.name=Unused library
unused.library.problem.descriptor=Unused library ''{0}''
unused.library.roots.problem.descriptor=Unused roots {0} from library ''{1}''
unused.library.backward.analysis.job.description=Perform backward analysis
inspection.duplicates.option.report.propertykey.expressions=&Ignore @PropertyKey expressions
inspection.same.parameter.fix.name=Inline value ''{1}'' for parameter ''{0}''
inspection.same.parameter.fix.family.name=Inline parameter as constant value
fix.all.inspection.problems.in.file=Fix all ''{0}'' problems in file
cleanup.in.file=Cleanup code
cleanup.in.scope=Cleanup code on...
severities.default.settings.message=Edit Settings|Colors \\& Fonts
unsupported.character.for.the.charset=Unsupported characters for the charset ''{0}''
lossy.encoding=Lossy encoding
non.ascii.characters=Non-ASCII characters
inspection.duplicated.code.display.name=Duplicated Code
inconsistent.line.separators=Inconsistent line separators
inspection.unused.symbol.public.method.parameters=Check parameters in &Non-private methods
introduce.constant.across.the.project=Introduce constant across the project
inspection.application.chosen.profile.log.message=Inspecting with profile ''{0}''
detach.library.quickfix.name=Detach library
detach.library.roots.quickfix.name=Detach unused library roots
inspection.javadoc.problem.pointing.to.itself=Javadoc pointing to itself

inspection.illegal.character=Illegal character

inspection.redirect.template=<html><body>Injected element has problem: {0} (in <a href=\"#navigation/{1}:{2}\">{3}</a>). </body></html>
nothing.found=Nothing found
special.annotations.list.annotation.pattern=Add Annotations Pattern

inspection.variable.assigned.to.itself.display.name=Variable is assigned to itself
assignment.to.itself.problem.descriptor=Variable ''{0}'' is assigned to itself
assignment.to.declared.variable.problem.descriptor=Variable ''{0}'' is initialized with self assignment
assignment.to.itself.quickfix.name=Remove self assignment

problematic.whitespace.display.name=Problematic whitespace
problematic.whitespace.tabs.problem.descriptor=File ''{0}'' uses tabs for indentation
problematic.whitespace.spaces.problem.descriptor=File ''{0}'' uses spaces for indentation
problematic.whitespace.show.whitespaces.quickfix=Toggle show whitespace in the editor

todo.comment.display.name=TODO comment
todo.comment.problem.descriptor=TODO comment <code>#ref</code> #loc
long.line.display.name=Line is longer than allowed by code style

inspection.default.annotation.param=Default annotation parameter value
preparing.for.apply.fix=Preparing to Apply Fix...
inspection.annotate.method.quickfix.family.name=Annotate method
inspection.annotate.overridden.method.quickfix.family.name=Annotate overridden methods
inspection.annotate.overridden.method.and.self.quickfix.family.name=Annotate overridden methods and self

inspection.tool.window.dialog.title=Inspection Tool Window
inspection.tool.window.dialog.no.options=Inspection ''{0}'' has no configurable options
inspection.tool.window.inspection.dialog.title=Inspection ''{0}'' options
nullable.stuff.inspection.navigate.null.argument.usages.fix.family.name=Navigate to 'null' argument usages
nullable.stuff.inspection.navigate.null.argument.usages.view.name=''null'' argument usages for parameter {0}

inspection.excessive.lambda.message=Excessive lambda usage
inspection.excessive.lambda.fix.family.name=Replace lambda with constant
inspection.excessive.lambda.fix.name=Use ''{0}'' method without lambda

inspection.explicit.argument.can.be.lambda.message=Explicit argument can be converted to function
inspection.explicit.argument.can.be.lambda.fix.family.name=Replace explicit argument with function
inspection.explicit.argument.can.be.lambda.fix.name=Use ''{0}'' method with functional argument

inspection.lambda.to.method.call.message=Can be replaced with ''{0}''
inspection.lambda.to.method.call.fix.family.name=Replace lambda expression with method call
inspection.lambda.to.method.call.fix.name=Replace lambda expression with ''{0}''

inspection.module.exports.package.to.itself=Module exports/opens package to itself
exports.to.itself.delete.statement.fix=Delete directive
exports.to.itself.delete.module.ref.fix=Delete reference to module ''{0}''

inspection.requires.auto.module=Dependencies on automatic modules
inspection.requires.auto.module.message='requires' directive for an automatic module
inspection.requires.auto.module.transitive='requires transitive' directive for an automatic module
inspection.requires.auto.module.option=Highlight only transitive dependencies

naming.convention.problem.descriptor.short={0} name <code>#ref</code> is too short ({1} \\&lt; {2}) #loc
naming.convention.problem.descriptor.long={0} name <code>#ref</code> is too long ({1} \\&gt; {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} name <code>#ref</code> doesn''t match regex ''{1}'' #loc

inspection.java.module.naming=Java module naming conventions
inspection.java.module.naming.terminal.digits=Module name component ''{0}'' should avoid terminal digits

inspection.replace.with.bulk.message=Iteration can be replaced with bulk ''{0}'' call
inspection.replace.with.bulk.fix.name=Replace iteration with bulk ''{0}'' call
inspection.replace.with.bulk.fix.family.name=Replace with bulk method call
inspection.replace.with.bulk.wrap.arrays=Use Arrays.asList() to wrap arrays
inspection.explicit.array.filling.fix.family.name=Replace loop with ''Arrays.{0}()'' method call
inspection.explicit.array.filling.description=Can be replaced with single ''Arrays.{0}()'' method call
inspection.explicit.array.filling.suggest.set.all=Suggest 'Arrays.setAll()'
inspection.explicit.array.filling.no.suggestion.for.set.all=Do not suggest to use 'Arrays.setAll()'

inspection.simplify.collector.message=Can be simplified using ''{0}'' collector
inspection.simplify.collector.fix.family.name=Simplify cascaded collector
inspection.simplify.collector.fix.name=Use ''Collectors.{0}'' collector

inspection.require.non.null=Replace null check with Objects/Stream static call
inspection.require.non.null.message=Replace condition with {0}
inspection.require.non.null.description=Null check can be replaced with method call
inspection.require.non.null.no.warning.replacement.bigger=Don't warn if length of replacement bigger than original
inspection.require.non.null.option.min.size=Minimal delta length when inspection will warn

inspection.redundant.stream.optional.call.message=Redundant ''{0}'' call
inspection.redundant.stream.optional.call.explanation.filter=predicate is always true
inspection.redundant.stream.optional.call.explanation.sorted=subsequent ''{0}'' call doesn''t depend on the sort order
inspection.redundant.stream.optional.call.explanation.sorted.twice=stream content is sorted again after that
inspection.redundant.stream.optional.call.explanation.distinct=there already was a 'distinct' call in the chain
inspection.redundant.stream.optional.call.explanation.distinct.set=elements will be distinct anyways when collected to the Set
inspection.redundant.stream.optional.call.explanation.unordered=there already was an 'unordered' call in the chain
inspection.redundant.stream.optional.call.explanation.parallel=there''s subsequent ''{0}'' call which overrides this call
inspection.redundant.stream.optional.call.explanation.at.most.one=stream contains at most one element
inspection.redundant.stream.optional.call.explanation.parallel.single=stream created from single element will not be parallelized
inspection.redundant.stream.optional.call.fix.family.name=Remove redundant chain call
inspection.redundant.stream.optional.call.fix.name=Remove ''{0}'' call
inspection.redundant.stream.optional.call.fix.collect.to.ordered.family.name=Collect to 'LinkedHashSet'
inspection.redundant.stream.optional.call.option.streamboxing=Report redundant boxing in Stream.map

inspection.map.foreach.message=Can be replaced with 'Map.forEach'
inspection.map.foreach.fix.name=Replace with Map.forEach
inspection.map.foreach.option.no.loops=Do not report loops

inspection.collection.factories.message=Can be replaced with ''{0}.{1}'' call
inspection.collection.factories.option.ignore.non.constant=Do not warn when content is non-constant
inspection.collection.factories.option.suggest.ofentries=Suggest 'Map.ofEntries'
inspection.collection.factories.fix.family.name=Replace with collection factory call
inspection.collection.factories.fix.name=Replace with ''{0}.{1}'' call

inspection.null.value.for.optional.message=Null is used for ''Optional'' type in {0}
inspection.null.value.for.optional.fix.family.name=Replace with empty Optional method
inspection.null.value.for.optional.fix.name=Replace with ''{0}''
inspection.null.value.for.optional.context.assignment=assignment
inspection.null.value.for.optional.context.parameter=parameter
inspection.null.value.for.optional.context.lambda=lambda expression
inspection.null.value.for.optional.context.return=return statement
inspection.null.value.for.optional.context.declaration=declaration

inspection.handle.signature.name=MethodHandle/VarHandle type mismatch
inspection.handle.signature.field.static=Field ''{0}'' is static
inspection.handle.signature.field.not.static=Field ''{0}'' is not static
inspection.handle.signature.field.type=The type of field ''{0}'' is ''{1}''
inspection.handle.signature.field.cannot.resolve=Cannot resolve field ''{0}''
inspection.handle.signature.method.static=Method ''{0}'' is static
inspection.handle.signature.method.not.static=Method ''{0}'' is not static
inspection.handle.signature.method.abstract=Method ''{0}'' is abstract in ''{1}''
inspection.handle.signature.not.subclass=Caller class ''{0}'' must be a subclass of ''{1}''

inspection.handle.signature.change.type.fix.name=Change type to ''{0}''
inspection.handle.signature.replace.with.fix.name=Replace with ''{0}''
inspection.handle.signature.use.method.fix.family.name=Use one of method overloads
inspection.handle.signature.use.method.fix.name=Use method ''{0}''
inspection.handle.signature.use.constructor.fix.family.name=Use one of constructor overloads
inspection.handle.signature.use.constructor.fix.name=Use constructor ''{0}''

inspection.reflection.invocation.name=Reflective invocation arguments mismatch
inspection.reflection.invocation.argument.count={0,choice,0#No arguments are|1#One argument is|1<{0} arguments are} expected
inspection.reflection.invocation.item.count={0,choice,0#Empty array is|1#Single-item array is|1<{0} array items are} expected
inspection.reflection.invocation.argument.not.assignable=Argument is not assignable to ''{0}''
inspection.reflection.invocation.item.not.assignable=Array item is not assignable to ''{0}''
inspection.reflection.invocation.array.not.assignable=Array {0,choice,1#item has|1<items have} incompatible {0,choice,1#type|1<types}

inspection.reflect.handle.invocation.receiver.null=Call receiver is 'null'
inspection.reflect.handle.invocation.receiver.incompatible=Call receiver type is incompatible: ''{0}'' is expected
inspection.reflect.handle.invocation.argument.not.exact=Argument type should be exactly ''{0}''
inspection.reflect.handle.invocation.result.not.exact=Should be cast to ''{0}''
inspection.reflect.handle.invocation.result.not.assignable=Should be cast to ''{0}'' or its superclass
inspection.reflect.handle.invocation.argument.not.array=Argument is not an array type
inspection.reflect.handle.invocation.primitive.argument.null=Argument of type ''{0}'' cannot be ''null''
inspection.reflect.handle.invocation.result.void=Return type is 'void'
inspection.reflect.handle.invocation.result.null=Returned value is always 'null'

inspection.implicit.subclass.display.forClass=Class ''{0}'' could be implicitly subclassed and must not be final
inspection.implicit.subclass.display.forMethod=Method ''{0}'' should be overridable
inspection.implicit.subclass.make.class.extendable=Make class ''{0}'' {1,choice,0#|1#and method {2} |1<and {1} required methods }extendable
inspection.implicit.subclass.extendable=Make ''{0}'' overridable
inspection.implicit.subclass.display.name=Final declaration can't be overridden at runtime

inspection.reflection.visibility.name=Reflective access across modules issues

inspection.reflection.member.access.name=Reflective access to nonexistent/not visible class member
inspection.reflection.member.access.cannot.resolve.field=Cannot resolve field ''{0}''
inspection.reflection.member.access.field.not.in.class=Field ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.field.not.public=Field ''{0}'' is not public
inspection.reflection.member.access.cannot.resolve.method=Cannot resolve method ''{0}''
inspection.reflection.member.access.cannot.resolve.method.arguments=Cannot resolve method ''{0}'' with specified argument types
inspection.reflection.member.access.method.not.in.class=Method ''{0}'' is not declared in class ''{1}''
inspection.reflection.member.access.method.not.public=Method ''{0}'' is not public
inspection.reflection.member.access.cannot.resolve.constructor.arguments=Cannot resolve constructor with specified argument types
inspection.reflection.member.access.constructor.not.public=Constructor is not public
inspection.reflection.member.access.check.exists=Check that field/method exists in non-final classes
inspection.reflection.member.access.check.exists.exclude=Exclude classes
inspection.reflection.member.access.check.exists.exclude.chooser=Class to exclude
inspection.reflection.member.access.fix.family.name=Use appropriate reflection method

inspection.replace.with.trivial.lambda.fix.family.name=Replace with trivial lambda
inspection.replace.with.trivial.lambda.fix.name=Replace with lambda returning ''{0}''

inspection.redundant.null.check.message=Redundant null-check: {0} is never null
inspection.redundant.null.check.always.fail.message=Null-check will always fail: {0} is never null
inspection.redundant.null.check.fix.family.name=Remove redundant null-check
inspection.redundant.null.check.fix.notnull.family.name=Remove erroneous '!= null'

inspection.comparator.result.comparison.display.name=Suspicious usage of compare method
inspection.comparator.result.comparison.problem.display.name=Comparison of compare method result with specific constant
inspection.comparator.result.comparison.fix.family.name=Fix comparator result comparison

module.not.in.requirements=The module ''{0}'' does not have the module ''{1}'' in requirements
module.package.not.exported=The module ''{0}'' does not export the package ''{1}'' to the module ''{2}''
module.package.not.open=The module ''{0}'' does not open the package ''{1}'' to the module ''{2}''
psi.search.overriding.progress=Searching for Overriding Methods...
unused.import.display.name=Unused import

inspection.fuse.stream.operations.fix.family.name=Fuse more statements to the Stream API chain
inspection.fuse.stream.operations.fix.name=Fuse {0} into the Stream API chain
inspection.fuse.stream.operations.message=Stream may be extended replacing {0}
inspection.fuse.stream.operations.display.name=Subsequent steps can be fused into Stream API chain
inspection.fuse.stream.operations.option.strict.mode=Do not suggest 'toList()' or 'toSet()' collectors

inspection.overwritten.key.set.message=Duplicate Set element
inspection.overwritten.key.map.message=Duplicate Map key
navigate.to.duplicate.fix=Navigate to duplicate

inspection.idempotent.loop.body=Idempotent loop body

inspection.undeclared.service.usage.name=Usage of service not declared in 'module-info'
inspection.undeclared.service.usage.message=Usage of service ''{0}'' is not declared in module-info

inspection.conditional.break.in.infinite.loop=Move condition to loop
inspection.conditional.break.in.infinite.loop.no.conversion.with.do.while=Don't suggest to replace with 'do while'
inspection.conditional.break.in.infinite.loop.description=Conditional break inside infinite loop

inspection.endless.stream.description=Non-short-circuit operation consumes the infinite stream

inspection.simplifiable.comparator.display.name=Comparator can be simplified
inspection.simplifiable.comparator.comparing.message=Unnecessary ''{0}()'' call
inspection.simplifiable.comparator.reversed.message=Comparator can be simplified if ''{0}()'' call is replaced with ''{1}()''
inspection.simplifiable.comparator.fix.comparing.family.name=Remove redundant call
inspection.simplifiable.comparator.fix.remove.name=Remove ''{0}()'' call
inspection.simplifiable.comparator.fix.replace.name=Remove ''{0}()'' call and use ''{1}()''
inspection.simplifiable.comparator.fix.reversed.family.name=Simplify comparator replacing 'max' with 'min'
inspection.simplifiable.comparator.fix.reversed.name=Replace with ''{0}'' simplifying the comparator

inspection.capturing.cleaner=Runnable passed to Cleaner.register() captures ''{0}'' reference
inspection.capturing.cleaner.description=Cleaner captures object reference

inspection.redundant.explicit.close=Redundant 'close()'
inspection.fold.expression.into.stream.display.name=Expression can be folded into Stream chain
inspection.fold.expression.into.stream.fix.name=Fold expression into Stream chain
inspection.fold.expression.into.string.display.name=Expression can be folded into 'String.join'
inspection.fold.expression.into.string.fix.name=Fold expression into 'String.join'
inspection.fold.expression.fix.family.name=Fold expression

inspection.charset.object.can.be.used.display.name=Standard Charset object can be used
inspection.charset.object.can.be.used.message={0} can be used instead
inspection.charset.object.can.be.used.fix.family.name=Use Charset constant
inspection.charset.object.can.be.used.fix.name=Replace with ''{0}''

inspection.suspicious.list.remove.display.name=Suspicious 'List.remove()' in the loop

inspection.cast.can.be.removed.narrowing.variable.type.name=Too weak variable type leads to unnecessary cast
inspection.cast.can.be.removed.narrowing.variable.type.message=Cast may be removed by changing the type of ''{0}'' to ''{1}''
inspection.cast.can.be.removed.narrowing.variable.type.fix.family.name=Change variable type and remove cast
inspection.cast.can.be.removed.narrowing.variable.type.fix.name=Change type of ''{0}'' to ''{1}'' and remove cast

inspection.wrapper.type.may.be.primitive.name=Type may be primitive
inspection.wrapper.type.may.be.primitive.fix.name=Convert wrapper type to primitive

inspection.class.getclass.display.name=Class.getClass() call
inspection.class.getclass.message='getClass()' is called on Class instance
inspection.class.getclass.fix.remove.name=Remove 'getClass()' call
inspection.class.getclass.fix.replace.name=Replace with 'Class.class'
redundant.backticks.around.raw.string.literal.display.name=Redundant backticks around raw string literal
inspection.objects.equals.can.be.simplified.display.name=Objects.equals() can be replaced with equals()
inspection.objects.equals.can.be.simplified.message=Can be replaced with ''{0}''

inspection.duplicate.expressions.display.name=Multiple occurrences of the same expression
inspection.duplicate.expressions.message=Multiple occurrences of <code>#ref</code> #loc
inspection.duplicate.expressions.complexity.threshold=Expression complexity threshold
inspection.duplicate.expressions.introduce.variable.fix.family.name=Introduce variable
inspection.duplicate.expressions.introduce.variable.fix.name=Introduce variable for ''{0}''
inspection.duplicate.expressions.reuse.variable.fix.family.name=Reuse variable
inspection.duplicate.expressions.reuse.variable.fix.name=Reuse variable ''{0}'' for ''{1}''
inspection.duplicate.expressions.replace.other.occurrences.fix.family.name=Replace with variable other occurrences of expression
inspection.duplicate.expressions.replace.other.occurrences.fix.name=Replace with ''{0}'' other occurrences of ''{1}''

inspection.sorted.collection.with.non.comparable.keys.display.name=Sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.message=Construction of sorted collection with non-comparable elements
inspection.sorted.collection.with.non.comparable.keys.option.type.parameters=Don't report non-comparable type parameters

inspection.join.declaration.and.assignment.display.name=Assignment can be joined with declaration
inspection.join.declaration.and.assignment.message=Assignment can be joined with declaration of ''{0}''
inspection.join.declaration.and.assignment.fix.family.name=Join declaration and assignment

inspection.overflowing.loop.index.inspection.name=Loop executes zero or billions times
inspection.overflowing.loop.index.inspection.description=Loop executes zero or billions times

inspection.switch.expression.migration.inspection.name=Statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.inspection.switch.description=Switch statement can be replaced with enhanced 'switch'
inspection.switch.expression.migration.warn.only.on.expression=Show warning only if conversion to expression is possible
inspection.switch.expression.migration.inspection.if.name=If statement can be replaced with enhanced 'switch'
inspection.replace.with.switch.expression.fix.name=Replace with 'switch' expression
inspection.replace.with.enhanced.switch.statement.fix.name=Replace with enhanced 'switch' statement

inspection.switch.expression.backward.migration.inspection.name=New style 'switch' can be replaced with old style one
inspection.switch.expression.backward.expression.migration.inspection.name='switch' expression can be replaced with old style 'switch' statement
inspection.switch.expression.backward.statement.migration.inspection.name='switch' statement can be replaced with old style 'switch' statement
inspection.replace.with.old.style.switch.statement.fix.name=Replace with old style 'switch' statement

inspection.duplicate.branches.in.switch.display.name=Duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.message=Duplicate branch in 'switch'
inspection.duplicate.branches.in.switch.default.message=Branch in 'switch' is a duplicate of the default branch
inspection.duplicate.branches.in.switch.merge.fix.family.name=Merge duplicate branches in 'switch'
inspection.duplicate.branches.in.switch.merge.fix.name=Merge with ''{0}''
inspection.duplicate.branches.in.switch.delete.fix.family.name=Delete redundant 'switch' branches
inspection.duplicate.branches.in.switch.delete.fix.name=Delete redundant 'switch' branch
inspection.duplicate.branches.in.switch.merge.with.default.fix.name=Merge with the default 'switch' branch

inspection.switch.labeled.rule.can.be.code.block.display.name=Labeled switch rule can have code block
inspection.switch.labeled.rule.can.be.code.block.expression.message=Labeled rule's result expression can be wrapped with code block
inspection.switch.labeled.rule.can.be.code.block.statement.message=Labeled rule's statement can be wrapped with code block
inspection.switch.labeled.rule.can.be.code.block.fix.expression.name=Wrap labeled rule's result expression with code block
inspection.switch.labeled.rule.can.be.code.block.fix.statement.name=Wrap labeled rule's statement with code block

inspection.labeled.switch.rule.redundant.code.block.display.name=Labeled switch rule has redundant code block
inspection.labeled.switch.rule.redundant.code.block.message=Labeled rule's code block is redundant
inspection.labeled.switch.rule.redundant.code.fix.name=Unwrap code block of labeled rule

inspection.redundant.operation.on.empty.container.display.name=Redundant operation on empty container
inspection.redundant.operation.on.empty.array.message=Array <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.collection.message=Collection <code>#ref</code> is always empty
inspection.redundant.operation.on.empty.map.message=Map <code>#ref</code> is always empty

inspection.collection.used.as.vararg.display.name=Iterable is used as vararg
inspection.collection.used.as.vararg.message=Iterable is passed as vararg: probably an array was intended
inspection.manual.min.max.calculation.description=Can be replaced with ''Math.{0}'' call
inspection.manual.min.max.calculation.disable.for.non.integral=Disable for float and double