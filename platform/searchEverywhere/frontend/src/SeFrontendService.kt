// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.package com.intellij.platform.searchEverywhere.frontendimport com.intellij.ide.actions.SearchEverywhereManagerFactoryimport com.intellij.ide.actions.searcheverywhere.SearchEverywhereManagerimport com.intellij.ide.actions.searcheverywhere.SearchEverywherePopupInstanceimport com.intellij.ide.actions.searcheverywhere.SearchEverywhereUIimport com.intellij.openapi.actionSystem.AnActionEventimport com.intellij.openapi.actionSystem.DataContextimport com.intellij.openapi.application.EDTimport com.intellij.openapi.components.Serviceimport com.intellij.openapi.project.Projectimport com.intellij.openapi.ui.popup.JBPopupimport com.intellij.openapi.ui.popup.JBPopupFactoryimport com.intellij.openapi.util.Disposerimport com.intellij.openapi.util.registry.Registryimport com.intellij.platform.searchEverywhere.SeSessionEntityimport com.intellij.platform.searchEverywhere.frontend.ui.SePopupContentPaneimport com.intellij.platform.searchEverywhere.frontend.vm.SePopupVmimport com.intellij.platform.searchEverywhere.providers.SeLogimport com.intellij.platform.util.coroutines.childScopeimport com.intellij.platform.util.coroutines.sync.OverflowSemaphoreimport com.intellij.util.ui.StartupUiUtilimport fleet.kernel.changeimport fleet.kernel.sharedimport kotlinx.coroutines.*import kotlinx.coroutines.channels.BufferOverflowimport org.jetbrains.annotations.ApiStatus@ApiStatus.Internal@Service(Service.Level.PROJECT)class SeFrontendService(val project: Project, private val coroutineScope: CoroutineScope): SearchEverywhereManager {  private val popupSemaphore = OverflowSemaphore(1, overflow = BufferOverflow.DROP_LATEST)  @Volatile  private var popupInstance: SePopupInstance? = null  override fun show(tabId: String, searchText: String?, initEvent: AnActionEvent) {    coroutineScope.launch {      doShowPopup(tabId, searchText, initEvent.dataContext)    }  }  private suspend fun doShowPopup(tabId: String?, searchText: String?, dataContext: DataContext) {    val popupScope = coroutineScope.childScope("SearchEverywhereFrontendService popup scope")    val sessionRef = SeSessionEntity.createRef()    try {      popupSemaphore.withPermit {        val startTime = System.currentTimeMillis()        val tabs = SeTabFactory.EP_NAME.extensionList.map {          it.getTab(project, sessionRef, dataContext)        }        var popup: JBPopup? = null        val popupVm = SePopupVm(popupScope, project, sessionRef, tabs, searchText) {          popup?.cancel()          popup = null        }        tabId?.let { popupVm.showTab(it) }        val completable = CompletableDeferred<Unit>()        withContext(Dispatchers.EDT) {          val contentPane = SePopupContentPane(popupVm)          popup = createPopup(contentPane, project) {            completable.complete(Unit)          }          popup?.showCenteredInCurrentWindow(project)          popupInstance = SePopupInstance(popupVm, contentPane)          val endTime = System.currentTimeMillis()          SeLog.log { "Search Everywhere popup opened in ${endTime - startTime} ms" }        }        completable.await()      }    }    finally {      popupInstance = null      withContext(NonCancellable) {        popupScope.cancel()        change {          shared {            sessionRef.derefOrNull()?.delete()          }        }      }    }  }  private fun createPopup(panel: SePopupContentPane, project: Project, onCancel: () -> Unit): JBPopup {    val popup = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, panel.preferableFocusedComponent)      .setProject(project)      .setModalContext(false)      .setNormalWindowLevel(StartupUiUtil.isWaylandToolkit())      .setCancelOnClickOutside(true)      .setRequestFocus(true)      .setCancelKeyEnabled(false)      .setResizable(true)      .setMovable(true)      .setDimensionServiceKey(project, POPUP_LOCATION_SETTINGS_KEY, true)      .setLocateWithinScreenBounds(false)      .setCancelCallback { onCancel(); true }      .createPopup()    Disposer.register(popup, panel)    return popup  }  override fun isShown(): Boolean = popupInstance != null  @Deprecated("Deprecated in the interface")  override fun getCurrentlyShownUI(): SearchEverywhereUI {    throw UnsupportedOperationException("The method is deprecated. Please use getCurrentlyShownPopupInstance() instead.")  }  override fun getCurrentlyShownPopupInstance(): SearchEverywherePopupInstance? = popupInstance  override fun getSelectedTabID(): String = popupInstance?.getSelectedTabID() ?: ""  override fun setSelectedTabID(tabID: String) {    popupInstance?.setSelectedTabID(tabID)  }  override fun toggleEverywhereFilter() {    popupInstance?.toggleEverywhereFilter()  }  override fun isEverywhere(): Boolean = popupInstance?.isEverywhere() ?: false  companion object {    @JvmStatic    fun getInstance(project: Project): SeFrontendService = project.getService(SeFrontendService::class.java)    @JvmStatic    val isEnabled: Boolean      get() = Registry.`is`("search.everywhere.new.enabled", false)    private const val POPUP_LOCATION_SETTINGS_KEY: String = "search.everywhere.popup"  }}@ApiStatus.Internalclass RemDevFriendlySearchEverywhereManager : SearchEverywhereManagerFactory {  override fun isAvailable(): Boolean = SeFrontendService.isEnabled  override fun getManager(project: Project): SearchEverywhereManager = SeFrontendService.getInstance(project)}