// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.package com.intellij.platform.searchEverywhere.frontendimport com.intellij.openapi.actionSystem.AnActionEventimport com.intellij.openapi.actionSystem.DataContextimport com.intellij.openapi.application.EDTimport com.intellij.openapi.components.Serviceimport com.intellij.openapi.project.Projectimport com.intellij.openapi.ui.popup.JBPopupimport com.intellij.openapi.ui.popup.JBPopupFactoryimport com.intellij.openapi.util.Disposerimport com.intellij.openapi.util.registry.Registryimport com.intellij.platform.searchEverywhere.SeSessionEntityimport com.intellij.platform.searchEverywhere.frontend.ui.SePopupContentPaneimport com.intellij.platform.searchEverywhere.frontend.vm.SePopupVmimport com.intellij.platform.util.coroutines.childScopeimport com.intellij.platform.util.coroutines.sync.OverflowSemaphoreimport com.intellij.util.ui.StartupUiUtilimport fleet.kernel.changeimport fleet.kernel.sharedimport kotlinx.coroutines.*import kotlinx.coroutines.channels.BufferOverflowimport org.jetbrains.annotations.ApiStatus@ApiStatus.Internal@Service(Service.Level.PROJECT)class SeFrontendService(val project: Project, private val coroutineScope: CoroutineScope) {  private val popupSemaphore = OverflowSemaphore(1, overflow = BufferOverflow.DROP_LATEST)  fun showPopup(searchText: String? = null, event: AnActionEvent) {    coroutineScope.launch {      doShowPopup(searchText, event.dataContext)    }  }  private suspend fun doShowPopup(searchText: String?, dataContext: DataContext) {    val popupScope = coroutineScope.childScope("SearchEverywhereFrontendService popup scope")    val sessionRef = SeSessionEntity.createRef()    try {      popupSemaphore.withPermit {        val tabs = SeTabProvider.EP_NAME.extensionList.map {          it.getTab(project, sessionRef, dataContext)        }        var popup: JBPopup? = null        val popupVm = SePopupVm(popupScope, project, sessionRef, tabs, searchText) {          popup?.cancel()          popup = null        }        val completable = CompletableDeferred<Unit>()        withContext(Dispatchers.EDT) {          popup = createPopup(popupVm, project) {            completable.complete(Unit)          }          popup?.showCenteredInCurrentWindow(project)        }        completable.await()      }    }    finally {      withContext(NonCancellable) {        popupScope.cancel()        change {          shared {            sessionRef.derefOrNull()?.delete()          }        }      }    }  }  private fun createPopup(vm: SePopupVm, project: Project, onCancel: () -> Unit): JBPopup {    val panel = SePopupContentPane(vm)    val popup = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, panel.preferableFocusedComponent)      .setProject(project)      .setModalContext(false)      .setNormalWindowLevel(StartupUiUtil.isWaylandToolkit())      .setCancelOnClickOutside(true)      .setRequestFocus(true)      .setCancelKeyEnabled(false)      .setResizable(true)      .setMovable(true)      .setDimensionServiceKey(project, POPUP_LOCATION_SETTINGS_KEY, true)      .setLocateWithinScreenBounds(false)      .setCancelCallback { onCancel(); true }      .createPopup()    Disposer.register(popup, panel)    return popup  }  companion object {    @JvmStatic    fun getInstance(project: Project): SeFrontendService = project.getService(SeFrontendService::class.java)    @JvmStatic    val isEnabled: Boolean      get() = Registry.`is`("search.everywhere.new.enabled", false)    private const val POPUP_LOCATION_SETTINGS_KEY: String = "search.everywhere.popup"  }}