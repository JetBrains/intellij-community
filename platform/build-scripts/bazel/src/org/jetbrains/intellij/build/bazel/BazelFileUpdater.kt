// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.intellij.build.bazel

import java.nio.file.Files
import java.nio.file.Path

internal class BazelFileUpdater(private val file: Path) {
  private var originalContent: String? = runCatching { Files.readString(file) }.getOrNull()
  private var fileContent: String? = originalContent

  fun removeSections(sectionName: String) {
    val fileContent = fileContent ?: return
    val pattern = Regex("### auto-generated section `$sectionName[^`]*` start[.\\n\\s\\S]*?### auto-generated section `$sectionName[^`]*` end")
    this.fileContent = fileContent.replace(pattern, "").trim().takeIf { it.isNotBlank() }
  }

  fun insertAutoGeneratedSection(sectionName: String, autoGeneratedContent: String) {
    require(sectionName.isNotEmpty()) {
      "sectionName must not be empty"
    }
    if (autoGeneratedContent.isEmpty()) {
      return
    }

    val startToken = "### auto-generated section `$sectionName` start"
    val endToken = "### auto-generated section `$sectionName` end"

    val newSection = "\n$autoGeneratedContent"
    val fileContent = fileContent
    if (fileContent == null) {
      resetFileContent(startToken = startToken, newSection = newSection, endToken = endToken)
      return
    }

    val startIndex = fileContent.indexOf(startToken)
    val endIndex = fileContent.indexOf(endToken)
    if (startIndex == -1 || endIndex == -1) {
      if (!fileContent.contains("### skip generation section `$sectionName`")) {
        appendFileContent(startToken, newSection, endToken)
      }
    }
    else {
      this.fileContent = fileContent.substring(0, startIndex + startToken.length) + newSection + fileContent.substring(endIndex)
    }
  }

  private fun resetFileContent(startToken: String, newSection: String, endToken: String) {
    this.fileContent = startToken + "\n" + newSection.trim() + "\n" + endToken
  }

  private fun appendFileContent(startToken: String, newSection: String, endToken: String) {
    if (fileContent?.lastOrNull() != '\n') {
      fileContent = fileContent + "\n"
    }
    fileContent = fileContent + "\n" + startToken + "\n" + newSection.trim() + "\n" + endToken
  }

  fun save() {
    val newContent = fileContent?.trim() ?: error("fileContent is not set")
    if (originalContent != newContent) {
      Files.writeString(file, newContent)
    }
  }
}