// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.intellij.build.bazel

import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.createParentDirectories
import kotlin.io.path.writeText

internal class BazelFileUpdater(private val file: Path) {
  private var originalContent: String? = runCatching { Files.readString(file) }.getOrNull()
  private var fileContent: String? = originalContent

  fun removeSections(sectionNamePrefix: String) {
    val fileContent = fileContent ?: return
    val pattern = Regex("### auto-generated section `$sectionNamePrefix[^`]*` start[.\\n\\s\\S]*?### auto-generated section `$sectionNamePrefix[^`]*` end")
    this.fileContent = fileContent.replace(pattern, "").trim().takeIf { it.isNotBlank() }
  }

  fun isSectionSkipped(sectionName: String): Boolean {
    val fileContent = fileContent ?: return false
    return fileContent.contains("### skip generation section `$sectionName`")
  }

  fun insertAutoGeneratedSection(sectionName: String, autoGeneratedContent: String) {
    require(sectionName.isNotEmpty()) {
      "sectionName must not be empty"
    }
    if (autoGeneratedContent.isEmpty()) {
      return
    }

    val startToken = "### auto-generated section `$sectionName` start"
    val endToken = "### auto-generated section `$sectionName` end"

    val newSection = "\n$autoGeneratedContent"
    val fileContent = fileContent
    if (fileContent == null) {
      resetFileContent(startToken = startToken, newSection = newSection, endToken = endToken)
      return
    }

    val startIndex = fileContent.indexOf(startToken)
    val endIndex = fileContent.indexOf(endToken)
    if (startIndex == -1 || endIndex == -1) {
      if (!fileContent.contains("### skip generation section `$sectionName`")) {
        appendFileContent(startToken, newSection, endToken)
      }
    }
    else {
      this.fileContent = fileContent.substring(0, startIndex + startToken.length) + newSection + fileContent.substring(endIndex)
    }
  }

  private fun resetFileContent(startToken: String, newSection: String, endToken: String) {
    this.fileContent = startToken + "\n" + newSection.trim() + "\n" + endToken
  }

  private fun appendFileContent(startToken: String, newSection: String, endToken: String) {
    if (fileContent?.lastOrNull() != '\n') {
      fileContent = fileContent + "\n"
    }
    fileContent = fileContent + "\n" + startToken + "\n" + newSection.trim() + "\n" + endToken
  }

  fun save() {
    val newContent = fileContent?.trim() ?: error("fileContent is not set for $file")
    if (originalContent != newContent) {
      file.createParentDirectories().writeText(newContent)
    }
  }
}