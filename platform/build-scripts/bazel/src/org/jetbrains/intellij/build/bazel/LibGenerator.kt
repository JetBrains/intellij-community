// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
@file:Suppress("ReplaceGetOrSet")

package org.jetbrains.intellij.build.bazel

import com.charleskorn.kaml.SingleLineStringStyle
import com.charleskorn.kaml.Yaml
import com.charleskorn.kaml.YamlConfiguration
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.serializer
import java.net.URI
import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.nio.file.Files
import java.nio.file.Path
import java.security.MessageDigest
import java.util.*
import kotlin.io.path.exists

private val httpClient = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.ALWAYS).build()

// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
internal object LibGenerator {
  @JvmStatic
  fun main(args: Array<String>) {
    generate(Path.of(args[0]))
  }
}

@Suppress("DuplicatedCode")
private fun calculateHash(url: String): String {
  val digest = MessageDigest.getInstance("SHA-256")
  println("Downloading '$url'")
  val requestBuilder = HttpRequest.newBuilder().uri(URI.create(url)).GET()
  val response = httpClient.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofInputStream())
  require(response.statusCode() == 200) {
    "Cannot download $url"
  }
  response.body().use { inputStream ->
    val buffer = ByteArray(8192)
    var bytesRead: Int
    while (inputStream.read(buffer).also { bytesRead = it } != -1) {
      digest.update(buffer, 0, bytesRead)
    }
  }
  return digest.digest().joinToString("") { "%02x".format(it) }
}

private val yaml = Yaml(
  configuration = YamlConfiguration(
    encodeDefaults = false,
    singleLineStringStyle = SingleLineStringStyle.PlainExceptAmbiguous,
  ),
)

@OptIn(ExperimentalSerializationApi::class)
private val json = Json {
  prettyPrint = true
  prettyPrintIndent = "  "
}

private fun generate(file: Path) {
  val lockFile = file.parent.resolve(file.fileName.toString().replace(".yaml", ".lock.json"))

  val serializer = serializer<List<JarRepositoryAndLibs>>()
  val data = yaml.decodeFromString(serializer, Files.readString(file))

  val lockSerializer = serializer<MutableMap<String, List<String>>>()
  val oldLockString = if (lockFile.exists()) Files.readString(lockFile) else null
  val lockData = if (oldLockString == null) HashMap() else json.decodeFromString(lockSerializer, oldLockString)
  val moduleContent = StringBuilder()
  val buildContent = StringBuilder()
  val unused = HashSet(lockData.keys)
  for (item in data) {
    for (lib in item.libs) {
      processLib(lib = lib, repoUrl = item.url, lockData = lockData, moduleContent = moduleContent, buildContent = buildContent, unused = unused)
    }
  }

  val moduleFileUpdater = BazelFileUpdater(file.parent.resolve("MODULE.bazel"))
  moduleFileUpdater.insertAutoGeneratedSection("libraries", moduleContent.toString())
  moduleFileUpdater.save()

  val buildFileUpdater = BazelFileUpdater(file.parent.resolve("BUILD.bazel"))
  buildFileUpdater.insertAutoGeneratedSection("libraries", buildContent.toString())
  buildFileUpdater.save()

  for (id in unused) {
    lockData.remove(id)
  }

  val newLockString = json.encodeToString(lockSerializer, TreeMap(lockData))
  if (oldLockString != newLockString) {
    Files.writeString(lockFile, newLockString)
  }
}

private fun processLib(
  lib: Lib,
  repoUrl: String,
  lockData: MutableMap<String, List<String>>,
  moduleContent: StringBuilder,
  buildContent: StringBuilder,
  unused: MutableSet<String>,
) {
  val id = lib.id.split(':')
  require(id.size == 2) { "incorrect id: $id" }
  val localName = id[1]
  val version = lib.version
  val baseUrl = repoUrl.trimEnd('/') + '/' + id[0].replace('.', '/') + '/' + localName + '/' + version + '/' + localName + '-' + version
  val url = "$baseUrl.jar"
  val sourcesUrl = "$baseUrl-sources.jar"

  val lockId = lib.id + ':' + version

  var hashes = lockData.get(lockId)
  if (hashes == null || hashes.size != 2 || hashes.any { it.isBlank() }) {
    hashes = listOf(calculateHash(url), calculateHash(sourcesUrl))
    lockData.put(lockId, hashes)
  }

  unused.remove(lockId)

  val modulePart = """
    http_file(
        name = "$localName",
        url = "$url",
        sha256 = "${hashes[0]}",
        downloaded_file_path = "$localName-$version.jar",
    )
    http_file(
        name = "$localName-sources",
        url = "$sourcesUrl",
        sha256 = "${hashes[1]}",
        downloaded_file_path = "$localName-$version-sources.jar",
    )
  """.trimIndent()
  moduleContent.append(modulePart)
  moduleContent.append("\n\n")

  val buildPart = """
    jvm_import(
        name = "${localName.removeSuffix("-jvm")}",
        jar = "@$localName//file",
        source_jar = "@$localName-sources//file",
        visibility = ["//visibility:public"],
  """.trimIndent()
  buildContent.append(buildPart)
  if (lib.runtimeDeps.isNotEmpty()) {
    val indent = " ".repeat(8)
    buildContent.append("\n    runtime_deps = [\n$indent${lib.runtimeDeps.joinToString(",\n$indent") { "\"$it\"" }}\n    ],")
  }
  buildContent.append("\n)\n\n")
}

@Serializable
private data class JarRepositoryAndLibs(
  @JvmField val url: String,
  @JvmField val libs: List<Lib>,
)

@Serializable
private data class Lib(
  @JvmField val id: String,
  @JvmField val version: String,
  @JvmField val runtimeDeps: List<String> = emptyList(),
)
