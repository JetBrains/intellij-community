// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.intellij.build.bazel

internal inline fun buildFile(out: BazelFileUpdater, sectionName: String, block: BuildFile.() -> Unit) {
  out.insertAutoGeneratedSection(sectionName = sectionName, autoGeneratedContent = BuildFile().apply(block).render())
}

internal interface Renderable {
  fun render(): String
}

internal class BuildFile {
  private val loads = HashSet<LoadStatement>()
  private val targets = mutableListOf<Target>()
  private val lines = mutableListOf<String>()

  val loadStatements: List<LoadStatement>
    get() = loads.toList()

  fun load(bzlFile: String, vararg symbols: String) {
    val existing = loads.firstOrNull { it.bzlFile == bzlFile }
    if (existing == null) {
      loads.add(LoadStatement(bzlFile, symbols.toList()))
    }
    else {
      loads.remove(existing)
      loads.add(LoadStatement(bzlFile, (symbols.toList() + existing.symbols).sorted().distinct()))
    }
  }

  fun addTarget(target: Target) {
    targets.add(target)
  }

  fun target(type: String, block: Target.() -> Unit) {
    val target = Target(type).apply(block)
    addTarget(target)
  }

  fun render(existingLoads: Map<String, Set<String>> = emptyMap()): String {
    val filteredLoads = loads.mapNotNull { load ->
      val filteredSymbols = load.symbols.filter { existingLoads[load.bzlFile]?.contains(it) != true }
      if (filteredSymbols.isEmpty()) {
        null
      }
      else {
        LoadStatement(load.bzlFile, filteredSymbols)
      }
    }

    val loadStatements = filteredLoads
      .map { it.render() }
      .sorted()
      .joinToString("\n")
    val targetStatements = targets.joinToString("\n") { it.render() }
    return sequenceOf(loadStatements, targetStatements, lines.joinToString("\n"))
      .filter { it.isNotEmpty() }
      .joinToString("\n\n")
  }
}

// Class to represent a load statement
internal data class LoadStatement(@JvmField val bzlFile: String, @JvmField val symbols: List<String>) : Renderable {
  override fun render(): String {
    val formattedSymbols = symbols.sorted().joinToString(", ") { "\"$it\"" }
    return """load("$bzlFile", $formattedSymbols)"""
  }
}

internal class Target(private val type: String) : Renderable {
  private val attributes = LinkedHashMap<String, Any>()

  // Support for setting key-value pairs with arrays
  fun option(key: String, value: Any) {
    verifyTypeIsSupported(value)

    if (attributes.containsKey(key)) {
      error("Duplicate key: $key. Old value: ${attributes[key]}, new value: $value")
    }

    attributes[key] = value
  }

  private fun verifyTypeIsSupported(value: Any) {
    val klass = value.javaClass
    when {
      String::class.java.isAssignableFrom(klass) -> Unit
      value == true || value == false -> Unit
      Renderable::class.java.isAssignableFrom(klass) -> Unit
      List::class.java.isAssignableFrom(klass) -> {
        for (item in value as List<*>) {
          verifyTypeIsSupported(item!!)
        }
      }
      LinkedHashSet::class.java.isAssignableFrom(klass) -> {
        for (item in value as LinkedHashSet<*>) {
          verifyTypeIsSupported(item!!)
        }
      }
      else -> error("Unsupported type '$klass' for value: $value")
    }
  }

  fun optionCount(): Int = attributes.size

  fun visibility(targets: Array<String>) {
    option("visibility", targets.toList())
  }

  internal fun glob(list: List<String>, exclude: List<String> = emptyList(), allowEmpty: Boolean = true): Renderable {
    return object : Renderable {
      override fun render(): String {
        val opts = LinkedHashMap<String, Any>()
        if (allowEmpty) {
          opts["allow_empty"] = true
        }
        if (exclude.isNotEmpty()) {
          opts["exclude"] = exclude
        }

        val extra = if (opts.isEmpty()) "" else ", ${opts.entries.joinToString(", ") { "${it.key} = ${formatValue(it.value)}" }}"

        // allow_empty - avoid detection of whether we have Kotlin/Java files or not
        return "glob([${list.joinToString(", ") { formatValue(it) }}]$extra)"
      }
    }
  }

  override fun render(): String {
    val renderedAttributes = attributes.map { (key, value) ->
      "  $key = ${formatValue(value)}"
    }.joinToString(",\n")

    return buildString {
      if (type.isEmpty()) {
        appendLine(renderedAttributes)
      }
      else {
        appendLine("$type(")
        appendLine(renderedAttributes)
        appendLine(")")
      }
    }
  }
}

private fun formatValue(value: Any?): String {
  return when (value) {
    is Collection<*> -> {
      if (value.size > 1) {
        value.joinToString(separator = ",\n    ", prefix = "[\n    ", postfix = ",\n  ]") { formatValue(it) }
      }
      else {
        value.joinToString(separator = ", ", prefix = "[", postfix = "]") { formatValue(it) }
      }
    }
    is Array<*> -> value.joinToString(separator = ", ", prefix = "[", postfix = "]") { formatValue(it) }
    is String -> "\"$value\""
    is Number -> value.toString()
    true -> "True"
    false -> "False"
    is Renderable -> value.render()
    else -> value.toString()
  }
}