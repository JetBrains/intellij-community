// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.intellij.build.bazel

internal inline fun buildFile(out: BazelFileUpdater, sectionName: String, block: BuildFile.() -> Unit) {
  out.insertAutoGeneratedSection(sectionName = sectionName, autoGeneratedContent = BuildFile().apply(block).render())
}

internal interface Renderable {
  fun render(): String
}

internal class BuildFile {
  private val loads = HashSet<LoadStatement>()
  private val targets = mutableListOf<Target>()
  private val lines = mutableListOf<String>()

  @JvmField val nameGuard = HashSet<String>()

  fun load(bzlFile: String, vararg symbols: String) {
    val existing = loads.firstOrNull { it.bzlFile == bzlFile }
    if (existing == null) {
      loads.add(LoadStatement(bzlFile, symbols.toList()))
    }
    else {
      loads.remove(existing)
      loads.add(LoadStatement(bzlFile, (symbols.toList() + existing.symbols).sorted().distinct()))
    }
  }

  fun target(type: String, isEmpty: (Target) -> Boolean = { false }, block: Target.() -> Unit) {
    val target = Target(type).apply(block)
    if (!isEmpty(target)) {
      targets.add(target)
    }
  }

  fun render(): String {
    val loadStatements = loads.asSequence().map { it.render() }.sorted().joinToString("\n")
    val targetStatements = targets.joinToString("\n") { it.render() }
    return sequenceOf(loadStatements, targetStatements, lines.joinToString("\n"))
      .filter { it.isNotEmpty() }
      .joinToString("\n\n")
  }

  fun reset() {
    loads.clear()
    targets.clear()
    lines.clear()
  }
}

// Class to represent a load statement
internal data class LoadStatement(@JvmField val bzlFile: String, @JvmField val symbols: List<String>) : Renderable {
  override fun render(): String {
    val formattedSymbols = symbols.sorted().joinToString(", ") { "\"$it\"" }
    return """load("$bzlFile", $formattedSymbols)"""
  }
}

internal class Target(private val type: String) : Renderable {
  private val attributes = LinkedHashMap<String, Any>()

  // Support for setting key-value pairs with arrays
  fun option(key: String, value: Any) {
    attributes[key] = value
  }

  fun optionCount(): Int = attributes.size

  fun visibility(targets: Array<String>) {
    option("visibility", targets)
  }

  internal fun glob(list: List<String>, exclude: List<String> = emptyList(), allowEmpty: Boolean = true): Renderable {
    return object : Renderable {
      override fun render(): String {
        val opts = LinkedHashMap<String, Any>()
        if (allowEmpty) {
          opts.put("allow_empty", true)
        }
        if (exclude.isNotEmpty()) {
          opts.put("exclude", exclude)
        }

        val extra = if (opts.isEmpty()) "" else ", ${opts.entries.joinToString(", ") { "${it.key} = ${formatValue(it.value)}" }}"

        // allow_empty - avoid detection of whether we have Kotlin/Java files or not
        return "glob([${list.joinToString(", ") { formatValue(it) }}]$extra)"
      }
    }
  }

  override fun render(): String {
    val renderedAttributes = attributes.map { (key, value) ->
      "  $key = ${formatValue(value)}"
    }.joinToString(",\n")

    return buildString {
      if (type.isEmpty()) {
        appendLine(renderedAttributes)
      }
      else {
        appendLine("$type(")
        appendLine(renderedAttributes)
        appendLine(")")
      }
    }
  }
}

private fun formatValue(value: Any?): String {
  return when (value) {
    is List<*> -> {
      if (value.size > 1) {
        value.joinToString(separator = ",\n    ", prefix = "[\n    ", postfix = ",\n  ]") { formatValue(it) }
      }
      else {
        value.joinToString(separator = ", ", prefix = "[", postfix = "]") { formatValue(it) }
      }
    }
    is Array<*> -> value.joinToString(separator = ", ", prefix = "[", postfix = "]") { formatValue(it) }
    is String -> "\"$value\""
    is Number -> value.toString()
    true -> "True"
    false -> "False"
    is Renderable -> value.render()
    else -> value.toString()
  }
}