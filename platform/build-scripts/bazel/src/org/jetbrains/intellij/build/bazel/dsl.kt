// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.intellij.build.bazel

internal inline fun buildFile(out: BazelFileUpdater, sectionName: String, block: BuildFile.() -> Unit) {
  out.insertAutoGeneratedSection(sectionName, BuildFile().apply(block).render())
}

internal interface Renderable {
  fun render(): String
}

internal class BuildFile {
  private val loads = mutableListOf<LoadStatement>()
  private val targets = mutableListOf<Target>()
  val lines = mutableListOf<String>()

  fun load(bzlFile: String, vararg symbols: String) {
    loads.add(LoadStatement(bzlFile, symbols.toList()))
  }

  fun target(type: String, block: Target.() -> Unit) {
    targets.add(Target(type).apply(block))
  }

  fun render(): String {
    val loadStatements = loads.joinToString("\n") { it.render() }
    val targetStatements = targets.joinToString("\n") { it.render() }
    return sequenceOf(loadStatements, targetStatements, lines.joinToString("\n"))
      .filter { it.isNotEmpty() }
      .joinToString("\n\n")
  }
}

// Class to represent a load statement
internal class LoadStatement(private val bzlFile: String, private val symbols: List<String>) : Renderable {
  override fun render(): String {
    val formattedSymbols = symbols.joinToString(", ") { "\"$it\"" }
    return """load("$bzlFile", $formattedSymbols)"""
  }
}

internal class Target(private val type: String) : Renderable {
  private val attributes = LinkedHashMap<String, Any>()

  // Support for setting key-value pairs with arrays
  fun option(key: String, value: Any) {
    attributes[key] = value
  }

  fun visibility(targets: Array<String>) {
    option("visibility", targets)
  }

  internal fun glob(list: List<String>, exclude: List<String> = listOf("**/module-info.java")) = object : Renderable {
    override fun render(): String {
      val excluded = exclude.takeIf { it.isNotEmpty() }?.joinToString(",\n    ") { formatValue(it) }?.let {
        ", exclude = [$it]"
      }.orEmpty()
      // allow_empty - avoid detection of whether we have Kotlin/Java files or not
      return "glob([${list.joinToString(", ") { formatValue(it) }}], allow_empty = True$excluded)"
    }
  }

  override fun render(): String {
    val renderedAttributes = attributes.map { (key, value) ->
      "  $key = ${formatValue(value)}"
    }.joinToString(",\n")

    return buildString {
      if (type.isEmpty()) {
        appendLine(renderedAttributes)
      }
      else {
        appendLine("$type(")
        appendLine(renderedAttributes)
        appendLine(")")
      }
    }
  }
}

private fun formatValue(value: Any?): String {
  return when (value) {
    is List<*> -> {
      if (value.size > 1) {
        value.joinToString(separator = ",\n    ", prefix = "[\n    ", postfix = ",\n  ]") { formatValue(it) }
      }
      else {
        value.joinToString(separator = ", ", prefix = "[", postfix = "]") { formatValue(it) }
      }
    }
    is Array<*> -> value.joinToString(separator = ", ", prefix = "[", postfix = "]") { formatValue(it) }
    is String -> "\"$value\""
    is Number -> value.toString()
    true -> "True"
    false -> "False"
    is Renderable -> value.render()
    else -> value.toString()
  }
}