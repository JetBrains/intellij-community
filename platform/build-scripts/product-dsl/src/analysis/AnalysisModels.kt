// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.intellij.build.productLayout.analysis

import kotlinx.serialization.Serializable
import org.jetbrains.intellij.build.productLayout.ModuleSet
import org.jetbrains.intellij.build.productLayout.ProductModulesContentSpec

/**
 * Metadata about a module set including its location and source file.
 *
 * @param moduleSet The module set instance
 * @param location The location category ("community" or "ultimate")
 * @param sourceFile The Kotlin source file path relative to project root where this module set is defined
 */
data class ModuleSetMetadata(
  val moduleSet: ModuleSet,
  val location: String,
  val sourceFile: String
)

/**
 * JSON filter for selective analysis output.
 * Supports various filter types: products, moduleSets, composition, duplicates, mergeImpact, modulePaths, or specific items.
 */
@Serializable
data class JsonFilter(
  val filter: String,  // "products", "moduleSets", "composition", "duplicates", "mergeImpact", "modulePaths", "product", "moduleSet"
  val value: String? = null,  // Product/module set name when filter is "product" or "moduleSet"
  val module: String? = null,  // Module name for "modulePaths" filter
  val source: String? = null,  // Source module set name for "mergeImpact" filter
  val target: String? = null,  // Target module set name for "mergeImpact" filter (null for inline operation)
  val operation: String? = null,  // Operation type for "mergeImpact": "merge", "move", or "inline" (default: "merge")
  val includeDuplicates: Boolean = false  // Include duplicate xi:include detection in output (for future unification)
)

/**
 * Product specification for JSON output.
 * Contains essential product metadata with source file paths for AI navigation,
 * plus complete ProductModulesContentSpec for full DSL representation.
 */
data class ProductSpec(
  val name: String,
  val className: String?,
  val sourceFile: String,
  val pluginXmlPath: String?,
  val contentSpec: ProductModulesContentSpec?,
  val buildModules: List<String>,
  val totalModuleCount: Int = 0,      // All modules including from module sets
  val directModuleCount: Int = 0,     // Just additionalModules count
  val moduleSetCount: Int = 0,        // Number of module sets included
  val uniqueModuleCount: Int = 0      // Deduplicated module count
)

/**
 * Module location information from .idea/modules.xml.
 * 
 * @param location Module location: "community", "ultimate", or "unknown"
 * @param imlPath Absolute path to the .iml file
 */
data class ModuleLocationInfo(
  val location: String,  // "community", "ultimate", or "unknown"
  val imlPath: String?
)

/**
 * Violation when a community product uses ultimate modules.
 */
data class CommunityProductViolation(
  val product: String,
  val productFile: String,
  val moduleSet: String,
  val moduleSetFile: String,
  val ultimateModules: List<String>,
  val communityModulesCount: Int,
  val unknownModulesCount: Int,
  val totalModulesCount: Int
)

/**
 * Violation when a module set is in the wrong location (community vs ultimate).
 */
data class ModuleSetLocationViolation(
  val moduleSet: String,
  val file: String,
  val issue: String,  // "community_contains_ultimate" or "ultimate_contains_only_community"
  val ultimateModules: List<String>? = null,
  val communityModules: List<String>? = null,
  val communityModulesCount: Int? = null,
  val ultimateModulesCount: Int? = null,
  val unknownModulesCount: Int,
  val suggestion: String
)

/**
 * Similarity between two products based on module set overlap.
 * Used for identifying merge candidates and refactoring opportunities.
 */
data class ProductSimilarityPair(
  val product1: String,
  val product2: String,
  val similarity: Double,
  val moduleSetSimilarity: Double,
  val sharedModuleSets: List<String>,
  val uniqueToProduct1: List<String>,
  val uniqueToProduct2: List<String>
)

/**
 * Overlap between two module sets.
 * Correctly identifies intentional nested set inclusions vs actual duplications.
 * Intentional nesting (e.g., libraries includes libraries.core) is filtered out.
 */
data class ModuleSetOverlap(
  val moduleSet1: String,
  val moduleSet2: String,
  val location1: String,
  val location2: String,
  val relationship: String,  // "overlap", "subset", "superset"
  val overlapPercent: Int,
  val sharedModules: Int,
  val totalModules1: Int,
  val totalModules2: Int,
  val recommendation: String
)

/**
 * Suggestion for module set unification (merge, inline, factor, split).
 * Generated by analyzing overlap, product similarity, and module set usage patterns.
 */
data class UnificationSuggestion(
  val priority: String,  // "high", "medium", "low"
  val strategy: String,  // "merge", "inline", "factor", "split"
  val type: String?,  // For merge: "subset", "superset", "high-overlap"
  val moduleSet: String?,  // For inline/split: single module set
  val moduleSet1: String?,  // For merge: first module set
  val moduleSet2: String?,  // For merge: second module set
  val products: List<String>?,  // For factor: products with shared sets
  val sharedModuleSets: List<String>?,  // For factor: shared module sets
  val reason: String,
  val impact: Map<String, Any>
)

/**
 * File reference in a module path trace.
 * Points to either a module set file or a product file that includes a module.
 */
data class PathFileReference(
  val type: String,  // "module-set" or "product"
  val path: String?,  // Absolute file path
  val name: String,  // Name of the module set or product
  val note: String  // Description like "contains module" or "includes module set"
)

/**
 * A single path showing how a module reaches a product.
 * Either directly or through module set(s).
 */
data class ModulePath(
  val type: String,  // "direct" or "module-set"
  val path: String,  // Human-readable path string like "module → set → product"
  val files: List<PathFileReference>  // File references involved in this path
)

/**
 * Complete tracing result for a module showing all paths to products.
 */
data class ModulePathsResult(
  val module: String,
  val paths: List<ModulePath>,
  val moduleSets: List<String>,  // Module sets that contain this module
  val products: List<String>  // Products that include this module (directly or indirectly)
)

/**
 * Impact analysis result for merging, moving, or inlining module sets.
 * Used to assess safety and predict consequences before refactoring.
 */
data class MergeImpactResult(
  val operation: String,  // "merge", "move", "inline"
  val sourceSet: String,
  val targetSet: String?,
  val productsUsingSource: List<String>,
  val productsUsingTarget: List<String>,
  val productsThatWouldChange: List<String>,
  val sizeImpact: Map<String, Int>,
  val violations: List<Map<String, Any>>,
  val recommendation: String,
  val safe: Boolean
)

// Private helper data classes for internal analysis

/**
 * Helper data class for module distribution analysis.
 */
internal data class ModuleDistributionInfo(
  val inModuleSets: MutableList<String> = mutableListOf(),
  val inProducts: MutableList<String> = mutableListOf(),
  var location: String = "unknown",  // "community", "ultimate", or "unknown"
  var imlPath: String? = null
)

/**
 * Helper data class for module set hierarchy analysis.
 */
internal data class ModuleSetHierarchyInfo(
  val includes: List<String>,
  val includedBy: MutableList<String> = mutableListOf(),
  val moduleCount: Int
)

/**
 * Helper data classes for module usage index.
 */
internal data class ModuleUsageInfo(
  val moduleSets: MutableList<ModuleSetReference> = mutableListOf(),
  val products: MutableList<ProductReference> = mutableListOf()
)

internal data class ModuleSetReference(
  val name: String,
  val location: String,
  val sourceFile: String
)

internal data class ProductReference(
  val name: String,
  val sourceFile: String
)
