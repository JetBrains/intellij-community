// Copyright 2000-2023 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.codeInsight.daemon.impl;

import com.intellij.codeHighlighting.Pass;
import com.intellij.codeInspection.ex.InspectionProfileWrapper;
import com.intellij.codeInspection.ex.InspectionToolWrapper;
import com.intellij.codeInspection.ex.LocalInspectionToolWrapper;
import com.intellij.lang.injection.InjectedLanguageManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.RangeMarker;
import com.intellij.openapi.editor.ex.MarkupModelEx;
import com.intellij.openapi.editor.ex.RangeHighlighterEx;
import com.intellij.openapi.editor.impl.DocumentMarkupModel;
import com.intellij.openapi.editor.impl.SweepProcessor;
import com.intellij.openapi.editor.markup.RangeHighlighter;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.Segment;
import com.intellij.openapi.util.TextRange;
import com.intellij.psi.PsiFile;
import com.intellij.util.ObjectUtils;
import com.intellij.util.containers.ContainerUtil;
import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

class HighlightInfoUpdater {
  private static final Logger LOG = Logger.getInstance(HighlightInfoUpdater.class);
  private static final Object UNKNOWN_ID = "unknownId";
  // tool id, containing file -> list of HighlightInfos generated by this tool in this file (there may be several files for one tool in case of injections)
  private final Map<Pair<Object, PsiFile>, List<HighlightInfo>> data = new ConcurrentHashMap<>();
  HighlightInfoUpdater(@NotNull PsiFile psiFile,
                       @NotNull MarkupModelEx markupModel,
                       boolean isWholeFileToolsPass,
                       @NotNull InspectionProfileWrapper profileWrapper) {
    readFromMarkupModel(psiFile, markupModel, isWholeFileToolsPass, profileWrapper);
  }

  private void readFromMarkupModel(@NotNull PsiFile psiFile, @NotNull MarkupModelEx markupModel, boolean isWholeFileToolsPass,
                                   @NotNull InspectionProfileWrapper profileWrapper) {
    data.clear();
    for (RangeHighlighter highlighter : markupModel.getAllHighlighters()) {
      HighlightInfo info = HighlightInfo.fromRangeHighlighter(highlighter);
      if (info != null) {
        Object toolId = info.toolId;
        if (toolId instanceof String inspectionToolId && isWholeFileTool(inspectionToolId, profileWrapper, psiFile) == isWholeFileToolsPass) {
          List<HighlightInfo> infos = getList(toolId, psiFile);
          synchronized (infos) {
            infos.add(info);
          }
        }
      }
    }
    for (Map.Entry<Pair<Object, PsiFile>, List<HighlightInfo>> entry : data.entrySet()) {
      ContainerUtil.quickSort(entry.getValue(), UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS);
    }
  }

  private static boolean isWholeFileTool(@NotNull String toolId, @NotNull InspectionProfileWrapper profileWrapper, @NotNull PsiFile psiFile) {
    InspectionToolWrapper<?, ?> tool = profileWrapper.getInspectionTool(toolId, psiFile);
    return tool instanceof LocalInspectionToolWrapper local && local.runForWholeFile();
  }

  @NotNull
  private List<HighlightInfo> getList(@Nullable @NonNls Object toolId, @NotNull PsiFile psiFile) {
    Pair<Object, PsiFile> toolIdInFile = Pair.create(Objects.requireNonNullElse(toolId, UNKNOWN_ID), psiFile);
    return data.computeIfAbsent(toolIdInFile, __ -> new ArrayList<>());
  }


  /**
   * Inspection tool {@code tool} has generated {@code infos} highlights during visiting (subset of) psi elements from {@code restrictRange}.
   * Remove all highlights that this tool had generated earlier during visiting this range and replace them with {@code infos}
   */
  void updateInspectionResult(@NotNull LocalInspectionToolWrapper tool,
                              @NotNull HighlightingSession session,
                              @NotNull Collection<? extends HighlightInfo> infos,
                              @NotNull PsiFile psiFile,
                              @NotNull TextRange restrictRange) {
    String shortName = tool.getShortName();
    List<? extends HighlightInfo> oldInfos = getList(shortName, psiFile);
    List<HighlightInfo> newInfos = new ArrayList<>(infos);
    ContainerUtil.quickSort(newInfos, UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS);
    synchronized (oldInfos) {
      Document document = session.getDocument();
      Project project = session.getProject();
      MarkupModelEx markup = (MarkupModelEx)DocumentMarkupModel.forDocument(document, project, true);

      TextRange hostRange = InjectedLanguageManager.getInstance(project).injectedToHost(psiFile, psiFile.getTextRange());
      TextRange updateRange = ObjectUtils.chooseNotNull(hostRange.intersection(restrictRange), hostRange);
      if (LOG.isDebugEnabled()) {
        LOG.debug("updateInspectionResult: tool:" + shortName + "; infos:" + infos + "; oldInfos:" + oldInfos + "; psiFile:" + psiFile);
      }
      List<HighlightInfo> resultInfos = setHighlightersInRange(updateRange, newInfos, oldInfos, markup, session);

      data.put(Pair.create(shortName, psiFile), resultInfos);
    }
  }

  // return list of new HighlightInfos (old infos from outside `range` plus re-created infos inside)
  @NotNull
  private static List<HighlightInfo> setHighlightersInRange(@NotNull TextRange range,
                                                            @NotNull List<? extends HighlightInfo> newInfos,
                                                            @NotNull List<? extends HighlightInfo> oldInfos,
                                                            @NotNull MarkupModelEx markup,
                                                            @NotNull HighlightingSession session) {
    ApplicationManager.getApplication().assertIsNonDispatchThread();
    ApplicationManager.getApplication().assertReadAccessAllowed();
    PsiFile psiFile = session.getPsiFile();
    Project project = session.getProject();
    SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(project);
    HighlightersRecycler toReuse = new HighlightersRecycler();
    Document document = session.getDocument();
    Long2ObjectMap<RangeMarker> range2markerCache = new Long2ObjectOpenHashMap<>(10);
    boolean[] changed = {false};
    List<HighlightInfo> result = new ArrayList<>(oldInfos.size());
    try {
      for (HighlightInfo oldInfo : oldInfos) {
        RangeHighlighterEx oldHighlighter = oldInfo.getHighlighter();
        Segment oldVisitingRange = oldInfo.getVisitingTextRange();
        if (oldHighlighter != null && range.contains(oldVisitingRange)) {
          toReuse.recycleHighlighter(oldHighlighter);
        }
        else {
          result.add(oldInfo);
        }
      }
      List<HighlightInfo> filteredNewInfos = UpdateHighlightersUtil.HighlightInfoPostFilters.applyPostFilter(project, newInfos);
      ContainerUtil.quickSort(filteredNewInfos, UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS);
      SweepProcessor.Generator<HighlightInfo> generator = processor -> ContainerUtil.process(filteredNewInfos, processor);
      List<HighlightInfo> infosToCreateHighlightersFor = new ArrayList<>(filteredNewInfos.size());
      SweepProcessor.sweep(generator, (__, info, atStart, overlappingIntervals) -> {
        if (!atStart) {
          return true;
        }

        if (!UpdateHighlightersUtil.isWarningCoveredByError(info, severityRegistrar, overlappingIntervals)) {
          // have to create RangeHighlighter later, to avoid exposing them to the markup model immediately,
          // thus messing the HighlightInfo.getStartOffset() leading to "sweep generator supplied infos in a wrong order" exception
          infosToCreateHighlightersFor.add(info);
          changed[0] = true;
        }
        return true;
      });
      for (HighlightInfo info : infosToCreateHighlightersFor) {
        if (info.isFileLevelAnnotation()) {
          RangeHighlighterEx salvagedHighlighter = toReuse.pickupHighlighterFromGarbageBin(0, psiFile.getTextLength(), -409423948);
          HighlightInfo oldFileInfo = salvagedHighlighter == null ? null : HighlightInfo.fromRangeHighlighter(salvagedHighlighter);
          if (oldFileInfo != null) {
            session.removeFileLevelHighlight(oldFileInfo);
            salvagedHighlighter = null;
          }
          session.addFileLevelHighlight(info, salvagedHighlighter);
        }
        else {
          BackgroundUpdateHighlightersUtil.createOrReuseHighlighterFor(info, session.getColorsScheme(), document, Pass.LOCAL_INSPECTIONS,
                                                                       psiFile, markup, toReuse, range2markerCache, severityRegistrar);
        }
        result.add(info);
      }
      changed[0] |= UpdateHighlightersUtil.incinerateObsoleteHighlighters(toReuse, session);
    }
    finally {
      toReuse.releaseHighlighters();
    }

    if (changed[0]) {
      UpdateHighlightersUtil.clearWhiteSpaceOptimizationFlag(document);
    }
    return result;
  }


  void infoAddedIncrementally(@NotNull HighlightInfo info, @NotNull PsiFile psiFile) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("infoAddedIncrementally "+info +" to "+psiFile);
    }
    // just register it in the data structure to help maintaining consistent state
    List<HighlightInfo> storedInfos = getList(info.toolId, psiFile);
    synchronized (storedInfos) {
      int i = ObjectUtils.binarySearch(0, storedInfos.size(),
                                       mid -> UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS.compare(storedInfos.get(mid), info));
      if (i < 0) {
        storedInfos.add(-i-1, info);
      }
    }
  }

  // remove all highlight infos generated by tools absent in data
  void removeObsoleteTools(@NotNull Set<? extends Pair<Object, PsiFile>> ids, @NotNull HighlightingSessionImpl session) {
    HighlightersRecycler recycler = new HighlightersRecycler();
    data.entrySet().removeIf(entry -> {
      Pair<Object, PsiFile> id = entry.getKey();
      if (UNKNOWN_ID.equals(id.first) || !(id.first instanceof String)) {
        return false;
      }
      if (ids.contains(id)) {
        return false;
      }
      for (HighlightInfo info : entry.getValue()) {
        RangeHighlighterEx highlighter = info.highlighter;
        if (highlighter != null) {
          recycler.recycleHighlighter(highlighter);
        }
      }
      return true;
    });
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeObsoleteTools: found "+recycler.forAllInGarbageBin());
    }
    UpdateHighlightersUtil.incinerateObsoleteHighlighters(recycler, session);
  }

  void removeWarningsInsideErrors(@NotNull HighlightingSessionImpl session) {
    HighlightersRecycler recycler = new HighlightersRecycler();
    List<HighlightInfo> sorted =
      ContainerUtil.sorted(ContainerUtil.flatten(data.values()), UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS);

    SweepProcessor.Generator<HighlightInfo> generator = processor -> ContainerUtil.process(sorted, processor);
    SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(session.getProject());
    SweepProcessor.sweep(generator, (__, info, atStart, overlappingIntervals) -> {
      if (!atStart) {
        return true;
      }
      if (info.isFileLevelAnnotation()) {
        return true;
      }

      if (UpdateHighlightersUtil.isWarningCoveredByError(info, severityRegistrar, overlappingIntervals)) {
        RangeHighlighterEx highlighter = info.getHighlighter();
        if (highlighter != null) {
          recycler.recycleHighlighter(highlighter);
        }
      }
      return true;
    });
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeWarningsInsideErrors: found "+recycler.forAllInGarbageBin());
    }
    UpdateHighlightersUtil.incinerateObsoleteHighlighters(recycler, session);
  }
}
