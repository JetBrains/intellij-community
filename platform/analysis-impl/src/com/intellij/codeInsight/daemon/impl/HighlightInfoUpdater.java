// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.codeInsight.daemon.impl;

import com.intellij.codeInspection.LocalInspectionTool;
import com.intellij.codeInspection.LocalInspectionToolSession;
import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.codeInspection.ex.LocalInspectionToolWrapper;
import com.intellij.lang.ASTNode;
import com.intellij.lang.Language;
import com.intellij.lang.annotation.HighlightSeverity;
import com.intellij.lang.injection.InjectedLanguageManager;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.RangeMarker;
import com.intellij.openapi.editor.ex.MarkupModelEx;
import com.intellij.openapi.editor.ex.RangeHighlighterEx;
import com.intellij.openapi.editor.impl.DocumentMarkupModel;
import com.intellij.openapi.editor.impl.SweepProcessor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.fileEditor.FileEditorManagerListener;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.Key;
import com.intellij.openapi.util.Pair;
import com.intellij.openapi.util.TextRange;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.*;
import com.intellij.psi.scope.PsiScopeProcessor;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.search.SearchScope;
import com.intellij.util.ArrayUtil;
import com.intellij.util.containers.ContainerUtil;
import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service(Service.Level.PROJECT)
final class HighlightInfoUpdater {
  private static final Logger LOG = Logger.getInstance(HighlightInfoUpdater.class);
  private static final Object UNKNOWN_ID = "unknownId";
  // containing File -> tool id -> map of (visited PsiElement -> list of HighlightInfos generated by this tool while visiting that PsiElement)
  private final Map<PsiFile, Map<Object, ToolHighlights>> data = new ConcurrentHashMap<>();

  static class ToolHighlights {
    final Map<PsiElement, List<? extends HighlightInfo>> elementHighlights = new ConcurrentHashMap<>();
    @NotNull ToolLatencies latencies = new ToolLatencies(0,0,0);
  }
  record ToolLatencies(
      long errorLatency, // latency of the first error, in nanoseconds (or 0 if none)
      long warningLatency, // latency of the first warning, in nanoseconds (or 0 if none)
      long otherLatency // latency of the first other info, in nanoseconds (or 0 if none)
  ) {
    int compareLatencies(@NotNull ToolLatencies other) {
      int o = cmp(errorLatency, other.errorLatency);
      if (o != 0) return o;
      o = cmp(warningLatency, other.warningLatency);
      if (o != 0) return o;
      o = cmp(otherLatency, other.otherLatency);
      return o;
    }
    int cmp(long lat1, long lat2) {
      return Long.compare(lat1 == 0 ? Long.MAX_VALUE : lat1, lat2 == 0 ? Long.MAX_VALUE : lat2);
    }
  }

  HighlightInfoUpdater(Project project) {
    project.getMessageBus().connect().subscribe(FileEditorManagerListener.FILE_EDITOR_MANAGER, new FileEditorManagerListener() {
      @Override
      public void fileClosed(@NotNull FileEditorManager manager, @NotNull VirtualFile file) {
        if (manager.getAllEditors(file).length == 0) {
          FileViewProvider provider = PsiManager.getInstance(project).findCachedViewProvider(file);
          if (provider != null) {
            PsiFile psiFile = provider.getAllFiles().get(0);
            data.remove(psiFile);
          }
        }
      }
    });
  }

  @NotNull
  HighlightersRecycler removeOrRecycleInvalidPsiElements(@NotNull PsiFile psiFile) {
    data.entrySet().removeIf(entry -> {
      PsiFile psi = entry.getKey();
      if (psi == psiFile || psi.isValid()) {
        return false;
      }
      Map<Object, ToolHighlights> map = entry.getValue();
      int removed = 0;
      for (ToolHighlights highlights : map.values()) {
        for (List<? extends HighlightInfo> list : highlights.elementHighlights.values()) {
          for (HighlightInfo info : list) {
            RangeHighlighterEx highlighter = info.highlighter;
            if (highlighter != null) {
              highlighter.dispose();
              removed++;
            }
          }
        }
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("removeOrRecycleInvalidPsiElements: removed invalid file: "+psi+" ("+removed+" highlighters removed)");
      }
      return true;
    });
    HighlightersRecycler toReuse = new HighlightersRecycler();
    Map<Object, ToolHighlights> map = data.get(psiFile);
    if (map == null) {
      return toReuse;
    }
    for (Map.Entry<Object, ToolHighlights> toolEntry: map.entrySet()) {
      ToolHighlights toolHighlights = toolEntry.getValue();
      toolHighlights.elementHighlights.entrySet().removeIf(entry -> {
        PsiElement psiElement = entry.getKey();
        if (psiElement == FAKE_ELEMENT || psiElement.isValid()) {
          return false;
        }
        for (HighlightInfo info : entry.getValue()) {
          RangeHighlighterEx highlighter = info.getHighlighter();
          if (highlighter != null) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("removeOrRecycleInvalidPsiElements: recycle " + info + " for " + psiElement);
            }
            toReuse.recycleHighlighter(highlighter);
          }
        }
        return true;
      });
    }
    return toReuse;
  }

  public static HighlightInfoUpdater getInstance(Project project) {
    return project.getService(HighlightInfoUpdater.class);
  }

  private void putInfosForVisitedPsi(@NotNull PsiFile psiFile,
                                     @NotNull @NonNls Object toolId,
                                     @NotNull PsiElement visitedPsi,
                                     @NotNull List<? extends HighlightInfo> newInfos) {
    Map<Object, ToolHighlights> map = data.computeIfAbsent(psiFile, __ -> new ConcurrentHashMap<>());
    ToolHighlights toolHighlights;
    if (newInfos.isEmpty()) {
      toolHighlights = map.get(toolId);
      if (toolHighlights != null) {
        toolHighlights.elementHighlights.remove(visitedPsi);
      }
    }
    else {
      toolHighlights = map.computeIfAbsent(toolId, __ -> new ToolHighlights());
      toolHighlights.elementHighlights.put(visitedPsi, newInfos);
    }
  }
  @NotNull
  private List<? extends HighlightInfo> getInfosForVisitedPsi(@NotNull PsiFile psiFile,
                                                              @NotNull @NonNls Object toolId,
                                                              @NotNull PsiElement visitedPsi) {
    Map<Object, ToolHighlights> map = data.get(psiFile);
    ToolHighlights toolHighlights = map == null ? null : map.get(toolId);
    List<? extends HighlightInfo> oldInfos = toolHighlights == null ? null : toolHighlights.elementHighlights.get(visitedPsi);
    return oldInfos == null ? Collections.emptyList() : oldInfos;
  }

  /**
   * Tool {@code toolId} has generated (maybe empty) {@code newInfos} highlights during visiting PsiElement {@code visitedPsiElement}.
   * Remove all highlights that this tool had generated earlier during visiting this psi element, and replace them with {@code newInfosGenerated}
   */
  void psiElementVisited(@NotNull Object toolId,
                         @NotNull PsiElement visitedPsiElement,
                         @NotNull List<? extends HighlightInfo> newInfos,
                         @NotNull Document hostDocument,
                         @NotNull PsiFile psiFile,
                         @NotNull Project project,
                         @NotNull HighlightersRecycler invalidElementRecycler,
                         @NotNull HighlightingSession session) {
    List<? extends HighlightInfo> oldInfos = getInfosForVisitedPsi(psiFile, toolId, visitedPsiElement);
    synchronized (oldInfos) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("psiElementVisited: " + visitedPsiElement+ " in "+psiFile+" injected in "+InjectedLanguageManager.getInstance(project).injectedToHost(psiFile, psiFile.getTextRange())+
                  "; tool:" + toolId + "; infos:" + newInfos+ "; oldInfos:" + oldInfos + "; document:" + hostDocument);
      }

      if (!oldInfos.isEmpty() || !newInfos.isEmpty()) {
        MarkupModelEx markup = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);
        setHighlightersInRange(newInfos, oldInfos, markup, session, invalidElementRecycler);
      }
    }
    // store back only after markup model changes are applied to avoid PCE thrown in the middle leaving corrupted data behind
    putInfosForVisitedPsi(psiFile, toolId, visitedPsiElement, newInfos);
  }

  private static void setHighlightersInRange(@NotNull List<? extends HighlightInfo> newInfos,
                                             @NotNull List<? extends HighlightInfo> oldInfos,
                                             @NotNull MarkupModelEx markup,
                                             @NotNull HighlightingSession session,
                                             @NotNull HighlightersRecycler invalidElementRecycler) {
    ApplicationManager.getApplication().assertIsNonDispatchThread();
    ApplicationManager.getApplication().assertReadAccessAllowed();
    PsiFile psiFile = session.getPsiFile();
    Project project = session.getProject();
    SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(project);
    HighlightersRecycler toReuse = new HighlightersRecycler();
    Document document = session.getDocument();
    Long2ObjectMap<RangeMarker> range2markerCache = new Long2ObjectOpenHashMap<>(10);
    boolean changed;
    try {
      for (HighlightInfo oldInfo : oldInfos) {
        RangeHighlighterEx oldHighlighter = oldInfo.getHighlighter();
        if (oldHighlighter != null) {
          toReuse.recycleHighlighter(oldHighlighter);
        }
      }

      // use both `toReuse` and `invalidElementRecycler` to pickup the recycled highlighter, but prefer the former
      HighlighterRecyclerPickup composite = (startOffset, endOffset, layer) -> {
        RangeHighlighterEx ex = toReuse.pickupHighlighterFromGarbageBin(startOffset, endOffset, layer);
        if (ex != null) return ex;
        return invalidElementRecycler.pickupHighlighterFromGarbageBin(startOffset, endOffset, layer);
      };
      for (HighlightInfo info : newInfos) {
        if (info.isFileLevelAnnotation()) {
          RangeHighlighterEx salvagedHighlighter = composite.pickupHighlighterFromGarbageBin(0, psiFile.getTextLength(), -409423948);
          HighlightInfo oldFileInfo = salvagedHighlighter == null ? null : HighlightInfo.fromRangeHighlighter(salvagedHighlighter);
          if (oldFileInfo != null) {
            session.removeFileLevelHighlight(oldFileInfo);
            salvagedHighlighter = null;
          }
          session.addFileLevelHighlight(info, salvagedHighlighter);
        }
        else {
          BackgroundUpdateHighlightersUtil.createOrReuseHighlighterFor(info, session.getColorsScheme(), document, -1,
                                                                       psiFile, markup, composite, range2markerCache, severityRegistrar);
        }
      }
      // remove highlighters recycled from the local psi element, but do not touch invalidElementRecycler just yet
      changed = UpdateHighlightersUtil.incinerateObsoleteHighlighters(toReuse, session);
    }
    finally {
      toReuse.releaseHighlighters();
    }

    if (changed) {
      UpdateHighlightersUtil.clearWhiteSpaceOptimizationFlag(document);
    }
  }


  // remove all highlight infos from `data` generated by tools absent in 'actualToolsRun'
  void recycleHighlightsForObsoleteTools(@NotNull PsiFile containingFile,
                                         @NotNull Set<? extends Pair<Object, PsiFile>> actualToolsRun,
                                         @NotNull HighlightersRecycler recycler) {
    for (Map.Entry<PsiFile, Map<Object, ToolHighlights>> entry : data.entrySet()) {
      PsiFile psiFile = entry.getKey();
      if (InjectedLanguageManager.getInstance(psiFile.getProject()).getTopLevelFile(psiFile) != containingFile) {
        continue;
      }

      entry.getValue().keySet().removeIf(toolId -> {
        if (UNKNOWN_ID.equals(toolId) || !isInspectionToolId(toolId)) {
          return false;
        }

        if (actualToolsRun.contains(Pair.create(toolId, psiFile))) {
          return false;
        }
        ToolHighlights toolHighlights = entry.getValue().get(toolId);
        for (List<? extends HighlightInfo> highlights : toolHighlights.elementHighlights.values()) {
          for (HighlightInfo info : highlights) {
            RangeHighlighterEx highlighter = info.highlighter;
            if (highlighter != null) {
              recycler.recycleHighlighter(highlighter);
            }
          }
        }
        return true;
      });
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeObsoleteTools: found "+recycler.forAllInGarbageBin());
    }
  }

  private static boolean isInspectionToolId(Object toolId) {
    return toolId instanceof String;
  }

  // TODO very dirty method which throws all incrementality away, but we'd need to rewrite too many inspections to get rid of it
  void removeWarningsInsideErrors(@NotNull HighlightingSessionImpl session) {
    HighlightersRecycler recycler = new HighlightersRecycler();
    for (Map.Entry<PsiFile, Map<Object, ToolHighlights>> entry : data.entrySet()) {
      PsiFile psiFile = entry.getKey();
      if (InjectedLanguageManager.getInstance(session.getProject()).getTopLevelFile(psiFile) != session.getPsiFile()) {
        continue;
      }
      Map<Object, ToolHighlights> map = entry.getValue();
      if (map == null) {
        continue;
      }
      List<? extends HighlightInfo> sorted = map.entrySet().stream()
        .filter(e -> isInspectionToolId(e.getKey())) // inspections only
        .flatMap(e -> e.getValue().elementHighlights.values().stream())
        .flatMap(l->l.stream())
        .sorted(UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS)
        .toList();
      SweepProcessor.Generator<HighlightInfo> generator = processor -> ContainerUtil.process(sorted, processor);
      SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(session.getProject());
      SweepProcessor.sweep(generator, (__, info, atStart, overlappingIntervals) -> {
        if (!atStart) {
          return true;
        }
        if (info.isFileLevelAnnotation()) {
          return true;
        }

        // TODO uncomment if duplicates need to be removed automatically
        // Currently they are not, to manifest incorrectly written inspections/annotators earlier
        if (UpdateHighlightersUtil.isWarningCoveredByError(info, severityRegistrar, overlappingIntervals)/* || overlappingIntervals.contains(info)*/) {
          RangeHighlighterEx highlighter = info.getHighlighter();
          if (highlighter != null) {
            recycler.recycleHighlighter(highlighter);

            ToolHighlights elementHighlights = map.get(info.toolId);
            for (Map.Entry<PsiElement, List<? extends HighlightInfo>> elementEntry : elementHighlights.elementHighlights.entrySet()) {
              List<? extends HighlightInfo> infos = elementEntry.getValue();
              int i = infos.indexOf(info);
              if (i != -1) {
                elementEntry.setValue(ContainerUtil.concat(infos.subList(0,i), infos.subList(i+1, infos.size())));
                break;
              }
            }
          }
        }
        return true;
      });
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeWarningsInsideErrors: found "+recycler.forAllInGarbageBin());
    }
    UpdateHighlightersUtil.incinerateObsoleteHighlighters(recycler, session);
  }

  /**
   * after inspections completed, save their latencies (from corresponding {@link InspectionRunner.InspectionContext#holder})
   * to use later in {@link com.intellij.codeInsight.daemon.impl.InspectionProfilerDataHolder#sortByLatencies(PsiFile, List)}
   */
  void saveLatencies(@NotNull PsiFile psiFile, @NotNull Map<Object, ToolLatencies> latencies) {
    if (!psiFile.getViewProvider().isPhysical()) {
      // ignore editor text fields/consoles etc
      return;
    }
    Map<Object, ToolHighlights> map = data.get(psiFile);
    if (map == null) return;
    for (Map.Entry<Object, ToolLatencies> entry : latencies.entrySet()) {
      Object toolId = entry.getKey();
      ToolHighlights toolHighlights = map.get(toolId);
      // no point saving latencies if nothing was reported
      if (toolHighlights == null) continue;
      ToolLatencies lats = entry.getValue();
      toolHighlights.latencies = new ToolLatencies(merge(toolHighlights.latencies.errorLatency, lats.errorLatency),
                                                   merge(toolHighlights.latencies.warningLatency, lats.warningLatency),
                                                   merge(toolHighlights.latencies.otherLatency, lats.otherLatency));
    }
  }

  private static long merge(long oldL, long newL) {
    return oldL == 0 || newL == 0 ? oldL+newL : Math.min(oldL, newL);
  }

  int compareLatencies(@NotNull PsiFile psiFile, @NotNull String toolId1, @NotNull String toolId2) {
    Map<Object, ToolHighlights> map = data.get(psiFile);
    if (map == null) return 0;
    ToolHighlights toolHighlights1 = map.get(toolId1);
    ToolHighlights toolHighlights2 = map.get(toolId2);
    if (toolHighlights1 == null) {
      return toolHighlights2 == null ? 0 : 1;
    }
    if (toolHighlights2 == null) {
      return -1;
    }
    return toolHighlights1.latencies.compareLatencies(toolHighlights2.latencies);
  }

  /**
   * sort `elements` by the number of produced diagnostics:
   *  - put first the elements for which this `toolWrapper` has produced some diagnostics on previous run
   *    - in case of a tie, put elements which generated higher severity diagnostics first
   *  - followed by all other elements
   */
  @NotNull
  List<? extends PsiElement> sortByPsiElementFertility(@NotNull PsiFile psiFile, @NotNull LocalInspectionToolWrapper toolWrapper, @NotNull List<? extends PsiElement> elements) {
    String toolId = toolWrapper.getShortName();
    Map<Object, ToolHighlights> map = data.get(psiFile);
    if (map == null) return elements;
    ToolHighlights toolHighlights = map.get(toolId);
    if (toolHighlights == null) return elements;
    Map<PsiElement, List<? extends HighlightInfo>> highlights = toolHighlights.elementHighlights;
    if (highlights.isEmpty()) return elements;
    List<PsiElement> sorted = new ArrayList<>(elements);
    sorted.sort((e1, e2) -> {
      List<? extends HighlightInfo> infos1 = highlights.get(e1);
      List<? extends HighlightInfo> infos2 = highlights.get(e2);
      if ((infos1 == null) != (infos2 == null)) {
        return infos1 == null ? 1 : -1; // put fertile element first
      }
      if (infos1 == null) {
        return Integer.compare(System.identityHashCode(e1), System.identityHashCode(e2)); // for consistency
      }
      // put error-generating element first
      return maxSeverity(infos2).compareTo(maxSeverity(infos1));
    });
    return sorted;
  }

  @NotNull
  private HighlightSeverity maxSeverity(@NotNull List<? extends HighlightInfo> infos) {
    HighlightSeverity max = HighlightSeverity.INFORMATION;
    for (HighlightInfo info : infos) {
      HighlightSeverity severity = info.getSeverity();
      if (severity.compareTo(max) > 0) max = severity;
    }
    return max;
  }

  /**
   * We associate each HighlightInfo with the PSI element for which the inspection builder has produced that info.
   * Unfortunately, there are some crazy inspections that produce infos in their {@link LocalInspectionTool#inspectionFinished(LocalInspectionToolSession, ProblemsHolder)} method instead.
   * Which is very slow, because that highlight info won't be displayed until the entire file is visited.
   * For these infos the associated PSI element is assumed to be this {@link #FAKE_ELEMENT}
   */
  static final PsiElement FAKE_ELEMENT = new PsiElement() {
      @Override
      public @NotNull Project getProject() {
        throw createException();
      }

      @Override
      public @NotNull Language getLanguage() {
        throw createException();
      }

      @Override
      public PsiManager getManager() {
        throw createException();
      }

      @Override
      public PsiElement @NotNull [] getChildren() {
        return EMPTY_ARRAY;
      }

      @Override
      public PsiElement getParent() {
        return null;
      }

      @Override
      public @Nullable PsiElement getFirstChild() {
        return null;
      }

      @Override
      public @Nullable PsiElement getLastChild() {
        return null;
      }

      @Override
      public @Nullable PsiElement getNextSibling() {
        return null;
      }

      @Override
      public @Nullable PsiElement getPrevSibling() {
        return null;
      }

      @Override
      public PsiFile getContainingFile() {
        return null;
      }

      @Override
      public TextRange getTextRange() {
        return TextRange.EMPTY_RANGE;
      }

      @Override
      public int getStartOffsetInParent() {
        return -1;
      }

      @Override
      public int getTextLength() {
        return 0;
      }

      @Override
      public PsiElement findElementAt(int offset) {
        return null;
      }

      @Override
      public @Nullable PsiReference findReferenceAt(int offset) {
        return null;
      }

      @Override
      public int getTextOffset() {
        return 0;
      }

      @Override
      public String getText() {
        return "";
      }

      @Override
      public char @NotNull [] textToCharArray() {
        return ArrayUtil.EMPTY_CHAR_ARRAY;
      }

      @Override
      public PsiElement getNavigationElement() {
        return null;
      }

      @Override
      public PsiElement getOriginalElement() {
        return null;
      }

      @Override
      public boolean textMatches(@NotNull CharSequence text) {
        return false;
      }

      @Override
      public boolean textMatches(@NotNull PsiElement element) {
        return false;
      }

      @Override
      public boolean textContains(char c) {
        return false;
      }

      @Override
      public void accept(@NotNull PsiElementVisitor visitor) {

      }

      @Override
      public void acceptChildren(@NotNull PsiElementVisitor visitor) {

      }

      @Override
      public PsiElement copy() {
        return null;
      }

      @Override
      public PsiElement add(@NotNull PsiElement element) {
        throw createException();
      }

      @Override
      public PsiElement addBefore(@NotNull PsiElement element, PsiElement anchor) {
        throw createException();
      }

      @Override
      public PsiElement addAfter(@NotNull PsiElement element, PsiElement anchor) {
        throw createException();
      }

      @Override
      public void checkAdd(@NotNull PsiElement element) {
        throw createException();
      }

      @Override
      public PsiElement addRange(PsiElement first, PsiElement last) {
        throw createException();
      }

      @Override
      public PsiElement addRangeBefore(@NotNull PsiElement first, @NotNull PsiElement last, PsiElement anchor) {
        throw createException();
      }

      @Override
      public PsiElement addRangeAfter(PsiElement first, PsiElement last, PsiElement anchor) {
        throw createException();
      }

      @Override
      public void delete() {
        throw createException();
      }

      @Override
      public void checkDelete() {
        throw createException();
      }

      @Override
      public void deleteChildRange(PsiElement first, PsiElement last) {
        throw createException();
      }

      @Override
      public PsiElement replace(@NotNull PsiElement newElement) {
        throw createException();
      }

      @Override
      public boolean isValid() {
        return true;
      }

      @Override
      public boolean isWritable() {
        return false;
      }

      PsiInvalidElementAccessException createException() {
        return new PsiInvalidElementAccessException(this, toString(), null);
      }

      @Override
      public @Nullable PsiReference getReference() {
        return null;
      }

      @Override
      public PsiReference @NotNull [] getReferences() {
        return PsiReference.EMPTY_ARRAY;
      }

      @Override
      public <T> T getCopyableUserData(@NotNull Key<T> key) {
        throw createException();
      }

      @Override
      public <T> void putCopyableUserData(@NotNull Key<T> key, T value) {
        throw createException();
      }

      @Override
      public boolean processDeclarations(@NotNull PsiScopeProcessor processor,
                                         @NotNull ResolveState state,
                                         PsiElement lastParent,
                                         @NotNull PsiElement place) {
        return false;
      }

      @Override
      public PsiElement getContext() {
        return null;
      }

      @Override
      public boolean isPhysical() {
        return true;
      }

      @Override
      public @NotNull GlobalSearchScope getResolveScope() {
        throw createException();
      }

      @Override
      public @NotNull SearchScope getUseScope() {
        throw createException();
      }

      @Override
      public ASTNode getNode() {
        throw createException();
      }

      @Override
      public <T> T getUserData(@NotNull Key<T> key) {
        throw createException();
      }

      @Override
      public <T> void putUserData(@NotNull Key<T> key, T value) {
        throw createException();
      }

      @Override
      public Icon getIcon(int flags) {
        throw createException();
      }

      @Override
      public boolean isEquivalentTo(final PsiElement another) {
        return this == another;
      }

      @Override
      public String toString() {
        return "FAKE_PSI_ELEMENT";
      }
    };
}
