// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.codeInsight.daemon.impl;

import com.intellij.codeInspection.LocalInspectionTool;
import com.intellij.codeInspection.LocalInspectionToolSession;
import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.codeInspection.ex.LocalInspectionToolWrapper;
import com.intellij.injected.editor.DocumentWindow;
import com.intellij.lang.ASTNode;
import com.intellij.lang.Language;
import com.intellij.lang.annotation.Annotator;
import com.intellij.lang.annotation.HighlightSeverity;
import com.intellij.lang.injection.InjectedLanguageManager;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.RangeMarker;
import com.intellij.openapi.editor.colors.EditorColorsUtil;
import com.intellij.openapi.editor.ex.MarkupModelEx;
import com.intellij.openapi.editor.ex.RangeHighlighterEx;
import com.intellij.openapi.editor.impl.DocumentMarkupModel;
import com.intellij.openapi.editor.impl.SweepProcessor;
import com.intellij.openapi.editor.markup.RangeHighlighter;
import com.intellij.openapi.editor.markup.TextAttributes;
import com.intellij.openapi.progress.ProgressManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.*;
import com.intellij.openapi.util.text.StringUtil;
import com.intellij.psi.*;
import com.intellij.psi.impl.PsiManagerEx;
import com.intellij.psi.impl.file.impl.FileManagerImpl;
import com.intellij.psi.impl.source.tree.injected.InjectedFileViewProvider;
import com.intellij.psi.scope.PsiScopeProcessor;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.search.SearchScope;
import com.intellij.psi.util.PsiUtilCore;
import com.intellij.util.ArrayUtil;
import com.intellij.util.ConcurrencyUtil;
import com.intellij.util.DocumentUtil;
import com.intellij.util.containers.CollectionFactory;
import com.intellij.util.containers.ContainerUtil;
import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Consumer;

@Service(Service.Level.PROJECT)
final class HighlightInfoUpdaterImpl extends HighlightInfoUpdater implements Disposable {
  static final Logger LOG = Logger.getInstance(HighlightInfoUpdaterImpl.class);
  private static final Object UNKNOWN_ID = "unknownId";

  // containing File -> tool id -> map of (visited PsiElement -> list of HighlightInfos generated by this tool while visiting that PsiElement)
  private static final Key<Map<PsiFile, Map<Object, ToolHighlights>>> VISITED_PSI_ELEMENTS = Key.create("VISITED_PSI_ELEMENTS");

  private static class ToolHighlights {
    @NotNull
    final ConcurrentMap<PsiElement, List<? extends HighlightInfo>> elementHighlights = CollectionFactory.createConcurrentSoftMap((map,evicted) -> {
      if (evicted != null) {
        removeEvicted(map, evicted);
      }
    });
    @NotNull
    ToolLatencies latencies = new ToolLatencies(0,0,0);
  }
  record ToolLatencies(
      long errorLatency, // latency of the first error, in nanoseconds (or 0 if none)
      long warningLatency, // latency of the first warning, in nanoseconds (or 0 if none)
      long otherLatency // latency of the first other info, in nanoseconds (or 0 if none)
  ) {
    int compareLatencies(@NotNull ToolLatencies other) {
      int o = cmp(errorLatency, other.errorLatency);
      if (o != 0) return o;
      o = cmp(warningLatency, other.warningLatency);
      if (o != 0) return o;
      o = cmp(otherLatency, other.otherLatency);
      return o;
    }
    static int cmp(long lat1, long lat2) {
      return Long.compare(lat1 == 0 ? Long.MAX_VALUE : lat1, lat2 == 0 ? Long.MAX_VALUE : lat2);
    }
  }

  HighlightInfoUpdaterImpl(Project project) {
    FileManagerImpl fileManager = (FileManagerImpl)PsiManagerEx.getInstanceEx(project).getFileManager();
    Disposer.register(this, () ->
      fileManager.forEachCachedDocument(document -> document.putUserData(VISITED_PSI_ELEMENTS, null)));
  }

  @Override
  public void dispose() {
  }

  private static void removeEvicted(@NotNull ConcurrentMap<PsiElement, List<? extends HighlightInfo>> map, @NotNull List<? extends HighlightInfo> evicted) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeEvicted: " + evicted);
    }
    // all evicted HighlightInfos will be stored in this map[PsiUtilCore.NULL_PSI_ELEMENT], to be disposed later, in recycleInvalidPsiElements(), when the HighlightSession is available
    List<HighlightInfo> storedEvictedHighlightInfos = Collections.synchronizedList(new ArrayList<>());
    storedEvictedHighlightInfos = (List<HighlightInfo>)ConcurrencyUtil.cacheOrGet(map, PsiUtilCore.NULL_PSI_ELEMENT, storedEvictedHighlightInfos);
    storedEvictedHighlightInfos.addAll(evicted);
  }

  @NotNull
  private static Map<Object, ToolHighlights> getData(@NotNull PsiFile psiFile) {
    PsiFile hostFile = InjectedLanguageManager.getInstance(psiFile.getProject()).getTopLevelFile(psiFile);
    Document hostDocument = hostFile.getFileDocument(); // store in the document because DocumentMarkupModel is associated with this document
    return getData(psiFile, hostDocument);
  }

  private static @NotNull Map<Object, ToolHighlights> getData(@NotNull PsiFile psiFile, @NotNull Document hostDocument) {
    Map<PsiFile, Map<Object, ToolHighlights>> map = getOrCreateHostMap(hostDocument);
    Map<Object, ToolHighlights> result = map.get(psiFile);
    if (result == null) {
      result = map.computeIfAbsent(psiFile, __->new ConcurrentHashMap<>());
    }
    return result;
  }

  private static @NotNull Map<PsiFile, Map<Object, ToolHighlights>> getOrCreateHostMap(@NotNull Document hostDocument) {
    Map<PsiFile, Map<Object, ToolHighlights>> map = hostDocument.getUserData(VISITED_PSI_ELEMENTS);
    if (map == null) {
      map = ((UserDataHolderEx)hostDocument).putUserDataIfAbsent(VISITED_PSI_ELEMENTS, CollectionFactory.createConcurrentSoftMap((__, oldMap) -> {
        if (oldMap != null) {
          removeEvictedFile(oldMap);
        }
      }));
    }
    invokeProcessQueueToTriggerEvictedListener(map);
    return map;
  }

  private static void invokeProcessQueueToTriggerEvictedListener(@NotNull Map<? extends PsiElement, ?> map) {
    Object v = map.remove(PsiUtilCore.NULL_PSI_FILE); // to invoke processQueue() and call evictionListener if needed
    assert null == v : v;
  }

  private static void removeEvictedFile(@NotNull Map<Object, ToolHighlights> map) {
    for (ToolHighlights toolHighlights : map.values()) {
      invokeProcessQueueToTriggerEvictedListener(toolHighlights.elementHighlights);
      for (List<? extends HighlightInfo> infos : toolHighlights.elementHighlights.values()) {
        removeEvicted(toolHighlights.elementHighlights, infos);
      }
    }
  }

  @Override
  synchronized void removeInfosForInjectedFilesOtherThan(@NotNull PsiFile hostPsiFile,
                                                         @NotNull TextRange restrictRange,
                                                         @NotNull HighlightingSession highlightingSession,
                                                         @NotNull Collection<? extends PsiFile> liveInjectedFiles) {
    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(hostPsiFile.getProject());
    Document hostDocument = hostPsiFile.getFileDocument();
    Map<PsiFile, Map<Object, ToolHighlights>> hostMap = getOrCreateHostMap(hostDocument);
    hostMap.entrySet().removeIf(entry -> {
      PsiFile psiFile = entry.getKey();
      Map<Object, ToolHighlights> toolMap = entry.getValue();
      boolean shouldRemove = injectedLanguageManager.isInjectedFragment(psiFile) &&
                  !liveInjectedFiles.contains(psiFile) &&
                  restrictRange.contains(injectedLanguageManager.injectedToHost(psiFile, psiFile.getTextRange()));
      if (shouldRemove) {
        removeAllHighlighterInsideFile(psiFile, this, highlightingSession, toolMap);
        return true;
      }
      return false;
    });
  }

  // dispose all range highlighters from recycler while removing corresponding (invalid) PSI elements from the data
  private synchronized void incinerateAndRemoveInvalidPsiHighlightersFromDataAtomically(@NotNull Document hostDocument,
                                                                                        @NotNull PsiFile psiFile,
                                                                                        @NotNull List<? extends InvalidPsi> invalidPsiElements,
                                                                                        @NotNull HighlighterRecycler invalidPsiRecycler) {
    // remove highlighters which were reused or incinerated from the HighlightInfoUpdater's maps
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeInvalidPsiHighlightersFromData: invalidPsiElements (" + invalidPsiElements.size() + "): " +
                invalidPsiElements + "; progress=" + System.identityHashCode(ProgressManager.getGlobalProgressIndicator())+(ProgressManager.getGlobalProgressIndicator() == null ? "?" : ProgressManager.getGlobalProgressIndicator().isCanceled() ? "X" : "V"));
    }

    Map<Object, ToolHighlights> data = getData(psiFile, hostDocument); // assume recycle contains things from one psi file from one HighlightingSession
    for (InvalidPsi entry : invalidPsiElements) {
      RangeHighlighterEx highlighter = entry.highlighter();
      Object toolId = entry.toolId();
      PsiElement psiElement = entry.psiElement();
      incinerateAndRemoveFromDataAtomically(data, invalidPsiRecycler, highlighter, toolId, psiElement);
    }
  }

  private void incinerateAndRemoveFromDataAtomically(@NotNull Map<Object, ToolHighlights> data,
                                                     @NotNull HighlighterRecycler recycler,
                                                     @NotNull RangeHighlighterEx highlighter,
                                                     @NotNull Object toolId,
                                                     @NotNull PsiElement psiElement) {
    boolean disposed;
    if (recycler.remove(highlighter)) {
      disposed = recycler.tryIncinerate(highlighter);
    }
    else {
      disposed = false;
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeInvalidPsiHighlightersFromData: " + highlighter + "; disposed=" + disposed);
    }
    ToolHighlights toolHighlights = data.get(toolId);
    if (toolHighlights != null) {
      List<? extends HighlightInfo> oldInfos = toolHighlights.elementHighlights.get(psiElement);
      List<? extends HighlightInfo> newInfos = oldInfos == null ? List.of() : ContainerUtil.filter(oldInfos, info -> info.highlighter != highlighter);
      if (newInfos.isEmpty()) {
        toolHighlights.elementHighlights.remove(psiElement);
      }
      else {
        toolHighlights.elementHighlights.put(psiElement, newInfos);
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("removeInvalidPsiHighlightersFromData: " + highlighter + ": old=" + oldInfos + "; new=" + newInfos);
      }
    }
  }

  private record InvalidPsi(@NotNull Object toolId, @NotNull PsiElement psiElement, @NotNull RangeHighlighterEx highlighter) {}

  @NotNull
  private synchronized List<InvalidPsi> recycleInvalidPsiElements(@NotNull PsiFile psiFile,
                                                                  @NotNull Object requestor,
                                                                  @NotNull HighlightingSession session,
                                                                  @NotNull HighlighterRecycler invalidPsiRecycler,
                                                                  boolean inspectionOnlyPredicate //true: recycle highlighters from inspections only; false: recycle highlighters from non-inspections only
  ) {
    List<InvalidPsi> invalidPsiElements = new ArrayList<>();
    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(psiFile.getProject());
    PsiFile hostFile = injectedLanguageManager.getTopLevelFile(psiFile);
    Document hostDocument = hostFile.getFileDocument();
    Map<PsiFile, Map<Object, ToolHighlights>> hostMap = getOrCreateHostMap(hostDocument);
    List<Map<Object, ToolHighlights>> maps = new ArrayList<>();
    PsiDocumentManager documentManager = PsiDocumentManager.getInstance(hostFile.getProject());
    // for invalid files, remove all highlighters inside immediately, there's no chance they'll ever be reused
    hostMap.entrySet().removeIf(entry -> {
      PsiFile psi = entry.getKey();
      Map<Object, ToolHighlights> toolMap = entry.getValue();
      if (psi.isValid()) {
        Document document = documentManager.getDocument(psi);
        Document topLevelDocument = document instanceof DocumentWindow ? ((DocumentWindow)document).getDelegate() : document;
        if (topLevelDocument == hostDocument) {
          maps.add(toolMap);
        }
        return false;
      }
      if (psi == psiFile) {
        return false;
      }
      removeAllHighlighterInsideFile(psi, requestor, session, toolMap);
      return true;
    });
    TextRange compositeDocumentDirtyRange = session instanceof HighlightingSessionImpl impl ? impl.getCompositeDocumentDirtyRange() : TextRange.EMPTY_RANGE;

    for (Map<Object, ToolHighlights> map : maps) {
      if (map.isEmpty()) {
        continue;
      }
      for (Map.Entry<Object, ToolHighlights> toolEntry : map.entrySet()) {
        ToolHighlights toolHighlights = toolEntry.getValue();
        Object toolId = toolEntry.getKey();
        invokeProcessQueueToTriggerEvictedListener(toolHighlights.elementHighlights);
        if (inspectionOnlyPredicate != HighlightInfoUpdaterImpl.isInspectionToolId(toolId)) {
          continue;
        }
        toolHighlights.elementHighlights.entrySet().removeIf(entry -> {
          PsiElement element = entry.getKey();
          ProgressManager.checkCanceled();
          if (element == PsiUtilCore.NULL_PSI_ELEMENT/*evicted*/ || element != FAKE_ELEMENT && !element.isValid()) {
            List<? extends HighlightInfo> oldInfos = entry.getValue();
            List<? extends HighlightInfo> newInfos = ContainerUtil.filter(oldInfos, info -> {
              RangeHighlighterEx highlighter = info.getHighlighter();
              // heuristic: when the invalid PSI element is contained within the dirty range, kill it immediately (e.g. when the user is typing, a lot of red code happens under the caret)
              // OTOH, when the PSI element is invalidated outside the dirty range, it usually means the incremental reparse support is poor, and a lot of PSI is invalidated unnecessarily on each typing,
              //  meaning that that PSI has a big chance to be recreated in that exact place later, when a (major) chunk of the file is reparsed, so we do not kill that highlighter, just recycle it to avoid annoying blinking
              boolean shootAtFirstSight = highlighter == null || someWhereNear(compositeDocumentDirtyRange, highlighter);
              if (highlighter != null) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("recycleInvalidPsiElements: " + highlighter +
                            "; shootAtFirstSight="+shootAtFirstSight+
                            "; inspectionOnly="+inspectionOnlyPredicate+
                            " for invalid " + element + " from " + requestor +
                            "; progress=" + System.identityHashCode(ProgressManager.getGlobalProgressIndicator())+(ProgressManager.getGlobalProgressIndicator() == null ? "?" : ProgressManager.getGlobalProgressIndicator().isCanceled() ? "X" : "V"));
                }
                if (shootAtFirstSight) {
                  UpdateHighlightersUtil.disposeWithFileLevelIgnoreErrors(highlighter, info, session);
                }
                else {
                  invalidPsiRecycler.recycleHighlighter(highlighter);
                }
                invalidPsiElements.add(new InvalidPsi(toolId, element, highlighter));
              }
              return !shootAtFirstSight;
            });
            if (newInfos.isEmpty()) {
              return true;
            }
            if (newInfos.size() != oldInfos.size()) {
              entry.setValue(newInfos);
            }
          }
          return false;
        });
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("recycleInvalidPsiElements: result recycler(" +invalidPsiRecycler.forAllInGarbageBin().size()+")"+
                "=" + invalidPsiRecycler.forAllInGarbageBin()+
                "; invalidPsiElements="+invalidPsiElements+"; progress="+System.identityHashCode(ProgressManager.getGlobalProgressIndicator())+(ProgressManager.getGlobalProgressIndicator() == null ? "?" : ProgressManager.getGlobalProgressIndicator().isCanceled() ? "X" : "V"));
    }
    return invalidPsiElements;
  }

  // return true if the highlighter is near the dirty range,
  // in this case: the highlighter is inside dirty lines
  private static boolean someWhereNear(@NotNull TextRange dirtyRange, @NotNull RangeHighlighter highlighter) {
    Document document = highlighter.getDocument();
    int lineStartOffset = DocumentUtil.getLineStartOffset(dirtyRange.getStartOffset(), document);
    int lineEndOffset = DocumentUtil.getLineEndOffset(dirtyRange.getEndOffset(), document);
    return new TextRange(lineStartOffset, lineEndOffset).contains(highlighter);
  }

  private static void removeAllHighlighterInsideFile(@NotNull PsiFile psiFile,
                                                     @NotNull Object requestor,
                                                     @NotNull HighlightingSession highlightingSession,
                                                     @NotNull Map<Object, ToolHighlights> toolMap) {
    int removed = 0;
    for (ToolHighlights highlights : toolMap.values()) {
      for (List<? extends HighlightInfo> list : highlights.elementHighlights.values()) {
        for (HighlightInfo info : list) {
          RangeHighlighterEx highlighter = info.highlighter;
          if (highlighter != null) {
            UpdateHighlightersUtil.disposeWithFileLevelIgnoreErrors(highlighter, info, highlightingSession);
            removed++;
          }
        }
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeAllHighlighterInsideFile: removed invalid file: " + psiFile + " (" + removed + " highlighters removed); from " + requestor);
    }
  }

  private static void putInfosForVisitedPsi(@NotNull Map<Object, ToolHighlights> data,
                                            @NotNull @NonNls Object toolId,
                                            @NotNull PsiElement visitedPsi,
                                            @NotNull List<? extends HighlightInfo> newInfos,
                                            @Nullable ToolHighlights toolHighlights) {
    if (newInfos.isEmpty() || toolHighlights == null) {
      boolean toolEmpty;
      if (toolHighlights == null) {
        toolEmpty = true;
      }
      else {
        toolHighlights.elementHighlights.remove(visitedPsi);
        toolEmpty = toolHighlights.elementHighlights.isEmpty();
      }
      if (toolEmpty) {
        data.remove(toolId);
      }
    }
    else {
      toolHighlights.elementHighlights.put(visitedPsi, newInfos);
    }
  }

  /**
   * Tool {@code toolId} has generated (maybe empty) {@code newInfos} highlights during visiting PsiElement {@code visitedPsiElement}.
   * Remove all highlights that this tool had generated earlier during visiting this psi element, and replace them with {@code newInfosGenerated}
   * Do not read below, it's very private and just for me
    Sometimes multiple file editors are submitted for highlighting, some of which may have the same underlying document,
    e.g., when the editor for the file is opened along with the git log with "preview diff" for the same file.
    In this case, it's possible that several instances of e.g., LocalInspectionPass can run in parallel,
    thus making `psiElementVisited` potentially reentrant (i.e., it can be called with the same `toolId` from different threads concurrently),
    so we need to guard `ToolHighlights` against parallel modification
   * @param toolId one of
   *               {@code String}: the tool is a {@link LocalInspectionTool} with its {@link LocalInspectionTool#getShortName()}==toolId
   *               {@code Class<? extends Annotator>}: the tool is an {@link Annotator} of the corresponding class
   *               {@code Class<? extends HighlightVisitor>}: the tool is a {@link HighlightVisitor} of the corresponding class
   */
  @Override
  synchronized void psiElementVisited(@NotNull Object toolId,
                                      @NotNull PsiElement visitedPsiElement,
                                      @NotNull List<? extends HighlightInfo> newInfos,
                                      @NotNull Document hostDocument,
                                      @NotNull PsiFile psiFile,
                                      @NotNull Project project,
                                      @NotNull HighlightingSession session,
                                      @NotNull HighlighterRecyclerPickup invalidElementRecycler) {
    Map<Object, ToolHighlights> data = getData(psiFile, hostDocument);
    ToolHighlights toolHighlights = newInfos.isEmpty() ? data.get(toolId) : data.computeIfAbsent(toolId, __ -> new ToolHighlights());
    List<? extends HighlightInfo> oldInfos = toolHighlights == null ? null : toolHighlights.elementHighlights.get(visitedPsiElement);
    List<? extends HighlightInfo> newInfosToStore;
    if (oldInfos != null || !newInfos.isEmpty()) {
      newInfosToStore = List.copyOf(newInfos);
      if (LOG.isDebugEnabled()) {
        //noinspection removal
        LOG.debug("psiElementVisited: " + visitedPsiElement + " in " + visitedPsiElement.getTextRange() +
                  (psiFile.getViewProvider() instanceof InjectedFileViewProvider ?
                   " injected in " + InjectedLanguageManager.getInstance(project).injectedToHost(psiFile, psiFile.getTextRange()) : "") +
                  "; tool:" + toolId + "; infos:" + newInfosToStore + "; oldInfos:" + oldInfos +
                  "; progress:" + System.identityHashCode(session.getProgressIndicator()) + (session.getProgressIndicator().isCanceled() ? "X" : "V"));
      }
      MarkupModelEx markup = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);
      setHighlightersInRange(newInfosToStore, oldInfos, markup, session, invalidElementRecycler);
    }
    else {
      newInfosToStore = List.of();
    }
    // store back only after markup model changes are applied to avoid PCE thrown in the middle leaving corrupted data behind
    putInfosForVisitedPsi(data, toolId, visitedPsiElement, newInfosToStore, toolHighlights);

    //assertNoDuplicates(psiFile, newInfosToStore);
  }

  static void assertNoDuplicates(@NotNull PsiFile psiFile,
                                 @NotNull List<? extends HighlightInfo> newInfosToStore) {
    record HI(TextRange range, String desc, TextAttributes attributes){}
    List<HI> map = ContainerUtil.map(newInfosToStore, h -> new HI(TextRange.create(h), h.getDescription(), h.getTextAttributes(psiFile,
                                                                                                                               EditorColorsUtil.getGlobalOrDefaultColorScheme())));
    if (new HashSet<HI>(map).size() != newInfosToStore.size()) {
      throw new RuntimeException("psiElementVisited Duplicates found: \n" + StringUtil.join(ContainerUtil.sorted(newInfosToStore, UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS), "\n"));
    }
  }

  private static void setHighlightersInRange(@NotNull List<? extends HighlightInfo> newInfos,
                                             @Nullable List<? extends HighlightInfo> oldInfos,
                                             @NotNull MarkupModelEx markup,
                                             @NotNull HighlightingSession session,
                                             @NotNull HighlighterRecyclerPickup invalidElementRecycler) {
    ApplicationManager.getApplication().assertIsNonDispatchThread();
    ApplicationManager.getApplication().assertReadAccessAllowed();
    PsiFile psiFile = session.getPsiFile();
    Project project = session.getProject();
    SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(project);
    boolean[] changed = {false};
    Document document = session.getDocument();
    HighlighterRecycler.runWithRecycler(session, toReuse -> {
      Long2ObjectMap<RangeMarker> range2markerCache = new Long2ObjectOpenHashMap<>(10);
      if (oldInfos != null) {
        for (HighlightInfo oldInfo : oldInfos) {
          RangeHighlighterEx oldHighlighter = oldInfo.getHighlighter();
          boolean recycled = false;
          if (oldHighlighter != null) {
            recycled = toReuse.recycleHighlighter(oldHighlighter);
          }
          if (oldInfo.isFileLevelAnnotation() && !recycled) {
            ((HighlightingSessionImpl)session).removeFileLevelHighlight(oldInfo);
          }
        }
      }

      // use both `toReuse` and `invalidElementRecycler` to pickup the recycled highlighter, but prefer the former
      HighlighterRecyclerPickup composite = new HighlighterRecyclerPickup() {
        @Override
        public RangeHighlighterEx pickupHighlighterFromGarbageBin(int startOffset, int endOffset, int layer) {
          RangeHighlighterEx ex = toReuse.pickupHighlighterFromGarbageBin(startOffset, endOffset, layer);
          if (ex != null) return ex;
          return invalidElementRecycler.pickupHighlighterFromGarbageBin(startOffset, endOffset, layer);
        }

        @Override
        public @Nullable RangeHighlighterEx pickupFileLevelRangeHighlighter(int fileTextLength) {
          RangeHighlighterEx ex = toReuse.pickupFileLevelRangeHighlighter(fileTextLength);
          if (ex != null) return ex;
          return invalidElementRecycler.pickupFileLevelRangeHighlighter(fileTextLength);
        }
      };

      for (HighlightInfo info : newInfos) {
        if (info.isFileLevelAnnotation()) {
          RangeHighlighterEx salvagedHighlighter = composite.pickupFileLevelRangeHighlighter(psiFile.getTextLength());
          HighlightInfo oldFileInfo = salvagedHighlighter == null ? null : HighlightInfo.fromRangeHighlighter(salvagedHighlighter);

          if (oldFileInfo == null) {
            ((HighlightingSessionImpl)session).addFileLevelHighlight(info, salvagedHighlighter);
          }
          else {
            ((HighlightingSessionImpl)session).replaceFileLevelHighlight(oldFileInfo, info, salvagedHighlighter);
          }
        }
        else {
          BackgroundUpdateHighlightersUtil.createOrReuseHighlighterFor(info, session.getColorsScheme(), document, -1,
                                                                       psiFile, markup, composite, range2markerCache, severityRegistrar);
        }
      }
      // remove highlighters recycled from the local psi element, but do not touch invalidElementRecycler just yet
      changed[0] = !toReuse.isEmpty();
      return true;
    });

    if (changed[0]) {
      UpdateHighlightersUtil.clearWhiteSpaceOptimizationFlag(document);
    }
  }


  // remove all highlight infos from `data` generated by tools absent in 'actualToolsRun'
  synchronized void removeHighlightsForObsoleteTools(@NotNull PsiFile containingFile,
                                                     @NotNull Document hostDocument,
                                                     @NotNull List<? extends PsiFile> injectedFragments,
                                                     @NotNull Set<? extends Pair<Object, PsiFile>> actualToolsRun,
                                                     @NotNull HighlightingSession highlightingSession) {
    for (PsiFile psiFile: ContainerUtil.append(injectedFragments, containingFile)) {
      getData(psiFile, hostDocument).entrySet().removeIf(entry -> {
        Object toolId = entry.getKey();
        ToolHighlights toolHighlights = entry.getValue();
        if (UNKNOWN_ID.equals(toolId) || !isInspectionToolId(toolId)) {
          return false;
        }

        if (actualToolsRun.contains(Pair.create(toolId, psiFile))) {
          return false;
        }
        for (List<? extends HighlightInfo> highlights : toolHighlights.elementHighlights.values()) {
          for (HighlightInfo info : highlights) {
            RangeHighlighterEx highlighter = info.highlighter;
            if (highlighter != null) {
              if (LOG.isTraceEnabled()) {
                LOG.trace("removeHighlightsForObsoleteTools: " + highlighter);
              }
              UpdateHighlightersUtil.disposeWithFileLevelIgnoreErrors(highlighter, info, highlightingSession);
            }
          }
        }
        return true;
      });
    }
  }

  static boolean isInspectionToolId(Object toolId) {
    return toolId instanceof String;
  }

  // TODO very dirty method which throws all incrementality away, but we'd need to rewrite too many inspections to get rid of it
  synchronized void removeWarningsInsideErrors(@NotNull List<? extends PsiFile> injectedFragments,
                                               @NotNull Document hostDocument,
                                               @NotNull HighlightingSession highlightingSession) {
    HighlighterRecycler.runWithRecycler(highlightingSession, recycler -> {
      for (PsiFile psiFile: ContainerUtil.append(injectedFragments, highlightingSession.getPsiFile())) {
        Map<Object, ToolHighlights> map = getData(psiFile, hostDocument);
        if (map.isEmpty()) {
          continue;
        }
        List<? extends HighlightInfo> sorted = map.entrySet().stream()
          .filter(e -> isInspectionToolId(e.getKey())) // inspections only
          .flatMap(e -> e.getValue().elementHighlights.values().stream())
          .flatMap(l->l.stream())
          .sorted(UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS)
          .toList();
        SweepProcessor.Generator<HighlightInfo> generator = processor -> ContainerUtil.process(sorted, processor);
        SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(highlightingSession.getProject());
        SweepProcessor.sweep(generator, (__, info, atStart, overlappingIntervals) -> {
          if (!atStart) {
            return true;
          }
          if (info.isFileLevelAnnotation()) {
            return true;
          }

          // TODO uncomment if duplicates need to be removed automatically
          // Currently they are not, to manifest incorrectly written inspections/annotators earlier
          if (UpdateHighlightersUtil.isWarningCoveredByError(info, severityRegistrar, overlappingIntervals)/* || overlappingIntervals.contains(info)*/) {
            RangeHighlighterEx highlighter = info.getHighlighter();
            if (highlighter != null) {
              recycler.recycleHighlighter(highlighter);

              ToolHighlights elementHighlights = map.get(info.toolId);
              for (Map.Entry<PsiElement, List<? extends HighlightInfo>> elementEntry : elementHighlights.elementHighlights.entrySet()) {
                List<? extends HighlightInfo> infos = elementEntry.getValue();
                int i = infos.indexOf(info);
                if (i != -1) {
                  List<HighlightInfo> listMinusInfo = ContainerUtil.concat(infos.subList(0, i), infos.subList(i + 1, infos.size()));
                  if (listMinusInfo.isEmpty()) {
                    elementHighlights.elementHighlights.remove(elementEntry.getKey());
                  }
                  else {
                    elementEntry.setValue(listMinusInfo);
                  }
                  break;
                }
              }
            }
          }
          return true;
        });
      }
      Collection<? extends RangeHighlighter> warns = recycler.forAllInGarbageBin();
      if (LOG.isDebugEnabled() && !warns.isEmpty()) {
        LOG.debug("removeWarningsInsideErrors: found " + warns);
      }
      return true;
    });
  }

  /**
   * after inspections completed, save their latencies (from corresponding {@link InspectionRunner.InspectionContext#holder})
   * to use later in {@link com.intellij.codeInsight.daemon.impl.InspectionProfilerDataHolder#sortByLatencies(PsiFile, List, HighlightInfoUpdaterImpl)}
   */
  synchronized void saveLatencies(@NotNull PsiFile psiFile, @NotNull Map<Object, ToolLatencies> latencies) {
    if (!psiFile.getViewProvider().isPhysical()) {
      // ignore editor text fields/consoles etc.
      return;
    }
    Map<Object, ToolHighlights> map = getData(psiFile);
    if (map.isEmpty()) return;
    for (Map.Entry<Object, ToolLatencies> entry : latencies.entrySet()) {
      Object toolId = entry.getKey();
      ToolHighlights toolHighlights = map.get(toolId);
      // no point saving latencies if nothing was reported
      if (toolHighlights == null) continue;

      ToolLatencies lats = entry.getValue();
      toolHighlights.latencies = new ToolLatencies(merge(toolHighlights.latencies.errorLatency, lats.errorLatency),
                                                   merge(toolHighlights.latencies.warningLatency, lats.warningLatency),
                                                   merge(toolHighlights.latencies.otherLatency, lats.otherLatency));
    }
  }

  private static long merge(long oldL, long newL) {
    return oldL == 0 || newL == 0 ? oldL+newL : Math.min(oldL, newL);
  }

  static int compareLatencies(@NotNull PsiFile psiFile, @NotNull String toolId1, @NotNull String toolId2) {
    Map<Object, ToolHighlights> map = getData(psiFile);
    if (map.isEmpty()) return 0;
    ToolHighlights toolHighlights1 = map.get(toolId1);
    ToolHighlights toolHighlights2 = map.get(toolId2);
    if (toolHighlights1 == null) {
      return toolHighlights2 == null ? 0 : 1;
    }
    if (toolHighlights2 == null) {
      return -1;
    }
    return toolHighlights1.latencies.compareLatencies(toolHighlights2.latencies);
  }

  /**
   * sort `elements` by the number of produced diagnostics:
   *  - put first the elements for which this `toolWrapper` has produced some diagnostics on previous run
   *    - in case of a tie, put elements which generated higher severity diagnostics first
   *  - followed by all other elements
   */
  @NotNull
  static List<? extends PsiElement> sortByPsiElementFertility(@NotNull PsiFile psiFile,
                                                              @NotNull LocalInspectionToolWrapper toolWrapper,
                                                              @NotNull List<? extends PsiElement> elements) {
    String toolId = toolWrapper.getShortName();
    Map<Object, ToolHighlights> map = getData(psiFile);
    if (map.isEmpty()) return elements;
    ToolHighlights toolHighlights = map.get(toolId);
    if (toolHighlights == null) return elements;
    Map<PsiElement, List<? extends HighlightInfo>> highlights = toolHighlights.elementHighlights;
    if (highlights.isEmpty()) return elements;
    List<PsiElement> sorted = new ArrayList<>(elements);
    sorted.sort((e1, e2) -> {
      List<? extends HighlightInfo> infos1 = highlights.get(e1);
      List<? extends HighlightInfo> infos2 = highlights.get(e2);
      if ((infos1 == null) != (infos2 == null)) {
        return infos1 == null ? 1 : -1; // put fertile element first
      }
      if (infos1 == null) {
        return Integer.compare(System.identityHashCode(e1), System.identityHashCode(e2)); // for consistency
      }
      // put error-generating element first
      return maxSeverity(infos2).compareTo(maxSeverity(infos1));
    });
    return sorted;
  }

  @NotNull
  private static HighlightSeverity maxSeverity(@NotNull List<? extends HighlightInfo> infos) {
    HighlightSeverity max = HighlightSeverity.INFORMATION;
    for (HighlightInfo info : infos) {
      HighlightSeverity severity = info.getSeverity();
      if (severity.compareTo(max) > 0) max = severity;
    }
    return max;
  }

  void runWithInvalidPsiRecycler(@NotNull HighlightingSession session,
                                 boolean inspectionOnlyPredicate, //true: recycle highlighters from inspections only; false: recycle highlighters from non-inspections only
                                 @NotNull Consumer<? super HighlighterRecyclerPickup> invalidPsiRecyclerConsumer) {
    HighlighterRecycler.runWithRecycler(session, invalidPsiRecycler -> {
      List<InvalidPsi> invalidPsi = recycleInvalidPsiElements(session.getPsiFile(), this, session, invalidPsiRecycler, inspectionOnlyPredicate);
      invalidPsiRecyclerConsumer.accept(invalidPsiRecycler);
      incinerateAndRemoveInvalidPsiHighlightersFromDataAtomically(session.getDocument(), session.getPsiFile(), invalidPsi, invalidPsiRecycler);
      return true;
    });
  }
  /**
   * We associate each {@link HighlightInfo} with the PSI element for which the inspection builder has produced that info.
   * Unfortunately, there are some crazy inspections that produce infos in their {@link LocalInspectionTool#inspectionFinished(LocalInspectionToolSession, ProblemsHolder)} method instead.
   * Which is very slow, because that highlight info won't be displayed until the entire file is visited.
   * For these infos the associated PSI element is assumed to be this {@code FAKE_ELEMENT}
   */
  static final PsiElement FAKE_ELEMENT = createFakePsiElement();

  static @NotNull PsiElement createFakePsiElement() {
    return new PsiElement() {
      @Override
      public @NotNull Project getProject() {
        throw createException();
      }

      @Override
      public @NotNull Language getLanguage() {
        throw createException();
      }

      @Override
      public PsiManager getManager() {
        throw createException();
      }

      @Override
      public PsiElement @NotNull [] getChildren() {
        return EMPTY_ARRAY;
      }

      @Override
      public PsiElement getParent() {
        return null;
      }

      @Override
      public @Nullable PsiElement getFirstChild() {
        return null;
      }

      @Override
      public @Nullable PsiElement getLastChild() {
        return null;
      }

      @Override
      public @Nullable PsiElement getNextSibling() {
        return null;
      }

      @Override
      public @Nullable PsiElement getPrevSibling() {
        return null;
      }

      @Override
      public PsiFile getContainingFile() {
        return null;
      }

      @Override
      public TextRange getTextRange() {
        return TextRange.EMPTY_RANGE;
      }

      @Override
      public int getStartOffsetInParent() {
        return -1;
      }

      @Override
      public int getTextLength() {
        return 0;
      }

      @Override
      public PsiElement findElementAt(int offset) {
        return null;
      }

      @Override
      public @Nullable PsiReference findReferenceAt(int offset) {
        return null;
      }

      @Override
      public int getTextOffset() {
        return 0;
      }

      @Override
      public String getText() {
        return "";
      }

      @Override
      public char @NotNull [] textToCharArray() {
        return ArrayUtil.EMPTY_CHAR_ARRAY;
      }

      @Override
      public PsiElement getNavigationElement() {
        return null;
      }

      @Override
      public PsiElement getOriginalElement() {
        return null;
      }

      @Override
      public boolean textMatches(@NotNull CharSequence text) {
        return false;
      }

      @Override
      public boolean textMatches(@NotNull PsiElement element) {
        return false;
      }

      @Override
      public boolean textContains(char c) {
        return false;
      }

      @Override
      public void accept(@NotNull PsiElementVisitor visitor) {

      }

      @Override
      public void acceptChildren(@NotNull PsiElementVisitor visitor) {

      }

      @Override
      public PsiElement copy() {
        return null;
      }

      @Override
      public PsiElement add(@NotNull PsiElement element) {
        throw createException();
      }

      @Override
      public PsiElement addBefore(@NotNull PsiElement element, PsiElement anchor) {
        throw createException();
      }

      @Override
      public PsiElement addAfter(@NotNull PsiElement element, PsiElement anchor) {
        throw createException();
      }

      @Override
      public void checkAdd(@NotNull PsiElement element) {
        throw createException();
      }

      @Override
      public PsiElement addRange(PsiElement first, PsiElement last) {
        throw createException();
      }

      @Override
      public PsiElement addRangeBefore(@NotNull PsiElement first, @NotNull PsiElement last, PsiElement anchor) {
        throw createException();
      }

      @Override
      public PsiElement addRangeAfter(PsiElement first, PsiElement last, PsiElement anchor) {
        throw createException();
      }

      @Override
      public void delete() {
        throw createException();
      }

      @Override
      public void checkDelete() {
        throw createException();
      }

      @Override
      public void deleteChildRange(PsiElement first, PsiElement last) {
        throw createException();
      }

      @Override
      public PsiElement replace(@NotNull PsiElement newElement) {
        throw createException();
      }

      @Override
      public boolean isValid() {
        return true;
      }

      @Override
      public boolean isWritable() {
        return false;
      }

      PsiInvalidElementAccessException createException() {
        return new PsiInvalidElementAccessException(this, toString(), null);
      }

      @Override
      public @Nullable PsiReference getReference() {
        return null;
      }

      @Override
      public PsiReference @NotNull [] getReferences() {
        return PsiReference.EMPTY_ARRAY;
      }

      @Override
      public <T> T getCopyableUserData(@NotNull Key<T> key) {
        throw createException();
      }

      @Override
      public <T> void putCopyableUserData(@NotNull Key<T> key, T value) {
        throw createException();
      }

      @Override
      public boolean processDeclarations(@NotNull PsiScopeProcessor processor,
                                         @NotNull ResolveState state,
                                         PsiElement lastParent,
                                         @NotNull PsiElement place) {
        return false;
      }

      @Override
      public PsiElement getContext() {
        return null;
      }

      @Override
      public boolean isPhysical() {
        return true;
      }

      @Override
      public @NotNull GlobalSearchScope getResolveScope() {
        throw createException();
      }

      @Override
      public @NotNull SearchScope getUseScope() {
        throw createException();
      }

      @Override
      public ASTNode getNode() {
        throw createException();
      }

      @Override
      public <T> T getUserData(@NotNull Key<T> key) {
        throw createException();
      }

      @Override
      public <T> void putUserData(@NotNull Key<T> key, T value) {
        throw createException();
      }

      @Override
      public Icon getIcon(int flags) {
        throw createException();
      }

      @Override
      public boolean isEquivalentTo(final PsiElement another) {
        return this == another;
      }

      @Override
      public String toString() {
        return "FAKE_PSI_ELEMENT";
      }
    };
  }
}
