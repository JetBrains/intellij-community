// Copyright 2000-2024 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.codeInsight.daemon.impl;

import com.intellij.codeInspection.LocalInspectionTool;
import com.intellij.codeInspection.LocalInspectionToolSession;
import com.intellij.codeInspection.ProblemsHolder;
import com.intellij.codeInspection.ex.LocalInspectionToolWrapper;
import com.intellij.injected.editor.DocumentWindow;
import com.intellij.lang.ASTNode;
import com.intellij.lang.Language;
import com.intellij.lang.annotation.HighlightSeverity;
import com.intellij.lang.injection.InjectedLanguageManager;
import com.intellij.openapi.Disposable;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.components.Service;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.RangeMarker;
import com.intellij.openapi.editor.ex.MarkupModelEx;
import com.intellij.openapi.editor.ex.RangeHighlighterEx;
import com.intellij.openapi.editor.impl.DocumentMarkupModel;
import com.intellij.openapi.editor.impl.SweepProcessor;
import com.intellij.openapi.editor.markup.RangeHighlighter;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.util.*;
import com.intellij.psi.*;
import com.intellij.psi.impl.PsiManagerEx;
import com.intellij.psi.impl.file.impl.FileManagerImpl;
import com.intellij.psi.impl.source.tree.injected.InjectedFileViewProvider;
import com.intellij.psi.scope.PsiScopeProcessor;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.search.SearchScope;
import com.intellij.psi.util.PsiUtilCore;
import com.intellij.util.ArrayUtil;
import com.intellij.util.ConcurrencyUtil;
import com.intellij.util.containers.CollectionFactory;
import com.intellij.util.containers.ContainerUtil;
import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
import org.jetbrains.annotations.NonNls;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.swing.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

@Service(Service.Level.PROJECT)
final class HighlightInfoUpdaterImpl extends HighlightInfoUpdater implements Disposable {
  private static final Logger LOG = Logger.getInstance(HighlightInfoUpdaterImpl.class);
  private static final Object UNKNOWN_ID = "unknownId";

  // containing File -> tool id -> map of (visited PsiElement -> list of HighlightInfos generated by this tool while visiting that PsiElement)
  private static final Key<Map<PsiFile, Map<Object, ToolHighlights>>> VISITED_PSI_ELEMENTS = Key.create("VISITED_PSI_ELEMENTS");

  private static class ToolHighlights {
    @NotNull
    final ConcurrentMap<PsiElement, List<? extends HighlightInfo>> elementHighlights = CollectionFactory.createConcurrentSoftMap((map,evicted) -> {
      if (evicted != null) {
        removeEvicted(map, evicted);
      }
    });
    @NotNull
    ToolLatencies latencies = new ToolLatencies(0,0,0);
  }
  record ToolLatencies(
      long errorLatency, // latency of the first error, in nanoseconds (or 0 if none)
      long warningLatency, // latency of the first warning, in nanoseconds (or 0 if none)
      long otherLatency // latency of the first other info, in nanoseconds (or 0 if none)
  ) {
    int compareLatencies(@NotNull ToolLatencies other) {
      int o = cmp(errorLatency, other.errorLatency);
      if (o != 0) return o;
      o = cmp(warningLatency, other.warningLatency);
      if (o != 0) return o;
      o = cmp(otherLatency, other.otherLatency);
      return o;
    }
    static int cmp(long lat1, long lat2) {
      return Long.compare(lat1 == 0 ? Long.MAX_VALUE : lat1, lat2 == 0 ? Long.MAX_VALUE : lat2);
    }
  }

  HighlightInfoUpdaterImpl(Project project) {
    FileManagerImpl fileManager = (FileManagerImpl)PsiManagerEx.getInstanceEx(project).getFileManager();
    Disposer.register(this, () ->
      fileManager.forEachCachedDocument(document -> document.putUserData(VISITED_PSI_ELEMENTS, null)));
  }

  @Override
  public void dispose() {
  }

  private static void removeEvicted(@NotNull ConcurrentMap<PsiElement, List<? extends HighlightInfo>> map, @NotNull List<? extends HighlightInfo> evicted) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeEvicted: " + evicted);
    }
    // all evicted HighlightInfos will be stored in this map[PsiUtilCore.NULL_PSI_ELEMENT], to be disposed later, in removeInvalidPsiElements(), when the HighlightSession is available
    List<HighlightInfo> storedEvictedHighlightInfos = Collections.synchronizedList(new ArrayList<>());
    storedEvictedHighlightInfos = (List<HighlightInfo>)ConcurrencyUtil.cacheOrGet(map, PsiUtilCore.NULL_PSI_ELEMENT, storedEvictedHighlightInfos);
    storedEvictedHighlightInfos.addAll(evicted);
  }

  @NotNull
  private static Map<Object, ToolHighlights> getData(@NotNull PsiFile psiFile) {
    PsiFile hostFile = InjectedLanguageManager.getInstance(psiFile.getProject()).getTopLevelFile(psiFile);
    Document hostDocument = hostFile.getFileDocument(); // store in the document because DocumentMarkupModel is associated with this document
    return getData(psiFile, hostDocument);
  }

  private static @NotNull Map<Object, ToolHighlights> getData(@NotNull PsiFile psiFile, @NotNull Document hostDocument) {
    Map<PsiFile, Map<Object, ToolHighlights>> map = getOrCreateHostMap(hostDocument);
    Map<Object, ToolHighlights> result = map.get(psiFile);
    if (result == null) {
      result = map.computeIfAbsent(psiFile, __->new ConcurrentHashMap<>());
    }
    return result;
  }

  private static @NotNull Map<PsiFile, Map<Object, ToolHighlights>> getOrCreateHostMap(@NotNull Document hostDocument) {
    Map<PsiFile, Map<Object, ToolHighlights>> map = hostDocument.getUserData(VISITED_PSI_ELEMENTS);
    if (map == null) {
      map = ((UserDataHolderEx)hostDocument).putUserDataIfAbsent(VISITED_PSI_ELEMENTS, CollectionFactory.createConcurrentSoftMap((__, oldMap) -> {
        if (oldMap != null) {
          removeEvictedFile(oldMap);
        }
      }));
    }
    invokeProcessQueueToTriggerEvictedListener(map);
    return map;
  }

  private static void invokeProcessQueueToTriggerEvictedListener(@NotNull Map<? extends PsiElement, ?> map) {
    Object v = map.remove(PsiUtilCore.NULL_PSI_FILE); // to invoke processQueue() and call evictionListener if needed
    assert null == v : v;
  }

  private static void removeEvictedFile(@NotNull Map<Object, ToolHighlights> map) {
    for (ToolHighlights toolHighlights : map.values()) {
      invokeProcessQueueToTriggerEvictedListener(toolHighlights.elementHighlights);
      for (List<? extends HighlightInfo> infos : toolHighlights.elementHighlights.values()) {
        removeEvicted(toolHighlights.elementHighlights, infos);
      }
    }
  }

  @Override
  void removeInfosForInjectedFilesOtherThan(@NotNull PsiFile hostPsiFile, @NotNull TextRange restrictRange, @NotNull HighlightingSession highlightingSession, @NotNull Collection<? extends PsiFile> liveInjectedFiles) {
    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(hostPsiFile.getProject());
    Document hostDocument = hostPsiFile.getFileDocument();
    Map<PsiFile, Map<Object, ToolHighlights>> hostMap = getOrCreateHostMap(hostDocument);
    hostMap.entrySet().removeIf(entry -> {
      PsiFile psiFile = entry.getKey();
      Map<Object, ToolHighlights> toolMap = entry.getValue();
      boolean shouldRemove = injectedLanguageManager.isInjectedFragment(psiFile) &&
                  !liveInjectedFiles.contains(psiFile) &&
                  restrictRange.contains(injectedLanguageManager.injectedToHost(psiFile, psiFile.getTextRange()));
      if (shouldRemove) {
        removeAllHighlighterInsideFile(psiFile, this, highlightingSession, toolMap);
        return true;
      }
      return false;
    });
  }

  static void removeInvalidPsiElements(@NotNull PsiFile psiFile,
                                       @NotNull Object requestor,
                                       @NotNull HighlightingSession highlightingSession) {
    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(psiFile.getProject());
    PsiFile hostFile = injectedLanguageManager.getTopLevelFile(psiFile);
    Document hostDocument = hostFile.getFileDocument();
    Map<PsiFile, Map<Object, ToolHighlights>> hostMap = getOrCreateHostMap(hostDocument);
    List<Map<Object, ToolHighlights>> myMaps = new ArrayList<>();
    PsiDocumentManager documentManager = PsiDocumentManager.getInstance(hostFile.getProject());
    hostMap.entrySet().removeIf(entry -> {
      PsiFile psi = entry.getKey();
      Map<Object, ToolHighlights> toolMap = entry.getValue();
      if (psi.isValid()) {
        Document document = documentManager.getDocument(psi);
        Document topLevelDocument = document instanceof DocumentWindow ? ((DocumentWindow)document).getDelegate() : document;
        if (topLevelDocument == hostDocument) {
          myMaps.add(toolMap);
        }
        return false;
      }
      if (psi == psiFile) {
        return false;
      }
      removeAllHighlighterInsideFile(psi, requestor, highlightingSession, toolMap);
      return true;
    });
    for (Map<Object, ToolHighlights> map : myMaps) {
      if (map.isEmpty()) {
        continue;
      }
      for (Map.Entry<Object, ToolHighlights> toolEntry : map.entrySet()) {
        ToolHighlights toolHighlights = toolEntry.getValue();
        synchronized (toolHighlights) {
          invokeProcessQueueToTriggerEvictedListener(toolHighlights.elementHighlights);
          Iterator<Map.Entry<PsiElement, List<? extends HighlightInfo>>> iterator = toolHighlights.elementHighlights.entrySet().iterator();
          while (iterator.hasNext()) {
            Map.Entry<PsiElement, List<? extends HighlightInfo>> entry = iterator.next();
            PsiElement element = entry.getKey();
            if (element == PsiUtilCore.NULL_PSI_ELEMENT/*evicted*/ || element != FAKE_ELEMENT && !element.isValid()) {
              List<? extends HighlightInfo> infos = entry.getValue();
              for (HighlightInfo info : infos) {
                RangeHighlighterEx highlighter = info.getHighlighter();
                if (highlighter != null) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("removeInvalidPsiElements: " + info + " for invalid " + element + " from " + requestor);
                  }
                  UpdateHighlightersUtil.disposeWithFileLevelIgnoreErrors(highlighter, info, highlightingSession);
                }
              }
              iterator.remove();
            }
          }
        }
      }
    }
  }

  private static void removeAllHighlighterInsideFile(@NotNull PsiFile psiFile,
                                                     @NotNull Object requestor,
                                                     @NotNull HighlightingSession highlightingSession,
                                                     @NotNull Map<Object, ToolHighlights> toolMap) {
    int removed = 0;
    for (ToolHighlights highlights : toolMap.values()) {
      for (List<? extends HighlightInfo> list : highlights.elementHighlights.values()) {
        for (HighlightInfo info : list) {
          RangeHighlighterEx highlighter = info.highlighter;
          if (highlighter != null) {
            UpdateHighlightersUtil.disposeWithFileLevelIgnoreErrors(highlighter, info, highlightingSession);
            removed++;
          }
        }
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("removeAllHighlighterInsideFile: removed invalid file: " + psiFile + " (" + removed + " highlighters removed); from " + requestor);
    }
  }

  private static void putInfosForVisitedPsi(@NotNull Map<Object, ToolHighlights> data,
                                            @NotNull @NonNls Object toolId,
                                            @NotNull PsiElement visitedPsi,
                                            @NotNull List<? extends HighlightInfo> newInfos,
                                            @Nullable ToolHighlights toolHighlights) {
    if (newInfos.isEmpty() || toolHighlights == null) {
      boolean toolEmpty;
      if (toolHighlights == null) {
        toolEmpty = true;
      }
      else {
        toolHighlights.elementHighlights.remove(visitedPsi);
        toolEmpty = toolHighlights.elementHighlights.isEmpty();
      }
      if (toolEmpty) {
        data.remove(toolId);
      }
    }
    else {
      toolHighlights.elementHighlights.put(visitedPsi, newInfos);
    }
  }

  /**
   * Tool {@code toolId} has generated (maybe empty) {@code newInfos} highlights during visiting PsiElement {@code visitedPsiElement}.
   * Remove all highlights that this tool had generated earlier during visiting this psi element, and replace them with {@code newInfosGenerated}
   * Do not read below, it's very private and just for me
   * @param toolId one of
   *               {@code String}: the tool is a {@link LocalInspectionTool} with its {@link LocalInspectionTool#getShortName()}==toolId
   *               {@code Class<? extends Annotator>}: the tool is an {@link com.intellij.lang.annotation.Annotator} of the corresponding class
   *               {@code Class<? extends HighlightVisitor>}: the tool is a {@link HighlightVisitor} of the corresponding class
   */
  void psiElementVisited(@NotNull Object toolId,
                         @NotNull PsiElement visitedPsiElement,
                         @NotNull List<? extends HighlightInfo> newInfos,
                         @NotNull Document hostDocument,
                         @NotNull PsiFile psiFile,
                         @NotNull Project project,
                         @NotNull HighlightingSession session) {
    Map<Object, ToolHighlights> data = getData(psiFile, hostDocument);
    ToolHighlights toolHighlights = newInfos.isEmpty() ? data.get(toolId) : data.computeIfAbsent(toolId, __ -> new ToolHighlights());
    // Sometimes multiple file editors are submitted for highlighting, some of which may have the same underlying document,
    // e.g., when the editor for file v is opened along with the git log with "preview diff" for the same file.
    // In this case, it's possible that several instances of e.g., LocalInspectionPass can run in parallel,
    // thus making `psiElementVisited` potentially reentrant (i.e., it can be called with the same `toolId` from different threads concurrently),
    // so we need to guard `ToolHighlights` against parallel modification:
    Object monitor = toolHighlights == null ? this : toolHighlights;
    synchronized (monitor) {
      List<? extends HighlightInfo> oldInfos = toolHighlights == null ? null : toolHighlights.elementHighlights.get(visitedPsiElement);
      if (oldInfos != null || !newInfos.isEmpty()) {
        newInfos = List.copyOf(newInfos);
        if (LOG.isDebugEnabled()) {
          //noinspection removal
          LOG.debug("psiElementVisited: " + visitedPsiElement + " in " + visitedPsiElement.getTextRange() +
                    (psiFile.getViewProvider() instanceof InjectedFileViewProvider ?
                     " injected in " + InjectedLanguageManager.getInstance(project).injectedToHost(psiFile, psiFile.getTextRange()) : "") +
                    "; tool:" + toolId + "; infos:" + newInfos + "; oldInfos:" + oldInfos + "; document:" + hostDocument);
        }
        MarkupModelEx markup = (MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument, project, true);
        setHighlightersInRange(newInfos, oldInfos, markup, session);
      }
      else {
        newInfos = List.of();
      }
      // store back only after markup model changes are applied to avoid PCE thrown in the middle leaving corrupted data behind
      putInfosForVisitedPsi(data, toolId, visitedPsiElement, newInfos, toolHighlights);
    }
  }

  private static void setHighlightersInRange(@NotNull List<? extends HighlightInfo> newInfos,
                                             @Nullable List<? extends HighlightInfo> oldInfos,
                                             @NotNull MarkupModelEx markup,
                                             @NotNull HighlightingSession session) {
    ApplicationManager.getApplication().assertIsNonDispatchThread();
    ApplicationManager.getApplication().assertReadAccessAllowed();
    PsiFile psiFile = session.getPsiFile();
    Project project = session.getProject();
    SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(project);
    HighlightersRecycler toReuse = new HighlightersRecycler();
    Document document = session.getDocument();
    Long2ObjectMap<RangeMarker> range2markerCache = new Long2ObjectOpenHashMap<>(10);
    boolean changed;
    try {
      if (oldInfos != null) {
        for (HighlightInfo oldInfo : oldInfos) {
          RangeHighlighterEx oldHighlighter = oldInfo.getHighlighter();
          if (oldHighlighter != null) {
            toReuse.recycleHighlighter(oldHighlighter);
          }
        }
      }

      for (HighlightInfo info : newInfos) {
        if (info.isFileLevelAnnotation()) {
          RangeHighlighterEx salvagedHighlighter = toReuse.pickupHighlighterFromGarbageBin(0, psiFile.getTextLength(), -409423948);
          HighlightInfo oldFileInfo = salvagedHighlighter == null ? null : HighlightInfo.fromRangeHighlighter(salvagedHighlighter);
          if (oldFileInfo != null) {
            UpdateHighlightersUtil.disposeWithFileLevelIgnoreErrors(salvagedHighlighter, oldFileInfo, session);
            salvagedHighlighter = null;
          }
          ((HighlightingSessionImpl)session).addFileLevelHighlight(info, salvagedHighlighter);
        }
        else {
          BackgroundUpdateHighlightersUtil.createOrReuseHighlighterFor(info, session.getColorsScheme(), document, -1,
                                                                       psiFile, markup, toReuse, range2markerCache, severityRegistrar);
        }
      }
      // remove highlighters recycled from the local psi element, but do not touch invalidElementRecycler just yet
      changed = UpdateHighlightersUtil.incinerateObsoleteHighlighters(toReuse, session);
    }
    finally {
      toReuse.releaseHighlighters();
    }

    if (changed) {
      UpdateHighlightersUtil.clearWhiteSpaceOptimizationFlag(document);
    }
  }


  // remove all highlight infos from `data` generated by tools absent in 'actualToolsRun'
  static void removeHighlightsForObsoleteTools(@NotNull PsiFile containingFile,
                                               @NotNull Document hostDocument,
                                               @NotNull List<? extends PsiFile> injectedFragments,
                                               @NotNull Set<? extends Pair<Object, PsiFile>> actualToolsRun,
                                               @NotNull HighlightingSession highlightingSession) {
    for (PsiFile psiFile: ContainerUtil.append(injectedFragments, containingFile)) {
      getData(psiFile, hostDocument).entrySet().removeIf(entry -> {
        Object toolId = entry.getKey();
        ToolHighlights toolHighlights = entry.getValue();
        if (UNKNOWN_ID.equals(toolId) || !isInspectionToolId(toolId)) {
          return false;
        }

        if (actualToolsRun.contains(Pair.create(toolId, psiFile))) {
          return false;
        }
        for (List<? extends HighlightInfo> highlights : toolHighlights.elementHighlights.values()) {
          for (HighlightInfo info : highlights) {
            RangeHighlighterEx highlighter = info.highlighter;
            if (highlighter != null) {
              if (LOG.isTraceEnabled()) {
                LOG.trace("removeHighlightsForObsoleteTools: " + highlighter);
              }
              UpdateHighlightersUtil.disposeWithFileLevelIgnoreErrors(highlighter, info, highlightingSession);
            }
          }
        }
        return true;
      });
    }
  }

  private static boolean isInspectionToolId(Object toolId) {
    return toolId instanceof String;
  }

  // TODO very dirty method which throws all incrementality away, but we'd need to rewrite too many inspections to get rid of it
  static void removeWarningsInsideErrors(@NotNull List<? extends PsiFile> injectedFragments,
                                         @NotNull Document hostDocument,
                                         @NotNull HighlightingSession highlightingSession) {
    HighlightersRecycler recycler = new HighlightersRecycler();
    for (PsiFile psiFile: ContainerUtil.append(injectedFragments, highlightingSession.getPsiFile())) {
      Map<Object, ToolHighlights> map = getData(psiFile, hostDocument);
      if (map.isEmpty()) {
        continue;
      }
      List<? extends HighlightInfo> sorted = map.entrySet().stream()
        .filter(e -> isInspectionToolId(e.getKey())) // inspections only
        .flatMap(e -> e.getValue().elementHighlights.values().stream())
        .flatMap(l->l.stream())
        .sorted(UpdateHighlightersUtil.BY_ACTUAL_START_OFFSET_NO_DUPS)
        .toList();
      SweepProcessor.Generator<HighlightInfo> generator = processor -> ContainerUtil.process(sorted, processor);
      SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(highlightingSession.getProject());
      SweepProcessor.sweep(generator, (__, info, atStart, overlappingIntervals) -> {
        if (!atStart) {
          return true;
        }
        if (info.isFileLevelAnnotation()) {
          return true;
        }

        // TODO uncomment if duplicates need to be removed automatically
        // Currently they are not, to manifest incorrectly written inspections/annotators earlier
        if (UpdateHighlightersUtil.isWarningCoveredByError(info, severityRegistrar, overlappingIntervals)/* || overlappingIntervals.contains(info)*/) {
          RangeHighlighterEx highlighter = info.getHighlighter();
          if (highlighter != null) {
            recycler.recycleHighlighter(highlighter);

            ToolHighlights elementHighlights = map.get(info.toolId);
            for (Map.Entry<PsiElement, List<? extends HighlightInfo>> elementEntry : elementHighlights.elementHighlights.entrySet()) {
              List<? extends HighlightInfo> infos = elementEntry.getValue();
              int i = infos.indexOf(info);
              if (i != -1) {
                List<HighlightInfo> listMinusInfo = ContainerUtil.concat(infos.subList(0, i), infos.subList(i + 1, infos.size()));
                if (listMinusInfo.isEmpty()) {
                  elementHighlights.elementHighlights.remove(elementEntry.getKey());
                }
                else {
                  elementEntry.setValue(listMinusInfo);
                }
                break;
              }
            }
          }
        }
        return true;
      });
    }
    Collection<? extends RangeHighlighter> warns = recycler.forAllInGarbageBin();
    if (LOG.isDebugEnabled() && !warns.isEmpty()) {
      LOG.debug("removeWarningsInsideErrors: found " + warns);
    }
    UpdateHighlightersUtil.incinerateObsoleteHighlighters(recycler, highlightingSession);
  }

  /**
   * after inspections completed, save their latencies (from corresponding {@link InspectionRunner.InspectionContext#holder})
   * to use later in {@link com.intellij.codeInsight.daemon.impl.InspectionProfilerDataHolder#sortByLatencies(PsiFile, List, HighlightInfoUpdaterImpl)}
   */
  static void saveLatencies(@NotNull PsiFile psiFile, @NotNull Map<Object, ToolLatencies> latencies) {
    if (!psiFile.getViewProvider().isPhysical()) {
      // ignore editor text fields/consoles etc.
      return;
    }
    Map<Object, ToolHighlights> map = getData(psiFile);
    if (map.isEmpty()) return;
    for (Map.Entry<Object, ToolLatencies> entry : latencies.entrySet()) {
      Object toolId = entry.getKey();
      ToolHighlights toolHighlights = map.get(toolId);
      // no point saving latencies if nothing was reported
      if (toolHighlights == null) continue;
      ToolLatencies lats = entry.getValue();
      toolHighlights.latencies = new ToolLatencies(merge(toolHighlights.latencies.errorLatency, lats.errorLatency),
                                                   merge(toolHighlights.latencies.warningLatency, lats.warningLatency),
                                                   merge(toolHighlights.latencies.otherLatency, lats.otherLatency));
    }
  }

  private static long merge(long oldL, long newL) {
    return oldL == 0 || newL == 0 ? oldL+newL : Math.min(oldL, newL);
  }

  static int compareLatencies(@NotNull PsiFile psiFile, @NotNull String toolId1, @NotNull String toolId2) {
    Map<Object, ToolHighlights> map = getData(psiFile);
    if (map.isEmpty()) return 0;
    ToolHighlights toolHighlights1 = map.get(toolId1);
    ToolHighlights toolHighlights2 = map.get(toolId2);
    if (toolHighlights1 == null) {
      return toolHighlights2 == null ? 0 : 1;
    }
    if (toolHighlights2 == null) {
      return -1;
    }
    return toolHighlights1.latencies.compareLatencies(toolHighlights2.latencies);
  }

  /**
   * sort `elements` by the number of produced diagnostics:
   *  - put first the elements for which this `toolWrapper` has produced some diagnostics on previous run
   *    - in case of a tie, put elements which generated higher severity diagnostics first
   *  - followed by all other elements
   */
  @NotNull
  static List<? extends PsiElement> sortByPsiElementFertility(@NotNull PsiFile psiFile,
                                                              @NotNull LocalInspectionToolWrapper toolWrapper,
                                                              @NotNull List<? extends PsiElement> elements) {
    String toolId = toolWrapper.getShortName();
    Map<Object, ToolHighlights> map = getData(psiFile);
    if (map.isEmpty()) return elements;
    ToolHighlights toolHighlights = map.get(toolId);
    if (toolHighlights == null) return elements;
    Map<PsiElement, List<? extends HighlightInfo>> highlights = toolHighlights.elementHighlights;
    if (highlights.isEmpty()) return elements;
    List<PsiElement> sorted = new ArrayList<>(elements);
    sorted.sort((e1, e2) -> {
      List<? extends HighlightInfo> infos1 = highlights.get(e1);
      List<? extends HighlightInfo> infos2 = highlights.get(e2);
      if ((infos1 == null) != (infos2 == null)) {
        return infos1 == null ? 1 : -1; // put fertile element first
      }
      if (infos1 == null) {
        return Integer.compare(System.identityHashCode(e1), System.identityHashCode(e2)); // for consistency
      }
      // put error-generating element first
      return maxSeverity(infos2).compareTo(maxSeverity(infos1));
    });
    return sorted;
  }

  @NotNull
  private static HighlightSeverity maxSeverity(@NotNull List<? extends HighlightInfo> infos) {
    HighlightSeverity max = HighlightSeverity.INFORMATION;
    for (HighlightInfo info : infos) {
      HighlightSeverity severity = info.getSeverity();
      if (severity.compareTo(max) > 0) max = severity;
    }
    return max;
  }

  /**
   * We associate each {@link HighlightInfo} with the PSI element for which the inspection builder has produced that info.
   * Unfortunately, there are some crazy inspections that produce infos in their {@link LocalInspectionTool#inspectionFinished(LocalInspectionToolSession, ProblemsHolder)} method instead.
   * Which is very slow, because that highlight info won't be displayed until the entire file is visited.
   * For these infos the associated PSI element is assumed to be this {@code FAKE_ELEMENT}
   */
  static final PsiElement FAKE_ELEMENT = createFakePsiElement();

  static @NotNull PsiElement createFakePsiElement() {
    return new PsiElement() {
      @Override
      public @NotNull Project getProject() {
        throw createException();
      }

      @Override
      public @NotNull Language getLanguage() {
        throw createException();
      }

      @Override
      public PsiManager getManager() {
        throw createException();
      }

      @Override
      public PsiElement @NotNull [] getChildren() {
        return EMPTY_ARRAY;
      }

      @Override
      public PsiElement getParent() {
        return null;
      }

      @Override
      public @Nullable PsiElement getFirstChild() {
        return null;
      }

      @Override
      public @Nullable PsiElement getLastChild() {
        return null;
      }

      @Override
      public @Nullable PsiElement getNextSibling() {
        return null;
      }

      @Override
      public @Nullable PsiElement getPrevSibling() {
        return null;
      }

      @Override
      public PsiFile getContainingFile() {
        return null;
      }

      @Override
      public TextRange getTextRange() {
        return TextRange.EMPTY_RANGE;
      }

      @Override
      public int getStartOffsetInParent() {
        return -1;
      }

      @Override
      public int getTextLength() {
        return 0;
      }

      @Override
      public PsiElement findElementAt(int offset) {
        return null;
      }

      @Override
      public @Nullable PsiReference findReferenceAt(int offset) {
        return null;
      }

      @Override
      public int getTextOffset() {
        return 0;
      }

      @Override
      public String getText() {
        return "";
      }

      @Override
      public char @NotNull [] textToCharArray() {
        return ArrayUtil.EMPTY_CHAR_ARRAY;
      }

      @Override
      public PsiElement getNavigationElement() {
        return null;
      }

      @Override
      public PsiElement getOriginalElement() {
        return null;
      }

      @Override
      public boolean textMatches(@NotNull CharSequence text) {
        return false;
      }

      @Override
      public boolean textMatches(@NotNull PsiElement element) {
        return false;
      }

      @Override
      public boolean textContains(char c) {
        return false;
      }

      @Override
      public void accept(@NotNull PsiElementVisitor visitor) {

      }

      @Override
      public void acceptChildren(@NotNull PsiElementVisitor visitor) {

      }

      @Override
      public PsiElement copy() {
        return null;
      }

      @Override
      public PsiElement add(@NotNull PsiElement element) {
        throw createException();
      }

      @Override
      public PsiElement addBefore(@NotNull PsiElement element, PsiElement anchor) {
        throw createException();
      }

      @Override
      public PsiElement addAfter(@NotNull PsiElement element, PsiElement anchor) {
        throw createException();
      }

      @Override
      public void checkAdd(@NotNull PsiElement element) {
        throw createException();
      }

      @Override
      public PsiElement addRange(PsiElement first, PsiElement last) {
        throw createException();
      }

      @Override
      public PsiElement addRangeBefore(@NotNull PsiElement first, @NotNull PsiElement last, PsiElement anchor) {
        throw createException();
      }

      @Override
      public PsiElement addRangeAfter(PsiElement first, PsiElement last, PsiElement anchor) {
        throw createException();
      }

      @Override
      public void delete() {
        throw createException();
      }

      @Override
      public void checkDelete() {
        throw createException();
      }

      @Override
      public void deleteChildRange(PsiElement first, PsiElement last) {
        throw createException();
      }

      @Override
      public PsiElement replace(@NotNull PsiElement newElement) {
        throw createException();
      }

      @Override
      public boolean isValid() {
        return true;
      }

      @Override
      public boolean isWritable() {
        return false;
      }

      PsiInvalidElementAccessException createException() {
        return new PsiInvalidElementAccessException(this, toString(), null);
      }

      @Override
      public @Nullable PsiReference getReference() {
        return null;
      }

      @Override
      public PsiReference @NotNull [] getReferences() {
        return PsiReference.EMPTY_ARRAY;
      }

      @Override
      public <T> T getCopyableUserData(@NotNull Key<T> key) {
        throw createException();
      }

      @Override
      public <T> void putCopyableUserData(@NotNull Key<T> key, T value) {
        throw createException();
      }

      @Override
      public boolean processDeclarations(@NotNull PsiScopeProcessor processor,
                                         @NotNull ResolveState state,
                                         PsiElement lastParent,
                                         @NotNull PsiElement place) {
        return false;
      }

      @Override
      public PsiElement getContext() {
        return null;
      }

      @Override
      public boolean isPhysical() {
        return true;
      }

      @Override
      public @NotNull GlobalSearchScope getResolveScope() {
        throw createException();
      }

      @Override
      public @NotNull SearchScope getUseScope() {
        throw createException();
      }

      @Override
      public ASTNode getNode() {
        throw createException();
      }

      @Override
      public <T> T getUserData(@NotNull Key<T> key) {
        throw createException();
      }

      @Override
      public <T> void putUserData(@NotNull Key<T> key, T value) {
        throw createException();
      }

      @Override
      public Icon getIcon(int flags) {
        throw createException();
      }

      @Override
      public boolean isEquivalentTo(final PsiElement another) {
        return this == another;
      }

      @Override
      public String toString() {
        return "FAKE_PSI_ELEMENT";
      }
    };
  }
}
