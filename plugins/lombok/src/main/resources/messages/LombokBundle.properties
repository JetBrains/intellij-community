plugin.settings.title=Lombok
config.warn.annotation-processing.disabled.title=Lombok requires enabled annotation processing
notification.enable.annotation.processing=Enable annotation processing
replace.synchronized.lombok.intention=Replace with Lombok @Synchronized
replace.with.annotations.lombok=Replace with annotations (Lombok)
replace.0.with.explicit.type.lombok=Replace ''{0}'' with explicit type (Lombok)
replace.explicit.type.with.0.lombok=Replace explicit type with ''{0}'' (Lombok)
dialog.message.logger.field.s.not.private.sfinal.field.named.s.refactor.anyway=Logger field: "{0}" Is not private {1, choice, 0#|1#static }final field named "{2}". Refactor anyway?
dialog.title.attention=Attention!
dialog.message.this.element.cannot.be.renamed=This element cannot be renamed.
inspection.message.lombok.annotation.deprecated.not.supported=Lombok''s annotation ''{0}'' is deprecated and not supported by Lombok plugin anymore. Use ''{1}'' instead.
inspection.message.default.constructor.doesn.t.exist=Default constructor doesn't exist
inspection.message.slf4j.logger.defined.explicitly=Slf4j Logger is defined explicitly. Use Lombok @Slf4j annotation instead.
intention.name.replace.with.lombok=Replace with Lombok
color.settings.comment=Comment
color.settings.clear=Clear
color.settings.key=Key
color.settings.value=Value
color.settings.separator=Separator
configurable.name.lombok.config=Lombok Config
filetype.lombok.config.description=Lombok config file
inspection.message.annotation.not.lombok.copyable=Lombok does not copy the annotation ''{0}'' into the constructor
inspection.message.val.works.only.on.local.variables='val' works only on local variables and on foreach loops
inspection.message.var.works.only.on.local.variables.on.for.foreach.loops='var' works only on local variables and on for/foreach loops
inspection.message.on.local.variable.requires.initializer.expression=''{0}'' on a local variable requires an initializer expression
inspection.message.not.compatible.with.array.initializer.expressions=''{0}'' is not compatible with array initializer expressions. Use the full form (new int[] ''{'' ... ''}'' instead of just ''{'' ... ''}'')
inspection.message.not.allowed.with.lambda.expressions=''{0}'' is not allowed with lambda expressions.
inspection.message.not.allowed.in.old.style.for.loops=''{0}'' is not allowed in old-style for loops
intention.name.create.new.field.s=Create new field ''{0}''
make.abstract.and.static.modifier.quickfix.family.name=Change modifier
make.abstract.and.static.modifier.quickfix=Make ''{0}'' abstract and static
inspection.message.utility.class.already.marks.class.final=@UtilityClass already marks the class final.
inspection.message.utility.class.already.marks.fields.static=@UtilityClass already marks fields static.
inspection.message.utility.class.already.marks.methods.static=@UtilityClass already marks methods static.
inspection.message.utility.class.already.marks.inner.classes.static=@UtilityClass already marks inner classes static.
inspection.message.val.already.marks.variables.final='val' already marks variables final.
inspection.message.value.already.marks.class.final=@Value already marks the class final.
inspection.message.value.already.marks.non.static.fields.final=@Value already marks non-static fields final.
inspection.message.value.already.marks.non.static.package.local.fields.private=@Value already marks non-static, package-local fields private.
inspection.message.cleanup.method.s.not.found.on.target.class=@Cleanup: method ''{0}()'' not found on target class
inspection.message.cleanup.legal.only.on.local.variable.declaration.inside.block=@Cleanup: is legal only on a local variable declaration inside a block
inspection.message.cleanup.variable.declarations.need.to.be.initialized=@Cleanup variable declarations need to be initialized.
inspection.message.cleanup.value.cannot.be.empty.string=@Cleanup: value cannot be the empty string
inspection.message.cleanup.legal.only.on.local.variable.declarations=@Cleanup is legal only on local variable declarations
inspection.message.synchronized.legal.only.on.concrete.methods=@Synchronized is legal only on concrete methods.
inspection.message.synchronized.legal.only.on.methods.in.classes.enums=@Synchronized is legal only on methods in classes and enums.
inspection.message.synchronized.field.is.not.static=The field ''{0}'' is non-static and this cannot be used on this static method
inspection.message.field.s.does.not.exist=The field ''{0}'' does not exist.
inspection.message.field.s.does.not.exist.exclude=The field ''{0}'' does not exist
inspection.message.field.s.would.have.been.excluded.anyway=The field ''{0}'' would have been excluded anyway
inspection.message.field.s.does.not.exist.field=The field ''{0}'' does not exist
inspection.message.data.only.supported.on.class.type=@Data is only supported on a class type
inspection.message.exclude.are.mutually.exclusive.exclude.parameter.will.be.ignored=Parameters 'exclude' and 'of' are mutually exclusive; the 'exclude' parameter will be ignored
inspection.message.equals.and.hashcode.only.supported.on.class.type=@EqualsAndHashCode is only supported on a class type
inspection.message.not.generating.equals.hashcode=Not generating equals and hashCode: A method with one of those names already exists. (Either both or none of these methods will be generated).
inspection.message.generating.equals.hashcode.with.super.call=Generating equals/hashCode with a supercall to java.lang.Object is pointless.
inspection.message.generating.equals.hashcode.implementation=Generating equals/hashCode implementation but without a call to superclass, even though this class does not extend java.lang.Object. If this is intentional, add '(callSuper=false)' to your type.
inspection.message.lazy.not.supported.for.getter.on.type='lazy' is not supported for @Getter on a type
inspection.message.getter.only.supported.on.class.enum.or.field.type=@Getter is only supported on a class, enum, or field type
inspection.message.setter.only.supported.on.class.or.field.type=@Setter is only supported on a class or field type
inspection.message.to.string.only.supported.on.class.or.enum.type=@ToString is only supported on a class or enum type
inspection.message.not.generated.s.method.with.same.name.already.exists=Not generated ''{0}()'': A method with same name already exists
inspection.message.utility.classes.cannot.have.declared.constructors=@UtilityClasses cannot have declared constructors.
inspection.message.utility.class.only.supported.on.class=@UtilityClass is only supported on a class (can't be an interface, enum, or annotation).
inspection.message.utility.class.automatically.makes.class.static=@UtilityClass automatically makes the class static, however, this class cannot be made static.
inspection.message.utility.class.cannot.be.placed=@UtilityClass cannot be placed on a method local or anonymous inner class, or any class nested in such a class.
inspection.message.value.only.supported.on.class.type=@Value is only supported on a class type
inspection.message.wither.only.supported.on.class.or.field=@Wither is only supported on a class or a field.
inspection.message.annotation.only.supported.on.class.or.enum.type={0} is only supported on a class or an enum.
inspection.message.lombok.needs.default.constructor.in.base.class=Lombok needs a default constructor in the base class
inspection.message.constructor.without.parameters.already.defined=Constructor without parameters is already defined
inspection.message.constructor.with.d.parameters.already.defined=Constructor ''{0}'' is already defined
inspection.message.constructor.noargs.needs.to.be.forced=Class contains required fields, you have to force NoArgsConstructor.
inspection.message.method.s.matched.static.constructor.name.already.defined=Method ''{0}'' matched staticConstructorName is already defined
inspection.message.method.s.with.d.parameters.matched.static.constructor.name.already.defined=Method ''{0}'' with ''{1}'' parameters matched staticConstructorName is already defined
inspection.message.field.name.constants.only.supported.on.class.or.enum=@FieldNameConstants is only supported on a class, an enum, or a record.
inspection.message.field.name.constants.only.supported.on.class.enum.or.field.type=@FieldNameConstants is only supported on a class, enum, record, or field type
inspection.message.field.name.constants.inner.type=@FieldNameConstants inner type already exists, but asEnum={0} does not match existing type
inspection.message.s.legal.only.on.classes.enums=''@{0}'' is legal only on classes and enums
inspection.message.not.generating.field.s.field.with.same.name.already.exists=Not generating field ''{0}'': A field with same name already exists
inspection.message.custom.log.not.configured.correctly=The @CustomLog is not configured correctly; please set log.custom.declaration in lombok.config.
inspection.message.custom.log.does.not.allow.topic=@CustomLog does not allow a topic.
inspection.message.custom.log.requires.topic=@CustomLog requires a topic.
inspection.message.not.generating.constant=Not generating constant for this field: The name of the constant would be equal to the name of this field.
inspection.message.lazy.does.not.work.with.access.level.none='lazy' does not work with AccessLevel.NONE.
inspection.message.lazy.requires.field.to.be.private.final='lazy' requires the field to be private and final
inspection.message.lazy.requires.field.initialization='lazy' requires field initialization.
inspection.message.annotation.copy.duplicate=Annotation ''{0}'' already present on field and will be duplicated by onX configuration
inspection.message.not.generating.getter.for.this.field=Not generating getter for this field: It does not fit your @Accessors prefix list.
inspection.message.not.generated.s.method.with.similar.name.s.already.exists=Not generated ''{0}()'': A method with similar name ''{0}'' already exists
inspection.message.not.generating.setter.for.this.field.it=Not generating setter for this field: It does not fit your @Accessors prefix list.
inspection.message.not.generating.setter.for.this.field.setters=Not generating setter for this field: Setters cannot be generated for final fields.
inspection.message.wither.needs.constructor.for.all.fields.d.parameters=@Wither needs constructor for all fields (''{0}'' parameters)
inspection.message.not.generating.s.method.with.that.name.already.exists=Not generating ''{0}()'': A method with that name already exists
inspection.message.not.generating.wither.for.this.field.withers=Not generating wither for this field: Withers cannot be generated for fields starting with $.
inspection.message.not.generating.wither=Not generating wither for this field: Withers cannot be generated for static fields.
inspection.message.not.generating.wither.for.this.field.withers.cannot.be.generated=Not generating wither for this field: Withers cannot be generated for final, initialized fields.
inspection.message.builder.can.be.used.only=@Builder is only supported on classes, records, constructors, and methods.
inspection.message.superbuilder.can.be.used.on.classes.only=@SuperBuilder is only supported on classes.
inspection.message.superbuilder.can.be.used.on.static.inner.classes.only=@SuperBuilder is not supported on non-static nested classes.
inspection.message.syntax.either.obtain.via.field=The syntax is either @ObtainVia(field = "fieldName") or @ObtainVia(method = "methodName").
inspection.message.lombok.annotations.are.not.allowed.on.builder.class=Lombok's annotations are not allowed on builder class.
inspection.message.s.not.valid.identifier=''{0}'' is not a valid identifier
inspection.message.can.t.singularize.this.name=Cannot singularize this name: ''{0}''; specify the singular form explicitly (i.e. @Singular("sheep"))
inspection.message.lombok.does.not.know=Lombok cannot generate singular-form builder methods for type ''{0}''
inspection.message.builder.default.requires.builder.annotation=@Builder.Default requires @Builder or @SuperBuilder on the class for it to mean anything.
inspection.message.builder.default.requires.initializing.expression=@Builder.Default requires an initializing expression (' = something;').
inspection.message.builder.default.singular.cannot.be.mixed=@Builder.Default and @Singular cannot be mixed.
inspection.message.obtain.via.is.static.true.not.valid.unless.method.has.been.set=@ObtainVia(isStatic = true) is not valid unless 'method' has been set.
inspection.message.sneakythrows.calls.to.sibling.super.constructors.excluded=Calls to sibling / super constructors are always excluded from @SneakyThrows; @SneakyThrows has been ignored because there is no other code in this constructor.
inspection.message.lombok.builder.needs.proper.constructor.for.this.class=Lombok @Builder needs a proper constructor for this class
inspection.message.delegate.does.not.support.recursion.delegating=@Delegate does not support recursion (delegating to a type that itself has @Delegate members). Member ''{0}'' is @Delegate in type ''{1}''
inspection.message.delegate.legal.only.on.instance.fields=@Delegate is legal only on instance fields or no-argument instance methods.
inspection.message.delegate.unknown.type.method=Cannot find {0, choice, 1#method|1<methods} in target type: {1}
inspection.message.delegate.can.only.use.concrete.class.types=@Delegate can only use concrete class types, not wildcards, arrays, type variables, or primitives. ''{0}'' is wrong class type
inspection.message.existing.builder.must.be.abstract.static.inner.class=Existing Builder must be an abstract static inner class.
inspection.message.delegate.legal.only.on.no.argument.methods=@Delegate is legal only on no-argument methods.
inspection.message.standardexception.class.only.supported.on.class=@StandardException is only supported on a class
inspection.message.standardexception.should.extend.throwable=@StandardException requires that you extend a Throwable type
inspection.message.standardexception.accesslevel.none.not.valid=AccessLevel.NONE is not valid here
inspection.message.jacksonized.requires.builder.superbuilder=@Jacksonized requires @Builder or @SuperBuilder for it to mean anything.
inspection.message.jacksonized.cannot.process.both.builder.superbuilder=@Jacksonized cannot process both @Builder and @SuperBuilder on the same class.
inspection.message.jacksonized.builder.on.abstract.classes=Builders on abstract classes cannot be @Jacksonized (the builder would never be used).
inspection.message.jacksonized.jsondeserialize.already.exists=@JsonDeserialize already exists on class. Either delete @JsonDeserialize, or remove @Jacksonized and manually configure Jackson.
action.defaultLombokData.text=Default @Data
action.defaultLombokData.description=Action to replace getter/setter/equals/hashcode/toString methods with lombok @Data annotation
action.defaultLombokSetter.text=Default @Setter
action.defaultLombokSetter.description=Action to replace all setter methods with lombok @Setter annotation
action.defaultLombokEqualsAndHashcode.text=Default @EqualsAndHashcode
action.defaultLombokEqualsAndHashcode.description=Action to replace equals and hashcode methods with lombok @EqualsAndHashcode annotation
action.defaultLombokToString.text=Default @ToString
action.defaultLombokToString.description=Action to replace toString method with lombok @ToString annotation
action.defaultLombokLogger.text=@Log (and friends)
action.defaultLombokLogger.description=Action to replace logger with lombok @Log annotation
group.DelombokActionGroup.text=Delombok
group.DelombokActionGroup.description=Refactor code removing lombok annotations
action.delombokAny.text=All Lombok Annotations
action.delombokAny.description=Action to replace all lombok annotations with vanilla java methods
action.delombokData.text=@Data
action.delombokData.description=Action to replace lombok @Data annotation with vanilla java methods
action.delombokValue.text=@Value
action.delombokValue.description=Action to replace lombok @Value annotation with vanilla java methods
action.delombokWither.text=@Wither
action.delombokWither.description=Action to replace lombok @Wither annotation with vanilla java methods
action.delombokDelegate.text=@Delegate
action.delombokDelegate.description=Action to replace lombok @Delegate annotation with vanilla java methods
action.delombokBuilder.text=@Builder
action.delombokBuilder.description=Action to replace lombok @Builder annotation with vanilla java methods
action.delombokSuperBuilder.text=@SuperBuilder
action.delombokSuperBuilder.description=Action to replace lombok @SuperBuilder annotation with vanilla java methods
action.delombokConstructor.text=@Constructors
action.delombokConstructor.description=Action to replace lombok @NoArgsConstructor, @RequiredArgsConstructor and @AllArgsConstructor annotations with vanilla java methods
action.delombokGetter.text=@Getter
action.delombokGetter.description=Action to replace lombok @Getter annotation with vanilla getter methods
action.delombokSetter.text=@Setter
action.delombokSetter.description=Action to replace lombok @Setter annotation with vanilla setter methods
action.delombokEqualsAndHashCode.text=@EqualsAndHashCode
action.delombokEqualsAndHashCode.description=Action to replace lombok @EqualsAndHashCode annotation with vanilla java methods
action.delombokToString.text=@ToString
action.delombokToString.description=Action to replace lombok @ToString annotation with vanilla java methods
action.delombokLogger.text=@Log (and friends)
action.delombokLogger.description=Action to replace lombok @Log (and other) annotation with vanilla log field
action.delombokFieldNameCostants.text=@FieldNameConstants
action.delombokFieldNameCostants.description=Action to replace lombok @FieldNameConstants annotation with vanilla java fields
action.delombokUtilityClass.text=@UtilityClass
action.delombokUtilityClass.description=Action to replace lombok @UtilityClass annotation with vanilla java fields
action.delombokStandardException.text=@StandardException
action.delombokStandardException.description=Action to replace lombok @StandardException annotation with vanilla java methods
action.defaultLombokGetter.text=Default @Getter
action.defaultLombokGetter.description=Action to replace all getter methods with lombok @Getter annotation
group.LombokActionGroup.text=Lombok
group.LombokActionGroup.description=Refactor code with lombok annotations
inspection.redundant.modifiers.val.lombok.display.name=Unnecessary final before 'val'
inspection.redundant.slf.4.j.definition.display.name=@Slf4j
inspection.redundant.modifiers.utility.class.lombok.display.name=@UtilityClass modifiers
inspection.redundant.modifiers.value.lombok.display.name=@Value modifiers
inspection.springqualifiercopyable.lombok.display.name=@Qualifier not copyable by Lombok
inspection.deprecated.lombok.display.name=Deprecated Lombok annotations
inspection.builder.static.import.name=Using static import for Lombok-generated methods
inspection.static.method.import.error=Static imports of Lombok-generated methods doesn't work with javac
inspection.lombok.display.name=Lombok annotations
inspection.lombok.flag.usage.display.name=Lombok flag usages
checkbox.settings.jps.fix=Automatically add '-Djps.track.ap.dependencies=false' compile option for old (<1.18.16) lombok version
inspection.lombok.group.name.lombok=Lombok
inspection.lombok.group.name.redundant.modifiers=Redundant modifiers
inspection.lombok.group.name.redundant.definitions=Redundant definitions
intention.category.lombok=Java/Lombok
popup.content.java.annotation.processing.has.been.enabled=Java annotation processing has been enabled
notification.group.lombok=Lombok integration problem
inspection.lombok.getter.may.be.used.display.name=Lombok @Getter may be used
inspection.lombok.getter.may.be.used.display.class.message=Class ''{0}'' may use Lombok @Getter
inspection.lombok.getter.may.be.used.display.field.message=Field ''{0}'' may have Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.family.name=Replace explicit getter method with Lombok @Getter
inspection.lombok.getter.may.be.used.display.fix.name=Use lombok @Getter for ''{0}''
inspection.lombok.setter.may.be.used.display.name=Lombok @Setter may be used
inspection.lombok.setter.may.be.used.display.class.message=Class ''{0}'' may use Lombok @Setter
inspection.lombok.setter.may.be.used.display.field.message=Field ''{0}'' may have Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.family.name=Replace explicit setter method with Lombok @Setter
inspection.lombok.setter.may.be.used.display.fix.name=Use lombok @Setter for ''{0}''
intention.family.name.slf4j.annotation=Replace logger field with @Slf4j annotation
inspection.message.use.flagged.lombok.annotation=Use of @{0} is flagged according to Lombok configuration.
inspection.message.withby.only.supported.on.class.or.field.type=@WithBy is only supported on a class or a field.
inspection.message.withby.onmethod.not.supported.on.class.type='onMethod' is not supported for @WithBy on a type.
inspection.message.withby.not.generating.filed.name.not.fit =Not generating ''{0}'' method for this field: It does not fit your @Accessors prefix list.
inspection.message.withby.not.generating.field.name.reserved =Not generating ''{0}'' for this field: WithBy methods cannot be generated for fields starting with $.
inspection.message.withby.not.generating.field.static =Not generating ''{0}'' for this field: WithBy methods cannot be generated for static fields.
inspection.message.withby.not.generating.field.final.initialized =Not generating ''{0}'' for this field: WithBy methods cannot be generated for final, initialized fields.
inspection.message.withby.not.generating.method.already.exists =Not generating ''{0}'' for this field: A method with that name already exists.