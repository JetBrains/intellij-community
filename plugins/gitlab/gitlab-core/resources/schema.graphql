# This file was generated. Do not edit manually.

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT

interface AlertManagementIntegration {
  "Whether the endpoint is currently accepting alerts."
  active: Boolean
  "URL at which Prometheus metrics can be queried to populate the metrics dashboard."
  apiUrl: String
  "ID of the integration."
  id: ID!
  "Name of the integration."
  name: String
  "Token used to authenticate alert notification requests."
  token: String
  "Type of integration."
  type: AlertManagementIntegrationType!
  "Endpoint which accepts alert notifications."
  url: String
}

interface AmazonS3ConfigurationInterface {
  "Access key ID of the Amazon S3 account."
  accessKeyXid: String!
  "AWS region where the bucket is created."
  awsRegion: String!
  "Name of the bucket where the audit events would be logged."
  bucketName: String!
  "ID of the configuration."
  id: ID!
  "Name of the external destination to send audit events to."
  name: String!
}

interface BaseHeaderInterface {
  "Header is active or not."
  active: Boolean!
  "ID of the header."
  id: ID!
  "Key of the header."
  key: String!
  "Value of the header."
  value: String!
}

interface CiVariable {
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}

"Represents signing information for a commit"
interface CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "Project of the associated commit."
  project: Project
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
}

interface CurrentUserTodos {
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
}

interface DesignFields {
  "Diff refs for this design."
  diffRefs: DiffRefs!
  "How this design was changed in the current version."
  event: DesignVersionEvent!
  "Filename of the design."
  filename: String!
  "Full path to the design file."
  fullPath: String!
  "ID of this design."
  id: ID!
  "URL of the full-sized image."
  image: String!
  "The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated"
  imageV432x230: String
  "Issue the design belongs to."
  issue: Issue!
  "Total count of user-created notes for this design."
  notesCount: Int!
  "Project the design belongs to."
  project: Project!
}

interface Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "Last commit SHA for the entry."
  sha: String!
  "Type of tree entry."
  type: EntryType!
}

interface Eventable {
  "List of events associated with the object."
  events(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EventConnection
}

interface ExternalAuditEventDestinationInterface {
  "External destination to send audit events to."
  destinationUrl: String!
  "List of event type filters added for streaming."
  eventTypeFilters: [String!]!
  "ID of the destination."
  id: ID!
  "Name of the external destination to send audit events to."
  name: String!
  "Verification token to validate source of event."
  verificationToken: String!
}

interface GoogleCloudLoggingConfigurationInterface {
  "Client email."
  clientEmail: String!
  "Google project ID."
  googleProjectIdName: String!
  "ID of the configuration."
  id: ID!
  "Log ID."
  logIdName: String!
  "Name of the external destination to send audit events to."
  name: String!
}

interface MemberInterface {
  "GitLab::Access level."
  accessLevel: AccessLevel
  "Date and time the membership was created."
  createdAt: Time
  "User that authorized membership."
  createdBy: UserCore
  "Date and time the membership expires."
  expiresAt: Time
  "ID of the member."
  id: ID!
  "Find a merge request."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Date and time the membership was last updated."
  updatedAt: Time
  "User that is associated with the member object."
  user: UserCore
}

interface NoteableInterface {
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
}

interface OrchestrationPolicy {
  "Description of the policy."
  description: String!
  "URL of policy edit page."
  editPath: String!
  "Indicates whether this policy is enabled."
  enabled: Boolean!
  "Name of the policy."
  name: String!
  "Timestamp of when the policy YAML was last updated."
  updatedAt: Time!
  "YAML definition of the policy."
  yaml: String!
}

"Represents metadata associated with a Package file"
interface PackageFileMetadata {
  "Date of creation."
  createdAt: Time!
  "Date of most recent update."
  updatedAt: Time!
}

interface ResolvableInterface {
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
}

interface Service {
  "Indicates if the service is active."
  active: Boolean
  "Type of the service."
  serviceType: ServiceType
  "Class name of the service."
  type: String
}

interface TimeboxReportInterface {
  "Historically accurate report about the timebox."
  report(
    "Full path of the project or group used as a scope for report. For example, `gitlab-org` or `gitlab-org/gitlab`."
    fullPath: String
  ): TimeboxReport
}

interface Todoable {
  "URL of this object."
  webUrl: String
}

"Representation of a GitLab user."
interface User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}

interface WorkItemWidget {
  "Widget type."
  type: WorkItemWidgetType
}

interface WorkItemWidgetDefinition {
  "Widget type."
  type: WorkItemWidgetType!
}

"Represents metadata associated with a dependency link"
union DependencyLinkMetadata = NugetDependencyLinkMetadata

"Represents an issuable."
union Issuable = Epic | Issue | MergeRequest | WorkItem

union JobNeedUnion = CiBuildNeed | CiJob

"Represents an object that supports notes."
union NoteableType = Design | Issue | MergeRequest

"Represents metadata associated with a Package"
union PackageMetadata = ComposerMetadata | ConanMetadata | MavenMetadata | NugetMetadata | PypiMetadata

union Registrable = CiSecureFileRegistry | ContainerRepositoryRegistry | DependencyProxyBlobRegistry | DependencyProxyManifestRegistry | DesignManagementRepositoryRegistry | GroupWikiRepositoryRegistry | JobArtifactRegistry | LfsObjectRegistry | MergeRequestDiffRegistry | PackageFileRegistry | PagesDeploymentRegistry | PipelineArtifactRegistry | ProjectWikiRepositoryRegistry | SnippetRepositoryRegistry | TerraformStateVersionRegistry | UploadRegistry

"Represents a policy source. Its fields depend on the source type."
union SecurityPolicySource = GroupSecurityPolicySource | ProjectSecurityPolicySource

"Represents a vulnerability detail field. The fields with data will depend on the vulnerability detail type"
union VulnerabilityDetail = VulnerabilityDetailBase | VulnerabilityDetailBoolean | VulnerabilityDetailCode | VulnerabilityDetailCommit | VulnerabilityDetailDiff | VulnerabilityDetailFileLocation | VulnerabilityDetailInt | VulnerabilityDetailList | VulnerabilityDetailMarkdown | VulnerabilityDetailModuleLocation | VulnerabilityDetailNamedList | VulnerabilityDetailTable | VulnerabilityDetailText | VulnerabilityDetailUrl

"Represents a vulnerability location. The fields with data will depend on the vulnerability report type"
union VulnerabilityLocation = VulnerabilityLocationClusterImageScanning | VulnerabilityLocationContainerScanning | VulnerabilityLocationCoverageFuzzing | VulnerabilityLocationDast | VulnerabilityLocationDependencyScanning | VulnerabilityLocationGeneric | VulnerabilityLocationSast | VulnerabilityLocationSecretDetection

"An abuse report"
type AbuseReport implements NoteableInterface {
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Global ID of the abuse report."
  id: AbuseReportID!
  "Labels of the abuse report."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
}

"Autogenerated return type of AbuseReportLabelCreate."
type AbuseReportLabelCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Label after mutation."
  label: Label
}

"Represents the access level of a relationship between a User and object that it is related to"
type AccessLevel {
  "Integer representation of access level."
  integerValue: Int
  "String representation of access level."
  stringValue: AccessLevelEnum
}

"Representation of a GitLab deploy key."
type AccessLevelDeployKey {
  "Expiration date of the deploy key."
  expiresAt: Date
  "ID of the deploy key."
  id: ID!
  "Title of the deploy key."
  title: String!
  "User assigned to the deploy key."
  user: AccessLevelUser!
}

"Representation of a GitLab group."
type AccessLevelGroup {
  "Avatar URL of the group."
  avatarUrl: String
  "ID of the group."
  id: ID!
  "Name of the group."
  name: String!
  "Parent group."
  parent: AccessLevelGroup
  "Web URL of the group."
  webUrl: String!
}

"Representation of a GitLab user."
type AccessLevelUser {
  "URL of the user's avatar."
  avatarUrl: String
  "ID of the user."
  id: ID!
  """

  Human-readable name of the user.
  Returns `****` if the user is a project bot and the requester does not have permission to view the project.
  """
  name: String!
  "User's public email."
  publicEmail: String
  "Username of the user."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
}

type Achievement {
  "URL to avatar of the achievement."
  avatarUrl: String
  "Timestamp the achievement was created."
  createdAt: Time!
  "Description or notes for the achievement."
  description: String
  "ID of the achievement."
  id: AchievementsAchievementID!
  "Name of the achievement."
  name: String!
  "Namespace of the achievement."
  namespace: Namespace
  "Timestamp the achievement was last updated."
  updatedAt: Time!
  "Recipients for the achievement. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
}

"The connection type for Achievement."
type AchievementConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [AchievementEdge]
  "A list of nodes."
  nodes: [Achievement]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AchievementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Achievement
}

"Autogenerated return type of AchievementsAward."
type AchievementsAwardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Achievement award."
  userAchievement: UserAchievement
}

"Autogenerated return type of AchievementsCreate."
type AchievementsCreatePayload {
  "Achievement created."
  achievement: Achievement
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AchievementsDelete."
type AchievementsDeletePayload {
  "Achievement."
  achievement: Achievement
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AchievementsRevoke."
type AchievementsRevokePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Achievement award."
  userAchievement: UserAchievement
}

"Autogenerated return type of AchievementsUpdate."
type AchievementsUpdatePayload {
  "Achievement."
  achievement: Achievement
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents AddOn purchase for Namespace"
type AddOnPurchase {
  "Number of seats assigned."
  assignedQuantity: Int!
  "ID of AddOnPurchase."
  id: GitlabSubscriptionsAddOnPurchaseID!
  "Name of AddOn."
  name: String!
  "Number of seats purchased."
  purchasedQuantity: Int!
}

"A user with add-on data"
type AddOnUser implements User {
  "Add-on purchase assignments for the user. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  addOnAssignments(
    "Global IDs of the add on purchases to find assignments for."
    addOnPurchaseIds: [GitlabSubscriptionsAddOnPurchaseID!]!,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAddOnAssignmentConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "Timestamp of the last sign in."
  lastLoginAt: Time
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"The connection type for AddOnUser."
type AddOnUserConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [AddOnUserEdge]
  "A list of nodes."
  nodes: [AddOnUser]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AddOnUserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AddOnUser
}

"Autogenerated return type of AddProjectToSecurityDashboard."
type AddProjectToSecurityDashboardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project that was added to the Instance Security Dashboard."
  project: Project
}

"Autogenerated return type of AdminSidekiqQueuesDeleteJobs."
type AdminSidekiqQueuesDeleteJobsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Information about the status of the deletion request."
  result: DeleteJobsResponse
}

"Configuration details for an Agent"
type AgentConfiguration {
  "Name of the agent."
  agentName: String
}

"The connection type for AgentConfiguration."
type AgentConfigurationConnection {
  "A list of edges."
  edges: [AgentConfigurationEdge]
  "A list of nodes."
  nodes: [AgentConfiguration]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AgentConfigurationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AgentConfiguration
}

"Information about a connected Agent"
type AgentMetadata {
  "Agent version commit."
  commit: String
  "Name of the pod running the Agent."
  podName: String
  "Namespace of the pod running the Agent."
  podNamespace: String
  "Agent version tag."
  version: String
}

"Autogenerated return type of AiAction."
type AiActionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "ID of the request."
  requestId: String
}

"AI features communication message"
type AiMessage {
  "Incremental ID for a chunk from a streamed message. Null when it is not a streamed message."
  chunkId: Int
  "Raw response content."
  content: String
  "Response content as HTML."
  contentHtml: String
  "Message errors."
  errors: [String!]
  "Extra message metadata."
  extras: AiMessageExtras
  "UUID of the message."
  id: ID
  "UUID of the original request. Shared between chat prompt and response."
  requestId: String
  "Message owner role."
  role: AiMessageRole!
  "Message creation timestamp."
  timestamp: Time!
  "Message type."
  type: AiMessageType
}

"The connection type for AiMessage."
type AiMessageConnection {
  "A list of edges."
  edges: [AiMessageEdge]
  "A list of nodes."
  nodes: [AiMessage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AiMessageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AiMessage
}

"Extra metadata for AI message."
type AiMessageExtras {
  "Sources used to form the message."
  sources: [JSON!]
}

"Describes an alert from the project's Alert Management"
type AlertManagementAlert implements NoteableInterface & Todoable {
  "Assignees of the alert."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Timestamp the alert was created."
  createdAt: Time
  "Description of the alert."
  description: String
  "Alert details."
  details: JSON
  "URL of the alert detail page."
  detailsUrl: String!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Timestamp the alert ended."
  endedAt: Time
  "Environment for the alert."
  environment: Environment
  "Number of events of this alert."
  eventCount: Int
  "List of hosts the alert came from."
  hosts: [String!]
  "ID of the alert."
  id: ID!
  "Internal ID of the alert."
  iid: ID!
  "Issue attached to the alert."
  issue: Issue
  "Internal ID of the GitLab issue attached to the alert. Deprecated in 13.10: Use issue field."
  issueIid: ID @deprecated(reason: "Use issue field. Deprecated in 13.10.")
  "URL for metrics embed for the alert. Deprecated in 16.0: Returns no data. Underlying feature was removed in 16.0."
  metricsDashboardUrl: String @deprecated(reason: "Returns no data. Underlying feature was removed in 16.0. Deprecated in 16.0.")
  "Monitoring tool the alert came from."
  monitoringTool: String
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Alert condition for Prometheus."
  prometheusAlert: PrometheusAlert
  "Runbook for the alert as defined in alert details."
  runbook: String
  "Service the alert came from."
  service: String
  "Severity of the alert."
  severity: AlertManagementSeverity
  "Timestamp the alert was raised."
  startedAt: Time
  "Status of the alert."
  status: AlertManagementStatus
  "Title of the alert."
  title: String
  "To-do items of the current user for the alert."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "Timestamp the alert was last updated."
  updatedAt: Time
  "URL of the alert."
  webUrl: String!
}

"The connection type for AlertManagementAlert."
type AlertManagementAlertConnection {
  "A list of edges."
  edges: [AlertManagementAlertEdge]
  "A list of nodes."
  nodes: [AlertManagementAlert]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AlertManagementAlertEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AlertManagementAlert
}

"Represents total number of alerts for the represented categories"
type AlertManagementAlertStatusCountsType {
  "Number of alerts with status ACKNOWLEDGED for the project"
  acknowledged: Int
  "Total number of alerts for the project."
  all: Int
  "Number of alerts with status IGNORED for the project"
  ignored: Int
  "Number of alerts with status TRIGGERED or ACKNOWLEDGED for the project."
  open: Int
  "Number of alerts with status RESOLVED for the project"
  resolved: Int
  "Number of alerts with status TRIGGERED for the project"
  triggered: Int
}

"An endpoint and credentials used to accept alerts for a project"
type AlertManagementHttpIntegration implements AlertManagementIntegration {
  "Whether the endpoint is currently accepting alerts."
  active: Boolean
  "URL at which Prometheus metrics can be queried to populate the metrics dashboard."
  apiUrl: String
  "ID of the integration."
  id: ID!
  "Name of the integration."
  name: String
  "Extract alert fields from payload example for custom mapping."
  payloadAlertFields: [AlertManagementPayloadAlertField!]
  "The custom mapping of GitLab alert attributes to fields from the payload_example."
  payloadAttributeMappings: [AlertManagementPayloadAlertMappingField!]
  "Example of an alert payload."
  payloadExample: JsonString
  "Token used to authenticate alert notification requests."
  token: String
  "Type of integration."
  type: AlertManagementIntegrationType!
  "Endpoint which accepts alert notifications."
  url: String
}

"The connection type for AlertManagementHttpIntegration."
type AlertManagementHttpIntegrationConnection {
  "A list of edges."
  edges: [AlertManagementHttpIntegrationEdge]
  "A list of nodes."
  nodes: [AlertManagementHttpIntegration]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AlertManagementHttpIntegrationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AlertManagementHttpIntegration
}

"The connection type for AlertManagementIntegration."
type AlertManagementIntegrationConnection {
  "A list of edges."
  edges: [AlertManagementIntegrationEdge]
  "A list of nodes."
  nodes: [AlertManagementIntegration]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AlertManagementIntegrationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AlertManagementIntegration
}

"Parsed field from an alert used for custom mappings"
type AlertManagementPayloadAlertField {
  "Human-readable label of the payload path."
  label: String
  "Path to value inside payload JSON."
  path: [PayloadAlertFieldPathSegment!]
  "Type of the parsed value."
  type: AlertManagementPayloadAlertFieldType
}

"Parsed field (with its name) from an alert used for custom mappings"
type AlertManagementPayloadAlertMappingField {
  "GitLab alert field name."
  fieldName: AlertManagementPayloadAlertFieldName
  "Human-readable label of the payload path."
  label: String
  "Path to value inside payload JSON."
  path: [PayloadAlertFieldPathSegment!]
  "Type of the parsed value."
  type: AlertManagementPayloadAlertFieldType
}

"An endpoint and credentials used to accept Prometheus alerts for a project"
type AlertManagementPrometheusIntegration implements AlertManagementIntegration {
  "Whether the endpoint is currently accepting alerts."
  active: Boolean
  "URL at which Prometheus metrics can be queried to populate the metrics dashboard."
  apiUrl: String
  "ID of the integration."
  id: ID!
  "Name of the integration."
  name: String
  "Token used to authenticate alert notification requests."
  token: String
  "Type of integration."
  type: AlertManagementIntegrationType!
  "Endpoint which accepts alert notifications."
  url: String
}

"Autogenerated return type of AlertSetAssignees."
type AlertSetAssigneesPayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}

"Autogenerated return type of AlertTodoCreate."
type AlertTodoCreatePayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}

"Stores Amazon S3 configurations for audit event streaming."
type AmazonS3ConfigurationType implements AmazonS3ConfigurationInterface {
  "Access key ID of the Amazon S3 account."
  accessKeyXid: String!
  "AWS region where the bucket is created."
  awsRegion: String!
  "Name of the bucket where the audit events would be logged."
  bucketName: String!
  "Group the configuration belongs to."
  group: Group!
  "ID of the configuration."
  id: ID!
  "Name of the external destination to send audit events to."
  name: String!
}

"The connection type for AmazonS3ConfigurationType."
type AmazonS3ConfigurationTypeConnection {
  "A list of edges."
  edges: [AmazonS3ConfigurationTypeEdge]
  "A list of nodes."
  nodes: [AmazonS3ConfigurationType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AmazonS3ConfigurationTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AmazonS3ConfigurationType
}

"Data associated with configuring API fuzzing scans in GitLab CI"
type ApiFuzzingCiConfiguration {
  "All available scan modes."
  scanModes: [ApiFuzzingScanMode!]
  "All default scan profiles."
  scanProfiles: [ApiFuzzingScanProfile!]
}

"An API Fuzzing scan profile."
type ApiFuzzingScanProfile {
  "Short description of the profile."
  description: String
  "Unique name of the profile."
  name: String
  "Syntax highlighted HTML representation of the YAML."
  yaml: String
}

"Describes a project approval rule regarding who can approve merge requests."
type ApprovalProjectRule {
  "Number of required approvals."
  approvalsRequired: Int
  "List of users eligible to approve merge requests for this approval rule."
  eligibleApprovers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "ID of the rule."
  id: GlobalID!
  "Name of the rule."
  name: String
  "Type of the rule."
  type: ApprovalRuleType
}

"The connection type for ApprovalProjectRule."
type ApprovalProjectRuleConnection {
  "A list of edges."
  edges: [ApprovalProjectRuleEdge]
  "A list of nodes."
  nodes: [ApprovalProjectRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ApprovalProjectRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ApprovalProjectRule
}

"Describes a rule for who can approve merge requests."
type ApprovalRule {
  "Indicates if the rule can be ignored if it is invalid."
  allowMergeWhenInvalid: Boolean
  "Number of required approvals."
  approvalsRequired: Int
  "Indicates if the rule is satisfied."
  approved: Boolean
  "List of users defined in the rule that approved the merge request."
  approvedBy(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "List of users, defined in the rule, who commented on the merge request."
  commentedBy(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Indicates if the rule contains approvers from a hidden group."
  containsHiddenGroups: Boolean
  "List of all users eligible to approve the merge request (defined explicitly and from associated groups)."
  eligibleApprovers: [UserCore!]
  "List of groups added as approvers for the rule."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "ID of the rule."
  id: GlobalID!
  "Indicates if the rule is invalid and cannot be approved."
  invalid: Boolean
  "Name of the rule."
  name: String
  "Indicates if the rule was overridden for the merge request."
  overridden: Boolean
  "List of scan result policies associated with the rule."
  scanResultPolicies: [ApprovalScanResultPolicy!]
  "Named section of the Code Owners file that the rule applies to."
  section: String
  "Source rule used to create the rule."
  sourceRule: ApprovalRule
  "Type of the rule."
  type: ApprovalRuleType
  "List of users added as approvers for the rule."
  users(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
}

"Represents the scan result policy"
type ApprovalScanResultPolicy {
  "Represents the required approvals defined in the policy."
  approvalsRequired: Int!
  "Represents the name of the policy."
  name: String!
  "Represents the report_type of the approval rule."
  reportType: ApprovalReportType!
}

"Autogenerated return type of ApproveDeployment."
type ApproveDeploymentPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "DeploymentApproval after mutation."
  deploymentApproval: DeploymentApproval!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of ArtifactDestroy."
type ArtifactDestroyPayload {
  "Deleted artifact."
  artifact: CiJobArtifact
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents a vulnerability asset type."
type AssetType {
  "Name of the asset."
  name: String!
  "Type of the asset."
  type: String!
  "URL of the asset."
  url: String!
}

"Represents the YAML definitions for audit events defined in `ee/config/audit_events/types/<event-type-name>.yml` and `config/audit_events/types/<event-type-name>.yml`."
type AuditEventDefinition {
  "Description of what action the audit event tracks."
  description: String!
  "Feature category associated with the event."
  featureCategory: String!
  "Link to the issue introducing the event. For olderaudit events, it can be a commit URL rather than amerge request URL."
  introducedByIssue: String
  "Link to the merge request introducing the event. Forolder audit events, it can be a commit URL rather thana merge request URL."
  introducedByMr: String
  "Milestone the event was introduced in."
  milestone: String!
  "Key name of the audit event."
  name: String!
  "Indicates if the event is saved to PostgreSQL database."
  savedToDatabase: Boolean!
  "Indicates if the event is streamed to an external destination."
  streamed: Boolean!
}

"The connection type for AuditEventDefinition."
type AuditEventDefinitionConnection {
  "A list of edges."
  edges: [AuditEventDefinitionEdge]
  "A list of nodes."
  nodes: [AuditEventDefinition]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AuditEventDefinitionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AuditEventDefinition
}

"Represents a subgroup or project filter that belongs to an external audit event streaming destination."
type AuditEventStreamingHTTPNamespaceFilter {
  "Destination to which the filter belongs."
  externalAuditEventDestination: ExternalAuditEventDestination!
  "ID of the filter."
  id: ID!
  "Group or project namespace the filter belongs to."
  namespace: Namespace!
}

"Represents a HTTP header key/value that belongs to an audit streaming destination."
type AuditEventStreamingHeader implements BaseHeaderInterface {
  "Header is active or not."
  active: Boolean!
  "ID of the header."
  id: ID!
  "Key of the header."
  key: String!
  "Value of the header."
  value: String!
}

"The connection type for AuditEventStreamingHeader."
type AuditEventStreamingHeaderConnection {
  "A list of edges."
  edges: [AuditEventStreamingHeaderEdge]
  "A list of nodes."
  nodes: [AuditEventStreamingHeader]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AuditEventStreamingHeaderEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AuditEventStreamingHeader
}

"Autogenerated return type of AuditEventsAmazonS3ConfigurationCreate."
type AuditEventsAmazonS3ConfigurationCreatePayload {
  "configuration created."
  amazonS3Configuration: AmazonS3ConfigurationType
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsAmazonS3ConfigurationDelete."
type AuditEventsAmazonS3ConfigurationDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsAmazonS3ConfigurationUpdate."
type AuditEventsAmazonS3ConfigurationUpdatePayload {
  "Updated Amazon S3 configuration."
  amazonS3Configuration: AmazonS3ConfigurationType
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsInstanceAmazonS3ConfigurationCreate."
type AuditEventsInstanceAmazonS3ConfigurationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created instance Amazon S3 configuration."
  instanceAmazonS3Configuration: InstanceAmazonS3ConfigurationType
}

"Autogenerated return type of AuditEventsInstanceAmazonS3ConfigurationDelete."
type AuditEventsInstanceAmazonS3ConfigurationDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsInstanceAmazonS3ConfigurationUpdate."
type AuditEventsInstanceAmazonS3ConfigurationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated instance-level Amazon S3 configuration."
  instanceAmazonS3Configuration: InstanceAmazonS3ConfigurationType
}

"Autogenerated return type of AuditEventsStreamingDestinationEventsAdd."
type AuditEventsStreamingDestinationEventsAddPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "List of event type filters for the audit event external destination."
  eventTypeFilters: [String!]
}

"Autogenerated return type of AuditEventsStreamingDestinationEventsRemove."
type AuditEventsStreamingDestinationEventsRemovePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsStreamingDestinationInstanceEventsAdd."
type AuditEventsStreamingDestinationInstanceEventsAddPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "List of event type filters for the audit event external destination."
  eventTypeFilters: [String!]
}

"Autogenerated return type of AuditEventsStreamingDestinationInstanceEventsRemove."
type AuditEventsStreamingDestinationInstanceEventsRemovePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsStreamingHTTPNamespaceFiltersAdd."
type AuditEventsStreamingHTTPNamespaceFiltersAddPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Namespace filter created."
  namespaceFilter: AuditEventStreamingHTTPNamespaceFilter
}

"Autogenerated return type of AuditEventsStreamingHTTPNamespaceFiltersDelete."
type AuditEventsStreamingHTTPNamespaceFiltersDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsStreamingHeadersCreate."
type AuditEventsStreamingHeadersCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created header."
  header: AuditEventStreamingHeader
}

"Autogenerated return type of AuditEventsStreamingHeadersDestroy."
type AuditEventsStreamingHeadersDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsStreamingHeadersUpdate."
type AuditEventsStreamingHeadersUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updates header."
  header: AuditEventStreamingHeader
}

"Represents a HTTP header key/value that belongs to an instance level audit streaming destination."
type AuditEventsStreamingInstanceHeader implements BaseHeaderInterface {
  "Header is active or not."
  active: Boolean!
  "ID of the header."
  id: ID!
  "Key of the header."
  key: String!
  "Value of the header."
  value: String!
}

"The connection type for AuditEventsStreamingInstanceHeader."
type AuditEventsStreamingInstanceHeaderConnection {
  "A list of edges."
  edges: [AuditEventsStreamingInstanceHeaderEdge]
  "A list of nodes."
  nodes: [AuditEventsStreamingInstanceHeader]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AuditEventsStreamingInstanceHeaderEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AuditEventsStreamingInstanceHeader
}

"Autogenerated return type of AuditEventsStreamingInstanceHeadersCreate."
type AuditEventsStreamingInstanceHeadersCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created header."
  header: AuditEventsStreamingInstanceHeader
}

"Autogenerated return type of AuditEventsStreamingInstanceHeadersDestroy."
type AuditEventsStreamingInstanceHeadersDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AuditEventsStreamingInstanceHeadersUpdate."
type AuditEventsStreamingInstanceHeadersUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updates header."
  header: AuditEventsStreamingInstanceHeader
}

"Core representation of a GitLab user."
type AutocompletedUser implements User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Merge request state related to the user."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"An emoji awarded by a user"
type AwardEmoji {
  "Emoji description."
  description: String!
  "Emoji as an icon."
  emoji: String!
  "Emoji name."
  name: String!
  "Emoji in Unicode."
  unicode: String!
  "Unicode version for this emoji."
  unicodeVersion: String!
  "User who awarded the emoji."
  user: UserCore!
}

"Autogenerated return type of AwardEmojiAdd."
type AwardEmojiAddPayload {
  "Emoji reactions after mutation."
  awardEmoji: AwardEmoji
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"The connection type for AwardEmoji."
type AwardEmojiConnection {
  "A list of edges."
  edges: [AwardEmojiEdge]
  "A list of nodes."
  nodes: [AwardEmoji]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type AwardEmojiEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: AwardEmoji
}

"Autogenerated return type of AwardEmojiRemove."
type AwardEmojiRemovePayload {
  "Emoji reactions after mutation."
  awardEmoji: AwardEmoji
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of AwardEmojiToggle."
type AwardEmojiTogglePayload {
  "Emoji reactions after mutation."
  awardEmoji: AwardEmoji
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Indicates the status of the emoji. True if the toggle awarded the emoji, and false if the toggle removed the emoji."
  toggledOn: Boolean!
}

type BaseService implements Service {
  "Indicates if the service is active."
  active: Boolean
  "Type of the service."
  serviceType: ServiceType
  "Class name of the service."
  type: String
}

type Blame {
  "First line of Git Blame for given range."
  firstLine: String
  "Git Blame grouped by contiguous lines for commit."
  groups: [Groups!]
}

type Blob implements Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "LFS ID of the blob."
  lfsOid: String
  "Blob mode in numeric format."
  mode: String
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "Last commit SHA for the entry."
  sha: String!
  "Type of tree entry."
  type: EntryType!
  "Web path of the blob."
  webPath: String
  "Web URL of the blob."
  webUrl: String
}

"The connection type for Blob."
type BlobConnection {
  "A list of edges."
  edges: [BlobEdge]
  "A list of nodes."
  nodes: [Blob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type BlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Blob
}

"Represents how the blob content should be displayed"
type BlobViewer {
  "Shows whether the blob should be displayed collapsed."
  collapsed: Boolean!
  "Content file type."
  fileType: String!
  "Shows whether the blob content is loaded asynchronously."
  loadAsync: Boolean!
  "Loading partial name."
  loadingPartialName: String!
  "Error rendering the blob content."
  renderError: String
  "Shows whether the blob is too large to be displayed."
  tooLarge: Boolean!
  "Type of blob viewer."
  type: BlobViewersType!
}

"Information about the rules that must be satisfied to merge this merge request."
type BlockingMergeRequests {
  "Blocking merge requests not visible to the user."
  hiddenCount: Int!
  "Total number of blocking merge requests."
  totalCount: Int!
  "Blocking merge requests visible to the user."
  visibleMergeRequests: [MergeRequest!]
}

"Represents a project or group issue board"
type Board {
  "Board assignee."
  assignee: UserCore
  "Timestamp of when the board was created."
  createdAt: Time!
  "Epics associated with board issues."
  epics(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters applied when selecting issues on the board."
    issueFilters: BoardIssueInput,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardEpicConnection
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "ID (global ID) of the board."
  id: ID!
  "Board iteration."
  iteration: Iteration
  "Board iteration cadence."
  iterationCadence: IterationCadence
  "Labels of the board."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Lists of the board."
  lists(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Find a list by its global ID."
    id: ListID,
    "Filters applied when getting issue metadata in the board list."
    issueFilters: BoardIssueInput,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardListConnection
  "Board milestone."
  milestone: Milestone
  "Name of the board."
  name: String
  "Timestamp of when the board was last updated."
  updatedAt: Time!
  "Web path of the board."
  webPath: String!
  "Web URL of the board."
  webUrl: String!
  "Weight of the board."
  weight: Int
}

"The connection type for Board."
type BoardConnection {
  "A list of edges."
  edges: [BoardEdge]
  "A list of nodes."
  nodes: [Board]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type BoardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Board
}

"Represents an epic on an issue board"
type BoardEpic implements CurrentUserTodos & Eventable & NoteableInterface & Todoable {
  "Ancestors (parents) of the epic."
  ancestors(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter epics by author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter epics by given confidentiality."
    confidential: Boolean,
    "Epics created after this date."
    createdAfter: Time,
    "Epics created before this date."
    createdBefore: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the epic, e.g., \"1\"."
    iid: ID,
    "Filter epics by IID for autocomplete."
    iidStartsWith: String,
    "List of IIDs of epics, e.g., `[1, 2]`."
    iids: [ID!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Include epics from ancestor groups."
    includeAncestorGroups: Boolean = true,
    "Include epics from descendant groups."
    includeDescendantGroups: Boolean = true,
    "Filter epics by labels."
    labelName: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter epics by milestone title, computed from epic's issues."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Negated epic arguments."
    not: NegatedEpicFilterInput,
    "Search query for title or description."
    search: String,
    "List epics by sort order."
    sort: EpicSort,
    "Filter epics by state."
    state: EpicState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Filter epics with a top-level hierarchy."
    topLevelHierarchyOnly: Boolean,
    "Epics updated after this date."
    updatedAfter: Time,
    "Epics updated before this date."
    updatedBefore: Time
  ): EpicConnection
  "Author of the epic."
  author: UserCore!
  "List of emoji reactions associated with the epic."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Indicates the epic is blocked."
  blocked: Boolean
  "Count of epics blocking this epic."
  blockedByCount: Int
  "Epics blocking this epic."
  blockedByEpics(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EpicConnection
  "Count of epics that this epic is blocking."
  blockingCount: Int
  "Children (sub-epics) of the epic."
  children(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter epics by author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter epics by given confidentiality."
    confidential: Boolean,
    "Epics created after this date."
    createdAfter: Time,
    "Epics created before this date."
    createdBefore: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the epic, e.g., \"1\"."
    iid: ID,
    "Filter epics by IID for autocomplete."
    iidStartsWith: String,
    "List of IIDs of epics, e.g., `[1, 2]`."
    iids: [ID!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Include child epics from ancestor groups."
    includeAncestorGroups: Boolean = true,
    "Include epics from descendant groups."
    includeDescendantGroups: Boolean = true,
    "Filter epics by labels."
    labelName: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter epics by milestone title, computed from epic's issues."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Negated epic arguments."
    not: NegatedEpicFilterInput,
    "Search query for title or description."
    search: String,
    "List epics by sort order."
    sort: EpicSort,
    "Filter epics by state."
    state: EpicState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Filter epics with a top-level hierarchy."
    topLevelHierarchyOnly: Boolean,
    "Epics updated after this date."
    updatedAfter: Time,
    "Epics updated before this date."
    updatedBefore: Time
  ): EpicConnection
  "Timestamp of when the epic was closed."
  closedAt: Time
  "Color of the epic. Returns `null` if `epic_color_highlight` feature flag is disabled."
  color: String
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Indicates if the epic is confidential."
  confidential: Boolean
  "Timestamp of when the epic was created."
  createdAt: Time
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Default Project for issue creation. Based on the project the user created the last issue in."
  defaultProjectForIssueCreation: Project
  "Number of open and closed descendant epics and issues."
  descendantCounts: EpicDescendantCount
  "Total weight of open and closed issues in the epic and its descendants."
  descendantWeightSum: EpicDescendantWeights
  "Description of the epic."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Number of downvotes the epic has received."
  downvotes: Int!
  "Due date of the epic."
  dueDate: Time
  "Fixed due date of the epic."
  dueDateFixed: Time
  "Inherited due date of the epic from child epics or milestones."
  dueDateFromInheritedSource: Time
  "Inherited due date of the epic from milestones."
  dueDateFromMilestones: Time
  "Indicates if the due date has been manually set."
  dueDateIsFixed: Boolean
  "List of events associated with the object."
  events(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EventConnection
  "Group to which the epic belongs."
  group: Group!
  "Indicates if the epic has children."
  hasChildren: Boolean!
  "Indicates if the epic has direct issues."
  hasIssues: Boolean!
  "Indicates if the epic has a parent epic."
  hasParent: Boolean!
  "Current health status of the epic."
  healthStatus: EpicHealthStatus
  "ID of the epic."
  id: ID!
  "Internal ID of the epic."
  iid: ID!
  "A list of issues associated with the epic."
  issues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EpicIssueConnection
  "Labels assigned to the epic."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Parent epic of the epic."
  parent: Epic
  "List of participants for the epic."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Internal reference of the epic. Returned in shortened format by default."
  reference(
    "Indicates if the reference should be returned in full."
    full: Boolean = false
  ): String!
  "URI path of the epic-issue relationship."
  relationPath: String
  "Relative position of the epic in the epic tree."
  relativePosition: Int
  "Start date of the epic."
  startDate: Time
  "Fixed start date of the epic."
  startDateFixed: Time
  "Inherited start date of the epic from child epics or milestones."
  startDateFromInheritedSource: Time
  "Inherited start date of the epic from milestones."
  startDateFromMilestones: Time
  "Indicates if the start date has been manually set."
  startDateIsFixed: Boolean
  "State of the epic."
  state: EpicState!
  "Indicates the currently logged in user is subscribed to the epic."
  subscribed: Boolean!
  "Text color generated for the epic. Returns `null` if `epic_color_highlight` feature flag is disabled."
  textColor: String
  "Title of the epic."
  title: String
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Timestamp of when the epic was updated."
  updatedAt: Time
  "Number of upvotes the epic has received."
  upvotes: Int!
  "Number of user discussions in the epic."
  userDiscussionsCount: Int!
  "Number of user notes of the epic."
  userNotesCount: Int!
  "Permissions for the current user on the resource"
  userPermissions: EpicPermissions!
  "User preferences for the epic on the issue board."
  userPreferences: BoardEpicUserPreferences
  "Web path of the epic."
  webPath: String!
  "Web URL of the epic."
  webUrl: String!
}

"The connection type for BoardEpic."
type BoardEpicConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [BoardEpicEdge]
  "A list of nodes."
  nodes: [BoardEpic]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of BoardEpicCreate."
type BoardEpicCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Epic after creation."
  epic: Epic
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type BoardEpicEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: BoardEpic
}

"Represents user preferences for a board epic"
type BoardEpicUserPreferences {
  "Indicates epic should be displayed as collapsed."
  collapsed: Boolean!
}

"Represents a list for an issue board"
type BoardList {
  "Assignee in the list."
  assignee: UserCore
  "Indicates if the list is collapsed for this user."
  collapsed: Boolean
  "ID (global ID) of the list."
  id: ID!
  "Board issues."
  issues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters applied when selecting issues in the board list."
    filters: BoardIssueInput,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssueConnection
  "Count of issues in the list."
  issuesCount: Int
  "Iteration of the list."
  iteration: Iteration
  "Label of the list."
  label: Label
  "Current limit metric for the list."
  limitMetric: ListLimitMetric
  "Type of the list."
  listType: String!
  "Maximum number of issues in the list."
  maxIssueCount: Int
  "Maximum weight of issues in the list."
  maxIssueWeight: Int
  "Milestone of the list."
  milestone: Milestone
  "Position of list within the board."
  position: Int
  "Title of the list."
  title: String!
  "Total weight of all issues in the list, encoded as a string."
  totalIssueWeight: BigInt
  "Total weight of all issues in the list. Deprecated in 16.2: Use `totalIssueWeight`."
  totalWeight: Int @deprecated(reason: "Use `totalIssueWeight`. Deprecated in 16.2.")
}

"The connection type for BoardList."
type BoardListConnection {
  "A list of edges."
  edges: [BoardListEdge]
  "A list of nodes."
  nodes: [BoardList]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of BoardListCreate."
type BoardListCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue list in the issue board."
  list: BoardList
}

"An edge in a connection."
type BoardListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: BoardList
}

"Autogenerated return type of BoardListUpdateLimitMetrics."
type BoardListUpdateLimitMetricsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated list."
  list: BoardList
}

type Branch {
  "Commit for the branch."
  commit: Commit
  "Name of the branch."
  name: String!
}

"Branch protection details for a branch rule."
type BranchProtection {
  "Toggle force push to the branch for users with write access."
  allowForcePush: Boolean!
  "Enforce code owner approvals before allowing a merge."
  codeOwnerApprovalRequired: Boolean!
  "Details about who can merge when this branch is the source branch."
  mergeAccessLevels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeAccessLevelConnection
  "Details about who can push when this branch is the source branch."
  pushAccessLevels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PushAccessLevelConnection
  "Details about who can unprotect this branch."
  unprotectAccessLevels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UnprotectAccessLevelConnection
}

"List of branch rules for a project, grouped by branch name."
type BranchRule {
  "Merge request approval rules configured for this branch rule."
  approvalRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ApprovalProjectRuleConnection
  "Branch protections configured for this branch rule."
  branchProtection: BranchProtection
  "Timestamp of when the branch rule was created."
  createdAt: Time!
  "External status checks configured for this branch rule."
  externalStatusChecks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ExternalStatusCheckConnection
  "Check if this branch rule protects the project's default branch."
  isDefault: Boolean!
  "Check if this branch rule protects access for the branch."
  isProtected: Boolean!
  "Number of existing branches that match this branch rule."
  matchingBranchesCount: Int!
  "Branch name, with wildcards, for the branch rules."
  name: String!
  "Timestamp of when the branch rule was last updated."
  updatedAt: Time!
}

"The connection type for BranchRule."
type BranchRuleConnection {
  "A list of edges."
  edges: [BranchRuleEdge]
  "A list of nodes."
  nodes: [BranchRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of BranchRuleCreate."
type BranchRuleCreatePayload {
  "Branch rule after mutation."
  branchRule: BranchRule
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type BranchRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: BranchRule
}

"Autogenerated return type of BranchRuleUpdate."
type BranchRuleUpdatePayload {
  "Branch rule after mutation."
  branchRule: BranchRule
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of BuildForecast."
type BuildForecastPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created forecast."
  forecast: Forecast!
}

"Autogenerated return type of BulkDestroyJobArtifacts."
type BulkDestroyJobArtifactsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of job artifacts deleted."
  destroyedCount: Int
  "IDs of job artifacts that were deleted."
  destroyedIds: [CiJobArtifactID!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of BulkEnableDevopsAdoptionNamespaces."
type BulkEnableDevopsAdoptionNamespacesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Enabled namespaces after mutation."
  enabledNamespaces: [DevopsAdoptionEnabledNamespace!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of BulkRunnerDelete."
type BulkRunnerDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of records effectively deleted. Only present if operation was performed synchronously."
  deletedCount: Int
  "IDs of records effectively deleted. Only present if operation was performed synchronously."
  deletedIds: [CiRunnerID!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents the total number of issues and their weights for a particular day"
type BurnupChartDailyTotals {
  "Number of closed issues as of this day."
  completedCount: Int!
  "Total weight of closed issues as of this day."
  completedWeight: Int!
  "Date for burnup totals."
  date: ISO8601Date!
  "Number of issues as of this day."
  scopeCount: Int!
  "Total weight of issues as of this day."
  scopeWeight: Int!
}

"Autogenerated return type of CatalogResourcesCreate."
type CatalogResourcesCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CatalogResourcesDestroy."
type CatalogResourcesDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type CiApplicationSettings {
  "Whether to keep the latest jobs artifacts."
  keepLatestArtifact: Boolean
}

type CiBuildNeed {
  "ID of the BuildNeed."
  id: ID!
  "Name of the job we need to complete."
  name: String
}

"The connection type for CiBuildNeed."
type CiBuildNeedConnection {
  "A list of edges."
  edges: [CiBuildNeedEdge]
  "A list of nodes."
  nodes: [CiBuildNeed]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiBuildNeedEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiBuildNeed
}

type CiCatalogResource {
  "Description of the catalog resource. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  description: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "Icon for the catalog resource. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  icon: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "ID of the catalog resource. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  id: ID! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "Release date of the catalog resource's latest version. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  latestReleasedAt: Time @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Latest version of the catalog resource. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  latestVersion: CiCatalogResourceVersion @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Name of the catalog resource. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  name: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "Count of open issues that belong to the the catalog resource. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  openIssuesCount: Int! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Count of open merge requests that belong to the the catalog resource. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  openMergeRequestsCount: Int! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "GitLab Flavored Markdown rendering of `readme` Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  readmeHtml: String! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Number of times the catalog resource has been starred. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  starCount: Int! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Versions of the catalog resource. This field can only be resolved for one catalog resource in any single request. Introduced in 16.2: This feature is an Experiment. It can be changed or removed at any time."
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Name of the version."
    name: String,
    "Sort versions by given criteria."
    sort: CiCatalogResourceVersionSort
  ): CiCatalogResourceVersionConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.")
  "Web path of the catalog resource. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  webPath: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
}

type CiCatalogResourceComponent {
  "ID of the component. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  id: CiCatalogResourcesComponentID! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Path used to include the component. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  includePath: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Inputs for the component. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  inputs: [CiCatalogResourceComponentInput!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Name of the component. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  name: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
}

"The connection type for CiCatalogResourceComponent."
type CiCatalogResourceComponentConnection {
  "A list of edges."
  edges: [CiCatalogResourceComponentEdge]
  "A list of nodes."
  nodes: [CiCatalogResourceComponent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiCatalogResourceComponentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiCatalogResourceComponent
}

type CiCatalogResourceComponentInput {
  "Default value for the input. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  default: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Name of the input. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  name: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Indicates if an input is required. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  required: Boolean @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
}

"The connection type for CiCatalogResource."
type CiCatalogResourceConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiCatalogResourceEdge]
  "A list of nodes."
  nodes: [CiCatalogResource]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiCatalogResourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiCatalogResource
}

type CiCatalogResourceVersion {
  "User that created the version. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  author: UserCore @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Commit associated with the version. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  commit: Commit @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Components belonging to the catalog resource. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  components(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiCatalogResourceComponentConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Timestamp of when the version was created. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  createdAt: Time @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Global ID of the version. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  id: CiCatalogResourcesVersionID! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Name that uniquely identifies the version within the catalog resource. Introduced in 16.8: This feature is an Experiment. It can be changed or removed at any time."
  name: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  "Relative web path to the version. Introduced in 16.8: This feature is an Experiment. It can be changed or removed at any time."
  path: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  "GitLab Flavored Markdown rendering of README.md. This field can only be resolved for one version in any single request. Introduced in 16.8: This feature is an Experiment. It can be changed or removed at any time."
  readmeHtml: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  "Timestamp of when the version was released. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  releasedAt: Time @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
}

"The connection type for CiCatalogResourceVersion."
type CiCatalogResourceVersionConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiCatalogResourceVersionEdge]
  "A list of nodes."
  nodes: [CiCatalogResourceVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiCatalogResourceVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiCatalogResourceVersion
}

type CiConfig {
  "Linting errors."
  errors: [String!]
  "List of included files."
  includes: [CiConfigInclude!]
  "Merged CI configuration YAML."
  mergedYaml: String
  "Stages of the pipeline."
  stages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigStageConnection
  "Status of linting, can be either valid or invalid."
  status: CiConfigStatus
  "Linting warnings."
  warnings: [String!]
}

type CiConfigGroup {
  "Jobs in group."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigJobConnection
  "Name of the job group."
  name: String
  "Size of the job group."
  size: Int
}

"The connection type for CiConfigGroup."
type CiConfigGroupConnection {
  "A list of edges."
  edges: [CiConfigGroupEdge]
  "A list of nodes."
  nodes: [CiConfigGroup]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiConfigGroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigGroup
}

type CiConfigInclude {
  "File blob location. It can be masked if it contains masked variables. For example, `\"https://gitlab.com/gitlab-org/gitlab/-/blob/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml\"`."
  blob: String
  "Current project scope, e.g., \"gitlab-org/gitlab\"."
  contextProject: String
  "Current sha scope."
  contextSha: String
  "Extra information for the `include`, which can contain `job_name`, `project`, and `ref`. Values can be masked if they contain masked variables."
  extra: JSON
  "File location. It can be masked if it contains masked variables. For example, `\".gitlab/ci/build-images.gitlab-ci.yml\"`."
  location: String
  "File raw location. It can be masked if it contains masked variables. For example, `\"https://gitlab.com/gitlab-org/gitlab/-/raw/e52d6d0246d7375291850e61f0abc101fbda9dc2/.gitlab/ci/build-images.gitlab-ci.yml\"`."
  raw: String
  "Include type."
  type: CiConfigIncludeType
}

type CiConfigJob {
  "Override a set of commands that are executed after the job."
  afterScript: [String!]
  "Allow job to fail."
  allowFailure: Boolean
  "Override a set of commands that are executed before the job."
  beforeScript: [String!]
  "Name of an environment to which the job deploys."
  environment: String
  "Limit when jobs are not created."
  except: CiConfigJobRestriction
  "Name of the job group."
  groupName: String
  "Name of the job."
  name: String
  "Builds that must complete before the jobs run."
  needs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigNeedConnection
  "Jobs are created when these conditions do not apply."
  only: CiConfigJobRestriction
  "Shell script that is executed by a runner."
  script: [String!]
  "Name of the job stage."
  stage: String
  "List of tags that are used to select a runner."
  tags: [String!]
  "When to run the job."
  when: String
}

"The connection type for CiConfigJob."
type CiConfigJobConnection {
  "A list of edges."
  edges: [CiConfigJobEdge]
  "A list of nodes."
  nodes: [CiConfigJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiConfigJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigJob
}

type CiConfigJobRestriction {
  "Git refs the job restriction applies to."
  refs: [String!]
}

type CiConfigNeed {
  "Name of the need."
  name: String
}

"The connection type for CiConfigNeed."
type CiConfigNeedConnection {
  "A list of edges."
  edges: [CiConfigNeedEdge]
  "A list of nodes."
  nodes: [CiConfigNeed]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiConfigNeedEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigNeed
}

type CiConfigStage {
  "Groups of jobs for the stage."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiConfigGroupConnection
  "Name of the stage."
  name: String
}

"The connection type for CiConfigStage."
type CiConfigStageConnection {
  "A list of edges."
  edges: [CiConfigStageEdge]
  "A list of nodes."
  nodes: [CiConfigStage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiConfigStageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiConfigStage
}

"CI/CD config variables."
type CiConfigVariable {
  "Description for the CI/CD config variable."
  description: String
  "Name of the variable."
  key: String
  "Value of the variable."
  value: String
  "Value options for the variable."
  valueOptions: [String!]
}

"Represents a deployment freeze window of a project"
type CiFreezePeriod {
  "Time zone for the cron fields, defaults to UTC if not provided."
  cronTimezone: String
  "End of the freeze period in cron format."
  endCron: String!
  "Timestamp (UTC) of when the current/next active period ends."
  endTime: Time
  "Start of the freeze period in cron format."
  startCron: String!
  "Timestamp (UTC) of when the current/next active period starts."
  startTime: Time
  "Freeze period status."
  status: CiFreezePeriodStatus!
}

type CiGroup {
  "Detailed status of the group."
  detailedStatus: DetailedStatus
  "ID for a group."
  id: String!
  "Jobs in group."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Name of the job group."
  name: String
  "Size of the group."
  size: Int
}

"The connection type for CiGroup."
type CiGroupConnection {
  "A list of edges."
  edges: [CiGroupEdge]
  "A list of nodes."
  nodes: [CiGroup]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiGroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiGroup
}

"Ci/CD environment scope for a group."
type CiGroupEnvironmentScope {
  "Scope name defininig the enviromnments that can use the variable."
  name: String
}

"The connection type for CiGroupEnvironmentScope."
type CiGroupEnvironmentScopeConnection {
  "A list of edges."
  edges: [CiGroupEnvironmentScopeEdge]
  "A list of nodes."
  nodes: [CiGroupEnvironmentScope]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiGroupEnvironmentScopeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiGroupEnvironmentScope
}

"CI/CD variables for a group."
type CiGroupVariable implements CiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable."
  environmentScope: String
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}

"The connection type for CiGroupVariable."
type CiGroupVariableConnection {
  "A list of edges."
  edges: [CiGroupVariableEdge]
  "Maximum amount of group CI/CD variables."
  limit: Int!
  "A list of nodes."
  nodes: [CiGroupVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiGroupVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiGroupVariable
}

"CI/CD variables for a GitLab instance."
type CiInstanceVariable implements CiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable. Deprecated in 15.3: No longer used, only available for GroupVariableType and ProjectVariableType."
  environmentScope: String @deprecated(reason: "No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in 15.3.")
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}

"The connection type for CiInstanceVariable."
type CiInstanceVariableConnection {
  "A list of edges."
  edges: [CiInstanceVariableEdge]
  "A list of nodes."
  nodes: [CiInstanceVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiInstanceVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiInstanceVariable
}

type CiJob {
  "Indicates the job is active."
  active: Boolean!
  "Ai generated analysis of the root cause of failure. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  aiFailureAnalysis: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Whether the job is allowed to fail."
  allowFailure: Boolean!
  "Artifacts generated by the job."
  artifacts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobArtifactConnection
  "URL for browsing the artifact's archive."
  browseArtifactsPath: String
  "Indicates whether the current user can play the job."
  canPlayJob: Boolean!
  "Indicates the job can be canceled."
  cancelable: Boolean!
  "Path to the commit that triggered the job."
  commitPath: String
  "Coverage level of the job."
  coverage: Float
  "When the job was created."
  createdAt: Time!
  "Whether the job was created by a tag."
  createdByTag: Boolean!
  "Detailed status of the job."
  detailedStatus: DetailedStatus
  "Downstream pipeline for a bridge."
  downstreamPipeline: Pipeline
  "Duration of the job in seconds."
  duration: Int
  "When the job was erased."
  erasedAt: Time
  "Message on why the job failed."
  failureMessage: String
  "When a job has finished running."
  finishedAt: Time
  "ID of the job."
  id: JobID
  "Indicates the type of job."
  kind: CiJobKind!
  "Whether the job has a manual action."
  manualJob: Boolean
  "Variables added to a manual job when the job is triggered."
  manualVariables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiManualVariableConnection
  "Name of the job."
  name: String
  "References to builds that must complete before the jobs run."
  needs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiBuildNeedConnection
  "Pipeline the job belongs to."
  pipeline: Pipeline
  "Play path of the job."
  playPath: String
  "Indicates the job can be played."
  playable: Boolean!
  "Jobs from the previous stage."
  previousStageJobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Jobs that must complete before the job runs. Returns `BuildNeed`, which is the needed jobs if the job uses the `needs` keyword, or the previous stage jobs otherwise. Deprecated in 16.4: Replaced by previousStageJobs and needs fields."
  previousStageJobsOrNeeds(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): JobNeedUnionConnection @deprecated(reason: "Replaced by previousStageJobs and needs fields. Deprecated in 16.4.")
  "Project that the job belongs to."
  project: Project
  "When the job was enqueued and marked as pending."
  queuedAt: Time
  "How long the job was enqueued before starting."
  queuedDuration: Duration
  "Ref name of the job."
  refName: String
  "Path to the ref."
  refPath: String
  "Indicates that the job has been retried."
  retried: Boolean
  "Indicates the job can be retried."
  retryable: Boolean!
  "Runner assigned to execute the job."
  runner: CiRunner
  "Runner manager assigned to the job. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  runnerManager: CiRunnerManager @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "Indicates the job is scheduled."
  scheduled: Boolean!
  "Schedule for the build."
  scheduledAt: Time
  "Type of job scheduling. Value is `dag` if the job uses the `needs` keyword, and `stage` otherwise."
  schedulingType: String
  "Short SHA1 ID of the commit."
  shortSha: String!
  "Stage of the job."
  stage: CiStage
  "When the job was started."
  startedAt: Time
  "Status of the job."
  status: CiJobStatus
  "Indicates the job is stuck."
  stuck: Boolean!
  "Tags for the current job."
  tags: [String!]
  "Trace generated by the job."
  trace: CiJobTrace
  "Whether the job was triggered."
  triggered: Boolean
  "Permissions for the current user on the resource"
  userPermissions: JobPermissions!
  "Web path of the job."
  webPath: String
}

type CiJobArtifact {
  "URL for downloading the artifact's file."
  downloadPath: String
  "Expiry date of the artifact."
  expireAt: Time
  "File type of the artifact."
  fileType: JobArtifactFileType
  "ID of the artifact."
  id: CiJobArtifactID!
  "File name of the artifact."
  name: String
  "Size of the artifact in bytes."
  size: BigInt!
}

"The connection type for CiJobArtifact."
type CiJobArtifactConnection {
  "A list of edges."
  edges: [CiJobArtifactEdge]
  "A list of nodes."
  nodes: [CiJobArtifact]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiJobArtifactEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJobArtifact
}

"The connection type for CiJob."
type CiJobConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [CiJobEdge]
  "A list of nodes."
  nodes: [CiJob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiJobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiJob
}

"Autogenerated return type of CiJobTokenScopeAddProject."
type CiJobTokenScopeAddProjectPayload {
  "CI job token's access scope."
  ciJobTokenScope: CiJobTokenScopeType
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CiJobTokenScopeRemoveProject."
type CiJobTokenScopeRemoveProjectPayload {
  "CI job token's scope of access."
  ciJobTokenScope: CiJobTokenScopeType
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type CiJobTokenScopeType {
  "Allow list of projects that can access the current project through its CI Job tokens."
  inboundAllowlist(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection!
  "Allow list of projects that are accessible using the current project's CI Job tokens."
  outboundAllowlist(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection!
  "Allow list of projects that can be accessed by CI Job tokens created by this project. Deprecated in 15.9: The `projects` attribute is being deprecated. Use `outbound_allowlist`."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection! @deprecated(reason: "The `projects` attribute is being deprecated. Use `outbound_allowlist`. Deprecated in 15.9.")
}

type CiJobTrace {
  "HTML summary that contains the tail lines of the trace. Returns at most 16KB of raw bytes from the trace. The returned string might start with an unexpected invalid UTF-8 code point due to truncation. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  htmlSummary(
    "Number of tail lines to return, up to a maximum of 100 lines."
    lastLines: Int = 10
  ): String! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
}

"Representation of duration statistics for a group of CI jobs."
type CiJobsDurationStatistics {
  "50th percentile. 50% of the durations are lower than this value. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  p50: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
  "75th percentile. 75% of the durations are lower than this value. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  p75: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
  "90th percentile. 90% of the durations are lower than this value. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  p90: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
  "95th percentile. 95% of the durations are lower than this value. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  p95: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
  "99th percentile. 99% of the durations are lower than this value. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  p99: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
}

"Statistics for a group of CI jobs."
type CiJobsStatistics {
  "Statistics for amount of time that jobs were waiting to be picked up. The calculation is performed based on the most recent 100 jobs executed by the 5000 most recently created runners in context. If no filter is applied to runners, the calculation is performed based on the most recent 100 jobs globally. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  queuedDuration: CiJobsDurationStatistics @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
}

"CI/CD variables given to a manual job."
type CiManualVariable implements CiVariable {
  "Scope defining the environments that can use the variable. Deprecated in 15.3: No longer used, only available for GroupVariableType and ProjectVariableType."
  environmentScope: String @deprecated(reason: "No longer used, only available for GroupVariableType and ProjectVariableType. Deprecated in 15.3.")
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}

"The connection type for CiManualVariable."
type CiManualVariableConnection {
  "A list of edges."
  edges: [CiManualVariableEdge]
  "A list of nodes."
  nodes: [CiManualVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiManualVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiManualVariable
}

type CiMinutesNamespaceMonthlyUsage {
  "Total number of compute minutes used by all projects in the namespace."
  minutes: Int
  "Month related to the usage data."
  month: String
  "Month related to the usage data in ISO 8601 date format."
  monthIso8601: ISO8601Date
  "Compute usage data for projects in the namespace."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiMinutesProjectMonthlyUsageConnection
  "Total duration (in seconds) of shared runners use by the namespace for the month."
  sharedRunnersDuration: Int
}

"The connection type for CiMinutesNamespaceMonthlyUsage."
type CiMinutesNamespaceMonthlyUsageConnection {
  "A list of edges."
  edges: [CiMinutesNamespaceMonthlyUsageEdge]
  "A list of nodes."
  nodes: [CiMinutesNamespaceMonthlyUsage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiMinutesNamespaceMonthlyUsageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiMinutesNamespaceMonthlyUsage
}

type CiMinutesProjectMonthlyUsage {
  "Number of compute minutes used by the project in the month."
  minutes: Int
  "Name of the project. Deprecated in 15.6: Use `project.name`."
  name: String @deprecated(reason: "Use `project.name`. Deprecated in 15.6.")
  "Project having the recorded usage."
  project: Project
  "Total duration (in seconds) of shared runners use by the project for the month."
  sharedRunnersDuration: Int
}

"The connection type for CiMinutesProjectMonthlyUsage."
type CiMinutesProjectMonthlyUsageConnection {
  "A list of edges."
  edges: [CiMinutesProjectMonthlyUsageEdge]
  "A list of nodes."
  nodes: [CiMinutesProjectMonthlyUsage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiMinutesProjectMonthlyUsageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiMinutesProjectMonthlyUsage
}

"CI/CD variables for a project."
type CiProjectVariable implements CiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable."
  environmentScope: String
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}

"The connection type for CiProjectVariable."
type CiProjectVariableConnection {
  "A list of edges."
  edges: [CiProjectVariableEdge]
  "Maximum amount of project CI/CD variables."
  limit: Int!
  "A list of nodes."
  nodes: [CiProjectVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiProjectVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiProjectVariable
}

type CiRunner {
  "Access level of the runner."
  accessLevel: CiRunnerAccessLevel!
  "Indicates the runner is allowed to receive jobs. Deprecated in 14.8: Use paused."
  active: Boolean! @deprecated(reason: "Use paused. Deprecated in 14.8.")
  "Admin URL of the runner. Only available for administrators."
  adminUrl: String
  "Architecture provided by the the runner. Deprecated in 16.2: Use field in `manager` object instead."
  architectureName: String @deprecated(reason: "Use field in `manager` object instead. Deprecated in 16.2.")
  "Timestamp of last contact from this runner."
  contactedAt: Time
  "Timestamp of creation of this runner."
  createdAt: Time
  "User that created this runner."
  createdBy: UserCore
  "Description of the runner."
  description: String
  "Admin form URL of the runner. Only available for administrators."
  editAdminUrl: String
  "Ephemeral authentication token used for runner manager registration. Only available for the creator of the runner for a limited time during registration. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  ephemeralAuthenticationToken: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "URL of the registration page of the runner manager. Only available for the creator of the runner for a limited time during registration. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  ephemeralRegisterUrl: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "Executor last advertised by the runner. Deprecated in 16.2: Use field in `manager` object instead."
  executorName: String @deprecated(reason: "Use field in `manager` object instead. Deprecated in 16.2.")
  "Groups the runner is associated with. For group runners only."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection
  "ID of the runner."
  id: CiRunnerID!
  "IP address of the runner. Deprecated in 16.2: Use field in `manager` object instead."
  ipAddress: String @deprecated(reason: "Use field in `manager` object instead. Deprecated in 16.2.")
  """

  Number of jobs processed by the runner (limited to 1000, plus one to indicate that more items exist).
  `jobCount` is an optimized version of `jobs { count }`, and can be requested for multiple runners on the same request.
  """
  jobCount: Int
  "Job execution status of the runner. Introduced in 15.7: This feature is an Experiment. It can be changed or removed at any time."
  jobExecutionStatus: CiRunnerJobExecutionStatus @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.7.")
  "Jobs assigned to the runner. This field can only be resolved for one runner in any single request."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter jobs by status."
    statuses: [CiJobStatus!]
  ): CiJobConnection
  "Indicates the runner is locked."
  locked: Boolean
  "Runner's maintenance notes."
  maintenanceNote: String
  "GitLab Flavored Markdown rendering of `maintenance_note`"
  maintenanceNoteHtml: String
  "Machines associated with the runner configuration. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  managers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiRunnerManagerConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Maximum timeout (in seconds) for jobs processed by the runner."
  maximumTimeout: Int
  "Project that owns the runner. For project runners only."
  ownerProject: Project
  "Indicates the runner is paused and not available to run jobs."
  paused: Boolean!
  "Platform provided by the runner. Deprecated in 16.2: Use field in `manager` object instead."
  platformName: String @deprecated(reason: "Use field in `manager` object instead. Deprecated in 16.2.")
  "Private projects' \"compute cost factor\" associated with the runner (GitLab.com only)."
  privateProjectsMinutesCostFactor: Float
  "Number of projects that the runner is associated with."
  projectCount: Int
  "Find projects the runner is associated with. For project runners only."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Return only projects that the current user is a member of."
    membership: Boolean,
    "Search query, which can be for the project name, a path, or a description."
    search: String,
    "Include namespace in project search."
    searchNamespaces: Boolean,
    "Filter projects by topics."
    topics: [String!]
  ): ProjectConnection
  "Public projects' \"compute cost factor\" associated with the runner (GitLab.com only)."
  publicProjectsMinutesCostFactor: Float
  "URL of the temporary registration page of the runner. Only available before the runner is registered. Only available for administrators."
  registerAdminUrl: String
  "Revision of the runner. Deprecated in 16.2: Use field in `manager` object instead."
  revision: String @deprecated(reason: "Use field in `manager` object instead. Deprecated in 16.2.")
  "Indicates the runner is able to run untagged jobs."
  runUntagged: Boolean!
  "Type of the runner."
  runnerType: CiRunnerType!
  "First eight characters of the runner's token used to authenticate new job requests. Used as the runner's unique ID."
  shortSha: String
  "Status of the runner."
  status: CiRunnerStatus!
  "Tags associated with the runner."
  tagList: [String!]
  "Runner token expiration time."
  tokenExpiresAt: Time
  "Availability of upgrades for the runner. Introduced in 14.10: This feature is an Experiment. It can be changed or removed at any time."
  upgradeStatus: CiRunnerUpgradeStatus @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 14.10.")
  "Permissions for the current user on the resource"
  userPermissions: RunnerPermissions!
  "Version of the runner. Deprecated in 16.2: Use field in `manager` object instead."
  version: String @deprecated(reason: "Use field in `manager` object instead. Deprecated in 16.2.")
}

"The connection type for CiRunner."
type CiRunnerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiRunnerEdge]
  """

  Jobs statistics for jobs executed by a collection of runners. Available only to admins.
  """
  jobsStatistics: CiJobsStatistics
  "A list of nodes."
  nodes: [CiRunner]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiRunnerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "Web URL of the runner edit page. The value depends on where you put this field in the query. You can use it for projects or groups."
  editUrl: String
  "The item at the end of the edge."
  node: CiRunner
  "Web URL of the runner. The value depends on where you put this field in the query. You can use it for projects or groups."
  webUrl: String
}

type CiRunnerManager {
  "Architecture provided by the runner manager."
  architectureName: String
  "Timestamp of last contact from the runner manager."
  contactedAt: Time
  "Timestamp of creation of the runner manager."
  createdAt: Time
  "Executor last advertised by the runner."
  executorName: String
  "ID of the runner manager."
  id: CiRunnerManagerID!
  "IP address of the runner manager."
  ipAddress: String
  "Job execution status of the runner manager. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  jobExecutionStatus: CiRunnerJobExecutionStatus @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Platform provided by the runner manager."
  platformName: String
  "Revision of the runner."
  revision: String
  "Runner configuration for the runner manager."
  runner: CiRunner
  "Status of the runner manager."
  status: CiRunnerStatus!
  "System ID associated with the runner manager."
  systemId: String!
  "Availability of upgrades for the runner manager. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  upgradeStatus: CiRunnerUpgradeStatus @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Version of the runner."
  version: String
}

"The connection type for CiRunnerManager."
type CiRunnerManagerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiRunnerManagerEdge]
  "A list of nodes."
  nodes: [CiRunnerManager]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiRunnerManagerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiRunnerManager
}

"Represents the Geo replication and verification state of a ci_secure_file."
type CiSecureFileRegistry {
  "ID of the Ci Secure File."
  ciSecureFileId: ID!
  "Timestamp when the CiSecureFileRegistry was created"
  createdAt: Time
  "ID of the CiSecureFileRegistry"
  id: ID!
  "Error message during sync of the CiSecureFileRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the CiSecureFileRegistry"
  lastSyncedAt: Time
  "Timestamp after which the CiSecureFileRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the CiSecureFileRegistry"
  retryCount: Int
  "Sync state of the CiSecureFileRegistry"
  state: RegistryState
  "The local checksum of the CiSecureFileRegistry"
  verificationChecksum: String
  "Error message during verification of the CiSecureFileRegistry"
  verificationFailure: String
  "Timestamp after which the CiSecureFileRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the CiSecureFileRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of CiSecureFileRegistry"
  verificationStartedAt: Time
  "Verification state of the CiSecureFileRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the CiSecureFileRegistry"
  verifiedAt: Time
}

"The connection type for CiSecureFileRegistry."
type CiSecureFileRegistryConnection {
  "A list of edges."
  edges: [CiSecureFileRegistryEdge]
  "A list of nodes."
  nodes: [CiSecureFileRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiSecureFileRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiSecureFileRegistry
}

type CiStage {
  "Detailed status of the stage."
  detailedStatus: DetailedStatus
  "Group of jobs for the stage."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiGroupConnection
  "ID of the stage."
  id: ID!
  "Jobs for the stage."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiJobConnection
  "Name of the stage."
  name: String
  "Status of the pipeline stage."
  status: String
}

"The connection type for CiStage."
type CiStageConnection {
  "A list of edges."
  edges: [CiStageEdge]
  "A list of nodes."
  nodes: [CiStage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiStageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiStage
}

type CiSubscriptionsProject {
  "Author of the subscription."
  author: UserCore
  "Downstream project of the subscription."
  downstreamProject: Project
  "Global ID of the subscription."
  id: CiSubscriptionsProjectID
  "Upstream project of the subscription."
  upstreamProject: Project
}

"The connection type for CiSubscriptionsProject."
type CiSubscriptionsProjectConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CiSubscriptionsProjectEdge]
  "A list of nodes."
  nodes: [CiSubscriptionsProject]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CiSubscriptionsProjectEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CiSubscriptionsProject
}

"GitLab CI/CD configuration template."
type CiTemplate {
  "Contents of the CI template."
  content: String!
  "Name of the CI template."
  name: String!
}

type ClusterAgent {
  "Recent activity for the cluster agent."
  activityEvents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentActivityEventConnection
  "Active connections for the cluster agent"
  connections(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ConnectedAgentConnection
  "Timestamp the cluster agent was created."
  createdAt: Time
  "User object, containing information about the person who created the agent."
  createdByUser: UserCore
  "ID of the cluster agent."
  id: ID!
  "Name of the cluster agent."
  name: String
  "Project this cluster agent is associated with."
  project: Project
  "Tokens associated with the cluster agent."
  tokens(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentTokenConnection
  "Timestamp the cluster agent was updated."
  updatedAt: Time
  "Container images reported on the agent vulnerabilities."
  vulnerabilityImages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityContainerImageConnection
  "Web path of the cluster agent."
  webPath: String
  "Workspaces associated with the agent. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalID."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
}

type ClusterAgentActivityEvent {
  "Agent token associated with the event."
  agentToken: ClusterAgentToken
  "Type of event."
  kind: String
  "Severity of the event."
  level: String
  "Timestamp the event was recorded."
  recordedAt: Time
  "User associated with the event."
  user: UserCore
}

"The connection type for ClusterAgentActivityEvent."
type ClusterAgentActivityEventConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ClusterAgentActivityEventEdge]
  "A list of nodes."
  nodes: [ClusterAgentActivityEvent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClusterAgentActivityEventEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentActivityEvent
}

type ClusterAgentAuthorizationCiAccess {
  "Authorized cluster agent."
  agent: ClusterAgent
  "Configuration for the authorized project."
  config: JSON
}

"The connection type for ClusterAgentAuthorizationCiAccess."
type ClusterAgentAuthorizationCiAccessConnection {
  "A list of edges."
  edges: [ClusterAgentAuthorizationCiAccessEdge]
  "A list of nodes."
  nodes: [ClusterAgentAuthorizationCiAccess]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClusterAgentAuthorizationCiAccessEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentAuthorizationCiAccess
}

type ClusterAgentAuthorizationUserAccess {
  "Authorized cluster agent."
  agent: ClusterAgent
  "Configuration for the authorized project."
  config: JSON
}

"The connection type for ClusterAgentAuthorizationUserAccess."
type ClusterAgentAuthorizationUserAccessConnection {
  "A list of edges."
  edges: [ClusterAgentAuthorizationUserAccessEdge]
  "A list of nodes."
  nodes: [ClusterAgentAuthorizationUserAccess]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ClusterAgentAuthorizationUserAccessEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentAuthorizationUserAccess
}

"The connection type for ClusterAgent."
type ClusterAgentConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ClusterAgentEdge]
  "A list of nodes."
  nodes: [ClusterAgent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of ClusterAgentDelete."
type ClusterAgentDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type ClusterAgentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgent
}

type ClusterAgentToken {
  "Cluster agent this token is associated with."
  clusterAgent: ClusterAgent
  "Timestamp the token was created."
  createdAt: Time
  "User who created the token."
  createdByUser: UserCore
  "Description of the token."
  description: String
  "Global ID of the token."
  id: ClustersAgentTokenID!
  "Timestamp the token was last used."
  lastUsedAt: Time
  "Name given to the token."
  name: String
  "Current status of the token."
  status: AgentTokenStatus
}

"The connection type for ClusterAgentToken."
type ClusterAgentTokenConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ClusterAgentTokenEdge]
  "A list of nodes."
  nodes: [ClusterAgentToken]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of ClusterAgentTokenCreate."
type ClusterAgentTokenCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Token secret value. Make sure you save it - you won't be able to access it again."
  secret: String
  "Token created after mutation."
  token: ClusterAgentToken
}

"An edge in a connection."
type ClusterAgentTokenEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ClusterAgentToken
}

"Autogenerated return type of ClusterAgentTokenRevoke."
type ClusterAgentTokenRevokePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents the code coverage activity for a group"
type CodeCoverageActivity {
  "Average percentage of the different code coverage results available for the group."
  averageCoverage: Float
  "Number of different code coverage results available for the group."
  coverageCount: Int
  "Date when the code coverage was created."
  date: Date!
  "Number of projects with code coverage results for the group."
  projectCount: Int
}

"The connection type for CodeCoverageActivity."
type CodeCoverageActivityConnection {
  "A list of edges."
  edges: [CodeCoverageActivityEdge]
  "A list of nodes."
  nodes: [CodeCoverageActivity]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CodeCoverageActivityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CodeCoverageActivity
}

"Represents the code coverage summary for a project"
type CodeCoverageSummary {
  "Average percentage of the different code coverage results available for the project."
  averageCoverage: Float
  "Number of different code coverage results available."
  coverageCount: Int
  "Latest date when the code coverage was created for the project."
  lastUpdatedOn: Date
}

"Represents a code quality degradation on the pipeline."
type CodeQualityDegradation {
  "Description of the code quality degradation."
  description: String!
  "Code Quality plugin that reported the finding."
  engineName: String!
  "Unique fingerprint to identify the code quality degradation. For example, an MD5 hash."
  fingerprint: String!
  "Line on which the code quality degradation occurred."
  line: Int!
  "Relative path to the file containing the code quality degradation."
  path: String!
  "Status of the degradation (BLOCKER, CRITICAL, MAJOR, MINOR, INFO, UNKNOWN)."
  severity: CodeQualityDegradationSeverity!
  "URL to the file along with line number."
  webUrl: String
}

"The connection type for CodeQualityDegradation."
type CodeQualityDegradationConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CodeQualityDegradationEdge]
  "A list of nodes."
  nodes: [CodeQualityDegradation]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CodeQualityDegradationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CodeQualityDegradation
}

"Code Quality report for a pipeline"
type CodeQualityReportSummary {
  "Total number of blocker status."
  blocker: Int
  "Total number of Code Quality reports."
  count: Int
  "Total number of critical status."
  critical: Int
  "Total number of info status."
  info: Int
  "Total number of major status."
  major: Int
  "Total number of minor status."
  minor: Int
  "Total number of unknown status."
  unknown: Int
}

"Represents reports comparison for code quality."
type CodequalityReportsComparer {
  "Compared codequality report."
  report: CodequalityReportsComparerReport
  "Compared codequality report generation status."
  status: CodequalityReportsComparerReportGenerationStatus
}

"Represents compared code quality report."
type CodequalityReportsComparerReport {
  "All code quality degradations."
  existingErrors: [CodequalityReportsComparerReportDegradation!]
  "New code quality degradations."
  newErrors: [CodequalityReportsComparerReportDegradation!]!
  "Resolved code quality degradations."
  resolvedErrors: [CodequalityReportsComparerReportDegradation!]
  "Status of report."
  status: CodequalityReportsComparerStatus!
  "Codequality report summary."
  summary: CodequalityReportsComparerReportSummary!
}

"Represents a degradation on the compared codequality report."
type CodequalityReportsComparerReportDegradation {
  "Description of the code quality degradation."
  description: String!
  "Code quality plugin that reported the degradation."
  engineName: String
  "Relative path to the file containing the code quality degradation."
  filePath: String!
  "Unique fingerprint to identify the code quality degradation. For example, an MD5 hash."
  fingerprint: String!
  "Line on which the code quality degradation occurred."
  line: Int!
  "Severity of the code quality degradation (BLOCKER, CRITICAL, MAJOR, MINOR, INFO, UNKNOWN)."
  severity: CodeQualityDegradationSeverity!
  "URL to the file along with line number."
  webUrl: String
}

"Represents a summary of the compared codequality report."
type CodequalityReportsComparerReportSummary {
  "Count of code quality errors."
  errored: Int
  "Count of resolved code quality degradations."
  resolved: Int
  "Total count of code quality degradations."
  total: Int
}

type Commit implements Todoable {
  "Author of the commit."
  author: UserCore
  "Commit author's email."
  authorEmail: String
  "Commit authors gravatar."
  authorGravatar: String
  "Commit authors name."
  authorName: String
  "Timestamp of when the commit was authored."
  authoredDate: Time
  "Timestamp of when the commit was committed."
  committedDate: Time
  "Email of the committer."
  committerEmail: String
  "Name of the committer."
  committerName: String
  "Description of the commit message."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Diffs contained within the commit. This field can only be resolved for 10 diffs in any single request."
  diffs: [Diff!]
  "Full title of the commit message."
  fullTitle: String
  "GitLab Flavored Markdown rendering of `full_title`"
  fullTitleHtml: String
  "ID (global ID) of the commit."
  id: ID!
  "Raw commit message."
  message: String
  "Pipelines of the commit ordered latest first."
  pipelines(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by scope."
    scope: PipelineScopeEnum,
    "Filter pipelines by the sha of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String,
    "Filter pipelines by their status."
    status: PipelineStatusEnum,
    "Pipelines updated after this date."
    updatedAfter: Time,
    "Pipelines updated before this date."
    updatedBefore: Time,
    "Filter pipelines by the user that triggered the pipeline."
    username: String
  ): PipelineConnection
  "SHA1 ID of the commit."
  sha: String!
  "Short SHA1 ID of the commit."
  shortId: String!
  "Signature of the commit."
  signature: CommitSignature
  "Rendered HTML of the commit signature."
  signatureHtml: String
  "Title of the commit message."
  title: String
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Web path of the commit."
  webPath: String!
  "Web URL of the commit."
  webUrl: String!
}

"The connection type for Commit."
type CommitConnection {
  "A list of edges."
  edges: [CommitEdge]
  "A list of nodes."
  nodes: [Commit]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of CommitCreate."
type CommitCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Commit after mutation."
  commit: Commit
  "ETag path for the commit's pipeline."
  commitPipelinePath: String
  "Contents of the commit."
  content: [String!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type CommitData {
  "CSS class for age of commit."
  ageMapClass: String!
  "Link to author avatar."
  authorAvatar: String!
  "Link to the commit author."
  commitAuthorLink: String!
  "Link to the commit."
  commitLink: String!
  "Link to blame prior to the change."
  projectBlameLink: String
  "Time of commit."
  timeAgoTooltip: String!
}

"An edge in a connection."
type CommitEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Commit
}

type CommitParentNames {
  "Names of the commit parent (branch or tag)."
  names: [String!]
}

type CommitReferences {
  "Get branch names containing a given commit."
  containingBranches(
    """

    Exclude tipping refs. WARNING: This argument can be confusing, if there is a limit.
    for example set the limit to 5 and in the 5 out a total of 25 refs there is 2 tipped refs,
    then the method will only 3 refs, even though there is more.
    """
    excludeTipped: Boolean! = false,
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
  "Get tag names containing a given commit."
  containingTags(
    """

    Exclude tipping refs. WARNING: This argument can be confusing, if there is a limit.
    for example set the limit to 5 and in the 5 out a total of 25 refs there is 2 tipped refs,
    then the method will only 3 refs, even though there is more.
    """
    excludeTipped: Boolean! = false,
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
  "Get branch names tipping at a given commit."
  tippingBranches(
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
  "Get tag names tipping at a given commit."
  tippingTags(
    "Number of ref names to return."
    limit: Int! = 100
  ): CommitParentNames
}

"Represents compared security report."
type ComparedSecurityReport {
  "New vulnerability findings. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  added: [ComparedSecurityReportFinding!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Time of the base report creation."
  baseReportCreatedAt: Time
  "Indicates whether the base report out of date."
  baseReportOutOfDate: Boolean
  "Fixed vulnerability findings. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  fixed: [ComparedSecurityReportFinding!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Time of the base report creation."
  headReportCreatedAt: Time
}

"Represents finding."
type ComparedSecurityReportFinding {
  "Description of the vulnerability finding."
  description: String
  "IID of the pipeline."
  foundByPipelineIid: String
  "Identifiers of the vulnerability finding. Returns `null` if `sast_reports_in_inline_diff` feature flag is disabled. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  identifiers: [VulnerabilityIdentifier!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Location of the vulnerability finding. Returns `null` if `sast_reports_in_inline_diff` feature flag is disabled. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  location: VulnerabilityLocation @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Compared report vulnerability scanner."
  scanner: ComparedSecurityReportScanner
  "Severity of the vulnerability finding."
  severity: VulnerabilitySeverity
  "Finding status."
  state: VulnerabilityState
  "Title of the vulnerability finding."
  title: String
  "UUIDv5 digest based on the vulnerability's report type, primary identifier, location, fingerprint, project identifier."
  uuid: String
}

"Represents a compared report vulnerability scanner"
type ComparedSecurityReportScanner {
  "External ID of the vulnerability scanner."
  externalId: String
  "Name of the vulnerability scanner."
  name: String
  "Vendor of the vulnerability scanner."
  vendor: String
}

"Represents a ComplianceFramework associated with a Project"
type ComplianceFramework {
  "Hexadecimal representation of compliance framework's label color."
  color: String!
  "Default compliance framework for the group."
  default: Boolean
  "Description of the compliance framework."
  description: String!
  "Compliance framework ID."
  id: ID!
  "Name of the compliance framework."
  name: String!
  "Full path of the compliance pipeline configuration stored in a project repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa` **(ULTIMATE ALL)**."
  pipelineConfigurationFullPath: String
  "Projects associated with the compliance framework."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection
  "Scan Execution Policies of the compliance framework."
  scanExecutionPolicies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ScanExecutionPolicyConnection
  "Scan Result Policies of the compliance framework."
  scanResultPolicies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ScanResultPolicyConnection
}

"The connection type for ComplianceFramework."
type ComplianceFrameworkConnection {
  "A list of edges."
  edges: [ComplianceFrameworkEdge]
  "A list of nodes."
  nodes: [ComplianceFramework]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ComplianceFrameworkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ComplianceFramework
}

"Compliance standards adherence for a project."
type ComplianceStandardsAdherence {
  "Name of the check for the compliance standard."
  checkName: ComplianceStandardsAdherenceCheckName!
  "Compliance standards adherence ID."
  id: ID!
  "Project adhering to the compliance standard."
  project: Project!
  "Name of the compliance standard."
  standard: ComplianceStandardsAdherenceStandard!
  "Status of the compliance standards adherence."
  status: ComplianceStandardsAdherenceStatus!
  "Timestamp when the adherence was updated."
  updatedAt: Time!
}

"The connection type for ComplianceStandardsAdherence."
type ComplianceStandardsAdherenceConnection {
  "A list of edges."
  edges: [ComplianceStandardsAdherenceEdge]
  "A list of nodes."
  nodes: [ComplianceStandardsAdherence]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ComplianceStandardsAdherenceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ComplianceStandardsAdherence
}

"Compliance violation associated with a merged merge request."
type ComplianceViolation {
  "Compliance violation ID."
  id: ID!
  "Merge request the compliance violation occurred in."
  mergeRequest: MergeRequest!
  "Reason the compliance violation occurred."
  reason: ComplianceViolationReason!
  "Severity of the compliance violation."
  severityLevel: ComplianceViolationSeverity!
  "User suspected of causing the compliance violation."
  violatingUser: UserCore!
}

"The connection type for ComplianceViolation."
type ComplianceViolationConnection {
  "A list of edges."
  edges: [ComplianceViolationEdge]
  "A list of nodes."
  nodes: [ComplianceViolation]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ComplianceViolationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ComplianceViolation
}

"Composer metadata"
type ComposerMetadata {
  "Data of the Composer JSON file."
  composerJson: PackageComposerJsonType!
  "Target SHA of the package."
  targetSha: String!
}

"Conan file metadata"
type ConanFileMetadata implements PackageFileMetadata {
  "Type of the Conan file."
  conanFileType: ConanMetadatumFileTypeEnum!
  "Reference of the Conan package."
  conanPackageReference: String
  "Date of creation."
  createdAt: Time!
  "ID of the metadatum."
  id: PackagesConanFileMetadatumID!
  "Revision of the package."
  packageRevision: String
  "Revision of the Conan recipe."
  recipeRevision: String!
  "Date of most recent update."
  updatedAt: Time!
}

"Conan metadata"
type ConanMetadata {
  "Date of creation."
  createdAt: Time!
  "ID of the metadatum."
  id: PackagesConanMetadatumID!
  "Channel of the Conan package."
  packageChannel: String!
  "Username of the Conan package."
  packageUsername: String!
  "Recipe of the Conan package."
  recipe: String!
  "Recipe path of the Conan package."
  recipePath: String!
  "Date of most recent update."
  updatedAt: Time!
}

"Autogenerated return type of ConfigureContainerScanning."
type ConfigureContainerScanningPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}

"Autogenerated return type of ConfigureDependencyScanning."
type ConfigureDependencyScanningPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}

"Autogenerated return type of ConfigureSastIac."
type ConfigureSastIacPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}

"Autogenerated return type of ConfigureSast."
type ConfigureSastPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}

"Autogenerated return type of ConfigureSecretDetection."
type ConfigureSecretDetectionPayload {
  "Branch that has the new/modified `.gitlab-ci.yml` file."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Redirect path to use when the response is successful."
  successPath: String
}

"Connection details for an Agent"
type ConnectedAgent {
  "When the connection was established."
  connectedAt: Time
  "ID of the connection."
  connectionId: BigInt
  "Information about the Agent."
  metadata: AgentMetadata
}

"The connection type for ConnectedAgent."
type ConnectedAgentConnection {
  "A list of edges."
  edges: [ConnectedAgentEdge]
  "A list of nodes."
  nodes: [ConnectedAgent]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ConnectedAgentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ConnectedAgent
}

"Represents the total number of contacts for the represented states."
type ContactStateCounts {
  "Number of contacts with state `ACTIVE`"
  active: Int
  "Number of contacts with state `ALL`"
  all: Int
  "Number of contacts with state `INACTIVE`"
  inactive: Int
}

"A tag expiration policy designed to keep only the images that matter most"
type ContainerExpirationPolicy {
  "This container expiration policy schedule."
  cadence: ContainerExpirationPolicyCadenceEnum!
  "Timestamp of when the container expiration policy was created."
  createdAt: Time!
  "Indicates whether this container expiration policy is enabled."
  enabled: Boolean!
  "Number of tags to retain."
  keepN: ContainerExpirationPolicyKeepEnum
  "Tags with names matching this regex pattern will expire."
  nameRegex: UntrustedRegexp
  "Tags with names matching this regex pattern will be preserved."
  nameRegexKeep: UntrustedRegexp
  "Next time that this container expiration policy will get executed."
  nextRunAt: Time
  "Tags older that this will expire."
  olderThan: ContainerExpirationPolicyOlderThanEnum
  "Timestamp of when the container expiration policy was updated."
  updatedAt: Time!
}

"A container registry protection rule designed to prevent users with a certain access level or lower from altering the container registry."
type ContainerRegistryProtectionRule {
  "Max GitLab access level to prevent from pushing container images to the container registry. For example `DEVELOPER`, `MAINTAINER`, `OWNER`."
  deleteProtectedUpToAccessLevel: ContainerRegistryProtectionRuleAccessLevel!
  "ID of the container registry protection rule."
  id: ContainerRegistryProtectionRuleID!
  "Max GitLab access level to prevent from pushing container images to the container registry. For example `DEVELOPER`, `MAINTAINER`, `OWNER`."
  pushProtectedUpToAccessLevel: ContainerRegistryProtectionRuleAccessLevel!
  "Container repository path pattern protected by the protection rule. For example `my-project/my-container-*`. Wildcard character `*` allowed."
  repositoryPathPattern: String!
}

"A container repository"
type ContainerRepository {
  "Can the current user delete the container repository. Deprecated in 16.7: Use `userPermissions` field. See `ContainerRepositoryPermissions` type."
  canDelete: Boolean! @deprecated(reason: "Use `userPermissions` field. See `ContainerRepositoryPermissions` type. Deprecated in 16.7.")
  "Timestamp when the container repository was created."
  createdAt: Time!
  "Tags cleanup status for the container repository."
  expirationPolicyCleanupStatus: ContainerRepositoryCleanupStatus
  "Timestamp when the cleanup done by the expiration policy was started on the container repository."
  expirationPolicyStartedAt: Time
  "ID of the container repository."
  id: ID!
  "Number of deleted tags from the last cleanup."
  lastCleanupDeletedTagsCount: Int
  "URL of the container repository."
  location: String!
  "Migration state of the container repository."
  migrationState: String!
  "Name of the container repository."
  name: String!
  "Path of the container repository."
  path: String!
  "Project of the container registry."
  project: Project!
  "Status of the container repository."
  status: ContainerRepositoryStatus
  "Number of tags associated with this image."
  tagsCount: Int!
  "Timestamp when the container repository was updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryPermissions!
}

"The connection type for ContainerRepository."
type ContainerRepositoryConnection {
  "A list of edges."
  edges: [ContainerRepositoryEdge]
  "A list of nodes."
  nodes: [ContainerRepository]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Details of a container repository"
type ContainerRepositoryDetails {
  "Can the current user delete the container repository. Deprecated in 16.7: Use `userPermissions` field. See `ContainerRepositoryPermissions` type."
  canDelete: Boolean! @deprecated(reason: "Use `userPermissions` field. See `ContainerRepositoryPermissions` type. Deprecated in 16.7.")
  "Timestamp when the container repository was created."
  createdAt: Time!
  "Tags cleanup status for the container repository."
  expirationPolicyCleanupStatus: ContainerRepositoryCleanupStatus
  "Timestamp when the cleanup done by the expiration policy was started on the container repository."
  expirationPolicyStartedAt: Time
  "ID of the container repository."
  id: ID!
  "Number of deleted tags from the last cleanup."
  lastCleanupDeletedTagsCount: Int
  "URL of the container repository."
  location: String!
  "Migration state of the container repository."
  migrationState: String!
  "Name of the container repository."
  name: String!
  "Path of the container repository."
  path: String!
  "Project of the container registry."
  project: Project!
  "Deduplicated size of the image repository in bytes. This is only available on GitLab.com for repositories created after `2021-11-04`."
  size: Float
  "Status of the container repository."
  status: ContainerRepositoryStatus
  "Tags of the container repository."
  tags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search by tag name."
    name: String,
    "Include tag referrers."
    referrers: Boolean,
    "Sort tags by these criteria."
    sort: ContainerRepositoryTagSort
  ): ContainerRepositoryTagConnection
  "Number of tags associated with this image."
  tagsCount: Int!
  "Timestamp when the container repository was updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryPermissions!
}

"An edge in a connection."
type ContainerRepositoryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContainerRepository
}

type ContainerRepositoryPermissions {
  "If `true`, the user can perform `destroy_container_image` on this resource"
  destroyContainerRepository: Boolean!
}

"A referrer for a container repository tag"
type ContainerRepositoryReferrer {
  "Artifact type of the referrer."
  artifactType: String
  "Digest of the referrer."
  digest: String
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryTagPermissions!
}

"Represents the Geo replication and verification state of an Container Repository."
type ContainerRepositoryRegistry {
  "ID of the ContainerRepository."
  containerRepositoryId: ID!
  "Timestamp when the ContainerRepositoryRegistry was created"
  createdAt: Time
  "ID of the ContainerRepositoryRegistry"
  id: ID!
  "Error message during sync of the ContainerRepositoryRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the ContainerRepositoryRegistry"
  lastSyncedAt: Time
  "Timestamp after which the ContainerRepositoryRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the ContainerRepositoryRegistry"
  retryCount: Int
  "Sync state of the ContainerRepositoryRegistry"
  state: RegistryState
  "The local checksum of the ContainerRepositoryRegistry"
  verificationChecksum: String
  "Error message during verification of the ContainerRepositoryRegistry"
  verificationFailure: String
  "Timestamp after which the ContainerRepositoryRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the ContainerRepositoryRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of ContainerRepositoryRegistry"
  verificationStartedAt: Time
  "Verification state of the ContainerRepositoryRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the ContainerRepositoryRegistry"
  verifiedAt: Time
}

"The connection type for ContainerRepositoryRegistry."
type ContainerRepositoryRegistryConnection {
  "A list of edges."
  edges: [ContainerRepositoryRegistryEdge]
  "A list of nodes."
  nodes: [ContainerRepositoryRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ContainerRepositoryRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContainerRepositoryRegistry
}

"A tag from a container repository"
type ContainerRepositoryTag {
  "Can the current user delete this tag. Deprecated in 16.7: Use `userPermissions` field. See `ContainerRepositoryTagPermissions` type."
  canDelete: Boolean! @deprecated(reason: "Use `userPermissions` field. See `ContainerRepositoryTagPermissions` type. Deprecated in 16.7.")
  "Timestamp when the tag was created."
  createdAt: Time
  "Digest of the tag."
  digest: String
  "URL of the tag."
  location: String!
  "Name of the tag."
  name: String!
  "Path of the tag."
  path: String!
  "Timestamp when the tag was published."
  publishedAt: Time
  "Referrers for this tag."
  referrers: [ContainerRepositoryReferrer!]
  "Revision of the tag."
  revision: String
  "Short revision of the tag."
  shortRevision: String
  "Size of the tag."
  totalSize: BigInt
  "Permissions for the current user on the resource"
  userPermissions: ContainerRepositoryTagPermissions!
}

"The connection type for ContainerRepositoryTag."
type ContainerRepositoryTagConnection {
  "A list of edges."
  edges: [ContainerRepositoryTagEdge]
  "A list of nodes."
  nodes: [ContainerRepositoryTag]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ContainerRepositoryTagEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContainerRepositoryTag
}

type ContainerRepositoryTagPermissions {
  "If `true`, the user can perform `destroy_container_image` on this resource"
  destroyContainerRepositoryTag: Boolean!
}

"Represents the contributions of a user."
type ContributionAnalyticsContribution {
  "Number of issues closed by the user."
  issuesClosed: Int
  "Number of issues created by the user."
  issuesCreated: Int
  "Number of merge requests approved by the user."
  mergeRequestsApproved: Int
  "Number of merge requests closed by the user."
  mergeRequestsClosed: Int
  "Number of merge requests created by the user."
  mergeRequestsCreated: Int
  "Number of merge requests merged by the user."
  mergeRequestsMerged: Int
  "Number of repository pushes the user made."
  repoPushed: Int
  "Total number of events contributed by the user."
  totalEvents: Int
  "Contributor User object."
  user: UserCore
}

"The connection type for ContributionAnalyticsContribution."
type ContributionAnalyticsContributionConnection {
  "A list of edges."
  edges: [ContributionAnalyticsContributionEdge]
  "A list of nodes."
  nodes: [ContributionAnalyticsContribution]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ContributionAnalyticsContributionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ContributionAnalyticsContribution
}

"Autogenerated return type of CorpusCreate."
type CorpusCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Corpus for a coverage fuzzing job."
type CoverageFuzzingCorpus {
  "ID of the corpus."
  id: AppSecFuzzingCoverageCorpusID!
  "Package of the corpus."
  package: PackageDetailsType!
}

"The connection type for CoverageFuzzingCorpus."
type CoverageFuzzingCorpusConnection {
  "A list of edges."
  edges: [CoverageFuzzingCorpusEdge]
  "A list of nodes."
  nodes: [CoverageFuzzingCorpus]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CoverageFuzzingCorpusEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CoverageFuzzingCorpus
}

"Autogenerated return type of CreateAlertIssue."
type CreateAlertIssuePayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}

"Autogenerated return type of CreateAnnotation."
type CreateAnnotationPayload {
  "Created annotation."
  annotation: MetricsDashboardAnnotation
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CreateBoard."
type CreateBoardPayload {
  "Board after mutation."
  board: Board
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CreateBranch."
type CreateBranchPayload {
  "Branch after mutation."
  branch: Branch
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CreateClusterAgent."
type CreateClusterAgentPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Cluster agent created after mutation."
  clusterAgent: ClusterAgent
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CreateComplianceFramework."
type CreateComplianceFrameworkPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created compliance framework."
  framework: ComplianceFramework
}

"Autogenerated return type of CreateContainerRegistryProtectionRule."
type CreateContainerRegistryProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container registry protection rule after mutation."
  containerRegistryProtectionRule: ContainerRegistryProtectionRule
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CreateCustomEmoji."
type CreateCustomEmojiPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "New custom emoji."
  customEmoji: CustomEmoji
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CreateDiffNote."
type CreateDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
}

"Autogenerated return type of CreateEpic."
type CreateEpicPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Created epic."
  epic: Epic
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of CreateImageDiffNote."
type CreateImageDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
}

"Autogenerated return type of CreateIssue."
type CreateIssuePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of CreateIteration."
type CreateIterationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created iteration."
  iteration: Iteration
}

"Autogenerated return type of CreateNote."
type CreateNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
}

"Autogenerated return type of CreatePackagesProtectionRule."
type CreatePackagesProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages protection rule after mutation."
  packageProtectionRule: PackagesProtectionRule
}

"Autogenerated return type of CreateRequirement."
type CreateRequirementPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requirement after mutation."
  requirement: Requirement
}

"Autogenerated return type of CreateSnippet."
type CreateSnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}

"Autogenerated return type of CreateTestCase."
type CreateTestCasePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Test case created."
  testCase: Issue
}

"Represents the current license"
type CurrentLicense {
  "Date when the license was activated."
  activatedAt: Date
  "Number of billable users on the system."
  billableUsersCount: Int
  "Date, including grace period, when licensed features will be blocked."
  blockChangesAt: Date
  "Company of the licensee."
  company: String
  "Date when the license was added."
  createdAt: Date
  "Email of the licensee."
  email: String
  "Date when the license expires."
  expiresAt: Date
  "ID of the license extracted from the license data."
  id: ID!
  "Date when the license was last synced."
  lastSync: Time
  "Highest number of billable users on the system during the term of the current license."
  maximumUserCount: Int
  "Name of the licensee."
  name: String
  "Name of the subscription plan."
  plan: String!
  "Date when the license started."
  startsAt: Date
  "Type of the license."
  type: String!
  "Number of paid users in the license."
  usersInLicenseCount: Int
  "Number of users over the paid users in the license."
  usersOverLicenseCount: Int
}

"The currently authenticated GitLab user."
type CurrentUser implements User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User access to AI chat feature. Introduced in 16.8: This feature is an Experiment. It can be changed or removed at any time."
  duoChatAvailable: Boolean! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"A custom emoji uploaded by user"
type CustomEmoji {
  "Timestamp of when the custom emoji was created."
  createdAt: Time!
  "Whether the emoji is an external link."
  external: Boolean!
  "ID of the emoji."
  id: CustomEmojiID!
  "Name of the emoji."
  name: String!
  "Link to file of the emoji."
  url: String!
  "Permissions for the current user on the resource"
  userPermissions: CustomEmojiPermissions!
}

"The connection type for CustomEmoji."
type CustomEmojiConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [CustomEmojiEdge]
  "A list of nodes."
  nodes: [CustomEmoji]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CustomEmojiEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomEmoji
}

type CustomEmojiPermissions {
  "If `true`, the user can perform `create_custom_emoji` on this resource"
  createCustomEmoji: Boolean!
  "If `true`, the user can perform `delete_custom_emoji` on this resource"
  deleteCustomEmoji: Boolean!
  "If `true`, the user can perform `read_custom_emoji` on this resource"
  readCustomEmoji: Boolean!
}

type CustomerRelationsContact {
  "State of the contact."
  active: Boolean!
  "Timestamp the contact was created."
  createdAt: Time!
  "Description of or notes for the contact."
  description: String
  "Email address of the contact."
  email: String
  "First name of the contact."
  firstName: String!
  "Internal ID of the contact."
  id: ID!
  "Last name of the contact."
  lastName: String!
  "Organization of the contact."
  organization: CustomerRelationsOrganization
  "Phone number of the contact."
  phone: String
  "Timestamp the contact was last updated."
  updatedAt: Time!
}

"The connection type for CustomerRelationsContact."
type CustomerRelationsContactConnection {
  "A list of edges."
  edges: [CustomerRelationsContactEdge]
  "A list of nodes."
  nodes: [CustomerRelationsContact]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of CustomerRelationsContactCreate."
type CustomerRelationsContactCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Contact after the mutation."
  contact: CustomerRelationsContact
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type CustomerRelationsContactEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomerRelationsContact
}

"Autogenerated return type of CustomerRelationsContactUpdate."
type CustomerRelationsContactUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Contact after the mutation."
  contact: CustomerRelationsContact
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type CustomerRelationsOrganization {
  "State of the organization."
  active: Boolean!
  "Timestamp the organization was created."
  createdAt: Time!
  "Standard billing rate for the organization."
  defaultRate: Float
  "Description of or notes for the organization."
  description: String
  "Internal ID of the organization."
  id: ID!
  "Name of the organization."
  name: String!
  "Timestamp the organization was last updated."
  updatedAt: Time!
}

"The connection type for CustomerRelationsOrganization."
type CustomerRelationsOrganizationConnection {
  "A list of edges."
  edges: [CustomerRelationsOrganizationEdge]
  "A list of nodes."
  nodes: [CustomerRelationsOrganization]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of CustomerRelationsOrganizationCreate."
type CustomerRelationsOrganizationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after the mutation."
  organization: CustomerRelationsOrganization
}

"An edge in a connection."
type CustomerRelationsOrganizationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomerRelationsOrganization
}

"Autogenerated return type of CustomerRelationsOrganizationUpdate."
type CustomerRelationsOrganizationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after the mutation."
  organization: CustomerRelationsOrganization!
}

"Represents a product analytics dashboard."
type CustomizableDashboard {
  "Category of dashboard."
  category: CustomizableDashboardCategory!
  "Project which contains the dashboard definition."
  configurationProject: Project
  "Description of the dashboard."
  description: String
  "Panels shown on the dashboard."
  panels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomizableDashboardPanelConnection!
  "Slug of the dashboard."
  slug: String!
  "Title of the dashboard."
  title: String!
  "Indicates whether the dashboard is user-defined or provided by GitLab."
  userDefined: Boolean!
}

"The connection type for CustomizableDashboard."
type CustomizableDashboardConnection {
  "A list of edges."
  edges: [CustomizableDashboardEdge]
  "A list of nodes."
  nodes: [CustomizableDashboard]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CustomizableDashboardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomizableDashboard
}

"Represents a product analytics dashboard panel."
type CustomizableDashboardPanel {
  "Description of the position and size of the panel."
  gridAttributes: JSON
  "Overrides for the visualization query object."
  queryOverrides: JSON
  "Title of the panel."
  title: String!
  "Visualization of the panel."
  visualization: CustomizableDashboardVisualization!
}

"The connection type for CustomizableDashboardPanel."
type CustomizableDashboardPanelConnection {
  "A list of edges."
  edges: [CustomizableDashboardPanelEdge]
  "A list of nodes."
  nodes: [CustomizableDashboardPanel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CustomizableDashboardPanelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomizableDashboardPanel
}

"Represents a product analytics dashboard visualization."
type CustomizableDashboardVisualization {
  "Data of the visualization."
  data: JSON!
  "Validation errors in the visualization."
  errors: [String!]
  "Options of the visualization."
  options: JSON!
  "Slug of the visualization."
  slug: String!
  "Type of the visualization."
  type: String!
}

"The connection type for CustomizableDashboardVisualization."
type CustomizableDashboardVisualizationConnection {
  "A list of edges."
  edges: [CustomizableDashboardVisualizationEdge]
  "A list of nodes."
  nodes: [CustomizableDashboardVisualization]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CustomizableDashboardVisualizationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomizableDashboardVisualization
}

type CustomizablePermission {
  "Objects the permission is available for."
  availableFor: [String!]!
  "Description of the permission."
  description: String
  "Localized name of the permission."
  name: String!
  "Requirement of the permission."
  requirement: String
  "Value of the permission."
  value: String!
}

"The connection type for CustomizablePermission."
type CustomizablePermissionConnection {
  "A list of edges."
  edges: [CustomizablePermissionEdge]
  "A list of nodes."
  nodes: [CustomizablePermission]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type CustomizablePermissionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CustomizablePermission
}

"Autogenerated return type of DastOnDemandScanCreate."
type DastOnDemandScanCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "URL of the pipeline that was created."
  pipelineUrl: String
}

"Represents a DAST Pre Scan Verification"
type DastPreScanVerification {
  "Pre Scan Verifications Steps."
  preScanVerificationSteps: [DastPreScanVerificationStep!]
  "Status of the pre scan verification."
  status: DastPreScanVerificationStatus
  "Whether or not the configuration has changed after the last pre scan run."
  valid: Boolean!
}

"Represents a DAST Pre Scan Verification Step"
type DastPreScanVerificationStep {
  "Type of the pre scan verification check."
  checkType: DastPreScanVerificationCheckType
  "Errors that occurred in the pre scan verification step."
  errors: [String!]
  "Name of the pre scan verification step. Deprecated in 15.10: This was renamed."
  name: String @deprecated(reason: "This was renamed. Please use `DastPreScanVerificationStep.checkType`. Deprecated in 15.10.")
  "Whether or not the pre scan verification step has errors."
  success: Boolean!
}

"Represents a DAST Profile"
type DastProfile {
  "Associated branch."
  branch: DastProfileBranch
  "DAST Pre Scan Verification associated with the site profile. Will always return `null` if `dast_on_demand_scans_scheduler` feature flag is disabled."
  dastPreScanVerification: DastPreScanVerification
  "Associated profile schedule."
  dastProfileSchedule: DastProfileSchedule
  "Associated scanner profile."
  dastScannerProfile: DastScannerProfile
  "Associated site profile."
  dastSiteProfile: DastSiteProfile
  "Description of the scan."
  description: String
  "Relative web path to the edit page of a profile."
  editPath: String
  "ID of the profile."
  id: DastProfileID!
  "Name of the profile."
  name: String
  "Runner tags associated with the profile."
  tagList: [String!]
}

"Represents a DAST Profile Branch"
type DastProfileBranch {
  "Indicates whether or not the branch exists."
  exists: Boolean
  "Name of the branch."
  name: String
}

"Represents DAST Profile Cadence."
type DastProfileCadence {
  "Duration of the DAST profile cadence."
  duration: Int
  "Unit for the duration of DAST profile cadence."
  unit: DastProfileCadenceUnit
}

"The connection type for DastProfile."
type DastProfileConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [DastProfileEdge]
  "A list of nodes."
  nodes: [DastProfile]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of DastProfileCreate."
type DastProfileCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Created profile."
  dastProfile: DastProfile
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "URL of the pipeline that was created. Requires `runAfterCreate` to be set to `true`."
  pipelineUrl: String
}

"Autogenerated return type of DastProfileDelete."
type DastProfileDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type DastProfileEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DastProfile
}

"Autogenerated return type of DastProfileRun."
type DastProfileRunPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "URL of the pipeline that was created."
  pipelineUrl: String
}

"Represents a DAST profile schedule."
type DastProfileSchedule {
  "Status of the DAST profile schedule."
  active: Boolean
  "Cadence of the DAST profile schedule."
  cadence: DastProfileCadence
  "ID of the DAST profile schedule."
  id: DastProfileScheduleID!
  "Next run time of the DAST profile schedule in the given timezone."
  nextRunAt: Time
  "Status of the current owner of the DAST profile schedule."
  ownerValid: Boolean
  "Start time of the DAST profile schedule in the given timezone."
  startsAt: Time
  "Time zone of the start time of the DAST profile schedule."
  timezone: String
}

"Autogenerated return type of DastProfileUpdate."
type DastProfileUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Updated profile."
  dastProfile: DastProfile
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "The URL of the pipeline that was created. Requires the input argument `runAfterUpdate` to be set to `true` when calling the mutation, otherwise no pipeline will be created."
  pipelineUrl: String
}

"Represents a DAST scanner profile"
type DastScannerProfile {
  "Relative web path to the edit page of a scanner profile."
  editPath: String
  "ID of the DAST scanner profile."
  id: DastScannerProfileID!
  "Name of the DAST scanner profile."
  profileName: String
  "List of security policy names that are referencing given project."
  referencedInSecurityPolicies: [String!]
  "Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan."
  scanType: DastScanTypeEnum
  "Indicates if debug messages should be included in DAST console output. True to include the debug messages."
  showDebugMessages: Boolean!
  "Maximum number of minutes allowed for the spider to traverse the site."
  spiderTimeout: Int
  "Runner tags associated with the scanner profile. Deprecated in 15.8: Moved to DastProfile."
  tagList: [String!] @deprecated(reason: "Moved to DastProfile. Deprecated in 15.8.")
  "Maximum number of seconds allowed for the site under test to respond to a request."
  targetTimeout: Int
  "Indicates if the AJAX spider should be used to crawl the target site. True to run the AJAX spider in addition to the traditional spider, and false to run only the traditional spider."
  useAjaxSpider: Boolean!
}

"The connection type for DastScannerProfile."
type DastScannerProfileConnection {
  "A list of edges."
  edges: [DastScannerProfileEdge]
  "A list of nodes."
  nodes: [DastScannerProfile]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of DastScannerProfileCreate."
type DastScannerProfileCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Created scanner profile."
  dastScannerProfile: DastScannerProfile
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "ID of the scanner profile. Deprecated in 14.10: use `dastScannerProfile` field."
  id: DastScannerProfileID @deprecated(reason: "use `dastScannerProfile` field. Deprecated in 14.10.")
}

"Autogenerated return type of DastScannerProfileDelete."
type DastScannerProfileDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type DastScannerProfileEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DastScannerProfile
}

"Autogenerated return type of DastScannerProfileUpdate."
type DastScannerProfileUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Updated scanner profile."
  dastScannerProfile: DastScannerProfile
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "ID of the scanner profile. Deprecated in 14.10: use `dastScannerProfile` field."
  id: DastScannerProfileID @deprecated(reason: "use `dastScannerProfile` field. Deprecated in 14.10.")
}

"Represents a DAST Site Profile"
type DastSiteProfile {
  "Target authentication details."
  auth: DastSiteProfileAuth
  "Relative web path to the edit page of a site profile."
  editPath: String
  "URLs to skip during an authenticated scan."
  excludedUrls: [String!]
  "ID of the site profile."
  id: DastSiteProfileID!
  "Normalized URL of the target to be scanned."
  normalizedTargetUrl: String
  "Name of the site profile."
  profileName: String
  "List of security policy names that are referencing given project."
  referencedInSecurityPolicies: [String!]
  "Comma-separated list of request header names and values to be added to every request made by DAST."
  requestHeaders: String
  "Scan File Path used as input for the scanner."
  scanFilePath: String
  "Scan method used by the scanner."
  scanMethod: DastScanMethodType
  "Type of target to be scanned."
  targetType: DastTargetTypeEnum
  "URL of the target to be scanned."
  targetUrl: String
  "Permissions for the current user on the resource"
  userPermissions: DastSiteProfilePermissions!
  "Site profile validation start time."
  validationStartedAt: Time
  "Current validation status of the site profile."
  validationStatus: DastSiteProfileValidationStatusEnum
}

"DastSiteProfile authentication"
type DastSiteProfileAuth {
  "Indicates whether authentication is enabled."
  enabled: Boolean
  "Redacted password to authenticate with on the target website."
  password: String
  "Name of password field at the sign-in HTML form."
  passwordField: String
  "Name or ID of sign-in submit button at the sign-in HTML form."
  submitField: String
  "The URL of the page containing the sign-in HTML form on the target website."
  url: String
  "Username to authenticate with on the target website."
  username: String
  "Name of username field at the sign-in HTML form."
  usernameField: String
}

"The connection type for DastSiteProfile."
type DastSiteProfileConnection {
  "A list of edges."
  edges: [DastSiteProfileEdge]
  "A list of nodes."
  nodes: [DastSiteProfile]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of DastSiteProfileCreate."
type DastSiteProfileCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Site Profile object."
  dastSiteProfile: DastSiteProfile
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "ID of the site profile. Deprecated in 14.10: use `dastSiteProfile.id` field."
  id: DastSiteProfileID @deprecated(reason: "use `dastSiteProfile.id` field. Deprecated in 14.10.")
}

"Autogenerated return type of DastSiteProfileDelete."
type DastSiteProfileDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type DastSiteProfileEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DastSiteProfile
}

"Check permissions for the current user on site profile"
type DastSiteProfilePermissions {
  "If `true`, the user can perform `create_on_demand_dast_scan` on this resource"
  createOnDemandDastScan: Boolean!
}

"Autogenerated return type of DastSiteProfileUpdate."
type DastSiteProfileUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Site profile object."
  dastSiteProfile: DastSiteProfile
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "ID of the site profile. Deprecated in 14.10: use `dastSiteProfile.id` field."
  id: DastSiteProfileID @deprecated(reason: "use `dastSiteProfile.id` field. Deprecated in 14.10.")
}

"Autogenerated return type of DastSiteTokenCreate."
type DastSiteTokenCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "ID of the site token."
  id: DastSiteTokenID
  "Current validation status of the target."
  status: DastSiteProfileValidationStatusEnum
  "Token string."
  token: String
}

"Represents a DAST Site Validation"
type DastSiteValidation {
  "Global ID of the site validation."
  id: DastSiteValidationID!
  "Normalized URL of the target to be validated."
  normalizedTargetUrl: String
  "Status of the site validation."
  status: DastSiteProfileValidationStatusEnum!
  "Timestamp of when the validation started."
  validationStartedAt: Time
}

"The connection type for DastSiteValidation."
type DastSiteValidationConnection {
  "A list of edges."
  edges: [DastSiteValidationEdge]
  "A list of nodes."
  nodes: [DastSiteValidation]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of DastSiteValidationCreate."
type DastSiteValidationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "ID of the site validation."
  id: DastSiteValidationID
  "Current validation status."
  status: DastSiteProfileValidationStatusEnum
}

"An edge in a connection."
type DastSiteValidationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DastSiteValidation
}

"Autogenerated return type of DastSiteValidationRevoke."
type DastSiteValidationRevokePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DeleteAnnotation."
type DeleteAnnotationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DeleteContainerRegistryProtectionRule."
type DeleteContainerRegistryProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container registry protection rule that was deleted successfully."
  containerRegistryProtectionRule: ContainerRegistryProtectionRule
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"The response from the AdminSidekiqQueuesDeleteJobs mutation"
type DeleteJobsResponse {
  "Whether or not the entire queue was processed in time; if not, retrying the same request is safe."
  completed: Boolean
  "Number of matching jobs deleted."
  deletedJobs: Int
  "Queue size after processing."
  queueSize: Int
}

"Autogenerated return type of DeletePackagesProtectionRule."
type DeletePackagesProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages protection rule that was deleted successfully."
  packageProtectionRule: PackagesProtectionRule
}

type DeletedNote {
  "ID of the discussion for the deleted note."
  discussionId: DiscussionID
  "ID of the deleted note."
  id: NoteID!
  "Whether deleted note is the last note in the discussion."
  lastDiscussionNote: Boolean
}

"A software dependency used by a project"
type Dependency {
  "ID of the dependency."
  id: GlobalID!
  "Licenses associated to the dependency."
  licenses: [License!]
  "Information about where the dependency is located."
  location: Location
  "Name of the dependency."
  name: String!
  "Description of the tool used to manage the dependency."
  packager: PackageManager
  "Version of the dependency."
  version: String
}

"The connection type for Dependency."
type DependencyConnection {
  "A list of edges."
  edges: [DependencyEdge]
  "A list of nodes."
  nodes: [Dependency]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DependencyEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Dependency
}

"Dependency proxy blob"
type DependencyProxyBlob {
  "Date of creation."
  createdAt: Time!
  "Name of the blob."
  fileName: String!
  "Size of the blob file."
  size: String!
  "Date of most recent update."
  updatedAt: Time!
}

"The connection type for DependencyProxyBlob."
type DependencyProxyBlobConnection {
  "A list of edges."
  edges: [DependencyProxyBlobEdge]
  "A list of nodes."
  nodes: [DependencyProxyBlob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DependencyProxyBlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DependencyProxyBlob
}

"Represents the Geo replication and verification state of a dependency_proxy_blob"
type DependencyProxyBlobRegistry {
  "Timestamp when the DependencyProxyBlobRegistry was created"
  createdAt: Time
  "ID of the Dependency Proxy Blob."
  dependencyProxyBlobId: ID!
  "ID of the DependencyProxyBlobRegistry"
  id: ID!
  "Error message during sync of the DependencyProxyBlobRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the DependencyProxyBlobRegistry"
  lastSyncedAt: Time
  "Timestamp after which the DependencyProxyBlobRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the DependencyProxyBlobRegistry"
  retryCount: Int
  "Sync state of the DependencyProxyBlobRegistry"
  state: RegistryState
  "The local checksum of the DependencyProxyBlobRegistry"
  verificationChecksum: String
  "Error message during verification of the DependencyProxyBlobRegistry"
  verificationFailure: String
  "Timestamp after which the DependencyProxyBlobRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the DependencyProxyBlobRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of DependencyProxyBlobRegistry"
  verificationStartedAt: Time
  "Verification state of the DependencyProxyBlobRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the DependencyProxyBlobRegistry"
  verifiedAt: Time
}

"The connection type for DependencyProxyBlobRegistry."
type DependencyProxyBlobRegistryConnection {
  "A list of edges."
  edges: [DependencyProxyBlobRegistryEdge]
  "A list of nodes."
  nodes: [DependencyProxyBlobRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DependencyProxyBlobRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DependencyProxyBlobRegistry
}

"Group-level Dependency Proxy TTL policy settings"
type DependencyProxyImageTtlGroupPolicy {
  "Timestamp of creation."
  createdAt: Time
  "Indicates whether the policy is enabled or disabled."
  enabled: Boolean!
  "Number of days to retain a cached image file."
  ttl: Int
  "Timestamp of the most recent update."
  updatedAt: Time
}

"Dependency proxy manifest"
type DependencyProxyManifest {
  "Date of creation."
  createdAt: Time!
  "Digest of the manifest."
  digest: String!
  "Name of the manifest."
  fileName: String!
  "ID of the manifest."
  id: DependencyProxyManifestID!
  "Name of the image."
  imageName: String!
  "Size of the manifest file."
  size: String!
  "Status of the manifest (default, pending_destruction, processing, error)"
  status: DependencyProxyManifestStatus!
  "Date of most recent update."
  updatedAt: Time!
}

"The connection type for DependencyProxyManifest."
type DependencyProxyManifestConnection {
  "A list of edges."
  edges: [DependencyProxyManifestEdge]
  "A list of nodes."
  nodes: [DependencyProxyManifest]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DependencyProxyManifestEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DependencyProxyManifest
}

"Represents the Geo replication and verification state of a dependency_proxy_manifest"
type DependencyProxyManifestRegistry {
  "Timestamp when the DependencyProxyManifestRegistry was created"
  createdAt: Time
  "ID of the Dependency Proxy Manifest."
  dependencyProxyManifestId: ID!
  "ID of the DependencyProxyManifestRegistry"
  id: ID!
  "Error message during sync of the DependencyProxyManifestRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the DependencyProxyManifestRegistry"
  lastSyncedAt: Time
  "Timestamp after which the DependencyProxyManifestRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the DependencyProxyManifestRegistry"
  retryCount: Int
  "Sync state of the DependencyProxyManifestRegistry"
  state: RegistryState
  "The local checksum of the DependencyProxyManifestRegistry"
  verificationChecksum: String
  "Error message during verification of the DependencyProxyManifestRegistry"
  verificationFailure: String
  "Timestamp after which the DependencyProxyManifestRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the DependencyProxyManifestRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of DependencyProxyManifestRegistry"
  verificationStartedAt: Time
  "Verification state of the DependencyProxyManifestRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the DependencyProxyManifestRegistry"
  verifiedAt: Time
}

"The connection type for DependencyProxyManifestRegistry."
type DependencyProxyManifestRegistryConnection {
  "A list of edges."
  edges: [DependencyProxyManifestRegistryEdge]
  "A list of nodes."
  nodes: [DependencyProxyManifestRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DependencyProxyManifestRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DependencyProxyManifestRegistry
}

"Project-level Dependency Proxy for packages settings"
type DependencyProxyPackagesSetting {
  "Indicates whether the dependency proxy for packages is enabled for the project. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  enabled: Boolean! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "URL for the external Maven packages registry. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  mavenExternalRegistryUrl: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Username for the external Maven packages registry. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  mavenExternalRegistryUsername: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
}

"Group-level Dependency Proxy settings"
type DependencyProxySetting {
  "Indicates whether the dependency proxy is enabled for the group."
  enabled: Boolean!
}

"The deployment of an environment"
type Deployment {
  "Approval summary of the deployment.This field can only be resolved for one deployment in any single request."
  approvalSummary: DeploymentApprovalSummary
  "Current approvals of the deployment."
  approvals: [DeploymentApproval!]
  "Commit details of the deployment."
  commit: Commit
  "When the deployment record was created."
  createdAt: Time
  "When the deployment finished."
  finishedAt: Time
  "Global ID of the deployment."
  id: ID
  "Project-level internal ID of the deployment."
  iid: ID
  "Pipeline job of the deployment."
  job: CiJob
  "Number of pending unified approvals on the deployment."
  pendingApprovalCount: Int
  "Git-Ref that the deployment ran on."
  ref: String
  "Git-SHA that the deployment ran on."
  sha: String
  "Status of the deployment."
  status: DeploymentStatus
  "True or false if the deployment ran on a Git-tag."
  tag: Boolean
  "Git tags that contain this deployment. This field can only be resolved for two deployments in any single request."
  tags: [DeploymentTag!]
  "User who executed the deployment."
  triggerer: UserCore
  "When the deployment record was updated."
  updatedAt: Time
  "Permissions for the current user on the resource"
  userPermissions: DeploymentPermissions!
}

"Approval of the deployment."
type DeploymentApproval {
  "Additional comment."
  comment: String
  "When the user approved/rejected first time."
  createdAt: Time
  "Whether the deployment was approved/rejected."
  status: DeploymentsApprovalStatus
  "When the user updated the approval."
  updatedAt: Time
  "User who approved or rejected the deployment."
  user: UserCore
}

"Approval summary of the deployment."
type DeploymentApprovalSummary {
  "Approval Rules for the deployment."
  rules: [ProtectedEnvironmentApprovalRuleForSummary!]
  "Status of the approvals."
  status: DeploymentApprovalSummaryStatus
  "Total pending approval count."
  totalPendingApprovalCount: Int
  "Total number of required approvals."
  totalRequiredApprovals: Int
}

"The connection type for Deployment."
type DeploymentConnection {
  "A list of edges."
  edges: [DeploymentEdge]
  "A list of nodes."
  nodes: [Deployment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DeploymentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Deployment
}

type DeploymentPermissions {
  "Indicates the user can perform `approve_deployment` on this resource. This field can only be resolved for one environment in any single request."
  approveDeployment: Boolean!
  "If `true`, the user can perform `destroy_deployment` on this resource"
  destroyDeployment: Boolean!
  "If `true`, the user can perform `update_deployment` on this resource"
  updateDeployment: Boolean!
}

"Tags for a given deployment"
type DeploymentTag {
  "Name of this git tag."
  name: String
  "Path for this tag."
  path: String
}

type DescriptionVersion {
  "Whether current user can delete description version associated to the note metadata. Deprecated in 15.7: For backwards compatibility with REST API version and to be removed in a next iteration."
  canDelete: Boolean @deprecated(reason: "For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.")
  "Web path to delete description version associated to the note metadata. Deprecated in 15.7: For backwards compatibility with REST API version and to be removed in a next iteration."
  deletePath: String @deprecated(reason: "For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.")
  "Whether description version associated to the note metadata is deleted. Deprecated in 15.7: For backwards compatibility with REST API version and to be removed in a next iteration."
  deleted: Boolean @deprecated(reason: "For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.")
  "Content of the given description version."
  description: String
  "Description diff between versions."
  diff(
    "ID of a previous version to compare. If not specified first previous version is used."
    versionId: DescriptionVersionID
  ): String
  "Web path to description version associated to the note metadata. Deprecated in 15.7: For backwards compatibility with REST API version and to be removed in a next iteration."
  diffPath: String @deprecated(reason: "For backwards compatibility with REST API version and to be removed in a next iteration. Deprecated in 15.7.")
  "ID of the description version."
  id: DescriptionVersionID!
}

"A single design"
type Design implements CurrentUserTodos & DesignFields & NoteableInterface & Todoable {
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Description of the design."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Diff refs for this design."
  diffRefs: DiffRefs!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "How this design was changed in the current version."
  event: DesignVersionEvent!
  "Filename of the design."
  filename: String!
  "Full path to the design file."
  fullPath: String!
  "ID of this design."
  id: ID!
  "URL of the full-sized image."
  image: String!
  "The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated"
  imageV432x230: String
  "Issue the design belongs to."
  issue: Issue!
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Total count of user-created notes for this design."
  notesCount: Int!
  "Project the design belongs to."
  project: Project!
  "All versions related to this design ordered newest first."
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Global ID of the most recent acceptable version."
    earlierOrEqualToId: DesignManagementVersionID,
    "SHA256 of the most recent acceptable version."
    earlierOrEqualToSha: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignVersionConnection!
  "URL of the design."
  webUrl: String!
}

"A design pinned to a specific version. The image field reflects the design as of the associated version"
type DesignAtVersion implements DesignFields {
  "Underlying design."
  design: Design!
  "Diff refs for this design."
  diffRefs: DiffRefs!
  "How this design was changed in the current version."
  event: DesignVersionEvent!
  "Filename of the design."
  filename: String!
  "Full path to the design file."
  fullPath: String!
  "ID of this design."
  id: ID!
  "URL of the full-sized image."
  image: String!
  "The URL of the design resized to fit within the bounds of 432x230. This will be `null` if the image has not been generated"
  imageV432x230: String
  "Issue the design belongs to."
  issue: Issue!
  "Total count of user-created notes for this design."
  notesCount: Int!
  "Project the design belongs to."
  project: Project!
  "Version this design-at-versions is pinned to."
  version: DesignVersion!
}

"The connection type for DesignAtVersion."
type DesignAtVersionConnection {
  "A list of edges."
  edges: [DesignAtVersionEdge]
  "A list of nodes."
  nodes: [DesignAtVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DesignAtVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesignAtVersion
}

"A collection of designs"
type DesignCollection {
  "Copy state of the design collection."
  copyState: DesignCollectionCopyState
  "Find a specific design."
  design(
    "Find a design by its filename."
    filename: String,
    "Find a design by its ID."
    id: DesignManagementDesignID
  ): Design
  "Find a design as of a version."
  designAtVersion(
    "Global ID of the design at this version."
    id: DesignManagementDesignAtVersionID!
  ): DesignAtVersion
  "All designs for the design collection."
  designs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filters designs to only those that existed at the version. If argument is omitted or nil then all designs will reflect the latest version"
    atVersion: DesignManagementVersionID,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters designs by their filename."
    filenames: [String!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters designs by their ID."
    ids: [DesignManagementDesignID!],
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignConnection!
  "Issue associated with the design collection."
  issue: Issue!
  "Project associated with the design collection."
  project: Project!
  "A specific version."
  version(
    "Global ID of the version."
    id: DesignManagementVersionID,
    "SHA256 of a specific version."
    sha: String
  ): DesignVersion
  "All versions related to all designs, ordered newest first."
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Global ID of the most recent acceptable version."
    earlierOrEqualToId: DesignManagementVersionID,
    "SHA256 of the most recent acceptable version."
    earlierOrEqualToSha: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignVersionConnection!
}

"The connection type for Design."
type DesignConnection {
  "A list of edges."
  edges: [DesignEdge]
  "A list of nodes."
  nodes: [Design]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DesignEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Design
}

type DesignManagement {
  "Find a design as of a version."
  designAtVersion(
    "Global ID of the design at this version."
    id: DesignManagementDesignAtVersionID!
  ): DesignAtVersion
  "Find a version."
  version(
    "Global ID of the version."
    id: DesignManagementVersionID!
  ): DesignVersion
}

"Autogenerated return type of DesignManagementDelete."
type DesignManagementDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "New version in which the designs are deleted."
  version: DesignVersion
}

"Autogenerated return type of DesignManagementMove."
type DesignManagementMovePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Current state of the collection."
  designCollection: DesignCollection
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents the Geo replication and verification state of a Design Management Repository"
type DesignManagementRepositoryRegistry {
  "Timestamp when the DesignManagementRepositoryRegistry was created"
  createdAt: Time
  "ID of the Design Management Repository."
  designManagementRepositoryId: ID!
  "ID of the DesignManagementRepositoryRegistry"
  id: ID!
  "Error message during sync of the DesignManagementRepositoryRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the DesignManagementRepositoryRegistry"
  lastSyncedAt: Time
  "Timestamp after which the DesignManagementRepositoryRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the DesignManagementRepositoryRegistry"
  retryCount: Int
  "Sync state of the DesignManagementRepositoryRegistry"
  state: RegistryState
  "The local checksum of the DesignManagementRepositoryRegistry"
  verificationChecksum: String
  "Error message during verification of the DesignManagementRepositoryRegistry"
  verificationFailure: String
  "Timestamp after which the DesignManagementRepositoryRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the DesignManagementRepositoryRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of DesignManagementRepositoryRegistry"
  verificationStartedAt: Time
  "Verification state of the DesignManagementRepositoryRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the DesignManagementRepositoryRegistry"
  verifiedAt: Time
}

"The connection type for DesignManagementRepositoryRegistry."
type DesignManagementRepositoryRegistryConnection {
  "A list of edges."
  edges: [DesignManagementRepositoryRegistryEdge]
  "A list of nodes."
  nodes: [DesignManagementRepositoryRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DesignManagementRepositoryRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesignManagementRepositoryRegistry
}

"Autogenerated return type of DesignManagementUpdate."
type DesignManagementUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Updated design."
  design: Design!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DesignManagementUpload."
type DesignManagementUploadPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Designs that were uploaded by the mutation."
  designs: [Design!]!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Any designs that were skipped from the upload due to there being no change to their content since their last version"
  skippedDesigns: [Design!]!
}

"A specific version in which designs were added, modified or deleted"
type DesignVersion {
  "Author of the version."
  author: UserCore!
  "Timestamp of when the version was created."
  createdAt: Time!
  "A particular design as of this version, provided it is visible at this version."
  designAtVersion(
    "ID of a specific design."
    designId: DesignManagementDesignID,
    "Filename of a specific design."
    filename: String,
    "ID of the DesignAtVersion."
    id: DesignManagementDesignAtVersionID
  ): DesignAtVersion!
  "All designs that were changed in the version."
  designs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignConnection!
  "All designs that are visible at this version, as of this version."
  designsAtVersion(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters designs by their filename."
    filenames: [String!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters designs by their ID."
    ids: [DesignManagementDesignID!],
    "Returns the last _n_ elements from the list."
    last: Int
  ): DesignAtVersionConnection!
  "ID of the design version."
  id: ID!
  "SHA of the design version."
  sha: ID!
}

"The connection type for DesignVersion."
type DesignVersionConnection {
  "A list of edges."
  edges: [DesignVersionEdge]
  "A list of nodes."
  nodes: [DesignVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DesignVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesignVersion
}

"Autogenerated return type of DestroyBoardList."
type DestroyBoardListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "List after mutation."
  list: BoardList
}

"Autogenerated return type of DestroyBoard."
type DestroyBoardPayload {
  "Board after mutation."
  board: Board
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyComplianceFramework."
type DestroyComplianceFrameworkPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyContainerRepository."
type DestroyContainerRepositoryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container repository policy after scheduling the deletion."
  containerRepository: ContainerRepository!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyContainerRepositoryTags."
type DestroyContainerRepositoryTagsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Deleted container repository tags."
  deletedTagNames: [String!]!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyCustomEmoji."
type DestroyCustomEmojiPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Deleted custom emoji."
  customEmoji: CustomEmoji
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyEpicBoard."
type DestroyEpicBoardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Epic board after mutation."
  epicBoard: EpicBoard
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyNote."
type DestroyNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
}

"Autogenerated return type of DestroyPackageFile."
type DestroyPackageFilePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyPackageFiles."
type DestroyPackageFilesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyPackage."
type DestroyPackagePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroyPackages."
type DestroyPackagesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of DestroySnippet."
type DestroySnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}

"Details of the import status of a project."
type DetailedImportStatus {
  "ID of the import state."
  id: ProjectImportStateID
  "Last error of the import."
  lastError: String
  "Time of the last successful update."
  lastSuccessfulUpdateAt: Time
  "Time of the last update."
  lastUpdateAt: Time
  "Time of the start of the last update."
  lastUpdateStartedAt: Time
  "Current status of the import."
  status: String
  "Import url."
  url: String
}

type DetailedStatus {
  "Action information for the status. This includes method, button title, icon, path, and title."
  action: StatusAction
  "Path of the details for the status."
  detailsPath: String
  "Favicon of the status."
  favicon: String
  "Group of the status. Deprecated in 16.4: The `group` attribute is deprecated. Use `name` instead."
  group: String @deprecated(reason: "The `group` attribute is deprecated. Use `name` instead. Deprecated in 16.4.")
  "Indicates if the status has further details."
  hasDetails: Boolean
  "Icon of the status. Deprecated in 16.4: The `icon` attribute is deprecated. Use `name` to identify the status to display instead."
  icon: String @deprecated(reason: "The `icon` attribute is deprecated. Use `name` to identify the status to display instead. Deprecated in 16.4.")
  "ID for a detailed status."
  id: String!
  "Human-readable label of the status (e.g. success)."
  label: String
  "Machine-readable status name (e.g. SUCCESS)."
  name: String
  "Text of the status. Deprecated in 16.4: The `text` attribute is being deprecated. Use `label` instead."
  text: String @deprecated(reason: "The `text` attribute is being deprecated. Use `label` instead. Deprecated in 16.4.")
  "Tooltip associated with the status."
  tooltip: String
}

"Enabled namespace for DevopsAdoption"
type DevopsAdoptionEnabledNamespace {
  "Namespace where data should be displayed."
  displayNamespace: Namespace
  "ID of the enabled namespace."
  id: ID!
  "Metrics snapshot for previous month for the enabled namespace."
  latestSnapshot: DevopsAdoptionSnapshot
  "Namespace which should be calculated."
  namespace: Namespace
  "Data snapshots of the namespace."
  snapshots(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter to snapshots with month end after the provided date."
    endTimeAfter: Time,
    "Filter to snapshots with month end before the provided date."
    endTimeBefore: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DevopsAdoptionSnapshotConnection
}

"The connection type for DevopsAdoptionEnabledNamespace."
type DevopsAdoptionEnabledNamespaceConnection {
  "A list of edges."
  edges: [DevopsAdoptionEnabledNamespaceEdge]
  "A list of nodes."
  nodes: [DevopsAdoptionEnabledNamespace]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DevopsAdoptionEnabledNamespaceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DevopsAdoptionEnabledNamespace
}

"Snapshot"
type DevopsAdoptionSnapshot {
  "Total number of projects with existing CODEOWNERS file."
  codeOwnersUsedCount: Int
  "Total number of projects with enabled coverage fuzzing."
  coverageFuzzingEnabledCount: Int
  "Total number of projects with enabled DAST."
  dastEnabledCount: Int
  "Total number of projects with enabled dependency scanning."
  dependencyScanningEnabledCount: Int
  "At least one deployment succeeded."
  deploySucceeded: Boolean!
  "End time for the snapshot where the data points were collected."
  endTime: Time!
  "At least one issue was opened."
  issueOpened: Boolean!
  "At least one merge request was approved."
  mergeRequestApproved: Boolean!
  "At least one merge request was opened."
  mergeRequestOpened: Boolean!
  "At least one pipeline succeeded."
  pipelineSucceeded: Boolean!
  "Time the snapshot was recorded."
  recordedAt: Time!
  "At least one runner was used."
  runnerConfigured: Boolean!
  "Total number of projects with enabled SAST."
  sastEnabledCount: Int
  "Start time for the snapshot where the data points were collected."
  startTime: Time!
  "Total number of projects."
  totalProjectsCount: Int
  "Total number of projects with vulnerability management used at least once."
  vulnerabilityManagementUsedCount: Int
}

"The connection type for DevopsAdoptionSnapshot."
type DevopsAdoptionSnapshotConnection {
  "A list of edges."
  edges: [DevopsAdoptionSnapshotEdge]
  "A list of nodes."
  nodes: [DevopsAdoptionSnapshot]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DevopsAdoptionSnapshotEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DevopsAdoptionSnapshot
}

type Diff {
  "Old file mode of the file."
  aMode: String
  "New file mode of the file."
  bMode: String
  "Indicates if the file has been removed. "
  deletedFile: String
  "Diff representation of the changes made to the file."
  diff: String
  "Indicates if the file has just been added. "
  newFile: String
  "New path of the file."
  newPath: String
  "Old path of the file."
  oldPath: String
  "Indicates if the file has been renamed."
  renamedFile: String
}

type DiffPosition {
  "Information about the branch, HEAD, and base at the time of commenting."
  diffRefs: DiffRefs!
  "Path of the file that was changed."
  filePath: String!
  "Total height of the image."
  height: Int
  "Line on HEAD SHA that was changed."
  newLine: Int
  "Path of the file on the HEAD SHA."
  newPath: String
  "Line on start SHA that was changed."
  oldLine: Int
  "Path of the file on the start SHA."
  oldPath: String
  "Type of file the position refers to."
  positionType: DiffPositionType!
  "Total width of the image."
  width: Int
  "X position of the note."
  x: Int
  "Y position of the note."
  y: Int
}

type DiffRefs {
  "Merge base of the branch the comment was made on."
  baseSha: String
  "SHA of the HEAD at the time the comment was made."
  headSha: String!
  "SHA of the branch being compared against."
  startSha: String!
}

"Changes to a single file"
type DiffStats {
  "Number of lines added to this file."
  additions: Int!
  "Number of lines deleted from this file."
  deletions: Int!
  "File path, relative to repository root."
  path: String!
}

"Aggregated summary of changes"
type DiffStatsSummary {
  "Number of lines added."
  additions: Int!
  "Number of lines changed."
  changes: Int!
  "Number of lines deleted."
  deletions: Int!
  "Number of files changed."
  fileCount: Int!
}

"Autogenerated return type of DisableDevopsAdoptionNamespace."
type DisableDevopsAdoptionNamespacePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type Discussion implements ResolvableInterface {
  "Timestamp of the discussion's creation."
  createdAt: Time!
  "ID of this discussion."
  id: DiscussionID!
  "Object which the discussion belongs to."
  noteable: NoteableType
  "All notes in the discussion."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "ID used to reply to this discussion."
  replyId: DiscussionID!
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
}

"The connection type for Discussion."
type DiscussionConnection {
  "A list of edges."
  edges: [DiscussionEdge]
  "A list of nodes."
  nodes: [Discussion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type DiscussionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Discussion
}

"Autogenerated return type of DiscussionToggleResolve."
type DiscussionToggleResolvePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Discussion after mutation."
  discussion: Discussion
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"All information related to DORA metrics."
type Dora {
  "DORA metrics for the current group or project."
  metrics(
    "Date range to end at. Default is the current date."
    endDate: Date,
    "Deployment tiers of the environments to return. Defaults to `[PRODUCTION]`."
    environmentTiers: [DeploymentTier!],
    "How the metric should be aggregated. Defaults to `DAILY`. In the case of `ALL`, the `date` field in the response will be `null`."
    interval: DoraMetricBucketingInterval,
    "Date range to start from. Default is 3 months ago."
    startDate: Date
  ): [DoraMetric!]
}

type DoraMetric {
  "Percentage of deployments that caused incidents in production."
  changeFailureRate: Float
  "Date of the data point."
  date: String
  "Number of deployments per day."
  deploymentFrequency: Float
  "Median time to deploy a merged merge request."
  leadTimeForChanges: Float
  "Median time to close an incident."
  timeToRestoreService: Float
  "Value of the data point. Deprecated in 15.10: Moved to corresponding metric field."
  value: Float @deprecated(reason: "Moved to corresponding metric field. Deprecated in 15.10.")
}

"Aggregated DORA score counts for projects for the last complete month."
type DoraPerformanceScoreCount {
  "Number of projects that score \"high\" on the metric."
  highProjectsCount: Int
  "Number of projects that score \"low\" on the metric."
  lowProjectsCount: Int
  "Number of projects that score \"medium\" on the metric."
  mediumProjectsCount: Int
  "Name of the DORA metric."
  metricName: String!
  "Number of projects with no data for the metric."
  noDataProjectsCount: Int
}

"The connection type for DoraPerformanceScoreCount."
type DoraPerformanceScoreCountConnection {
  "A list of edges."
  edges: [DoraPerformanceScoreCountEdge]
  "Count of projects without any DORA scores within the scope."
  noDoraDataProjectsCount: Int!
  "A list of nodes."
  nodes: [DoraPerformanceScoreCount]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Count of total projects."
  totalProjectsCount: Int!
}

"An edge in a connection."
type DoraPerformanceScoreCountEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DoraPerformanceScoreCount
}

"Autogenerated return type of EchoCreate."
type EchoCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Messages returned to the user."
  echoes: [String!]
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type EgressNode {
  "Artifacts egress for that project in that period of time."
  artifactsEgress: BigInt!
  "First day of the node range. There is one node per month."
  date: String!
  "Packages egress for that project in that period of time."
  packagesEgress: BigInt!
  "Registry egress for that project in that period of time."
  registryEgress: BigInt!
  "Repository egress for that project in that period of time."
  repositoryEgress: BigInt!
  "Total egress for that project in that period of time."
  totalEgress: BigInt!
}

"The connection type for EgressNode."
type EgressNodeConnection {
  "A list of edges."
  edges: [EgressNodeEdge]
  "A list of nodes."
  nodes: [EgressNode]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type EgressNodeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EgressNode
}

type Email {
  "Timestamp the email was confirmed."
  confirmedAt: Time
  "Timestamp the email was created."
  createdAt: Time!
  "Email address."
  email: String!
  "Internal ID of the email."
  id: ID!
  "Timestamp the email was last updated."
  updatedAt: Time!
}

"The connection type for Email."
type EmailConnection {
  "A list of edges."
  edges: [EmailEdge]
  "A list of nodes."
  nodes: [Email]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type EmailEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Email
}

"Autogenerated return type of EnableDevopsAdoptionNamespace."
type EnableDevopsAdoptionNamespacePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Enabled namespace after mutation."
  enabledNamespace: DevopsAdoptionEnabledNamespace
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Describes where code is deployed for a project"
type Environment {
  "When the environment is going to be deleted automatically."
  autoDeleteAt: Time
  "When the environment is going to be stopped automatically."
  autoStopAt: Time
  "Cluster agent of the environment."
  clusterAgent: ClusterAgent
  "When the environment was created."
  createdAt: Time
  "Deployment freeze periods of the environment."
  deployFreezes: [CiFreezePeriod!]
  "Deployments of the environment. This field can only be resolved for one environment in any single request."
  deployments(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Order by a specified field."
    orderBy: DeploymentsOrderByInput,
    "Statuses of the deployments."
    statuses: [DeploymentStatus!]
  ): DeploymentConnection
  "Folder name of the environment."
  environmentType: String
  "External URL of the environment."
  externalUrl: String
  "Flux resource path of the environment."
  fluxResourcePath: String
  "ID of the environment."
  id: ID!
  "Kubernetes namespace of the environment."
  kubernetesNamespace: String
  "Last deployment of the environment."
  lastDeployment(
    "Status of the Deployment."
    status: DeploymentStatus!
  ): Deployment
  "Most severe open alert for the environment. If multiple alerts have equal severity, the most recent is returned."
  latestOpenedMostSevereAlert: AlertManagementAlert
  "Human-readable name of the environment."
  name: String!
  "Path to the environment."
  path: String!
  "Protected Environments for the environment."
  protectedEnvironments(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProtectedEnvironmentConnection
  "Slug of the environment."
  slug: String
  "State of the environment, for example: available/stopped."
  state: String!
  "Deployment tier of the environment."
  tier: DeploymentTier
  "When the environment was updated."
  updatedAt: Time
  "Permissions for the current user on the resource. This field can only be resolved for one environment in any single request."
  userPermissions: EnvironmentPermissions!
}

"The connection type for Environment."
type EnvironmentConnection {
  "A list of edges."
  edges: [EnvironmentEdge]
  "A list of nodes."
  nodes: [Environment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of EnvironmentCreate."
type EnvironmentCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Created environment."
  environment: Environment
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of EnvironmentDelete."
type EnvironmentDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type EnvironmentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Environment
}

type EnvironmentPermissions {
  "If `true`, the user can perform `destroy_environment` on this resource"
  destroyEnvironment: Boolean!
  "If `true`, the user can perform `stop_environment` on this resource"
  stopEnvironment: Boolean!
  "If `true`, the user can perform `update_environment` on this resource"
  updateEnvironment: Boolean!
}

"Autogenerated return type of EnvironmentStop."
type EnvironmentStopPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Environment after attempt to stop."
  environment: Environment
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of EnvironmentUpdate."
type EnvironmentUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Environment after attempt to update."
  environment: Environment
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of EnvironmentsCanaryIngressUpdate."
type EnvironmentsCanaryIngressUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents an epic"
type Epic implements CurrentUserTodos & Eventable & NoteableInterface & Todoable {
  "Ancestors (parents) of the epic."
  ancestors(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter epics by author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter epics by given confidentiality."
    confidential: Boolean,
    "Epics created after this date."
    createdAfter: Time,
    "Epics created before this date."
    createdBefore: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the epic, e.g., \"1\"."
    iid: ID,
    "Filter epics by IID for autocomplete."
    iidStartsWith: String,
    "List of IIDs of epics, e.g., `[1, 2]`."
    iids: [ID!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Include epics from ancestor groups."
    includeAncestorGroups: Boolean = true,
    "Include epics from descendant groups."
    includeDescendantGroups: Boolean = true,
    "Filter epics by labels."
    labelName: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter epics by milestone title, computed from epic's issues."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Negated epic arguments."
    not: NegatedEpicFilterInput,
    "Search query for title or description."
    search: String,
    "List epics by sort order."
    sort: EpicSort,
    "Filter epics by state."
    state: EpicState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Filter epics with a top-level hierarchy."
    topLevelHierarchyOnly: Boolean,
    "Epics updated after this date."
    updatedAfter: Time,
    "Epics updated before this date."
    updatedBefore: Time
  ): EpicConnection
  "Author of the epic."
  author: UserCore!
  "List of emoji reactions associated with the epic."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Indicates the epic is blocked."
  blocked: Boolean
  "Count of epics blocking this epic."
  blockedByCount: Int
  "Epics blocking this epic."
  blockedByEpics(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EpicConnection
  "Count of epics that this epic is blocking."
  blockingCount: Int
  "Children (sub-epics) of the epic."
  children(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter epics by author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter epics by given confidentiality."
    confidential: Boolean,
    "Epics created after this date."
    createdAfter: Time,
    "Epics created before this date."
    createdBefore: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the epic, e.g., \"1\"."
    iid: ID,
    "Filter epics by IID for autocomplete."
    iidStartsWith: String,
    "List of IIDs of epics, e.g., `[1, 2]`."
    iids: [ID!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Include child epics from ancestor groups."
    includeAncestorGroups: Boolean = true,
    "Include epics from descendant groups."
    includeDescendantGroups: Boolean = true,
    "Filter epics by labels."
    labelName: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter epics by milestone title, computed from epic's issues."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Negated epic arguments."
    not: NegatedEpicFilterInput,
    "Search query for title or description."
    search: String,
    "List epics by sort order."
    sort: EpicSort,
    "Filter epics by state."
    state: EpicState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Filter epics with a top-level hierarchy."
    topLevelHierarchyOnly: Boolean,
    "Epics updated after this date."
    updatedAfter: Time,
    "Epics updated before this date."
    updatedBefore: Time
  ): EpicConnection
  "Timestamp of when the epic was closed."
  closedAt: Time
  "Color of the epic. Returns `null` if `epic_color_highlight` feature flag is disabled."
  color: String
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Indicates if the epic is confidential."
  confidential: Boolean
  "Timestamp of when the epic was created."
  createdAt: Time
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Default Project for issue creation. Based on the project the user created the last issue in."
  defaultProjectForIssueCreation: Project
  "Number of open and closed descendant epics and issues."
  descendantCounts: EpicDescendantCount
  "Total weight of open and closed issues in the epic and its descendants."
  descendantWeightSum: EpicDescendantWeights
  "Description of the epic."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Number of downvotes the epic has received."
  downvotes: Int!
  "Due date of the epic."
  dueDate: Time
  "Fixed due date of the epic."
  dueDateFixed: Time
  "Inherited due date of the epic from child epics or milestones."
  dueDateFromInheritedSource: Time
  "Inherited due date of the epic from milestones."
  dueDateFromMilestones: Time
  "Indicates if the due date has been manually set."
  dueDateIsFixed: Boolean
  "List of events associated with the object."
  events(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EventConnection
  "Group to which the epic belongs."
  group: Group!
  "Indicates if the epic has children."
  hasChildren: Boolean!
  "Indicates if the epic has direct issues."
  hasIssues: Boolean!
  "Indicates if the epic has a parent epic."
  hasParent: Boolean!
  "Current health status of the epic."
  healthStatus: EpicHealthStatus
  "ID of the epic."
  id: ID!
  "Internal ID of the epic."
  iid: ID!
  "A list of issues associated with the epic."
  issues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EpicIssueConnection
  "Labels assigned to the epic."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Parent epic of the epic."
  parent: Epic
  "List of participants for the epic."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Internal reference of the epic. Returned in shortened format by default."
  reference(
    "Indicates if the reference should be returned in full."
    full: Boolean = false
  ): String!
  "URI path of the epic-issue relationship."
  relationPath: String
  "Relative position of the epic in the epic tree."
  relativePosition: Int
  "Start date of the epic."
  startDate: Time
  "Fixed start date of the epic."
  startDateFixed: Time
  "Inherited start date of the epic from child epics or milestones."
  startDateFromInheritedSource: Time
  "Inherited start date of the epic from milestones."
  startDateFromMilestones: Time
  "Indicates if the start date has been manually set."
  startDateIsFixed: Boolean
  "State of the epic."
  state: EpicState!
  "Indicates the currently logged in user is subscribed to the epic."
  subscribed: Boolean!
  "Text color generated for the epic. Returns `null` if `epic_color_highlight` feature flag is disabled."
  textColor: String
  "Title of the epic."
  title: String
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Timestamp of when the epic was updated."
  updatedAt: Time
  "Number of upvotes the epic has received."
  upvotes: Int!
  "Number of user discussions in the epic."
  userDiscussionsCount: Int!
  "Number of user notes of the epic."
  userNotesCount: Int!
  "Permissions for the current user on the resource"
  userPermissions: EpicPermissions!
  "Web path of the epic."
  webPath: String!
  "Web URL of the epic."
  webUrl: String!
}

"Autogenerated return type of EpicAddIssue."
type EpicAddIssuePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Epic after mutation."
  epic: Epic
  "Epic-issue relationship."
  epicIssue: EpicIssue
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents an epic board"
type EpicBoard {
  "Whether or not display epic colors."
  displayColors: Boolean
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "Global ID of the epic board."
  id: BoardsEpicBoardID!
  "Labels of the board."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Epic board lists."
  lists(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters applied when getting epic metadata in the epic board list."
    epicFilters: EpicFilters,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Find an epic board list by ID."
    id: BoardsEpicListID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EpicListConnection
  "Name of the epic board."
  name: String
  "Web path of the epic board."
  webPath: String!
  "Web URL of the epic board."
  webUrl: String!
}

"The connection type for EpicBoard."
type EpicBoardConnection {
  "A list of edges."
  edges: [EpicBoardEdge]
  "A list of nodes."
  nodes: [EpicBoard]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of EpicBoardCreate."
type EpicBoardCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Created epic board."
  epicBoard: EpicBoard
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type EpicBoardEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EpicBoard
}

"Autogenerated return type of EpicBoardListCreate."
type EpicBoardListCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Epic list in the epic board."
  list: EpicList
}

"Autogenerated return type of EpicBoardListDestroy."
type EpicBoardListDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Epic board list. `null` if the board was destroyed successfully."
  list: EpicList
}

"Autogenerated return type of EpicBoardUpdate."
type EpicBoardUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Updated epic board."
  epicBoard: EpicBoard
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"The connection type for Epic."
type EpicConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [EpicEdge]
  "A list of nodes."
  nodes: [Epic]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Counts of descendent epics"
type EpicDescendantCount {
  "Number of closed child epics."
  closedEpics: Int
  "Number of closed epic issues."
  closedIssues: Int
  "Number of opened child epics."
  openedEpics: Int
  "Number of opened epic issues."
  openedIssues: Int
}

"Total weight of open and closed descendant issues"
type EpicDescendantWeights {
  "Total weight of completed (closed) issues in this epic, including epic descendants. Deprecated in 16.6: Use `closedIssuesTotal`."
  closedIssues: Int @deprecated(reason: "Use `closedIssuesTotal`. Deprecated in 16.6.")
  """

  Total weight of completed (closed) issues in this epic, including epic descendants,
  encoded as a string.
  """
  closedIssuesTotal: BigInt
  "Total weight of opened issues in this epic, including epic descendants. Deprecated in 16.6: Use `OpenedIssuesTotal`."
  openedIssues: Int @deprecated(reason: "Use `OpenedIssuesTotal`. Deprecated in 16.6.")
  "Total weight of opened issues in this epic, including epic descendants, encoded as a string."
  openedIssuesTotal: BigInt
}

"An edge in a connection."
type EpicEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Epic
}

"Health status of child issues"
type EpicHealthStatus {
  "Number of issues at risk."
  issuesAtRisk: Int
  "Number of issues that need attention."
  issuesNeedingAttention: Int
  "Number of issues on track."
  issuesOnTrack: Int
}

"Relationship between an epic and an issue"
type EpicIssue implements CurrentUserTodos & NoteableInterface & Todoable {
  "Alert associated to this issue. Deprecated in 15.6: Use `alert_management_alerts`."
  alertManagementAlert: AlertManagementAlert @deprecated(reason: "Use `alert_management_alerts`. Deprecated in 15.6.")
  "Alert Management alerts associated to this issue."
  alertManagementAlerts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Username of a user assigned to the issue."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter query for given domain."
    domain: AlertManagementDomainFilter! = operations,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the alert. For example, \"1\"."
    iid: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Sort alerts by this criteria."
    sort: AlertManagementAlertSort,
    "Alerts with the specified statues. For example, `[TRIGGERED]`."
    statuses: [AlertManagementStatus!]
  ): AlertManagementAlertConnection
  "Assignees of the issue."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "User that created the issue."
  author: UserCore!
  "Indicates the issue is blocked."
  blocked: Boolean!
  "Count of issues blocking this issue."
  blockedByCount: Int
  "Issues blocking this issue."
  blockedByIssues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssueConnection
  "Count of issues this issue is blocking."
  blockingCount: Int!
  "Issue this issue was closed as a duplicate of."
  closedAsDuplicateOf: Issue
  "Timestamp of when the issue was closed."
  closedAt: Time
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Indicates the issue is confidential."
  confidential: Boolean!
  "User specific email address for the issue."
  createNoteEmail: String
  "Timestamp of when the issue was created."
  createdAt: Time!
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Customer relations contacts of the issue."
  customerRelationsContacts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomerRelationsContactConnection
  "Description of the issue."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Collection of design images associated with this issue."
  designCollection: DesignCollection
  "Indicates discussion is locked on the issue."
  discussionLocked: Boolean!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Number of downvotes the issue has received."
  downvotes: Int!
  "Due date of the issue."
  dueDate: Time
  "Indicates if the parent project or group has email notifications disabled: `true` if email notifications are disabled. Deprecated in 16.3: Use `emails_enabled`."
  emailsDisabled: Boolean! @deprecated(reason: "Use `emails_enabled`. Deprecated in 16.3.")
  "Indicates if the parent project or group has email notifications disabled: `false` if email notifications are disabled."
  emailsEnabled: Boolean!
  "Epic to which this issue belongs."
  epic: Epic
  "ID of the epic-issue relation."
  epicIssueId: ID!
  "Escalation policy associated with the issue. Available for issues which support escalation."
  escalationPolicy: EscalationPolicyType
  "Escalation status of the issue."
  escalationStatus: IssueEscalationStatus
  "Email address of non-GitLab user reporting the issue. For guests, the email address is obfuscated."
  externalAuthor: String
  """

  Indicates if the issue belongs to an epic.
  Can return true and not show an associated epic when the user has no access to the epic.
  """
  hasEpic: Boolean!
  "Indicates if the issue has a parent work item. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  hasParent: Boolean! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Current health status."
  healthStatus: HealthStatus
  "Indicates the issue is hidden because the author has been banned."
  hidden: Boolean
  "Human-readable time estimate of the issue."
  humanTimeEstimate: String
  "Human-readable total time reported as spent on the issue."
  humanTotalTimeSpent: String
  "Global ID of the epic-issue relation."
  id: ID
  "Internal ID of the issue."
  iid: ID!
  "Issuable resource links of the incident issue."
  issuableResourceLinks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of the incident."
    incidentId: IssueID!,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssuableResourceLinkConnection
  "Iteration of the issue."
  iteration: Iteration
  "Labels of the issue."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Number of merge requests that close the issue on merge."
  mergeRequestsCount: Int!
  "Metric images associated to the issue."
  metricImages: [MetricImage!]
  "Milestone of the issue."
  milestone: Milestone
  "Indicates if issue got moved from other project."
  moved: Boolean
  "Updated Issue after it got moved to another project."
  movedTo: Issue
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "List of participants in the issue."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "ID of the issue project."
  projectId: Int
  "Internal reference of the issue. Returned in shortened format by default."
  reference(
    "Boolean option specifying whether the reference should be returned in full."
    full: Boolean = false
  ): String!
  "Merge requests related to the issue. This field can only be resolved for one issue in any single request."
  relatedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Related vulnerabilities of the issue."
  relatedVulnerabilities(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityConnection
  "URI path of the epic-issue relation."
  relationPath: String
  "Relative position of the issue (used for positioning in epic tree and issue boards)."
  relativePosition: Int
  "Severity level of the incident."
  severity: IssuableSeverity
  "Timestamp of when the issue SLA expires."
  slaDueAt: Time
  "State of the issue."
  state: IssueState!
  "Indicates whether an issue is published to the status page."
  statusPagePublishedIncident: Boolean
  "Indicates the currently logged in user is subscribed to the issue."
  subscribed: Boolean!
  "Task completion status of the issue."
  taskCompletionStatus: TaskCompletionStatus!
  "Time estimate of the issue."
  timeEstimate: Int!
  "Timelogs on the issue."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection!
  "Title of the issue."
  title: String!
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Total time (in seconds) reported as spent on the issue."
  totalTimeSpent: Int!
  "Type of the issue."
  type: IssueType
  "Timestamp of when the issue was last updated."
  updatedAt: Time!
  "User that last updated the issue."
  updatedBy: UserCore
  "Number of upvotes the issue has received."
  upvotes: Int!
  "Number of user discussions in the issue."
  userDiscussionsCount: Int!
  "Number of user notes of the issue."
  userNotesCount: Int!
  "Permissions for the current user on the resource"
  userPermissions: IssuePermissions!
  "Web path of the issue."
  webPath: String!
  "Web URL of the issue."
  webUrl: String!
  "Weight of the issue."
  weight: Int
}

"The connection type for EpicIssue."
type EpicIssueConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [EpicIssueEdge]
  "A list of nodes."
  nodes: [EpicIssue]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total weight of issues collection."
  weight: Int!
}

"An edge in a connection."
type EpicIssueEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EpicIssue
}

"Represents an epic board list"
type EpicList {
  "Indicates if this list is collapsed for this user."
  collapsed: Boolean
  "List epics."
  epics(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters applied when selecting epics in the board list."
    filters: EpicFilters,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EpicConnection
  "Count of epics in the list. Deprecated in 14.9: This was renamed."
  epicsCount: Int @deprecated(reason: "This was renamed. Please use `metadata`. Deprecated in 14.9.")
  "Global ID of the board list."
  id: BoardsEpicListID!
  "Label of the list."
  label: Label
  "Type of the list."
  listType: String!
  "Epic list metatada."
  metadata: EpicListMetadata
  "Position of the list within the board."
  position: Int
  "Title of the list."
  title: String!
}

"The connection type for EpicList."
type EpicListConnection {
  "A list of edges."
  edges: [EpicListEdge]
  "A list of nodes."
  nodes: [EpicList]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type EpicListEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EpicList
}

"Represents epic board list metadata"
type EpicListMetadata {
  "Count of epics in the list."
  epicsCount: Int
  "Total weight of all issues in the list. Introduced in 14.7: This feature is an Experiment. It can be changed or removed at any time."
  totalWeight: Int @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 14.7.")
}

"Autogenerated return type of EpicMoveList."
type EpicMoveListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Epic after mutation."
  epic: Epic
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Check permissions for the current user on an epic"
type EpicPermissions {
  "If `true`, the user can perform `admin_epic` on this resource"
  adminEpic: Boolean!
  "If `true`, the user can perform `admin_epic_relation` on this resource"
  adminEpicRelation: Boolean!
  "If `true`, the user can perform `award_emoji` on this resource"
  awardEmoji: Boolean!
  "If `true`, the user can perform `create_epic` on this resource"
  createEpic: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `destroy_epic` on this resource"
  destroyEpic: Boolean!
  "If `true`, the user can perform `read_epic` on this resource"
  readEpic: Boolean!
  "If `true`, the user can perform `read_epic_iid` on this resource"
  readEpicIid: Boolean!
  "If `true`, the user can perform `update_epic` on this resource"
  updateEpic: Boolean!
}

"Autogenerated return type of EpicSetSubscription."
type EpicSetSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Epic after mutation."
  epic: Epic
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of EpicTreeReorder."
type EpicTreeReorderPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of EscalationPolicyCreate."
type EscalationPolicyCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Escalation policy."
  escalationPolicy: EscalationPolicyType
}

"Autogenerated return type of EscalationPolicyDestroy."
type EscalationPolicyDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Escalation policy."
  escalationPolicy: EscalationPolicyType
}

"Represents an escalation policy"
type EscalationPolicyType {
  "Description of the escalation policy."
  description: String
  "ID of the escalation policy."
  id: IncidentManagementEscalationPolicyID
  "Name of the escalation policy."
  name: String
  "Steps of the escalation policy."
  rules: [EscalationRuleType!]
}

"The connection type for EscalationPolicyType."
type EscalationPolicyTypeConnection {
  "A list of edges."
  edges: [EscalationPolicyTypeEdge]
  "A list of nodes."
  nodes: [EscalationPolicyType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type EscalationPolicyTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: EscalationPolicyType
}

"Autogenerated return type of EscalationPolicyUpdate."
type EscalationPolicyUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Escalation policy."
  escalationPolicy: EscalationPolicyType
}

"Represents an escalation rule for an escalation policy"
type EscalationRuleType {
  "Time in seconds before the rule is activated."
  elapsedTimeSeconds: Int
  "ID of the escalation policy."
  id: IncidentManagementEscalationRuleID
  "On-call schedule to notify."
  oncallSchedule: IncidentManagementOncallSchedule
  "Status required to prevent the rule from activating."
  status: EscalationRuleStatus
  "User to notify."
  user: UserCore
}

"Representing an event"
type Event {
  "Action of the event."
  action: EventAction!
  "Author of this event."
  author: UserCore!
  "When this event was created."
  createdAt: Time!
  "ID of the event."
  id: ID!
  "When this event was updated."
  updatedAt: Time!
}

"The connection type for Event."
type EventConnection {
  "A list of edges."
  edges: [EventEdge]
  "A list of nodes."
  nodes: [Event]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type EventEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Event
}

type ExplainVulnerabilityPresubmissionCheckResults {
  "This flag is true if we think there might be a secret in the code that would be sent in the LLM prompt."
  potentialSecretsInCode: Boolean!
  "This flag is true if the vulnerability being explained is specifically a secret detection vulnerability"
  secretDetectionResult: Boolean!
}

type ExplainVulnerabilityPrompt {
  "An object containing booleans. Each booolean indicates the result of a presubmission check: `true` for passed, and `false` for failed."
  presubmissionChecks: ExplainVulnerabilityPresubmissionCheckResults!
  "AI text prompt generated using the vulnerability's information, including the vulnerable code."
  promptWithCode: String
  "AI text prompt generated using the vulnerability's information, excluding the vulnerable code."
  promptWithoutCode: String
}

"Autogenerated return type of ExportRequirements."
type ExportRequirementsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Represents an external resource to send audit events to"
type ExternalAuditEventDestination implements ExternalAuditEventDestinationInterface {
  "External destination to send audit events to."
  destinationUrl: String!
  "List of event type filters added for streaming."
  eventTypeFilters: [String!]!
  "Group the destination belongs to."
  group: Group!
  "List of additional HTTP headers sent with each event."
  headers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AuditEventStreamingHeaderConnection!
  "ID of the destination."
  id: ID!
  "Name of the external destination to send audit events to."
  name: String!
  "List of subgroup or project filters for the destination."
  namespaceFilter: AuditEventStreamingHTTPNamespaceFilter
  "Verification token to validate source of event."
  verificationToken: String!
}

"The connection type for ExternalAuditEventDestination."
type ExternalAuditEventDestinationConnection {
  "A list of edges."
  edges: [ExternalAuditEventDestinationEdge]
  "A list of nodes."
  nodes: [ExternalAuditEventDestination]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of ExternalAuditEventDestinationCreate."
type ExternalAuditEventDestinationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Destination created."
  externalAuditEventDestination: ExternalAuditEventDestination
}

"Autogenerated return type of ExternalAuditEventDestinationDestroy."
type ExternalAuditEventDestinationDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type ExternalAuditEventDestinationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ExternalAuditEventDestination
}

"Autogenerated return type of ExternalAuditEventDestinationUpdate."
type ExternalAuditEventDestinationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated destination."
  externalAuditEventDestination: ExternalAuditEventDestination
}

"Represents an external issue"
type ExternalIssue {
  "Timestamp of when the issue was created."
  createdAt: Time
  "Type of external tracker."
  externalTracker: String
  "Relative reference of the issue in the external tracker."
  relativeReference: String
  "Status of the issue in the external tracker."
  status: String
  "Title of the issue in the external tracker."
  title: String
  "Timestamp of when the issue was updated."
  updatedAt: Time
  "URL to the issue in the external tracker."
  webUrl: String
}

"Describes an external status check."
type ExternalStatusCheck {
  "External URL for the status check."
  externalUrl: String!
  "ID of the rule."
  id: GlobalID!
  "Name of the rule."
  name: String!
}

"The connection type for ExternalStatusCheck."
type ExternalStatusCheckConnection {
  "A list of edges."
  edges: [ExternalStatusCheckEdge]
  "A list of nodes."
  nodes: [ExternalStatusCheck]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ExternalStatusCheckEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ExternalStatusCheck
}

type FileUpload {
  "Global ID of the upload."
  id: UploadID!
  "Path of the upload."
  path: String!
  "Size of the upload in bytes."
  size: Int!
}

"Represents security reports comparison for vulnerability findings."
type FindingReportsComparer {
  "Compared security report. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  report: ComparedSecurityReport @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Comparison status."
  status: FindingReportsComparerStatus
  "Text explaining the status."
  statusReason: String
}

"Information about specific forecast created"
type Forecast {
  "Status of the forecast."
  status: ForecastStatus!
  "Actual forecast values."
  values(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ForecastDatapointConnection
}

"Information about specific forecast datapoint"
type ForecastDatapoint {
  "Datapoint of the forecast. Usually a date."
  datapoint: String!
  "Value of the given datapoint."
  value: Float
}

"The connection type for ForecastDatapoint."
type ForecastDatapointConnection {
  "A list of edges."
  edges: [ForecastDatapointEdge]
  "A list of nodes."
  nodes: [ForecastDatapoint]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ForecastDatapointEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ForecastDatapoint
}

"Details of the fork project compared to its upstream project."
type ForkDetails {
  "Number of commits ahead of upstream."
  ahead: Int
  "Number of commits behind upstream."
  behind: Int
  "Indicates if the fork conflicts with its upstream project."
  hasConflicts: Boolean
  "Indicates if there is a synchronization in progress."
  isSyncing: Boolean
}

type GeoNode {
  "Find Ci Secure File registries on this Geo node"
  ciSecureFileRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): CiSecureFileRegistryConnection
  "Maximum concurrency of container repository sync for this secondary node."
  containerRepositoriesMaxCapacity: Int
  "Find Container Repository registries on this Geo node."
  containerRepositoryRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): ContainerRepositoryRegistryConnection
  "Find Dependency Proxy Blob registries on this Geo node. Introduced in 15.6: This feature is an Experiment. It can be changed or removed at any time."
  dependencyProxyBlobRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): DependencyProxyBlobRegistryConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.")
  "Find Dependency Proxy Manifest registries on this Geo node."
  dependencyProxyManifestRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): DependencyProxyManifestRegistryConnection
  "Find Design Management Repository registries on this Geo node. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  designManagementRepositoryRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): DesignManagementRepositoryRegistryConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Indicates whether this Geo node is enabled."
  enabled: Boolean
  "Maximum concurrency of LFS/attachment backfill for this secondary node."
  filesMaxCapacity: Int
  "Find group wiki repository registries on this Geo node."
  groupWikiRepositoryRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): GroupWikiRepositoryRegistryConnection
  "ID of this GeoNode."
  id: ID!
  "URL defined on the primary node secondary nodes should use to contact it."
  internalUrl: String
  "Find Job Artifact registries on this Geo node."
  jobArtifactRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): JobArtifactRegistryConnection
  "Find LFS object registries on this Geo node."
  lfsObjectRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): LfsObjectRegistryConnection
  "Find merge request diff registries on this Geo node."
  mergeRequestDiffRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): MergeRequestDiffRegistryConnection
  "Interval (in days) in which the repository verification is valid. After expiry, it is reverted."
  minimumReverificationInterval: Int
  "Unique identifier for this Geo node."
  name: String
  "Package file registries of the GeoNode."
  packageFileRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): PackageFileRegistryConnection
  "Find Pages Deployment registries on this Geo node"
  pagesDeploymentRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): PagesDeploymentRegistryConnection
  "Find pipeline artifact registries on this Geo node."
  pipelineArtifactRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): PipelineArtifactRegistryConnection
  "Indicates whether this Geo node is the primary."
  primary: Boolean
  "Find Project registries on this Geo node. Ignored if `geo_project_repository_replication` feature flag is disabled."
  projectRepositoryRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): ProjectRepositoryRegistryConnection
  "Find Project Wiki Repository registries on this Geo node. Ignored if `geo_project_wiki_repository_replication` feature flag is disabled."
  projectWikiRepositoryRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): ProjectWikiRepositoryRegistryConnection
  "Maximum concurrency of repository backfill for this secondary node."
  reposMaxCapacity: Int
  "Namespaces that should be synced, if `selective_sync_type` == `namespaces`."
  selectiveSyncNamespaces(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceConnection
  "Repository storages whose projects should be synced, if `selective_sync_type` == `shards`."
  selectiveSyncShards: [String!]
  "Indicates if syncing is limited to only specific groups, or shards."
  selectiveSyncType: String
  "Find snippet repository registries on this Geo node."
  snippetRepositoryRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): SnippetRepositoryRegistryConnection
  "Indicates if this secondary node will replicate blobs in Object Storage."
  syncObjectStorage: Boolean
  "Find terraform state version registries on this Geo node."
  terraformStateVersionRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): TerraformStateVersionRegistryConnection
  "Find Upload registries on this Geo node"
  uploadRegistries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filters registries by their ID."
    ids: [ID!],
    "Filters registries by their attributes using a keyword."
    keyword: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filters registries by their replication state."
    replicationState: ReplicationStateEnum,
    "Filters registries by their verification state."
    verificationState: VerificationStateEnum
  ): UploadRegistryConnection
  "User-facing URL for this Geo node."
  url: String
  "Maximum concurrency of repository verification for this secondary node."
  verificationMaxCapacity: Int
}

"Autogenerated return type of GeoRegistriesBulkUpdate."
type GeoRegistriesBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated Geo registry class."
  registryClass: GeoRegistryClass
}

"Autogenerated return type of GeoRegistriesUpdate."
type GeoRegistriesUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated Geo registry entry."
  registry: Registrable
}

"Autogenerated return type of GitlabSubscriptionActivate."
type GitlabSubscriptionActivatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Array of future subscriptions."
  futureSubscriptions: [SubscriptionFutureEntry!]
  "Current license."
  license: CurrentLicense
}

"Autogenerated return type of GoogleCloudLoggingConfigurationCreate."
type GoogleCloudLoggingConfigurationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "configuration created."
  googleCloudLoggingConfiguration: GoogleCloudLoggingConfigurationType
}

"Autogenerated return type of GoogleCloudLoggingConfigurationDestroy."
type GoogleCloudLoggingConfigurationDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Stores Google Cloud Logging configurations associated with IAM service accounts,used for generating access tokens."
type GoogleCloudLoggingConfigurationType implements GoogleCloudLoggingConfigurationInterface {
  "Client email."
  clientEmail: String!
  "Google project ID."
  googleProjectIdName: String!
  "Group the configuration belongs to."
  group: Group!
  "ID of the configuration."
  id: ID!
  "Log ID."
  logIdName: String!
  "Name of the external destination to send audit events to."
  name: String!
}

"The connection type for GoogleCloudLoggingConfigurationType."
type GoogleCloudLoggingConfigurationTypeConnection {
  "A list of edges."
  edges: [GoogleCloudLoggingConfigurationTypeEdge]
  "A list of nodes."
  nodes: [GoogleCloudLoggingConfigurationType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type GoogleCloudLoggingConfigurationTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GoogleCloudLoggingConfigurationType
}

"Autogenerated return type of GoogleCloudLoggingConfigurationUpdate."
type GoogleCloudLoggingConfigurationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "configuration updated."
  googleCloudLoggingConfiguration: GoogleCloudLoggingConfigurationType
}

"GPG signature for a signed commit"
type GpgSignature implements CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "ID of the GPG key."
  gpgKeyPrimaryKeyid: String
  "User email associated with the GPG key."
  gpgKeyUserEmail: String
  "User name associated with the GPG key."
  gpgKeyUserName: String
  "Project of the associated commit."
  project: Project
  "User associated with the key."
  user: UserCore
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
}

type GrafanaIntegration {
  "Timestamp of the issue's creation."
  createdAt: Time!
  "Indicates whether Grafana integration is enabled."
  enabled: Boolean!
  "URL for the Grafana host for the Grafana integration."
  grafanaUrl: String!
  "Internal ID of the Grafana integration."
  id: ID!
  "Timestamp of the issue's last activity."
  updatedAt: Time!
}

type Group {
  "Achievements for the namespace. Returns `null` if the `achievements` feature flag is disabled. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  achievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter achievements by IDs."
    ids: [AchievementsAchievementID!],
    "Returns the last _n_ elements from the list."
    last: Int
  ): AchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
  "Size limit for repositories in the namespace in bytes. This limit only applies to namespaces under Project limit enforcement."
  actualRepositorySizeLimit: Float
  "The actual storage size limit (in bytes) based on the enforcement type of either repository or namespace. This limit is agnostic of enforcement type."
  actualSizeLimit: Float
  "Users in the namespace hierarchy that add ons are applicable for. This only applies to root namespaces. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  addOnEligibleUsers(
    "Type of add on to filter the eligible users by."
    addOnType: GitlabSubscriptionsAddOnType!,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search the user list."
    search: String
  ): AddOnUserConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "AddOnPurchase associated with the namespace"
  addOnPurchase(
    "AddOn name."
    addOnName: String!
  ): AddOnPurchase
  "Additional storage purchased for the root namespace in bytes."
  additionalPurchasedStorageSize: Float
  "Indicates whether to regularly prune stale group runners. Defaults to false."
  allowStaleRunnerPruning: Boolean!
  "Amazon S3 configurations that receive audit events belonging to the group."
  amazonS3Configurations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AmazonS3ConfigurationTypeConnection
  "Indicates whether Auto DevOps is enabled for all projects within this group."
  autoDevopsEnabled: Boolean
  "Search users for autocompletion"
  autocompleteUsers(
    "Query to search users by name, username, or public email."
    search: String
  ): [AutocompletedUser!]
  "Avatar URL of the group."
  avatarUrl: String
  "Number of billable users in the group."
  billableMembersCount(
    "Plan from which to get billable members."
    requestedHostedPlan: String
  ): Int
  "A single board of the group."
  board(
    "ID of the board."
    id: BoardID!
  ): Board
  "Boards of the group."
  boards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Find a board by its ID."
    id: BoardID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "List of the group's CI/CD variables."
  ciVariables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Sort order of results."
    sort: CiVariableSort
  ): CiGroupVariableConnection
  "Cluster agents associated with projects in the group and its subgroups."
  clusterAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only cluster agents which have an associated remote development agent config."
    hasRemoteDevelopmentAgentConfig: Boolean,
    "Returns only cluster agents which have been enabled with the remote development feature."
    hasRemoteDevelopmentEnabled: Boolean,
    "Returns only cluster agents which have vulnerabilities."
    hasVulnerabilities: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentConnection
  "Represents the code coverage activity for this group."
  codeCoverageActivities(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "First day for which to fetch code coverage activity (maximum time window is set to 90 days)."
    startDate: Date!
  ): CodeCoverageActivityConnection
  "Compliance frameworks available to projects in this namespace."
  complianceFrameworks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of a specific compliance framework to return."
    id: ComplianceManagementFrameworkID,
    "List of Global IDs of compliance frameworks to return."
    ids: [ComplianceManagementFrameworkID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search framework with most similar names."
    search: String
  ): ComplianceFrameworkConnection
  "Counts of contacts by state for the group."
  contactStateCounts(
    "Search term to find contacts with."
    search: String,
    "State of the contacts to search for."
    state: CustomerRelationsContactState
  ): ContactStateCounts
  "Find contacts of this group."
  contacts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter contacts by IDs."
    ids: [CustomerRelationsContactID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search term to find contacts with."
    search: String,
    "Criteria to sort contacts by."
    sort: ContactSort = LAST_NAME_ASC,
    "State of the contacts to search for."
    state: CustomerRelationsContactState
  ): CustomerRelationsContactConnection
  "Container repositories of the group."
  containerRepositories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter the container repositories by their name."
    name: String,
    "Sort container repositories by this criteria."
    sort: ContainerRepositorySort = created_desc
  ): ContainerRepositoryConnection
  "Number of container repositories in the group."
  containerRepositoriesCount: Int!
  "Includes at least one project where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement."
  containsLockedProjects: Boolean
  "Provides the aggregated contributions by users within the group and its subgroups"
  contributions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Start date of the reporting time range."
    from: ISO8601Date!,
    "End date of the reporting time range. The end date must be within 93 days after the start date."
    to: ISO8601Date!
  ): ContributionAnalyticsContributionConnection
  "Indicates if the cross_project_pipeline feature is available for the namespace."
  crossProjectPipelineAvailable: Boolean!
  "Custom emoji in this namespace. Introduced in 13.6: This feature is an Experiment. It can be changed or removed at any time."
  customEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Includes custom emoji from parent groups."
    includeAncestorGroups: Boolean = false,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomEmojiConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 13.6.")
  "Visualizations of the group or associated configuration project. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  customizableDashboardVisualizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Slug of the visualization to return."
    slug: String
  ): CustomizableDashboardVisualizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Customizable dashboards for the group. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  customizableDashboards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Find by dashboard type."
    category: CustomizableDashboardCategory,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Find by dashboard slug."
    slug: String
  ): CustomizableDashboardConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Data transfer data point for a specific period. This is mocked data under a development feature flag."
  dataTransfer(
    "Retain egress data for one year. Data for the current month will increase dynamically as egress occurs."
    from: Date,
    "End date for the data."
    to: Date
  ): GroupDataTransfer
  "Number of dependency proxy blobs cached in the group."
  dependencyProxyBlobCount: Int!
  "Dependency Proxy blobs."
  dependencyProxyBlobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DependencyProxyBlobConnection
  "Number of dependency proxy images cached in the group."
  dependencyProxyImageCount: Int!
  "Prefix for pulling images when using the dependency proxy."
  dependencyProxyImagePrefix: String!
  "Dependency proxy TTL policy for the group."
  dependencyProxyImageTtlPolicy: DependencyProxyImageTtlGroupPolicy
  "Dependency Proxy manifests."
  dependencyProxyManifests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DependencyProxyManifestConnection
  "Dependency Proxy settings for the group."
  dependencyProxySetting: DependencyProxySetting
  "Total size of the dependency proxy cached images."
  dependencyProxyTotalSize: String!
  "Total size of the dependency proxy cached images in bytes, encoded as a string."
  dependencyProxyTotalSizeBytes: BigInt!
  "Total size of the dependency proxy cached images in bytes. Deprecated in 16.1: Use `dependencyProxyTotalSizeBytes`."
  dependencyProxyTotalSizeInBytes: Int! @deprecated(reason: "Use `dependencyProxyTotalSizeBytes`. Deprecated in 16.1.")
  "List of descendant groups of this group."
  descendantGroups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List of descendant groups of the parent group."
    includeParentDescendants: Boolean = true,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Limit result to groups owned by authenticated user."
    owned: Boolean,
    "Search query for group name or group full path."
    search: String
  ): GroupConnection
  "Count of direct descendant groups of this group."
  descendantGroupsCount: Int!
  "Description of the namespace."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Group's DORA metrics."
  dora: Dora
  "Group's DORA scores for all projects by DORA key metric for the last complete month."
  doraPerformanceScoreCounts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter DORA metric results by project attributes."
    projectFilters: DoraProjectFilterInput
  ): DoraPerformanceScoreCountConnection
  "Indicates if a group has email notifications disabled."
  emailsDisabled: Boolean
  "Indicates whether the group has limited users for a free plan."
  enforceFreeUserCap: Boolean
  "Environment scopes of the group."
  environmentScopes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Name of the environment scope."
    name: String,
    "Search query for environment scope name."
    search: String
  ): CiGroupEnvironmentScopeConnection
  "Find a single epic."
  epic(
    "Filter epics by author."
    authorUsername: String,
    "Filter epics by given confidentiality."
    confidential: Boolean,
    "Epics created after this date."
    createdAfter: Time,
    "Epics created before this date."
    createdBefore: Time,
    "IID of the epic, e.g., \"1\"."
    iid: ID,
    "Filter epics by IID for autocomplete."
    iidStartsWith: String,
    "List of IIDs of epics, e.g., `[1, 2]`."
    iids: [ID!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Include epics from ancestor groups."
    includeAncestorGroups: Boolean = false,
    "Include epics from descendant groups."
    includeDescendantGroups: Boolean = true,
    "Filter epics by labels."
    labelName: [String!],
    "Filter epics by milestone title, computed from epic's issues."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Negated epic arguments."
    not: NegatedEpicFilterInput,
    "Search query for title or description."
    search: String,
    "List epics by sort order."
    sort: EpicSort,
    "Filter epics by state."
    state: EpicState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Filter epics with a top-level hierarchy."
    topLevelHierarchyOnly: Boolean,
    "Epics updated after this date."
    updatedAfter: Time,
    "Epics updated before this date."
    updatedBefore: Time
  ): Epic
  "Find a single epic board."
  epicBoard(
    "Find an epic board by ID."
    id: BoardsEpicBoardID!
  ): EpicBoard
  "Find epic boards."
  epicBoards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EpicBoardConnection
  "Find epics."
  epics(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter epics by author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter epics by given confidentiality."
    confidential: Boolean,
    "Epics created after this date."
    createdAfter: Time,
    "Epics created before this date."
    createdBefore: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the epic, e.g., \"1\"."
    iid: ID,
    "Filter epics by IID for autocomplete."
    iidStartsWith: String,
    "List of IIDs of epics, e.g., `[1, 2]`."
    iids: [ID!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Include epics from ancestor groups."
    includeAncestorGroups: Boolean = false,
    "Include epics from descendant groups."
    includeDescendantGroups: Boolean = true,
    "Filter epics by labels."
    labelName: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter epics by milestone title, computed from epic's issues."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Negated epic arguments."
    not: NegatedEpicFilterInput,
    "Search query for title or description."
    search: String,
    "List epics by sort order."
    sort: EpicSort,
    "Filter epics by state."
    state: EpicState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Filter epics with a top-level hierarchy."
    topLevelHierarchyOnly: Boolean,
    "Epics updated after this date."
    updatedAfter: Time,
    "Epics updated before this date."
    updatedBefore: Time
  ): EpicConnection
  "Indicates if Epics are enabled for namespace"
  epicsEnabled: Boolean
  "External locations that receive audit events belonging to the group."
  externalAuditEventDestinations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ExternalAuditEventDestinationConnection
  "Flow metrics for value stream analytics. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  flowMetrics: GroupValueStreamAnalyticsFlowMetrics @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Full name of the namespace."
  fullName: String!
  "Full path of the namespace."
  fullPath: ID!
  "Preview Billable User Changes"
  gitlabSubscriptionsPreviewBillableUserChange(
    "Group ID to add."
    addGroupId: Int,
    "User emails to add."
    addUserEmails: [String!],
    "User IDs to add."
    addUserIds: [Int!],
    "Custom role assigned to the users."
    memberRoleId: Int,
    "Role of users being added to group."
    role: GitlabSubscriptionsUserRole!
  ): PreviewBillableUserChange
  "Google Cloud logging configurations that receive audit events belonging to the group."
  googleCloudLoggingConfigurations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GoogleCloudLoggingConfigurationTypeConnection
  "A membership of a user within this group."
  groupMembers(
    "Filter members by the given access levels."
    accessLevels: [AccessLevelEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter members by the given member relations."
    relations: [GroupMemberRelation!] = [DIRECT, INHERITED],
    "Search query."
    search: String,
    "sort query."
    sort: MemberSort
  ): GroupMemberConnection
  "Count of direct members of this group."
  groupMembersCount: Int!
  "ID of the namespace."
  id: ID!
  "Status of the temporary storage increase. Deprecated in 16.7: Feature removal, will be completely removed in 17.0."
  isTemporaryStorageIncreaseEnabled: Boolean @deprecated(reason: "Feature removal, will be completely removed in 17.0. Deprecated in 16.7.")
  "Issues for projects in this group."
  issues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of a user assigned to the issues. Wildcard values \"NONE\" and \"ANY\" are supported."
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Issues closed after this date."
    closedAfter: Time,
    "Issues closed before this date."
    closedBefore: Time,
    "Filter for confidential issues. If \"false\", excludes confidential issues. If \"true\", returns only confidential issues."
    confidential: Boolean,
    "Issues created after this date."
    createdAfter: Time,
    "Issues created before this date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "ID of an epic associated with the issues, \"none\" and \"any\" values are supported."
    epicId: String,
    "Filter by epic ID wildcard. Incompatible with epicId."
    epicWildcardId: EpicWildcardId,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Health status of the issue, \"none\" and \"any\" values are supported."
    healthStatusFilter: HealthStatusFilter,
    "IID of the issue. For example, \"1\"."
    iid: String,
    "List of IIDs of issues. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Return issues from archived projects"
    includeArchived: Boolean = false,
    "Whether to include subepics when filtering issues by epicId."
    includeSubepics: Boolean,
    "Include issues belonging to subgroups"
    includeSubgroups: Boolean = false,
    "Filter by a list of iteration cadence IDs."
    iterationCadenceId: [IterationsCadenceID!],
    "List of iteration Global IDs applied to the issue."
    iterationId: [ID],
    "Filter by iteration title."
    iterationTitle: String,
    "Filter by iteration ID wildcard."
    iterationWildcardId: IterationWildcardId,
    "Labels applied to this issue."
    labelName: [String],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Milestone applied to this issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Search query for title or description."
    search: String,
    "Sort issues by this criteria."
    sort: IssueSort = created_desc,
    "Current state of this issue."
    state: IssuableState,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after this date."
    updatedAfter: Time,
    "Issues updated before this date."
    updatedBefore: Time,
    "Weight applied to the issue, \"none\" and \"any\" values are supported."
    weight: String,
    "Filter by weight ID wildcard. Incompatible with weight."
    weightWildcardId: WeightWildcardId
  ): IssueConnection
  "Find iteration cadences."
  iterationCadences(
    "Whether the iteration cadence is active."
    active: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Whether the iteration cadence should automatically generate upcoming iterations."
    automatic: Boolean,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Duration in weeks of the iterations within this cadence."
    durationInWeeks: Int,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of the iteration cadence to look up."
    id: IterationsCadenceID,
    "Whether to include ancestor groups to search iterations cadences in."
    includeAncestorGroups: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Fuzzy search by title."
    title: String
  ): IterationCadenceConnection
  "Find iterations."
  iterations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of the Iteration to look up."
    id: ID,
    "Internal ID of the Iteration to look up."
    iid: ID,
    "Fields in which the fuzzy-search should be performed with the query given in the argument `search`. Defaults to `[title]`."
    in: [IterationSearchableField!],
    "Whether to include ancestor iterations. Defaults to true."
    includeAncestors: Boolean,
    "Whether to include descendant iterations."
    includeDescendants: Boolean,
    "Global iteration cadence IDs by which to look up the iterations."
    iterationCadenceIds: [IterationsCadenceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Query used for fuzzy-searching in the fields selected in the argument `in`. Returns all iterations if empty."
    search: String,
    "List iterations by sort order. If unspecified, an arbitrary order (subject to change) is used."
    sort: IterationSort,
    "Filter iterations by state."
    state: IterationState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe
  ): IterationConnection
  "Label available on this group."
  label(
    "Title of the label."
    title: String!
  ): Label
  "Labels available on this group."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Include labels from ancestor groups."
    includeAncestorGroups: Boolean = false,
    "Include labels from descendant groups."
    includeDescendantGroups: Boolean = false,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Include only group level labels."
    onlyGroupLabels: Boolean = false,
    "Search term to find labels with."
    searchTerm: String
  ): LabelConnection
  "Indicates if Large File Storage (LFS) is enabled for namespace."
  lfsEnabled: Boolean
  "Member roles available for the group. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  memberRoles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of the member role to look up."
    id: MemberRoleID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MemberRoleConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Indicates if a group is disabled from getting mentioned."
  mentionsDisabled: Boolean
  "Compliance violations reported on merge requests merged within the group."
  mergeRequestViolations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters applied when retrieving compliance violations."
    filters: ComplianceViolationInput = {},
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List compliance violations by sort order."
    sort: ComplianceViolationSort = SEVERITY_LEVEL_DESC
  ): ComplianceViolationConnection
  "Merge requests for projects in this group."
  mergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Return merge requests from archived projects"
    includeArchived: Boolean = false,
    "Include merge requests belonging to subgroups"
    includeSubgroups: Boolean = false,
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Milestones of the group."
  milestones(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Date the milestone contains."
    containingDate: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global milestone IDs, e.g., `\"gid://gitlab/Milestone/1\"`."
    ids: [ID!],
    "Include milestones from all parent groups."
    includeAncestors: Boolean,
    "Include milestones from all subgroups and subprojects."
    includeDescendants: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search string for the title."
    searchTitle: String,
    "Sort milestones by this criteria."
    sort: MilestoneSort = DUE_DATE_ASC,
    "Filter milestones by state."
    state: MilestoneStateEnum,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Title of the milestone."
    title: String
  ): MilestoneConnection
  "Name of the namespace."
  name: String!
  "Counts of organizations by status for the group."
  organizationStateCounts(
    "Search term to find organizations with."
    search: String,
    "State of the organizations to search for."
    state: CustomerRelationsOrganizationState
  ): OrganizationStateCounts
  "Find organizations of this group."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter organizations by IDs."
    ids: [CustomerRelationsOrganizationID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search term used to find organizations with."
    search: String,
    "Criteria to sort organizations by."
    sort: OrganizationSort = NAME_ASC,
    "State of the organization to search for."
    state: CustomerRelationsOrganizationState
  ): CustomerRelationsOrganizationConnection
  "Package settings for the namespace."
  packageSettings: PackageSettings
  "Packages of the group. This field can only be resolved for one group in any single request."
  packages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Include versionless packages."
    includeVersionless: Boolean = false,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search a package by name."
    packageName: String,
    "Filter a package by type."
    packageType: PackageTypeEnum,
    """

    Filter a package by version. If used in combination with `include_versionless`,
    then no versionless packages are returned.
    """
    packageVersion: String,
    "Sort packages by this criteria."
    sort: PackageGroupSort = CREATED_DESC,
    "Filter a package by status."
    status: PackageStatus
  ): PackageConnection
  "Parent group."
  parent: Group
  "Path of the namespace."
  path: String!
  "A pending membership of a user within this group. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  pendingMembers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PendingGroupMemberConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Compliance standards adherence for the projects in a group and its subgroups."
  projectComplianceStandardsAdherence(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters applied when retrieving compliance standards adherence."
    filters: ComplianceStandardsAdherenceInput = {},
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ComplianceStandardsAdherenceConnection
  "Permission level required to create projects in the group."
  projectCreationLevel: String
  "Projects within this namespace."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters applied when selecting a compliance framework."
    complianceFrameworkFilters: ComplianceFrameworkFilters,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only the projects which have code coverage."
    hasCodeCoverage: Boolean = false,
    "Returns only the projects which have vulnerabilities."
    hasVulnerabilities: Boolean = false,
    "Filter projects by IDs."
    ids: [ID!],
    "Include also subgroup projects."
    includeSubgroups: Boolean = false,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Include projects that are not aimed for deletion."
    notAimedForDeletion: Boolean = false,
    "Return only the projects related to the specified SBOM component."
    sbomComponentId: ID,
    "Search project with most similar names or paths."
    search: String,
    "Sort projects by this criteria."
    sort: NamespaceProjectSort,
    "Return only projects with issues enabled."
    withIssuesEnabled: Boolean,
    "Return only projects with merge requests enabled."
    withMergeRequestsEnabled: Boolean
  ): ProjectConnection!
  "Count of direct projects in this group."
  projectsCount: Int!
  "List of recently visited boards of the group. Maximum size is 4."
  recentIssueBoards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "Releases belonging to projects in the group."
  releases(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Sort group releases by given criteria."
    sort: GroupReleaseSort = RELEASED_AT_DESC
  ): ReleaseConnection
  "Number of projects in the root namespace where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement."
  repositorySizeExcessProjectCount: Int
  "Indicates if users can request access to namespace."
  requestAccessEnabled: Boolean
  "Indicates if all users in this group are required to set up two-factor authentication."
  requireTwoFactorAuthentication: Boolean
  "Aggregated storage statistics of the namespace. Only available for root namespaces."
  rootStorageStatistics: RootStorageStatistics
  "Find runners visible to the current user."
  runners(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter runners by creator ID."
    creatorId: UserID,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Control which runners to include in the results."
    membership: CiRunnerMembershipFilter = DESCENDANTS,
    "Filter runners by `paused` (true) or `active` (false) status."
    paused: Boolean,
    "Filter by full token or partial text in description field."
    search: String,
    "Sort order of results."
    sort: CiRunnerSort,
    "Filter runners by status."
    status: CiRunnerStatus,
    "Filter by tags associated with the runner (comma-separated or array)."
    tagList: [String!],
    "Filter runners by type."
    type: CiRunnerType,
    "Filter by upgrade status."
    upgradeStatus: CiRunnerUpgradeStatus
  ): CiRunnerConnection
  "Scan Execution Policies of the namespace."
  scanExecutionPolicies(
    "Filters policies by the action scan type. Only these scan types are supported: `dast`, `secret_detection`, `cluster_image_scanning`, `container_scanning`, `sast`, `sast_iac`, `dependency_scanning`."
    actionScanTypes: [SecurityReportTypeEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter policies by the given policy relationship."
    relationship: SecurityPolicyRelationType = DIRECT
  ): ScanExecutionPolicyConnection
  "Scan Result Policies of the project"
  scanResultPolicies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter policies by the given policy relationship."
    relationship: SecurityPolicyRelationType = DIRECT
  ): ScanResultPolicyConnection
  "Indicates if sharing a project with another group within this group is prevented."
  shareWithGroupLock: Boolean
  "Shared runners availability for the namespace and its descendants."
  sharedRunnersSetting: SharedRunnersSetting
  "Group statistics."
  stats: GroupStats
  "The storage limit (in bytes) included with the root namespace plan. This limit only applies to namespaces under namespace limit enforcement."
  storageSizeLimit: Float
  "Permission level required to create subgroups within the group."
  subgroupCreationLevel: String
  "Date until the temporary storage increase is active. Deprecated in 16.7: Feature removal, will be completely removed in 17.0."
  temporaryStorageIncreaseEndsOn: Time @deprecated(reason: "Feature removal, will be completely removed in 17.0. Deprecated in 16.7.")
  "Timelog categories for the namespace. Introduced in 15.3: This feature is an Experiment. It can be changed or removed at any time."
  timelogCategories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimeTrackingTimelogCategoryConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.")
  "Time logged on issues and merge requests in the group and its subgroups."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection!
  "Total repository size of all projects in the root namespace in bytes."
  totalRepositorySize: Float
  "Total excess repository size of all projects in the root namespace in bytes. This only applies to namespaces under Project limit enforcement."
  totalRepositorySizeExcess: Float
  "Time before two-factor authentication is enforced."
  twoFactorGracePeriod: Int
  "Permissions for the current user on the resource"
  userPermissions: GroupPermissions!
  "Aggregated usage counts within the group Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  valueStreamDashboardUsageOverview(
    "Type of counts to retrieve."
    identifier: ValueStreamDashboardMetric!,
    "Counts recorded during this time frame, usually from beginning of the month until the end of the month (the system runs monthly aggregations)."
    timeframe: Timeframe!
  ): ValueStreamDashboardCount @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Value streams available to the group."
  valueStreams(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ValueStreamConnection
  "Visibility of the namespace."
  visibility: String
  "Vulnerabilities reported on the projects in the group and its subgroups."
  vulnerabilities(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter vulnerabilities by `cluster_agent_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterAgentId: [ClustersAgentID!],
    "Filter vulnerabilities by `cluster_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterId: [ClustersClusterID!],
    "Filter by dismissal reason. Only dismissed Vulnerabilities will be included with the filter."
    dismissalReason: [VulnerabilityDismissalReason!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only the vulnerabilities which have linked issues."
    hasIssues: Boolean,
    "Returns only the vulnerabilities which have linked merge requests."
    hasMergeRequest: Boolean,
    "Returns only the vulnerabilities which have remediations."
    hasRemediations: Boolean,
    "Returns only the vulnerabilities which have been resolved on default branch."
    hasResolution: Boolean,
    "Filter vulnerabilities by location image. When this filter is present, the response only matches entries for a `reportType` that includes `container_scanning`, `cluster_image_scanning`."
    image: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter vulnerabilities by OWASP Top 10 category."
    owaspTopTen: [VulnerabilityOwaspTop10!],
    "Filter vulnerabilities by project."
    projectId: [ID!],
    "Filter vulnerabilities by report type."
    reportType: [VulnerabilityReportType!],
    "Filter vulnerabilities by VulnerabilityScanner.externalId."
    scanner: [String!],
    "Filter vulnerabilities by scanner ID."
    scannerId: [VulnerabilitiesScannerID!],
    "Filter vulnerabilities by severity."
    severity: [VulnerabilitySeverity!],
    "List vulnerabilities by sort order."
    sort: VulnerabilitySort = severity_desc,
    "Filter vulnerabilities by state."
    state: [VulnerabilityState!]
  ): VulnerabilityConnection
  "The historical number of vulnerabilities per day for the projects in the group and its subgroups."
  vulnerabilitiesCountByDay(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Last day for which to fetch vulnerability history."
    endDate: ISO8601Date!,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "First day for which to fetch vulnerability history."
    startDate: ISO8601Date!
  ): VulnerabilitiesCountByDayConnection
  "Represents vulnerable project counts for each grade."
  vulnerabilityGrades(
    "Include grades belonging to subgroups."
    includeSubgroups: Boolean = false,
    "Filter the response by given letter grade."
    letterGrade: VulnerabilityGrade
  ): [VulnerableProjectsByGrade!]
  "Vulnerability scanners reported on the project vulnerabilities of the group and its subgroups."
  vulnerabilityScanners(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityScannerConnection
  "Counts for each vulnerability severity in the group and its subgroups."
  vulnerabilitySeveritiesCount(
    "Filter vulnerabilities by `cluster_agent_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterAgentId: [ClustersAgentID!],
    "Filter by dismissal reason."
    dismissalReason: [VulnerabilityDismissalReason!],
    "Filter vulnerabilities that do or do not have issues."
    hasIssues: Boolean,
    "Filter vulnerabilities that do or do not have a merge request."
    hasMergeRequest: Boolean,
    "Filter vulnerabilities that do or do not have remediations."
    hasRemediations: Boolean,
    "Filter vulnerabilities that do or do not have a resolution."
    hasResolution: Boolean,
    "Filter vulnerabilities by location image. When this filter is present, the response only matches entries for a `reportType` that includes `container_scanning`, `cluster_image_scanning`."
    image: [String!],
    "Filter vulnerabilities by OWASP Top 10 category."
    owaspTopTen: [VulnerabilityOwaspTop10!],
    "Filter vulnerabilities by project."
    projectId: [ID!],
    "Filter vulnerabilities by report type."
    reportType: [VulnerabilityReportType!],
    "Filter vulnerabilities by scanner."
    scanner: [String!],
    "Filter vulnerabilities by scanner ID."
    scannerId: [VulnerabilitiesScannerID!],
    "Filter vulnerabilities by severity."
    severity: [VulnerabilitySeverity!],
    "Filter vulnerabilities by state."
    state: [VulnerabilityState!]
  ): VulnerabilitySeveritiesCount
  "Web URL of the group."
  webUrl: String!
  "Find a work item by IID directly associated with the group. Returns `null` if the `namespace_level_work_items` feature flag is disabled. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  workItem(
    "IID of the work item."
    iid: String!
  ): WorkItem @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Counts of work items by state for the namespace. Returns `null` if the `namespace_level_work_items` feature flag is disabled. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  workItemStateCounts(
    "IID of the work item. For example, \"1\"."
    iid: String,
    "List of IIDs of work items. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Search query for title or description."
    search: String,
    "Sort work items by criteria."
    sort: WorkItemSort = created_desc,
    "Current state of the work item."
    state: IssuableState,
    "Input for status widget filter. Ignored if `work_items_mvc_2` is disabled."
    statusWidget: StatusFilterInput,
    "Filter work items by the given work item types."
    types: [IssueType!]
  ): WorkItemStateCountsType @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Work item types available to the group."
  workItemTypes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "If `true`, only taskable work item types will be returned. Argument is experimental and can be removed in the future without notice."
    taskable: Boolean
  ): WorkItemTypeConnection
  "Work items that belong to the namespace. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  workItems(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the work item. For example, \"1\"."
    iid: String,
    "List of IIDs of work items. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for title or description."
    search: String,
    "Sort work items by criteria."
    sort: WorkItemSort = created_desc,
    "Current state of the work item."
    state: IssuableState,
    "Input for status widget filter. Ignored if `work_items_mvc_2` is disabled."
    statusWidget: StatusFilterInput,
    "Filter work items by the given work item types."
    types: [IssueType!]
  ): WorkItemConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
}

"The connection type for Group."
type GroupConnection {
  "A list of edges."
  edges: [GroupEdge]
  "A list of nodes."
  nodes: [Group]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

type GroupDataTransfer {
  "Data nodes."
  egressNodes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EgressNodeConnection
}

"An edge in a connection."
type GroupEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Group
}

"Represents a Group Membership"
type GroupMember implements MemberInterface {
  "GitLab::Access level."
  accessLevel: AccessLevel
  "Date and time the membership was created."
  createdAt: Time
  "User that authorized membership."
  createdBy: UserCore
  "Date and time the membership expires."
  expiresAt: Time
  "Group that a user is a member of."
  group: Group
  "ID of the member."
  id: ID!
  "Find a merge request."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Group notification email for user. Only available for admins."
  notificationEmail: String
  "Date and time the membership was last updated."
  updatedAt: Time
  "User that is associated with the member object."
  user: UserCore
  "Permissions for the current user on the resource"
  userPermissions: GroupPermissions!
}

"Autogenerated return type of GroupMemberBulkUpdate."
type GroupMemberBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Group members after mutation."
  groupMembers: [GroupMember!]
}

"The connection type for GroupMember."
type GroupMemberConnection {
  "A list of edges."
  edges: [GroupMemberEdge]
  "A list of nodes."
  nodes: [GroupMember]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type GroupMemberEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GroupMember
}

type GroupPermissions {
  "If `true`, the user can perform `create_custom_emoji` on this resource"
  createCustomEmoji: Boolean!
  "If `true`, the user can perform `create_projects` on this resource"
  createProjects: Boolean!
  "If `true`, the user can perform `read_group` on this resource"
  readGroup: Boolean!
}

"Contains release-related statistics about a group"
type GroupReleaseStats {
  "Total number of releases in all descendant projects of the group."
  releasesCount: Int
  "Percentage of the group's descendant projects that have at least one release."
  releasesPercentage: Int
}

"Represents the source of a security policy belonging to a group"
type GroupSecurityPolicySource {
  "Indicates whether this policy is inherited from parent group."
  inherited: Boolean!
  "Project the policy is associated with."
  namespace: Namespace
}

"Contains statistics about a group"
type GroupStats {
  "Statistics related to releases within the group."
  releaseStats: GroupReleaseStats
}

"Autogenerated return type of GroupUpdate."
type GroupUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Group after update."
  group: Group
}

"Exposes aggregated value stream flow metrics"
type GroupValueStreamAnalyticsFlowMetrics {
  "Median time from first commit to issue closed"
  cycleTime(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Project IDs within the group hierarchy."
    projectIds: [ID!],
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Number of production deployments in the given period."
  deploymentCount(
    "Timestamp marking the start date and time."
    from: Time!,
    "Project IDs within the group hierarchy."
    projectIds: [ID!],
    "Timestamp marking the end date and time."
    to: Time!
  ): ValueStreamAnalyticsMetric
  "Number of issues opened in the given period."
  issueCount(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Project IDs within the group hierarchy."
    projectIds: [ID!],
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Number of open issues closed (completed) in the given period. Maximum value is 10,001."
  issuesCompletedCount(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Project IDs within the group hierarchy."
    projectIds: [ID!],
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Median time from when the issue was created to when it was closed."
  leadTime(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Project IDs within the group hierarchy."
    projectIds: [ID!],
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Median time from merge request creation to merge request merged."
  timeToMerge(
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Username of the author of the merge request."
    authorUsername: String,
    "Timestamp marking the start date and time."
    from: Time!,
    "Labels applied to the merge request."
    labelNames: [String!],
    "Milestone applied to the merge request."
    milestoneTitle: String,
    "Project IDs within the group hierarchy."
    projectIds: [ID!],
    "Timestamp marking the end date and time."
    to: Time!
  ): ValueStreamAnalyticsMetric
}

"Represents the Geo sync and verification state of a group wiki repository"
type GroupWikiRepositoryRegistry {
  "Timestamp when the GroupWikiRepositoryRegistry was created"
  createdAt: Time
  "ID of the Group Wiki Repository."
  groupWikiRepositoryId: ID!
  "ID of the GroupWikiRepositoryRegistry"
  id: ID!
  "Error message during sync of the GroupWikiRepositoryRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the GroupWikiRepositoryRegistry"
  lastSyncedAt: Time
  "Timestamp after which the GroupWikiRepositoryRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the GroupWikiRepositoryRegistry"
  retryCount: Int
  "Sync state of the GroupWikiRepositoryRegistry"
  state: RegistryState
  "The local checksum of the GroupWikiRepositoryRegistry"
  verificationChecksum: String
  "Error message during verification of the GroupWikiRepositoryRegistry"
  verificationFailure: String
  "Timestamp after which the GroupWikiRepositoryRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the GroupWikiRepositoryRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of GroupWikiRepositoryRegistry"
  verificationStartedAt: Time
  "Verification state of the GroupWikiRepositoryRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the GroupWikiRepositoryRegistry"
  verifiedAt: Time
}

"The connection type for GroupWikiRepositoryRegistry."
type GroupWikiRepositoryRegistryConnection {
  "A list of edges."
  edges: [GroupWikiRepositoryRegistryEdge]
  "A list of nodes."
  nodes: [GroupWikiRepositoryRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type GroupWikiRepositoryRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GroupWikiRepositoryRegistry
}

type Groups {
  "Commit responsible for specified group."
  commit: Commit!
  "HTML data derived from commit needed to present blame."
  commitData: CommitData
  "Starting line number for the commit group."
  lineno: Int!
  "Array of lines added for the commit group."
  lines: [String!]!
  "Number of contiguous lines which the blame spans for the commit group."
  span: Int!
}

"Helm file metadata"
type HelmFileMetadata implements PackageFileMetadata {
  "Channel of the Helm chart."
  channel: String!
  "Date of creation."
  createdAt: Time!
  "Metadata of the Helm chart."
  metadata: PackageHelmMetadataType!
  "Date of most recent update."
  updatedAt: Time!
}

"Autogenerated return type of HttpIntegrationCreate."
type HttpIntegrationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}

"Autogenerated return type of HttpIntegrationDestroy."
type HttpIntegrationDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}

"Autogenerated return type of HttpIntegrationResetToken."
type HttpIntegrationResetTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}

"Autogenerated return type of HttpIntegrationUpdate."
type HttpIntegrationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "HTTP integration."
  integration: AlertManagementHttpIntegration
}

"IDE settings and feature flags."
type Ide {
  "Indicates whether AI assisted code suggestions are enabled."
  codeSuggestionsEnabled: Boolean!
}

"Describes an incident management on-call rotation"
type IncidentManagementOncallRotation {
  "Active period for the on-call rotation."
  activePeriod: OncallRotationActivePeriodType
  "End date and time of the on-call rotation."
  endsAt: Time
  "ID of the on-call rotation."
  id: IncidentManagementOncallRotationID!
  "Length of the on-call schedule, in the units specified by lengthUnit."
  length: Int
  "Unit of the on-call rotation length."
  lengthUnit: OncallRotationUnitEnum
  "Name of the on-call rotation."
  name: String!
  "Participants of the on-call rotation."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OncallParticipantTypeConnection
  "Blocks of time for which a participant is on-call within a given time frame. Time frame cannot exceed one month."
  shifts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "End of timeframe to include shifts for. Cannot exceed one month after start."
    endTime: Time!,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Start of timeframe to include shifts for."
    startTime: Time!
  ): IncidentManagementOncallShiftConnection
  "Start date of the on-call rotation."
  startsAt: Time
}

"The connection type for IncidentManagementOncallRotation."
type IncidentManagementOncallRotationConnection {
  "A list of edges."
  edges: [IncidentManagementOncallRotationEdge]
  "A list of nodes."
  nodes: [IncidentManagementOncallRotation]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type IncidentManagementOncallRotationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: IncidentManagementOncallRotation
}

"Describes an incident management on-call schedule"
type IncidentManagementOncallSchedule {
  "Description of the on-call schedule."
  description: String
  "Internal ID of the on-call schedule."
  iid: ID!
  "Name of the on-call schedule."
  name: String!
  oncallUsers: [UserCore!]
  "On-call rotation for the on-call schedule."
  rotation(
    "ID of the on-call rotation."
    id: IncidentManagementOncallRotationID!
  ): IncidentManagementOncallRotation
  "On-call rotations for the on-call schedule."
  rotations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IncidentManagementOncallRotationConnection!
  "Time zone of the on-call schedule."
  timezone: String!
}

"The connection type for IncidentManagementOncallSchedule."
type IncidentManagementOncallScheduleConnection {
  "A list of edges."
  edges: [IncidentManagementOncallScheduleEdge]
  "A list of nodes."
  nodes: [IncidentManagementOncallSchedule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type IncidentManagementOncallScheduleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: IncidentManagementOncallSchedule
}

"A block of time for which a participant is on-call."
type IncidentManagementOncallShift {
  "End time of the on-call shift."
  endsAt: Time
  "Participant assigned to the on-call shift."
  participant: OncallParticipantType
  "Start time of the on-call shift."
  startsAt: Time
}

"The connection type for IncidentManagementOncallShift."
type IncidentManagementOncallShiftConnection {
  "A list of edges."
  edges: [IncidentManagementOncallShiftEdge]
  "A list of nodes."
  nodes: [IncidentManagementOncallShift]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type IncidentManagementOncallShiftEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: IncidentManagementOncallShift
}

"CI/CD variables a project inherites from its parent group and ancestors."
type InheritedCiVariable {
  "Description of the variable."
  description: String
  "Scope defining the environments that can use the variable."
  environmentScope: String
  "Indicates the path to the CI/CD settings of the group the variable belongs to."
  groupCiCdSettingsPath: String
  "Indicates group the variable belongs to."
  groupName: String
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is masked."
  masked: Boolean
  "Indicates whether the variable is protected."
  protected: Boolean
  "Indicates whether the variable is raw."
  raw: Boolean
  "Type of the variable."
  variableType: CiVariableType
}

"The connection type for InheritedCiVariable."
type InheritedCiVariableConnection {
  "A list of edges."
  edges: [InheritedCiVariableEdge]
  "A list of nodes."
  nodes: [InheritedCiVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type InheritedCiVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: InheritedCiVariable
}

"Stores instance level Amazon S3 configurations for audit event streaming."
type InstanceAmazonS3ConfigurationType implements AmazonS3ConfigurationInterface {
  "Access key ID of the Amazon S3 account."
  accessKeyXid: String!
  "AWS region where the bucket is created."
  awsRegion: String!
  "Name of the bucket where the audit events would be logged."
  bucketName: String!
  "ID of the configuration."
  id: ID!
  "Name of the external destination to send audit events to."
  name: String!
}

"The connection type for InstanceAmazonS3ConfigurationType."
type InstanceAmazonS3ConfigurationTypeConnection {
  "A list of edges."
  edges: [InstanceAmazonS3ConfigurationTypeEdge]
  "A list of nodes."
  nodes: [InstanceAmazonS3ConfigurationType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type InstanceAmazonS3ConfigurationTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: InstanceAmazonS3ConfigurationType
}

"Represents an external resource to send instance audit events to"
type InstanceExternalAuditEventDestination implements ExternalAuditEventDestinationInterface {
  "External destination to send audit events to."
  destinationUrl: String!
  "List of event type filters added for streaming."
  eventTypeFilters: [String!]!
  "List of additional HTTP headers sent with each event."
  headers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AuditEventsStreamingInstanceHeaderConnection!
  "ID of the destination."
  id: ID!
  "Name of the external destination to send audit events to."
  name: String!
  "Verification token to validate source of event."
  verificationToken: String!
}

"The connection type for InstanceExternalAuditEventDestination."
type InstanceExternalAuditEventDestinationConnection {
  "A list of edges."
  edges: [InstanceExternalAuditEventDestinationEdge]
  "A list of nodes."
  nodes: [InstanceExternalAuditEventDestination]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of InstanceExternalAuditEventDestinationCreate."
type InstanceExternalAuditEventDestinationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Destination created."
  instanceExternalAuditEventDestination: InstanceExternalAuditEventDestination
}

"Autogenerated return type of InstanceExternalAuditEventDestinationDestroy."
type InstanceExternalAuditEventDestinationDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type InstanceExternalAuditEventDestinationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: InstanceExternalAuditEventDestination
}

"Autogenerated return type of InstanceExternalAuditEventDestinationUpdate."
type InstanceExternalAuditEventDestinationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated destination."
  instanceExternalAuditEventDestination: InstanceExternalAuditEventDestination
}

"Autogenerated return type of InstanceGoogleCloudLoggingConfigurationCreate."
type InstanceGoogleCloudLoggingConfigurationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "configuration created."
  instanceGoogleCloudLoggingConfiguration: InstanceGoogleCloudLoggingConfigurationType
}

"Autogenerated return type of InstanceGoogleCloudLoggingConfigurationDestroy."
type InstanceGoogleCloudLoggingConfigurationDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Stores instance level Google Cloud Logging configurations associated with IAM service accounts,used for generating access tokens."
type InstanceGoogleCloudLoggingConfigurationType implements GoogleCloudLoggingConfigurationInterface {
  "Client email."
  clientEmail: String!
  "Google project ID."
  googleProjectIdName: String!
  "ID of the configuration."
  id: ID!
  "Log ID."
  logIdName: String!
  "Name of the external destination to send audit events to."
  name: String!
}

"The connection type for InstanceGoogleCloudLoggingConfigurationType."
type InstanceGoogleCloudLoggingConfigurationTypeConnection {
  "A list of edges."
  edges: [InstanceGoogleCloudLoggingConfigurationTypeEdge]
  "A list of nodes."
  nodes: [InstanceGoogleCloudLoggingConfigurationType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type InstanceGoogleCloudLoggingConfigurationTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: InstanceGoogleCloudLoggingConfigurationType
}

"Autogenerated return type of InstanceGoogleCloudLoggingConfigurationUpdate."
type InstanceGoogleCloudLoggingConfigurationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "configuration updated."
  instanceGoogleCloudLoggingConfiguration: InstanceGoogleCloudLoggingConfigurationType
}

type InstanceSecurityDashboard {
  "Cluster agents associated with projects selected in the Instance Security Dashboard."
  clusterAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only cluster agents which have an associated remote development agent config."
    hasRemoteDevelopmentAgentConfig: Boolean,
    "Returns only cluster agents which have been enabled with the remote development feature."
    hasRemoteDevelopmentEnabled: Boolean,
    "Returns only cluster agents which have vulnerabilities."
    hasVulnerabilities: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentConnection
  "Projects selected in Instance Security Dashboard."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query, which can be for the project name, a path, or a description."
    search: String
  ): ProjectConnection!
  "Represents vulnerable project counts for each grade."
  vulnerabilityGrades(
    "Filter the response by given letter grade."
    letterGrade: VulnerabilityGrade
  ): [VulnerableProjectsByGrade!]!
  "Vulnerability scanners reported on the vulnerabilities from projects selected in Instance Security Dashboard."
  vulnerabilityScanners(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityScannerConnection
  "Counts for each vulnerability severity from projects selected in Instance Security Dashboard."
  vulnerabilitySeveritiesCount(
    "Filter vulnerabilities by `cluster_agent_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterAgentId: [ClustersAgentID!],
    "Filter by dismissal reason."
    dismissalReason: [VulnerabilityDismissalReason!],
    "Filter vulnerabilities that do or do not have issues."
    hasIssues: Boolean,
    "Filter vulnerabilities that do or do not have a merge request."
    hasMergeRequest: Boolean,
    "Filter vulnerabilities that do or do not have remediations."
    hasRemediations: Boolean,
    "Filter vulnerabilities that do or do not have a resolution."
    hasResolution: Boolean,
    "Filter vulnerabilities by location image. When this filter is present, the response only matches entries for a `reportType` that includes `container_scanning`, `cluster_image_scanning`."
    image: [String!],
    "Filter vulnerabilities by OWASP Top 10 category."
    owaspTopTen: [VulnerabilityOwaspTop10!],
    "Filter vulnerabilities by project."
    projectId: [ID!],
    "Filter vulnerabilities by report type."
    reportType: [VulnerabilityReportType!],
    "Filter vulnerabilities by scanner."
    scanner: [String!],
    "Filter vulnerabilities by scanner ID."
    scannerId: [VulnerabilitiesScannerID!],
    "Filter vulnerabilities by severity."
    severity: [VulnerabilitySeverity!],
    "Filter vulnerabilities by state."
    state: [VulnerabilityState!]
  ): VulnerabilitySeveritiesCount
}

"Describes an issuable resource link for incident issues"
type IssuableResourceLink {
  "ID of the Issuable resource link."
  id: IncidentManagementIssuableResourceLinkID!
  "Incident of the resource link."
  issue: Issue!
  "Web Link to the resource."
  link: String!
  "Optional text for the link."
  linkText: String
  "Type of the resource link."
  linkType: IssuableResourceLinkType!
}

"The connection type for IssuableResourceLink."
type IssuableResourceLinkConnection {
  "A list of edges."
  edges: [IssuableResourceLinkEdge]
  "A list of nodes."
  nodes: [IssuableResourceLink]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of IssuableResourceLinkCreate."
type IssuableResourceLinkCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issuable resource link."
  issuableResourceLink: IssuableResourceLink
}

"Autogenerated return type of IssuableResourceLinkDestroy."
type IssuableResourceLinkDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issuable resource link."
  issuableResourceLink: IssuableResourceLink
}

"An edge in a connection."
type IssuableResourceLinkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: IssuableResourceLink
}

type Issue implements CurrentUserTodos & NoteableInterface & Todoable {
  "Alert associated to this issue. Deprecated in 15.6: Use `alert_management_alerts`."
  alertManagementAlert: AlertManagementAlert @deprecated(reason: "Use `alert_management_alerts`. Deprecated in 15.6.")
  "Alert Management alerts associated to this issue."
  alertManagementAlerts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Username of a user assigned to the issue."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter query for given domain."
    domain: AlertManagementDomainFilter! = operations,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the alert. For example, \"1\"."
    iid: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Sort alerts by this criteria."
    sort: AlertManagementAlertSort,
    "Alerts with the specified statues. For example, `[TRIGGERED]`."
    statuses: [AlertManagementStatus!]
  ): AlertManagementAlertConnection
  "Assignees of the issue."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "User that created the issue."
  author: UserCore!
  "Indicates the issue is blocked."
  blocked: Boolean!
  "Count of issues blocking this issue."
  blockedByCount: Int
  "Issues blocking this issue."
  blockedByIssues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssueConnection
  "Count of issues this issue is blocking."
  blockingCount: Int!
  "Issue this issue was closed as a duplicate of."
  closedAsDuplicateOf: Issue
  "Timestamp of when the issue was closed."
  closedAt: Time
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Indicates the issue is confidential."
  confidential: Boolean!
  "User specific email address for the issue."
  createNoteEmail: String
  "Timestamp of when the issue was created."
  createdAt: Time!
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Customer relations contacts of the issue."
  customerRelationsContacts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomerRelationsContactConnection
  "Description of the issue."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Collection of design images associated with this issue."
  designCollection: DesignCollection
  "Indicates discussion is locked on the issue."
  discussionLocked: Boolean!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Number of downvotes the issue has received."
  downvotes: Int!
  "Due date of the issue."
  dueDate: Time
  "Indicates if the parent project or group has email notifications disabled: `true` if email notifications are disabled. Deprecated in 16.3: Use `emails_enabled`."
  emailsDisabled: Boolean! @deprecated(reason: "Use `emails_enabled`. Deprecated in 16.3.")
  "Indicates if the parent project or group has email notifications disabled: `false` if email notifications are disabled."
  emailsEnabled: Boolean!
  "Epic to which this issue belongs."
  epic: Epic
  "Escalation policy associated with the issue. Available for issues which support escalation."
  escalationPolicy: EscalationPolicyType
  "Escalation status of the issue."
  escalationStatus: IssueEscalationStatus
  "Email address of non-GitLab user reporting the issue. For guests, the email address is obfuscated."
  externalAuthor: String
  """

  Indicates if the issue belongs to an epic.
  Can return true and not show an associated epic when the user has no access to the epic.
  """
  hasEpic: Boolean!
  "Indicates if the issue has a parent work item. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  hasParent: Boolean! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Current health status."
  healthStatus: HealthStatus
  "Indicates the issue is hidden because the author has been banned."
  hidden: Boolean
  "Human-readable time estimate of the issue."
  humanTimeEstimate: String
  "Human-readable total time reported as spent on the issue."
  humanTotalTimeSpent: String
  "ID of the issue."
  id: ID!
  "Internal ID of the issue."
  iid: ID!
  "Issuable resource links of the incident issue."
  issuableResourceLinks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of the incident."
    incidentId: IssueID!,
    "Returns the last _n_ elements from the list."
    last: Int
  ): IssuableResourceLinkConnection
  "Iteration of the issue."
  iteration: Iteration
  "Labels of the issue."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Number of merge requests that close the issue on merge."
  mergeRequestsCount: Int!
  "Metric images associated to the issue."
  metricImages: [MetricImage!]
  "Milestone of the issue."
  milestone: Milestone
  "Indicates if issue got moved from other project."
  moved: Boolean
  "Updated Issue after it got moved to another project."
  movedTo: Issue
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "List of participants in the issue."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "ID of the issue project."
  projectId: Int
  "Internal reference of the issue. Returned in shortened format by default."
  reference(
    "Boolean option specifying whether the reference should be returned in full."
    full: Boolean = false
  ): String!
  "Merge requests related to the issue. This field can only be resolved for one issue in any single request."
  relatedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestConnection
  "Related vulnerabilities of the issue."
  relatedVulnerabilities(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityConnection
  "Relative position of the issue (used for positioning in epic tree and issue boards)."
  relativePosition: Int
  "Severity level of the incident."
  severity: IssuableSeverity
  "Timestamp of when the issue SLA expires."
  slaDueAt: Time
  "State of the issue."
  state: IssueState!
  "Indicates whether an issue is published to the status page."
  statusPagePublishedIncident: Boolean
  "Indicates the currently logged in user is subscribed to the issue."
  subscribed: Boolean!
  "Task completion status of the issue."
  taskCompletionStatus: TaskCompletionStatus!
  "Time estimate of the issue."
  timeEstimate: Int!
  "Timelogs on the issue."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection!
  "Title of the issue."
  title: String!
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Total time (in seconds) reported as spent on the issue."
  totalTimeSpent: Int!
  "Type of the issue."
  type: IssueType
  "Timestamp of when the issue was last updated."
  updatedAt: Time!
  "User that last updated the issue."
  updatedBy: UserCore
  "Number of upvotes the issue has received."
  upvotes: Int!
  "Number of user discussions in the issue."
  userDiscussionsCount: Int!
  "Number of user notes of the issue."
  userNotesCount: Int!
  "Permissions for the current user on the resource"
  userPermissions: IssuePermissions!
  "Web path of the issue."
  webPath: String!
  "Web URL of the issue."
  webUrl: String!
  "Weight of the issue."
  weight: Int
}

"The connection type for Issue."
type IssueConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [IssueEdge]
  "A list of nodes."
  nodes: [Issue]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total weight of issues collection."
  weight: Int!
}

"An edge in a connection."
type IssueEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Issue
}

"Autogenerated return type of IssueLinkAlerts."
type IssueLinkAlertsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueMoveList."
type IssueMoveListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueMove."
type IssueMovePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Check permissions for the current user on a issue"
type IssuePermissions {
  "If `true`, the user can perform `admin_issue` on this resource"
  adminIssue: Boolean!
  "If `true`, the user can perform `admin_issue_relation` on this resource"
  adminIssueRelation: Boolean!
  "If `true`, the user can perform `create_design` on this resource"
  createDesign: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `destroy_design` on this resource"
  destroyDesign: Boolean!
  "If `true`, the user can perform `read_design` on this resource"
  readDesign: Boolean!
  "If `true`, the user can perform `read_issue` on this resource"
  readIssue: Boolean!
  "If `true`, the user can perform `reopen_issue` on this resource"
  reopenIssue: Boolean!
  "If `true`, the user can perform `update_design` on this resource"
  updateDesign: Boolean!
  "If `true`, the user can perform `update_issue` on this resource"
  updateIssue: Boolean!
}

"Autogenerated return type of IssueSetAssignees."
type IssueSetAssigneesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetConfidential."
type IssueSetConfidentialPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetCrmContacts."
type IssueSetCrmContactsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetDueDate."
type IssueSetDueDatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetEpic."
type IssueSetEpicPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetEscalationPolicy."
type IssueSetEscalationPolicyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetEscalationStatus."
type IssueSetEscalationStatusPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetIteration."
type IssueSetIterationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetLocked."
type IssueSetLockedPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetSeverity."
type IssueSetSeverityPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetSubscription."
type IssueSetSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssueSetWeight."
type IssueSetWeightPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Represents total number of issues for the represented statuses"
type IssueStatusCountsType {
  "Number of issues with status ALL for the project"
  all: Int
  "Number of issues with status CLOSED for the project"
  closed: Int
  "Number of issues with status OPENED for the project"
  opened: Int
}

"Autogenerated return type of IssueUnlinkAlert."
type IssueUnlinkAlertPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of IssuesBulkUpdate."
type IssuesBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Number of issues that were successfully updated."
  updatedIssueCount: Int
}

"Represents an iteration object"
type Iteration implements TimeboxReportInterface {
  "Timestamp of iteration creation."
  createdAt: Time!
  "Description of the iteration."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Timestamp of the iteration due date."
  dueDate: Time
  "ID of the iteration."
  id: ID!
  "Internal ID of the iteration."
  iid: ID!
  "Cadence of the iteration."
  iterationCadence: IterationCadence!
  "Historically accurate report about the timebox."
  report(
    "Full path of the project or group used as a scope for report. For example, `gitlab-org` or `gitlab-org/gitlab`."
    fullPath: String
  ): TimeboxReport
  "Web path of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts."
  scopedPath: String
  "Web URL of the iteration, scoped to the query parent. Only valid for Project parents. Returns null in other contexts."
  scopedUrl: String
  "Sequence number for the iteration when you sort the containing cadence's iterations by the start and end date. The earliest starting and ending iteration is assigned 1."
  sequence: Int!
  "Timestamp of the iteration start date."
  startDate: Time
  "State of the iteration."
  state: IterationState!
  "Title of the iteration."
  title: String
  "Timestamp of last iteration update."
  updatedAt: Time!
  "Web path of the iteration."
  webPath: String!
  "Web URL of the iteration."
  webUrl: String!
}

"Represents an iteration cadence"
type IterationCadence {
  "Whether the iteration cadence is active."
  active: Boolean
  "Whether the iteration cadence should automatically generate upcoming iterations."
  automatic: Boolean
  "Description of the iteration cadence. Maximum length is 5000 characters."
  description: String
  "Duration in weeks of the iterations within this cadence."
  durationInWeeks: Int
  "Global ID of the iteration cadence."
  id: IterationsCadenceID!
  "Upcoming iterations to be created when iteration cadence is set to automatic."
  iterationsInAdvance: Int
  "Whether the iteration cadence should roll over issues to the next iteration or not."
  rollOver: Boolean!
  "Timestamp of the automation start date."
  startDate: Time
  "Title of the iteration cadence."
  title: String!
}

"The connection type for IterationCadence."
type IterationCadenceConnection {
  "A list of edges."
  edges: [IterationCadenceEdge]
  "A list of nodes."
  nodes: [IterationCadence]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of IterationCadenceCreate."
type IterationCadenceCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created iteration cadence."
  iterationCadence: IterationCadence
}

"Autogenerated return type of IterationCadenceDestroy."
type IterationCadenceDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Group the iteration cadence belongs to."
  group: Group!
}

"An edge in a connection."
type IterationCadenceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: IterationCadence
}

"Autogenerated return type of IterationCadenceUpdate."
type IterationCadenceUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated iteration cadence."
  iterationCadence: IterationCadence
}

"The connection type for Iteration."
type IterationConnection {
  "A list of edges."
  edges: [IterationEdge]
  "A list of nodes."
  nodes: [Iteration]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of IterationDelete."
type IterationDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Group the iteration belongs to."
  group: Group!
}

"An edge in a connection."
type IterationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Iteration
}

type JiraImport {
  "Timestamp of when the Jira import was created."
  createdAt: Time
  "Count of issues that failed to import."
  failedToImportCount: Int!
  "Count of issues that were successfully imported."
  importedIssuesCount: Int!
  "Project key for the imported Jira project."
  jiraProjectKey: String!
  "Timestamp of when the Jira import was scheduled."
  scheduledAt: Time
  "User that started the Jira import."
  scheduledBy: UserCore
  "Total count of issues that were attempted to import."
  totalIssueCount: Int!
}

"The connection type for JiraImport."
type JiraImportConnection {
  "A list of edges."
  edges: [JiraImportEdge]
  "A list of nodes."
  nodes: [JiraImport]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type JiraImportEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: JiraImport
}

"Autogenerated return type of JiraImportStart."
type JiraImportStartPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Jira import data after mutation."
  jiraImport: JiraImport
}

"Autogenerated return type of JiraImportUsers."
type JiraImportUsersPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Users returned from Jira, matched by email and name if possible."
  jiraUsers: [JiraUser!]
}

type JiraProject {
  "Key of the Jira project."
  key: String!
  "Name of the Jira project."
  name: String
  "ID of the Jira project."
  projectId: Int!
}

"The connection type for JiraProject."
type JiraProjectConnection {
  "A list of edges."
  edges: [JiraProjectEdge]
  "A list of nodes."
  nodes: [JiraProject]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type JiraProjectEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: JiraProject
}

type JiraService implements Service {
  "Indicates if the service is active."
  active: Boolean
  "List of all Jira projects fetched through Jira REST API."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Project name or key."
    name: String
  ): JiraProjectConnection
  "Type of the service."
  serviceType: ServiceType
  "Class name of the service."
  type: String
}

type JiraUser {
  "ID of the matched GitLab user."
  gitlabId: Int
  "Name of the matched GitLab user."
  gitlabName: String
  "Username of the matched GitLab user."
  gitlabUsername: String
  "Account ID of the Jira user."
  jiraAccountId: String!
  "Display name of the Jira user."
  jiraDisplayName: String!
  "Email of the Jira user, returned only for users with public emails."
  jiraEmail: String
}

"Represents the Geo replication and verification state of a job_artifact."
type JobArtifactRegistry {
  "ID of the Job Artifact."
  artifactId: ID!
  "Timestamp when the JobArtifactRegistry was created"
  createdAt: Time
  "ID of the JobArtifactRegistry"
  id: ID!
  "Error message during sync of the JobArtifactRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the JobArtifactRegistry"
  lastSyncedAt: Time
  "Timestamp after which the JobArtifactRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the JobArtifactRegistry"
  retryCount: Int
  "Sync state of the JobArtifactRegistry"
  state: RegistryState
  "The local checksum of the JobArtifactRegistry"
  verificationChecksum: String
  "Error message during verification of the JobArtifactRegistry"
  verificationFailure: String
  "Timestamp after which the JobArtifactRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the JobArtifactRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of JobArtifactRegistry"
  verificationStartedAt: Time
  "Verification state of the JobArtifactRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the JobArtifactRegistry"
  verifiedAt: Time
}

"The connection type for JobArtifactRegistry."
type JobArtifactRegistryConnection {
  "A list of edges."
  edges: [JobArtifactRegistryEdge]
  "A list of nodes."
  nodes: [JobArtifactRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type JobArtifactRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: JobArtifactRegistry
}

"Autogenerated return type of JobArtifactsDestroy."
type JobArtifactsDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of artifacts deleted."
  destroyedArtifactsCount: Int!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job with artifacts to be deleted."
  job: CiJob
}

"Autogenerated return type of JobCancel."
type JobCancelPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}

"The connection type for JobNeedUnion."
type JobNeedUnionConnection {
  "A list of edges."
  edges: [JobNeedUnionEdge]
  "A list of nodes."
  nodes: [JobNeedUnion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type JobNeedUnionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: JobNeedUnion
}

type JobPermissions {
  "If `true`, the user can perform `cancel_build` on this resource"
  cancelBuild: Boolean!
  "If `true`, the user can perform `read_build` on this resource"
  readBuild: Boolean!
  "If `true`, the user can perform `read_job_artifacts` on this resource"
  readJobArtifacts: Boolean!
  "If `true`, the user can perform `update_build` on this resource"
  updateBuild: Boolean!
}

"Autogenerated return type of JobPlay."
type JobPlayPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}

"Autogenerated return type of JobRetry."
type JobRetryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}

"Autogenerated return type of JobUnschedule."
type JobUnschedulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Job after the mutation."
  job: CiJob
}

type Kas {
  "Indicates whether the Kubernetes Agent Server is enabled."
  enabled: Boolean!
  "URL used by the Agents to communicate with KAS."
  externalUrl: String
  "KAS version."
  version: String
}

"Represents an SSH key."
type Key {
  "Timestamp of when the key was created."
  createdAt: Time!
  "Timestamp of when the key expires. It's null if it never expires."
  expiresAt: Time!
  "ID of the key."
  id: ID!
  "Public key of the key pair."
  key: String!
  "Title of the key."
  title: String!
}

type Label {
  "Background color of the label."
  color: String!
  "When this label was created."
  createdAt: Time!
  "Description of the label (Markdown rendered as HTML for caching)."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Label ID."
  id: ID!
  "Indicates this label is locked for merge requests that have been merged."
  lockOnMerge: Boolean!
  "Text color of the label."
  textColor: String!
  "Content of the label."
  title: String!
  "When this label was last updated."
  updatedAt: Time!
}

"The connection type for Label."
type LabelConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [LabelEdge]
  "A list of nodes."
  nodes: [Label]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of LabelCreate."
type LabelCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Label after mutation."
  label: Label
}

"An edge in a connection."
type LabelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Label
}

"Represents the Geo sync and verification state of an LFS object"
type LfsObjectRegistry {
  "Timestamp when the LfsObjectRegistry was created"
  createdAt: Time
  "ID of the LfsObjectRegistry"
  id: ID!
  "Error message during sync of the LfsObjectRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the LfsObjectRegistry"
  lastSyncedAt: Time
  "ID of the LFS object."
  lfsObjectId: ID!
  "Timestamp after which the LfsObjectRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the LfsObjectRegistry"
  retryCount: Int
  "Sync state of the LfsObjectRegistry"
  state: RegistryState
  "The local checksum of the LfsObjectRegistry"
  verificationChecksum: String
  "Error message during verification of the LfsObjectRegistry"
  verificationFailure: String
  "Timestamp after which the LfsObjectRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the LfsObjectRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of LfsObjectRegistry"
  verificationStartedAt: Time
  "Verification state of the LfsObjectRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the LfsObjectRegistry"
  verifiedAt: Time
}

"The connection type for LfsObjectRegistry."
type LfsObjectRegistryConnection {
  "A list of edges."
  edges: [LfsObjectRegistryEdge]
  "A list of nodes."
  nodes: [LfsObjectRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type LfsObjectRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: LfsObjectRegistry
}

type License {
  "Name of the license."
  name: String!
  "License URL in relation to SPDX."
  url: String!
}

"Represents an entry from the Cloud License history"
type LicenseHistoryEntry {
  "Date when the license was activated."
  activatedAt: Date
  "Date, including grace period, when licensed features will be blocked."
  blockChangesAt: Date
  "Company of the licensee."
  company: String
  "Date when the license was added."
  createdAt: Date
  "Email of the licensee."
  email: String
  "Date when the license expires."
  expiresAt: Date
  "ID of the license extracted from the license data."
  id: ID!
  "Name of the licensee."
  name: String
  "Name of the subscription plan."
  plan: String!
  "Date when the license started."
  startsAt: Date
  "Type of the license."
  type: String!
  "Number of paid users in the license."
  usersInLicenseCount: Int
}

"The connection type for LicenseHistoryEntry."
type LicenseHistoryEntryConnection {
  "A list of edges."
  edges: [LicenseHistoryEntryEdge]
  "A list of nodes."
  nodes: [LicenseHistoryEntry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type LicenseHistoryEntryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: LicenseHistoryEntry
}

type LinkedWorkItemType {
  "Timestamp the link was created."
  linkCreatedAt: Time!
  "Global ID of the link."
  linkId: WorkItemsRelatedWorkItemLinkID!
  "Type of link."
  linkType: String!
  "Timestamp the link was updated."
  linkUpdatedAt: Time!
  "Linked work item."
  workItem: WorkItem
}

"The connection type for LinkedWorkItemType."
type LinkedWorkItemTypeConnection {
  "A list of edges."
  edges: [LinkedWorkItemTypeEdge]
  "A list of nodes."
  nodes: [LinkedWorkItemType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type LinkedWorkItemTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: LinkedWorkItemType
}

type Location {
  "HTTP URI path to view the input file in GitLab."
  blobPath: String
  "Path, relative to the root of the repository, of the filewhich was analyzed to detect the dependency."
  path: String
}

"Represents links to perform actions on the candidate"
type MLCandidateLinks {
  "Path to the artifact."
  artifactPath: String
  "Path to the details page of the candidate."
  showPath: String
}

"Represents links to perform actions on the model"
type MLModelLinks {
  "Path to the details page of the model."
  showPath: String
}

"Represents links to perform actions on the model version"
type MLModelVersionLinks {
  "Path to the package of the model version."
  packagePath: String
  "Path to the details page of the model version."
  showPath: String
}

"Autogenerated return type of MarkAsSpamSnippet."
type MarkAsSpamSnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}

"Maven metadata"
type MavenMetadata {
  "App group of the Maven package."
  appGroup: String!
  "App name of the Maven package."
  appName: String!
  "App version of the Maven package."
  appVersion: String
  "Date of creation."
  createdAt: Time!
  "ID of the metadatum."
  id: PackagesMavenMetadatumID!
  "Path of the Maven package."
  path: String!
  "Date of most recent update."
  updatedAt: Time!
}

"The connection type for MemberInterface."
type MemberInterfaceConnection {
  "A list of edges."
  edges: [MemberInterfaceEdge]
  "A list of nodes."
  nodes: [MemberInterface]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MemberInterfaceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MemberInterface
}

"Represents a member role"
type MemberRole {
  "Base access level for the custom role. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  baseAccessLevel: AccessLevel! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Description of the member role."
  description: String
  "Array of all permissions enabled for the custom role. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  enabledPermissions: [MemberRolePermission!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "ID of the member role."
  id: MemberRoleID!
  "Total number of members with the custom role. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  membersCount: Int! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Name of the member role."
  name: String!
}

"The connection type for MemberRole."
type MemberRoleConnection {
  "A list of edges."
  edges: [MemberRoleEdge]
  "A list of nodes."
  nodes: [MemberRole]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of MemberRoleCreate."
type MemberRoleCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated member role."
  memberRole: MemberRole
}

"Autogenerated return type of MemberRoleDelete."
type MemberRoleDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted member role."
  memberRole: MemberRole
}

"An edge in a connection."
type MemberRoleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MemberRole
}

"Autogenerated return type of MemberRoleUpdate."
type MemberRoleUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated member role."
  memberRole: MemberRole
}

"Defines which user roles, users, or groups can merge into a protected branch."
type MergeAccessLevel {
  "GitLab::Access level."
  accessLevel: Int!
  "Human readable representation for this access level."
  accessLevelDescription: String!
  "Group associated with this access level."
  group: AccessLevelGroup
  "User associated with this access level."
  user: AccessLevelUser
}

"The connection type for MergeAccessLevel."
type MergeAccessLevelConnection {
  "A list of edges."
  edges: [MergeAccessLevelEdge]
  "A list of nodes."
  nodes: [MergeAccessLevel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeAccessLevelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeAccessLevel
}

type MergeRequest implements CurrentUserTodos & NoteableInterface & Todoable {
  "Indicates if members of the target project can push to the fork."
  allowCollaboration: Boolean
  "Allows assigning multiple users to a merge request."
  allowsMultipleAssignees: Boolean!
  "Allows assigning multiple reviewers to a merge request."
  allowsMultipleReviewers: Boolean!
  "Information relating to rules that must be satisfied to merge this merge request."
  approvalState: MergeRequestApprovalState!
  "Number of approvals left."
  approvalsLeft: Int
  "Number of approvals required."
  approvalsRequired: Int
  "Indicates if the merge request has all the required approvals."
  approved: Boolean!
  "Users who approved the merge request."
  approvedBy(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Assignees of the merge request."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestAssigneeConnection
  "User who created this merge request."
  author: MergeRequestAuthor
  "Indicates if auto merge is enabled for the merge request."
  autoMergeEnabled: Boolean!
  "Selected auto merge strategy."
  autoMergeStrategy: String
  "Array of available auto merge strategies."
  availableAutoMergeStrategies: [String!]
  "List of emoji reactions associated with the merge request."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Merge requests that block another merge request from merging. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  blockingMergeRequests: BlockingMergeRequests @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Code quality reports comparison reported on the merge request. Returns `null` if `sast_reports_in_inline_diff` feature flag is disabled. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  codequalityReportsComparer: CodequalityReportsComparer @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Number of commits in the merge request."
  commitCount: Int
  "Merge request commits."
  commits(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CommitConnection
  "Merge request commits excluding merge commits."
  commitsWithoutMergeCommits(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CommitConnection
  "Users who have added commits to the merge request."
  committers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Indicates if the merge request has conflicts."
  conflicts: Boolean!
  "Timestamp of when the merge request was created."
  createdAt: Time!
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Default merge commit message of the merge request."
  defaultMergeCommitMessage: String
  "Default squash commit message of the merge request."
  defaultSquashCommitMessage: String
  "Description of the merge request (Markdown rendered as HTML for caching)."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Detailed merge status of the merge request."
  detailedMergeStatus: DetailedMergeStatus
  "Diff head SHA of the merge request."
  diffHeadSha: String
  "Diff summaries generated by AI Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  diffLlmSummaries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestDiffLlmSummaryConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "References of the base SHA, the head SHA, and the start SHA for this merge request."
  diffRefs: DiffRefs
  "Details about which files were changed in this merge request."
  diffStats(
    "Specific file path."
    path: String
  ): [DiffStats!]
  "Summary of which files were changed in this merge request."
  diffStatsSummary: DiffStatsSummary
  "Indicates if comments on the merge request are locked to members only."
  discussionLocked: Boolean!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Indicates if the source branch is behind the target branch."
  divergedFromTargetBranch: Boolean!
  "Number of downvotes for the merge request."
  downvotes: Int!
  "Indicates if the merge request is a draft."
  draft: Boolean!
  "Vulnerability finding reports comparison reported on the merge request. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  findingReportsComparer(
    "Filter vulnerability findings by report type."
    reportType: ComparableSecurityReportType!
  ): FindingReportsComparer @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Indicates if the project settings will lead to source branch deletion after merge."
  forceRemoveSourceBranch: Boolean
  "Indicates if the merge request has CI."
  hasCi: Boolean!
  "Indicates if the source branch has any security reports."
  hasSecurityReports: Boolean!
  "Pipeline running on the branch HEAD of the merge request."
  headPipeline: Pipeline
  "Human-readable time estimate of the merge request."
  humanTimeEstimate: String
  "Human-readable total time reported as spent on the merge request."
  humanTotalTimeSpent: String
  "ID of the merge request."
  id: ID!
  "Internal ID of the merge request."
  iid: String!
  "Commit SHA of the merge request if merge is in progress."
  inProgressMergeCommitSha: String
  "Labels of the merge request."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "SHA of the merge request commit (set once merged)."
  mergeCommitSha: String
  "Error message due to a merge error."
  mergeError: String
  "Indicates if a merge is currently occurring."
  mergeOngoing: Boolean!
  "Diff versions of a merge request Introduced in 16.2: This feature is an Experiment. It can be changed or removed at any time."
  mergeRequestDiffs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestDiffConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.")
  "Status of the merge request. Deprecated in 14.0: This was renamed."
  mergeStatus: String @deprecated(reason: "This was renamed. Please use `MergeRequest.mergeStatusEnum`. Deprecated in 14.0.")
  "Merge status of the merge request."
  mergeStatusEnum: MergeStatus
  "Number of merge requests in the merge train."
  mergeTrainsCount: Int
  "User who merged this merge request or set it to auto-merge."
  mergeUser: UserCore
  "Indicates if the merge has been set to auto-merge."
  mergeWhenPipelineSucceeds: Boolean
  "Status of all mergeability checks of the merge request. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  mergeabilityChecks: [MergeRequestMergeabilityCheck!]! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Indicates if the merge request is mergeable."
  mergeable: Boolean!
  "Indicates if all discussions in the merge request have been resolved, allowing the merge request to be merged."
  mergeableDiscussionsState: Boolean
  "Timestamp of when the merge request was merged, null if not merged."
  mergedAt: Time
  "Milestone of the merge request."
  milestone: Milestone
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Participants in the merge request. This includes the author, assignees, reviewers, and users mentioned in notes."
  participants(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestParticipantConnection
  "Pipelines for the merge request. Note: for performance reasons, no more than the most recent 500 pipelines will be returned."
  pipelines(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by scope."
    scope: PipelineScopeEnum,
    "Filter pipelines by the sha of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String,
    "Filter pipelines by their status."
    status: PipelineStatusEnum,
    "Pipelines updated after this date."
    updatedAfter: Time,
    "Pipelines updated before this date."
    updatedBefore: Time,
    "Filter pipelines by the user that triggered the pipeline."
    username: String
  ): PipelineConnection
  "Timestamp of when the merge request was prepared."
  preparedAt: Time
  "Alias for target_project."
  project: Project!
  "ID of the merge request project."
  projectId: Int!
  "Rebase commit SHA of the merge request."
  rebaseCommitSha: String
  "Indicates if there is a rebase currently in progress for the merge request."
  rebaseInProgress: Boolean!
  "Internal reference of the merge request. Returned in shortened format by default."
  reference(
    "Boolean option specifying whether the reference should be returned in full."
    full: Boolean = false
  ): String!
  "Users from whom a review has been requested."
  reviewers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestReviewerConnection
  "Indicates if the merge request is created by @GitLab-Security-Bot."
  securityAutoFix: Boolean
  "Indicates if the target branch security reports are out of date."
  securityReportsUpToDateOnTargetBranch: Boolean!
  "Indicates if the merge request will be rebased."
  shouldBeRebased: Boolean!
  "Indicates if the source branch of the merge request will be deleted after merge."
  shouldRemoveSourceBranch: Boolean
  "Source branch of the merge request."
  sourceBranch: String!
  "Indicates if the source branch of the merge request exists."
  sourceBranchExists: Boolean!
  "Indicates if the source branch is protected."
  sourceBranchProtected: Boolean!
  "Source project of the merge request."
  sourceProject: Project
  "ID of the merge request source project."
  sourceProjectId: Int
  "Indicates if the merge request is set to be squashed when merged. [Project settings](https://docs.gitlab.com/ee/user/project/merge_requests/squash_and_merge.html#configure-squash-options-for-a-project) may override this value. Use `squash_on_merge` instead to take project squash options into account."
  squash: Boolean!
  "Indicates if the merge request will be squashed when merged."
  squashOnMerge: Boolean!
  "State of the merge request."
  state: MergeRequestState!
  "Indicates if the currently logged in user is subscribed to this merge request."
  subscribed: Boolean!
  "Suggested reviewers for merge request. Returns `null` if `suggested_reviewers` feature flag is disabled. This flag is disabled by default and only available on GitLab.com because the feature is experimental and is subject to change without notice. Introduced in 15.4: This feature is an Experiment. It can be changed or removed at any time."
  suggestedReviewers: SuggestedReviewersType @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.4.")
  "Indicates if the merge request supports locked labels."
  supportsLockOnMerge: Boolean!
  "Target branch of the merge request."
  targetBranch: String!
  "Indicates if the target branch of the merge request exists."
  targetBranchExists: Boolean!
  "Target project of the merge request."
  targetProject: Project!
  "ID of the merge request target project."
  targetProjectId: Int!
  "Completion status of tasks"
  taskCompletionStatus: TaskCompletionStatus!
  "Time estimate of the merge request."
  timeEstimate: Int!
  "Timelogs on the merge request."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelogConnection!
  "Title of the merge request."
  title: String!
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Total time (in seconds) reported as spent on the merge request."
  totalTimeSpent: Int!
  "Timestamp of when the merge request was last updated."
  updatedAt: Time!
  "Number of upvotes for the merge request."
  upvotes: Int!
  "Number of user discussions in the merge request."
  userDiscussionsCount: Int
  "User notes count of the merge request."
  userNotesCount: Int
  "Permissions for the current user on the resource"
  userPermissions: MergeRequestPermissions!
  "Web URL of the merge request."
  webUrl: String
}

"Autogenerated return type of MergeRequestAccept."
type MergeRequestAcceptPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Information relating to rules that must be satisfied to merge this merge request."
type MergeRequestApprovalState {
  "Indicates if the merge request approval rules are overwritten for the merge request."
  approvalRulesOverwritten: Boolean
  "List of approval rules that are associated with the merge request, but invalid."
  invalidApproversRules: [ApprovalRule!]
  "List of approval rules associated with the merge request."
  rules: [ApprovalRule!]
  "List of suggested approvers."
  suggestedApprovers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
}

"A user assigned to a merge request."
type MergeRequestAssignee implements User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of this user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"The connection type for MergeRequestAssignee."
type MergeRequestAssigneeConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestAssigneeEdge]
  "A list of nodes."
  nodes: [MergeRequestAssignee]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeRequestAssigneeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestAssignee
}

"The author of the merge request."
type MergeRequestAuthor implements User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of this user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"The connection type for MergeRequest."
type MergeRequestConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestEdge]
  "A list of nodes."
  nodes: [MergeRequest]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total sum of time to merge, in seconds, for the collection of merge requests."
  totalTimeToMerge: Float
}

"Autogenerated return type of MergeRequestCreate."
type MergeRequestCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"A diff version of a merge request."
type MergeRequestDiff {
  "Timestamp of when the diff was created."
  createdAt: Time!
  "Diff summary generated by AI."
  diffLlmSummary: MergeRequestDiffLlmSummary
  "Review summaries generated by AI."
  reviewLlmSummaries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MergeRequestReviewLlmSummaryConnection
  "Timestamp of when the diff was updated."
  updatedAt: Time!
}

"The connection type for MergeRequestDiff."
type MergeRequestDiffConnection {
  "A list of edges."
  edges: [MergeRequestDiffEdge]
  "A list of nodes."
  nodes: [MergeRequestDiff]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeRequestDiffEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestDiff
}

"A diff summary generated by AI."
type MergeRequestDiffLlmSummary {
  "Content of the diff summary."
  content: String!
  "Timestamp of when the diff summary was created."
  createdAt: Time!
  "ID of the Merge Request diff associated with the diff summary."
  mergeRequestDiffId: ID!
  "AI provider that generated the summary."
  provider: String!
  "Timestamp of when the diff summary was updated."
  updatedAt: Time!
  "User associated with the diff summary."
  user: UserCore
}

"The connection type for MergeRequestDiffLlmSummary."
type MergeRequestDiffLlmSummaryConnection {
  "A list of edges."
  edges: [MergeRequestDiffLlmSummaryEdge]
  "A list of nodes."
  nodes: [MergeRequestDiffLlmSummary]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeRequestDiffLlmSummaryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestDiffLlmSummary
}

"Represents the Geo sync and verification state of a Merge Request diff"
type MergeRequestDiffRegistry {
  "Timestamp when the MergeRequestDiffRegistry was created"
  createdAt: Time
  "ID of the MergeRequestDiffRegistry"
  id: ID!
  "Error message during sync of the MergeRequestDiffRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the MergeRequestDiffRegistry"
  lastSyncedAt: Time
  "ID of the Merge Request diff."
  mergeRequestDiffId: ID!
  "Timestamp after which the MergeRequestDiffRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the MergeRequestDiffRegistry"
  retryCount: Int
  "Sync state of the MergeRequestDiffRegistry"
  state: RegistryState
  "The local checksum of the MergeRequestDiffRegistry"
  verificationChecksum: String
  "Error message during verification of the MergeRequestDiffRegistry"
  verificationFailure: String
  "Timestamp after which the MergeRequestDiffRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the MergeRequestDiffRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of MergeRequestDiffRegistry"
  verificationStartedAt: Time
  "Verification state of the MergeRequestDiffRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the MergeRequestDiffRegistry"
  verifiedAt: Time
}

"The connection type for MergeRequestDiffRegistry."
type MergeRequestDiffRegistryConnection {
  "A list of edges."
  edges: [MergeRequestDiffRegistryEdge]
  "A list of nodes."
  nodes: [MergeRequestDiffRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeRequestDiffRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestDiffRegistry
}

"An edge in a connection."
type MergeRequestEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequest
}

"Mergeability check of the merge request."
type MergeRequestMergeabilityCheck {
  "Identifier of the mergeability check."
  identifier: MergeabilityCheckIdentifier!
  "Status of the mergeability check."
  status: MergeabilityCheckStatus!
}

"A user participating in a merge request."
type MergeRequestParticipant implements User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of this user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"The connection type for MergeRequestParticipant."
type MergeRequestParticipantConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestParticipantEdge]
  "A list of nodes."
  nodes: [MergeRequestParticipant]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeRequestParticipantEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestParticipant
}

"Check permissions for the current user on a merge request"
type MergeRequestPermissions {
  "If `true`, the user can perform `admin_merge_request` on this resource"
  adminMergeRequest: Boolean!
  "If `true`, the user can perform `can_approve` on this resource"
  canApprove: Boolean!
  "If `true`, the user can perform `can_merge` on this resource"
  canMerge: Boolean!
  "If `true`, the user can perform `cherry_pick_on_current_merge_request` on this resource"
  cherryPickOnCurrentMergeRequest: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `push_to_source_branch` on this resource"
  pushToSourceBranch: Boolean!
  "If `true`, the user can perform `read_merge_request` on this resource"
  readMergeRequest: Boolean!
  "If `true`, the user can perform `remove_source_branch` on this resource"
  removeSourceBranch: Boolean!
  "If `true`, the user can perform `revert_on_current_merge_request` on this resource"
  revertOnCurrentMergeRequest: Boolean!
  "If `true`, the user can perform `update_merge_request` on this resource"
  updateMergeRequest: Boolean!
}

"A review summary generated by AI."
type MergeRequestReviewLlmSummary {
  "Content of the review summary."
  content: String!
  "HTML content of the review summary, converted from Markdown."
  contentHtml: String!
  "Timestamp of when the review summary was created."
  createdAt: Time!
  "ID of the Merge Request diff associated with the review summary."
  mergeRequestDiffId: ID!
  "AI provider that generated the summary."
  provider: String!
  "User who authored the review associated with the review summary."
  reviewer: UserCore
  "Timestamp of when the review summary was updated."
  updatedAt: Time!
  "User associated with the review summary."
  user: UserCore
}

"The connection type for MergeRequestReviewLlmSummary."
type MergeRequestReviewLlmSummaryConnection {
  "A list of edges."
  edges: [MergeRequestReviewLlmSummaryEdge]
  "A list of nodes."
  nodes: [MergeRequestReviewLlmSummary]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeRequestReviewLlmSummaryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestReviewLlmSummary
}

"A user assigned to a merge request as a reviewer."
type MergeRequestReviewer implements User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Details of this user's interactions with the merge request."
  mergeRequestInteraction: UserMergeRequestInteraction
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"The connection type for MergeRequestReviewer."
type MergeRequestReviewerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [MergeRequestReviewerEdge]
  "A list of nodes."
  nodes: [MergeRequestReviewer]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MergeRequestReviewerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MergeRequestReviewer
}

"Autogenerated return type of MergeRequestReviewerRereview."
type MergeRequestReviewerRereviewPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestSetAssignees."
type MergeRequestSetAssigneesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestSetDraft."
type MergeRequestSetDraftPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestSetLabels."
type MergeRequestSetLabelsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestSetLocked."
type MergeRequestSetLockedPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestSetMilestone."
type MergeRequestSetMilestonePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestSetReviewers."
type MergeRequestSetReviewersPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestSetSubscription."
type MergeRequestSetSubscriptionPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestUpdateApprovalRule."
type MergeRequestUpdateApprovalRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of MergeRequestUpdate."
type MergeRequestUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge request after mutation."
  mergeRequest: MergeRequest
}

type Metadata {
  "Enterprise edition."
  enterprise: Boolean!
  "Metadata about KAS."
  kas: Kas!
  "Revision."
  revision: String!
  "Version."
  version: String!
}

"Represents a metric image upload"
type MetricImage {
  "File name of the metric image."
  fileName: String
  "File path of the metric image."
  filePath: String
  "ID of the metric upload."
  id: ID!
  "Internal ID of the metric upload."
  iid: ID!
  "URL of the metric source."
  url: String!
}

type MetricsDashboardAnnotation {
  "Description of the annotation."
  description: String
  "Timestamp marking end of annotated time span."
  endingAt: Time
  "ID of the annotation."
  id: ID!
  "ID of a dashboard panel to which the annotation should be scoped."
  panelId: String
  "Timestamp marking start of annotated time span."
  startingAt: Time
}

"Represents a milestone"
type Milestone implements TimeboxReportInterface {
  "Timestamp of milestone creation."
  createdAt: Time!
  "Description of the milestone."
  description: String
  "Timestamp of the milestone due date."
  dueDate: Time
  "Expired state of the milestone (a milestone is expired when the due date is past the current date). Defaults to `false` when due date has not been set."
  expired: Boolean!
  "Indicates if milestone is at group level."
  groupMilestone: Boolean!
  "ID of the milestone."
  id: ID!
  "Internal ID of the milestone."
  iid: ID!
  "Indicates if milestone is at project level."
  projectMilestone: Boolean!
  "Releases associated with this milestone."
  releases(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseConnection
  "Historically accurate report about the timebox."
  report(
    "Full path of the project or group used as a scope for report. For example, `gitlab-org` or `gitlab-org/gitlab`."
    fullPath: String
  ): TimeboxReport
  "Timestamp of the milestone start date."
  startDate: Time
  "State of the milestone."
  state: MilestoneStateEnum!
  "Milestone statistics."
  stats: MilestoneStats
  "Indicates if milestone is at subgroup level."
  subgroupMilestone: Boolean!
  "Title of the milestone."
  title: String!
  "Timestamp of last milestone update."
  updatedAt: Time!
  "Web path of the milestone."
  webPath: String!
}

"The connection type for Milestone."
type MilestoneConnection {
  "A list of edges."
  edges: [MilestoneEdge]
  "A list of nodes."
  nodes: [Milestone]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MilestoneEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Milestone
}

"Contains statistics about a milestone"
type MilestoneStats {
  "Number of closed issues associated with the milestone."
  closedIssuesCount: Int
  "Total number of issues associated with the milestone."
  totalIssuesCount: Int
}

"Candidate for a model version in the model registry"
type MlCandidate {
  "Map of links to perform actions on the candidate."
  _links: MLCandidateLinks!
  "Date of creation."
  createdAt: Time!
  "ID of the candidate."
  id: MlCandidateID!
  "Name of the candidate."
  name: String!
}

"The connection type for MlCandidate."
type MlCandidateConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlCandidateEdge]
  "A list of nodes."
  nodes: [MlCandidate]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MlCandidateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlCandidate
}

"Machine learning model in the model registry"
type MlModel {
  "Map of links to perform actions on the model."
  _links: MLModelLinks!
  "Version candidates of the model."
  candidates(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlCandidateConnection
  "Date of creation."
  createdAt: Time!
  "Description of the model."
  description: String!
  "ID of the model."
  id: MlModelID!
  "Latest version of the model."
  latestVersion: MlModelVersion
  "Name of the model."
  name: String!
  "Count of versions in the model."
  versionCount: Int
  "Versions of the model."
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MlModelVersionConnection
}

"The connection type for MlModel."
type MlModelConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlModelEdge]
  "A list of nodes."
  nodes: [MlModel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of MlModelCreate."
type MlModelCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Model after mutation."
  model: MlModel
}

"An edge in a connection."
type MlModelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlModel
}

"Version of a machine learning model"
type MlModelVersion {
  "Map of links to perform actions on the model version."
  _links: MLModelVersionLinks!
  "Date of creation."
  createdAt: Time!
  "ID of the model version."
  id: MlModelVersionID!
  "Name of the version."
  version: String!
}

"The connection type for MlModelVersion."
type MlModelVersionConnection {
  "Limited count of collection. Returns limit + 1 for counts greater than the limit."
  count(
    "Limit value to be applied to the count query. Default is 1000."
    limit: Int = 1000
  ): Int!
  "A list of edges."
  edges: [MlModelVersionEdge]
  "A list of nodes."
  nodes: [MlModelVersion]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type MlModelVersionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: MlModelVersion
}

"Product analytics events for a specific month and year."
type MonthlyUsage {
  "Count of product analytics events."
  count: Int
  "Month of the data."
  month: Int!
  "Year of the data."
  year: Int!
}

type Mutation {
  abuseReportLabelCreate(
    "Parameters for AbuseReportLabelCreate"
    input: AbuseReportLabelCreateInput!
  ): AbuseReportLabelCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  achievementsAward(
    "Parameters for AchievementsAward"
    input: AchievementsAwardInput!
  ): AchievementsAwardPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  achievementsCreate(
    "Parameters for AchievementsCreate"
    input: AchievementsCreateInput!
  ): AchievementsCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
  achievementsDelete(
    "Parameters for AchievementsDelete"
    input: AchievementsDeleteInput!
  ): AchievementsDeletePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  achievementsRevoke(
    "Parameters for AchievementsRevoke"
    input: AchievementsRevokeInput!
  ): AchievementsRevokePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  achievementsUpdate(
    "Parameters for AchievementsUpdate"
    input: AchievementsUpdateInput!
  ): AchievementsUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  addProjectToSecurityDashboard(
    "Parameters for AddProjectToSecurityDashboard"
    input: AddProjectToSecurityDashboardInput!
  ): AddProjectToSecurityDashboardPayload
  adminSidekiqQueuesDeleteJobs(
    "Parameters for AdminSidekiqQueuesDeleteJobs"
    input: AdminSidekiqQueuesDeleteJobsInput!
  ): AdminSidekiqQueuesDeleteJobsPayload
  aiAction(
    "Parameters for AiAction"
    input: AiActionInput!
  ): AiActionPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  alertSetAssignees(
    "Parameters for AlertSetAssignees"
    input: AlertSetAssigneesInput!
  ): AlertSetAssigneesPayload
  alertTodoCreate(
    "Parameters for AlertTodoCreate"
    input: AlertTodoCreateInput!
  ): AlertTodoCreatePayload
  approveDeployment(
    "Parameters for ApproveDeployment"
    input: ApproveDeploymentInput!
  ): ApproveDeploymentPayload
  artifactDestroy(
    "Parameters for ArtifactDestroy"
    input: ArtifactDestroyInput!
  ): ArtifactDestroyPayload
  auditEventsAmazonS3ConfigurationCreate(
    "Parameters for AuditEventsAmazonS3ConfigurationCreate"
    input: AuditEventsAmazonS3ConfigurationCreateInput!
  ): AuditEventsAmazonS3ConfigurationCreatePayload
  auditEventsAmazonS3ConfigurationDelete(
    "Parameters for AuditEventsAmazonS3ConfigurationDelete"
    input: AuditEventsAmazonS3ConfigurationDeleteInput!
  ): AuditEventsAmazonS3ConfigurationDeletePayload
  auditEventsAmazonS3ConfigurationUpdate(
    "Parameters for AuditEventsAmazonS3ConfigurationUpdate"
    input: AuditEventsAmazonS3ConfigurationUpdateInput!
  ): AuditEventsAmazonS3ConfigurationUpdatePayload
  auditEventsInstanceAmazonS3ConfigurationCreate(
    "Parameters for AuditEventsInstanceAmazonS3ConfigurationCreate"
    input: AuditEventsInstanceAmazonS3ConfigurationCreateInput!
  ): AuditEventsInstanceAmazonS3ConfigurationCreatePayload
  auditEventsInstanceAmazonS3ConfigurationDelete(
    "Parameters for AuditEventsInstanceAmazonS3ConfigurationDelete"
    input: AuditEventsInstanceAmazonS3ConfigurationDeleteInput!
  ): AuditEventsInstanceAmazonS3ConfigurationDeletePayload
  auditEventsInstanceAmazonS3ConfigurationUpdate(
    "Parameters for AuditEventsInstanceAmazonS3ConfigurationUpdate"
    input: AuditEventsInstanceAmazonS3ConfigurationUpdateInput!
  ): AuditEventsInstanceAmazonS3ConfigurationUpdatePayload
  auditEventsStreamingDestinationEventsAdd(
    "Parameters for AuditEventsStreamingDestinationEventsAdd"
    input: AuditEventsStreamingDestinationEventsAddInput!
  ): AuditEventsStreamingDestinationEventsAddPayload
  auditEventsStreamingDestinationEventsRemove(
    "Parameters for AuditEventsStreamingDestinationEventsRemove"
    input: AuditEventsStreamingDestinationEventsRemoveInput!
  ): AuditEventsStreamingDestinationEventsRemovePayload
  auditEventsStreamingDestinationInstanceEventsAdd(
    "Parameters for AuditEventsStreamingDestinationInstanceEventsAdd"
    input: AuditEventsStreamingDestinationInstanceEventsAddInput!
  ): AuditEventsStreamingDestinationInstanceEventsAddPayload
  auditEventsStreamingDestinationInstanceEventsRemove(
    "Parameters for AuditEventsStreamingDestinationInstanceEventsRemove"
    input: AuditEventsStreamingDestinationInstanceEventsRemoveInput!
  ): AuditEventsStreamingDestinationInstanceEventsRemovePayload
  auditEventsStreamingHeadersCreate(
    "Parameters for AuditEventsStreamingHeadersCreate"
    input: AuditEventsStreamingHeadersCreateInput!
  ): AuditEventsStreamingHeadersCreatePayload
  auditEventsStreamingHeadersDestroy(
    "Parameters for AuditEventsStreamingHeadersDestroy"
    input: AuditEventsStreamingHeadersDestroyInput!
  ): AuditEventsStreamingHeadersDestroyPayload
  auditEventsStreamingHeadersUpdate(
    "Parameters for AuditEventsStreamingHeadersUpdate"
    input: AuditEventsStreamingHeadersUpdateInput!
  ): AuditEventsStreamingHeadersUpdatePayload
  auditEventsStreamingHttpNamespaceFiltersAdd(
    "Parameters for AuditEventsStreamingHTTPNamespaceFiltersAdd"
    input: AuditEventsStreamingHTTPNamespaceFiltersAddInput!
  ): AuditEventsStreamingHTTPNamespaceFiltersAddPayload
  auditEventsStreamingHttpNamespaceFiltersDelete(
    "Parameters for AuditEventsStreamingHTTPNamespaceFiltersDelete"
    input: AuditEventsStreamingHTTPNamespaceFiltersDeleteInput!
  ): AuditEventsStreamingHTTPNamespaceFiltersDeletePayload
  auditEventsStreamingInstanceHeadersCreate(
    "Parameters for AuditEventsStreamingInstanceHeadersCreate"
    input: AuditEventsStreamingInstanceHeadersCreateInput!
  ): AuditEventsStreamingInstanceHeadersCreatePayload
  auditEventsStreamingInstanceHeadersDestroy(
    "Parameters for AuditEventsStreamingInstanceHeadersDestroy"
    input: AuditEventsStreamingInstanceHeadersDestroyInput!
  ): AuditEventsStreamingInstanceHeadersDestroyPayload
  auditEventsStreamingInstanceHeadersUpdate(
    "Parameters for AuditEventsStreamingInstanceHeadersUpdate"
    input: AuditEventsStreamingInstanceHeadersUpdateInput!
  ): AuditEventsStreamingInstanceHeadersUpdatePayload
  awardEmojiAdd(
    "Parameters for AwardEmojiAdd"
    input: AwardEmojiAddInput!
  ): AwardEmojiAddPayload
  awardEmojiRemove(
    "Parameters for AwardEmojiRemove"
    input: AwardEmojiRemoveInput!
  ): AwardEmojiRemovePayload
  awardEmojiToggle(
    "Parameters for AwardEmojiToggle"
    input: AwardEmojiToggleInput!
  ): AwardEmojiTogglePayload
  boardEpicCreate(
    "Parameters for BoardEpicCreate"
    input: BoardEpicCreateInput!
  ): BoardEpicCreatePayload
  boardListCreate(
    "Parameters for BoardListCreate"
    input: BoardListCreateInput!
  ): BoardListCreatePayload
  boardListUpdateLimitMetrics(
    "Parameters for BoardListUpdateLimitMetrics"
    input: BoardListUpdateLimitMetricsInput!
  ): BoardListUpdateLimitMetricsPayload
  branchRuleCreate(
    "Parameters for BranchRuleCreate"
    input: BranchRuleCreateInput!
  ): BranchRuleCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  branchRuleUpdate(
    "Parameters for BranchRuleUpdate"
    input: BranchRuleUpdateInput!
  ): BranchRuleUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  buildForecast(
    "Parameters for BuildForecast"
    input: BuildForecastInput!
  ): BuildForecastPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
  bulkDestroyJobArtifacts(
    "Parameters for BulkDestroyJobArtifacts"
    input: BulkDestroyJobArtifactsInput!
  ): BulkDestroyJobArtifactsPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "**BETA** This endpoint is subject to change without notice."
  bulkEnableDevopsAdoptionNamespaces(
    "Parameters for BulkEnableDevopsAdoptionNamespaces"
    input: BulkEnableDevopsAdoptionNamespacesInput!
  ): BulkEnableDevopsAdoptionNamespacesPayload
  bulkRunnerDelete(
    "Parameters for BulkRunnerDelete"
    input: BulkRunnerDeleteInput!
  ): BulkRunnerDeletePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.")
  catalogResourcesCreate(
    "Parameters for CatalogResourcesCreate"
    input: CatalogResourcesCreateInput!
  ): CatalogResourcesCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  catalogResourcesDestroy(
    "Parameters for CatalogResourcesDestroy"
    input: CatalogResourcesDestroyInput!
  ): CatalogResourcesDestroyPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  ciJobTokenScopeAddProject(
    "Parameters for CiJobTokenScopeAddProject"
    input: CiJobTokenScopeAddProjectInput!
  ): CiJobTokenScopeAddProjectPayload
  ciJobTokenScopeRemoveProject(
    "Parameters for CiJobTokenScopeRemoveProject"
    input: CiJobTokenScopeRemoveProjectInput!
  ): CiJobTokenScopeRemoveProjectPayload
  clusterAgentDelete(
    "Parameters for ClusterAgentDelete"
    input: ClusterAgentDeleteInput!
  ): ClusterAgentDeletePayload
  clusterAgentTokenCreate(
    "Parameters for ClusterAgentTokenCreate"
    input: ClusterAgentTokenCreateInput!
  ): ClusterAgentTokenCreatePayload
  clusterAgentTokenRevoke(
    "Parameters for ClusterAgentTokenRevoke"
    input: ClusterAgentTokenRevokeInput!
  ): ClusterAgentTokenRevokePayload
  commitCreate(
    "Parameters for CommitCreate"
    input: CommitCreateInput!
  ): CommitCreatePayload
  """

  Configure Container Scanning for a project by enabling Container Scanning in a new or modified
  `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
  create a merge request are part of the response.
  """
  configureContainerScanning(
    "Parameters for ConfigureContainerScanning"
    input: ConfigureContainerScanningInput!
  ): ConfigureContainerScanningPayload
  """

  Configure Dependency Scanning for a project by enabling Dependency Scanning in a new or modified
  `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
  create a Merge Request are a part of the response.
  """
  configureDependencyScanning(
    "Parameters for ConfigureDependencyScanning"
    input: ConfigureDependencyScanningInput!
  ): ConfigureDependencyScanningPayload
  """

  Configure SAST for a project by enabling SAST in a new or modified
  `.gitlab-ci.yml` file in a new branch. The new branch and a URL to
  create a Merge Request are a part of the response.
  """
  configureSast(
    "Parameters for ConfigureSast"
    input: ConfigureSastInput!
  ): ConfigureSastPayload
  """

  Enable SAST IaC for a project in a new or
  modified `.gitlab-ci.yml` file in a new branch. The new
  branch and a URL to create a merge request are a part of the
  response.
  """
  configureSastIac(
    "Parameters for ConfigureSastIac"
    input: ConfigureSastIacInput!
  ): ConfigureSastIacPayload
  """

  Configure Secret Detection for a project by enabling Secret Detection
  in a new or modified `.gitlab-ci.yml` file in a new branch. The new
  branch and a URL to create a Merge Request are a part of the
  response.
  """
  configureSecretDetection(
    "Parameters for ConfigureSecretDetection"
    input: ConfigureSecretDetectionInput!
  ): ConfigureSecretDetectionPayload
  corpusCreate(
    "Parameters for CorpusCreate"
    input: CorpusCreateInput!
  ): CorpusCreatePayload
  createAlertIssue(
    "Parameters for CreateAlertIssue"
    input: CreateAlertIssueInput!
  ): CreateAlertIssuePayload
  createAnnotation(
    "Parameters for CreateAnnotation"
    input: CreateAnnotationInput!
  ): CreateAnnotationPayload @deprecated(reason: "Underlying feature was removed in 16.0. Deprecated in 16.0.")
  createBoard(
    "Parameters for CreateBoard"
    input: CreateBoardInput!
  ): CreateBoardPayload
  createBranch(
    "Parameters for CreateBranch"
    input: CreateBranchInput!
  ): CreateBranchPayload
  createClusterAgent(
    "Parameters for CreateClusterAgent"
    input: CreateClusterAgentInput!
  ): CreateClusterAgentPayload
  createComplianceFramework(
    "Parameters for CreateComplianceFramework"
    input: CreateComplianceFrameworkInput!
  ): CreateComplianceFrameworkPayload
  "Creates a protection rule to restrict access to a project's container registry. Available only when feature flag `container_registry_protected_containers` is enabled. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  createContainerRegistryProtectionRule(
    "Parameters for CreateContainerRegistryProtectionRule"
    input: CreateContainerRegistryProtectionRuleInput!
  ): CreateContainerRegistryProtectionRulePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  createCustomEmoji(
    "Parameters for CreateCustomEmoji"
    input: CreateCustomEmojiInput!
  ): CreateCustomEmojiPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 13.6.")
  createDiffNote(
    "Parameters for CreateDiffNote"
    input: CreateDiffNoteInput!
  ): CreateDiffNotePayload
  createEpic(
    "Parameters for CreateEpic"
    input: CreateEpicInput!
  ): CreateEpicPayload
  createImageDiffNote(
    "Parameters for CreateImageDiffNote"
    input: CreateImageDiffNoteInput!
  ): CreateImageDiffNotePayload
  createIssue(
    "Parameters for CreateIssue"
    input: CreateIssueInput!
  ): CreateIssuePayload
  createIteration(
    "Parameters for CreateIteration"
    input: CreateIterationInput!
  ): CreateIterationPayload @deprecated(reason: "Use iterationCreate. Deprecated in 14.0.")
  """

  Creates a Note.
  If the body of the Note contains only quick actions,
  the Note will be destroyed during an update, and no Note will be
  returned.
  """
  createNote(
    "Parameters for CreateNote"
    input: CreateNoteInput!
  ): CreateNotePayload
  "Creates a protection rule to restrict access to project packages. Available only when feature flag `packages_protected_packages` is enabled. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  createPackagesProtectionRule(
    "Parameters for CreatePackagesProtectionRule"
    input: CreatePackagesProtectionRuleInput!
  ): CreatePackagesProtectionRulePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  createRequirement(
    "Parameters for CreateRequirement"
    input: CreateRequirementInput!
  ): CreateRequirementPayload
  createSnippet(
    "Parameters for CreateSnippet"
    input: CreateSnippetInput!
  ): CreateSnippetPayload
  createTestCase(
    "Parameters for CreateTestCase"
    input: CreateTestCaseInput!
  ): CreateTestCasePayload
  customerRelationsContactCreate(
    "Parameters for CustomerRelationsContactCreate"
    input: CustomerRelationsContactCreateInput!
  ): CustomerRelationsContactCreatePayload
  customerRelationsContactUpdate(
    "Parameters for CustomerRelationsContactUpdate"
    input: CustomerRelationsContactUpdateInput!
  ): CustomerRelationsContactUpdatePayload
  customerRelationsOrganizationCreate(
    "Parameters for CustomerRelationsOrganizationCreate"
    input: CustomerRelationsOrganizationCreateInput!
  ): CustomerRelationsOrganizationCreatePayload
  customerRelationsOrganizationUpdate(
    "Parameters for CustomerRelationsOrganizationUpdate"
    input: CustomerRelationsOrganizationUpdateInput!
  ): CustomerRelationsOrganizationUpdatePayload
  dastOnDemandScanCreate(
    "Parameters for DastOnDemandScanCreate"
    input: DastOnDemandScanCreateInput!
  ): DastOnDemandScanCreatePayload
  dastProfileCreate(
    "Parameters for DastProfileCreate"
    input: DastProfileCreateInput!
  ): DastProfileCreatePayload
  dastProfileDelete(
    "Parameters for DastProfileDelete"
    input: DastProfileDeleteInput!
  ): DastProfileDeletePayload
  dastProfileRun(
    "Parameters for DastProfileRun"
    input: DastProfileRunInput!
  ): DastProfileRunPayload
  dastProfileUpdate(
    "Parameters for DastProfileUpdate"
    input: DastProfileUpdateInput!
  ): DastProfileUpdatePayload
  dastScannerProfileCreate(
    "Parameters for DastScannerProfileCreate"
    input: DastScannerProfileCreateInput!
  ): DastScannerProfileCreatePayload
  dastScannerProfileDelete(
    "Parameters for DastScannerProfileDelete"
    input: DastScannerProfileDeleteInput!
  ): DastScannerProfileDeletePayload
  dastScannerProfileUpdate(
    "Parameters for DastScannerProfileUpdate"
    input: DastScannerProfileUpdateInput!
  ): DastScannerProfileUpdatePayload
  dastSiteProfileCreate(
    "Parameters for DastSiteProfileCreate"
    input: DastSiteProfileCreateInput!
  ): DastSiteProfileCreatePayload
  dastSiteProfileDelete(
    "Parameters for DastSiteProfileDelete"
    input: DastSiteProfileDeleteInput!
  ): DastSiteProfileDeletePayload
  dastSiteProfileUpdate(
    "Parameters for DastSiteProfileUpdate"
    input: DastSiteProfileUpdateInput!
  ): DastSiteProfileUpdatePayload
  dastSiteTokenCreate(
    "Parameters for DastSiteTokenCreate"
    input: DastSiteTokenCreateInput!
  ): DastSiteTokenCreatePayload
  dastSiteValidationCreate(
    "Parameters for DastSiteValidationCreate"
    input: DastSiteValidationCreateInput!
  ): DastSiteValidationCreatePayload
  dastSiteValidationRevoke(
    "Parameters for DastSiteValidationRevoke"
    input: DastSiteValidationRevokeInput!
  ): DastSiteValidationRevokePayload
  deleteAnnotation(
    "Parameters for DeleteAnnotation"
    input: DeleteAnnotationInput!
  ): DeleteAnnotationPayload @deprecated(reason: "Underlying feature was removed in 16.0. Deprecated in 16.0.")
  "Deletes a container registry protection rule. Available only when feature flag `container_registry_protected_containers` is enabled. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  deleteContainerRegistryProtectionRule(
    "Parameters for DeleteContainerRegistryProtectionRule"
    input: DeleteContainerRegistryProtectionRuleInput!
  ): DeleteContainerRegistryProtectionRulePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Deletes a protection rule for packages. Available only when feature flag `packages_protected_packages` is enabled. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  deletePackagesProtectionRule(
    "Parameters for DeletePackagesProtectionRule"
    input: DeletePackagesProtectionRuleInput!
  ): DeletePackagesProtectionRulePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  designManagementDelete(
    "Parameters for DesignManagementDelete"
    input: DesignManagementDeleteInput!
  ): DesignManagementDeletePayload
  designManagementMove(
    "Parameters for DesignManagementMove"
    input: DesignManagementMoveInput!
  ): DesignManagementMovePayload
  designManagementUpdate(
    "Parameters for DesignManagementUpdate"
    input: DesignManagementUpdateInput!
  ): DesignManagementUpdatePayload
  designManagementUpload(
    "Parameters for DesignManagementUpload"
    input: DesignManagementUploadInput!
  ): DesignManagementUploadPayload
  destroyBoard(
    "Parameters for DestroyBoard"
    input: DestroyBoardInput!
  ): DestroyBoardPayload
  destroyBoardList(
    "Parameters for DestroyBoardList"
    input: DestroyBoardListInput!
  ): DestroyBoardListPayload
  destroyComplianceFramework(
    "Parameters for DestroyComplianceFramework"
    input: DestroyComplianceFrameworkInput!
  ): DestroyComplianceFrameworkPayload
  destroyContainerRepository(
    "Parameters for DestroyContainerRepository"
    input: DestroyContainerRepositoryInput!
  ): DestroyContainerRepositoryPayload
  destroyContainerRepositoryTags(
    "Parameters for DestroyContainerRepositoryTags"
    input: DestroyContainerRepositoryTagsInput!
  ): DestroyContainerRepositoryTagsPayload
  destroyCustomEmoji(
    "Parameters for DestroyCustomEmoji"
    input: DestroyCustomEmojiInput!
  ): DestroyCustomEmojiPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 13.6.")
  destroyEpicBoard(
    "Parameters for DestroyEpicBoard"
    input: DestroyEpicBoardInput!
  ): DestroyEpicBoardPayload
  destroyNote(
    "Parameters for DestroyNote"
    input: DestroyNoteInput!
  ): DestroyNotePayload
  destroyPackage(
    "Parameters for DestroyPackage"
    input: DestroyPackageInput!
  ): DestroyPackagePayload
  destroyPackageFile(
    "Parameters for DestroyPackageFile"
    input: DestroyPackageFileInput!
  ): DestroyPackageFilePayload
  destroyPackageFiles(
    "Parameters for DestroyPackageFiles"
    input: DestroyPackageFilesInput!
  ): DestroyPackageFilesPayload
  destroyPackages(
    "Parameters for DestroyPackages"
    input: DestroyPackagesInput!
  ): DestroyPackagesPayload
  destroySnippet(
    "Parameters for DestroySnippet"
    input: DestroySnippetInput!
  ): DestroySnippetPayload
  "**BETA** This endpoint is subject to change without notice."
  disableDevopsAdoptionNamespace(
    "Parameters for DisableDevopsAdoptionNamespace"
    input: DisableDevopsAdoptionNamespaceInput!
  ): DisableDevopsAdoptionNamespacePayload
  "Toggles the resolved state of a discussion"
  discussionToggleResolve(
    "Parameters for DiscussionToggleResolve"
    input: DiscussionToggleResolveInput!
  ): DiscussionToggleResolvePayload
  """

  A mutation that does not perform any changes.

  This is expected to be used for testing of endpoints, to verify
  that a user has mutation access.
  """
  echoCreate(
    "Parameters for EchoCreate"
    input: EchoCreateInput!
  ): EchoCreatePayload
  "**BETA** This endpoint is subject to change without notice."
  enableDevopsAdoptionNamespace(
    "Parameters for EnableDevopsAdoptionNamespace"
    input: EnableDevopsAdoptionNamespaceInput!
  ): EnableDevopsAdoptionNamespacePayload
  "Create an environment."
  environmentCreate(
    "Parameters for EnvironmentCreate"
    input: EnvironmentCreateInput!
  ): EnvironmentCreatePayload
  "Delete an environment."
  environmentDelete(
    "Parameters for EnvironmentDelete"
    input: EnvironmentDeleteInput!
  ): EnvironmentDeletePayload
  "Stop an environment."
  environmentStop(
    "Parameters for EnvironmentStop"
    input: EnvironmentStopInput!
  ): EnvironmentStopPayload
  "Update an environment."
  environmentUpdate(
    "Parameters for EnvironmentUpdate"
    input: EnvironmentUpdateInput!
  ): EnvironmentUpdatePayload
  "**Deprecated** This endpoint is planned to be removed along with certificate-based clusters. [See this epic](https://gitlab.com/groups/gitlab-org/configure/-/epics/8) for more information."
  environmentsCanaryIngressUpdate(
    "Parameters for EnvironmentsCanaryIngressUpdate"
    input: EnvironmentsCanaryIngressUpdateInput!
  ): EnvironmentsCanaryIngressUpdatePayload
  epicAddIssue(
    "Parameters for EpicAddIssue"
    input: EpicAddIssueInput!
  ): EpicAddIssuePayload
  epicBoardCreate(
    "Parameters for EpicBoardCreate"
    input: EpicBoardCreateInput!
  ): EpicBoardCreatePayload
  epicBoardListCreate(
    "Parameters for EpicBoardListCreate"
    input: EpicBoardListCreateInput!
  ): EpicBoardListCreatePayload
  "Destroys an epic board list."
  epicBoardListDestroy(
    "Parameters for EpicBoardListDestroy"
    input: EpicBoardListDestroyInput!
  ): EpicBoardListDestroyPayload
  epicBoardUpdate(
    "Parameters for EpicBoardUpdate"
    input: EpicBoardUpdateInput!
  ): EpicBoardUpdatePayload
  epicMoveList(
    "Parameters for EpicMoveList"
    input: EpicMoveListInput!
  ): EpicMoveListPayload
  epicSetSubscription(
    "Parameters for EpicSetSubscription"
    input: EpicSetSubscriptionInput!
  ): EpicSetSubscriptionPayload
  epicTreeReorder(
    "Parameters for EpicTreeReorder"
    input: EpicTreeReorderInput!
  ): EpicTreeReorderPayload
  escalationPolicyCreate(
    "Parameters for EscalationPolicyCreate"
    input: EscalationPolicyCreateInput!
  ): EscalationPolicyCreatePayload
  escalationPolicyDestroy(
    "Parameters for EscalationPolicyDestroy"
    input: EscalationPolicyDestroyInput!
  ): EscalationPolicyDestroyPayload
  escalationPolicyUpdate(
    "Parameters for EscalationPolicyUpdate"
    input: EscalationPolicyUpdateInput!
  ): EscalationPolicyUpdatePayload
  exportRequirements(
    "Parameters for ExportRequirements"
    input: ExportRequirementsInput!
  ): ExportRequirementsPayload
  externalAuditEventDestinationCreate(
    "Parameters for ExternalAuditEventDestinationCreate"
    input: ExternalAuditEventDestinationCreateInput!
  ): ExternalAuditEventDestinationCreatePayload
  externalAuditEventDestinationDestroy(
    "Parameters for ExternalAuditEventDestinationDestroy"
    input: ExternalAuditEventDestinationDestroyInput!
  ): ExternalAuditEventDestinationDestroyPayload
  externalAuditEventDestinationUpdate(
    "Parameters for ExternalAuditEventDestinationUpdate"
    input: ExternalAuditEventDestinationUpdateInput!
  ): ExternalAuditEventDestinationUpdatePayload
  "Mutates multiple Geo registries for a given registry class. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  geoRegistriesBulkUpdate(
    "Parameters for GeoRegistriesBulkUpdate"
    input: GeoRegistriesBulkUpdateInput!
  ): GeoRegistriesBulkUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Mutates a Geo registry. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  geoRegistriesUpdate(
    "Parameters for GeoRegistriesUpdate"
    input: GeoRegistriesUpdateInput!
  ): GeoRegistriesUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  gitlabSubscriptionActivate(
    "Parameters for GitlabSubscriptionActivate"
    input: GitlabSubscriptionActivateInput!
  ): GitlabSubscriptionActivatePayload
  googleCloudLoggingConfigurationCreate(
    "Parameters for GoogleCloudLoggingConfigurationCreate"
    input: GoogleCloudLoggingConfigurationCreateInput!
  ): GoogleCloudLoggingConfigurationCreatePayload
  googleCloudLoggingConfigurationDestroy(
    "Parameters for GoogleCloudLoggingConfigurationDestroy"
    input: GoogleCloudLoggingConfigurationDestroyInput!
  ): GoogleCloudLoggingConfigurationDestroyPayload
  googleCloudLoggingConfigurationUpdate(
    "Parameters for GoogleCloudLoggingConfigurationUpdate"
    input: GoogleCloudLoggingConfigurationUpdateInput!
  ): GoogleCloudLoggingConfigurationUpdatePayload
  groupMemberBulkUpdate(
    "Parameters for GroupMemberBulkUpdate"
    input: GroupMemberBulkUpdateInput!
  ): GroupMemberBulkUpdatePayload
  groupUpdate(
    "Parameters for GroupUpdate"
    input: GroupUpdateInput!
  ): GroupUpdatePayload
  httpIntegrationCreate(
    "Parameters for HttpIntegrationCreate"
    input: HttpIntegrationCreateInput!
  ): HttpIntegrationCreatePayload
  httpIntegrationDestroy(
    "Parameters for HttpIntegrationDestroy"
    input: HttpIntegrationDestroyInput!
  ): HttpIntegrationDestroyPayload
  httpIntegrationResetToken(
    "Parameters for HttpIntegrationResetToken"
    input: HttpIntegrationResetTokenInput!
  ): HttpIntegrationResetTokenPayload
  httpIntegrationUpdate(
    "Parameters for HttpIntegrationUpdate"
    input: HttpIntegrationUpdateInput!
  ): HttpIntegrationUpdatePayload
  instanceExternalAuditEventDestinationCreate(
    "Parameters for InstanceExternalAuditEventDestinationCreate"
    input: InstanceExternalAuditEventDestinationCreateInput!
  ): InstanceExternalAuditEventDestinationCreatePayload
  instanceExternalAuditEventDestinationDestroy(
    "Parameters for InstanceExternalAuditEventDestinationDestroy"
    input: InstanceExternalAuditEventDestinationDestroyInput!
  ): InstanceExternalAuditEventDestinationDestroyPayload
  instanceExternalAuditEventDestinationUpdate(
    "Parameters for InstanceExternalAuditEventDestinationUpdate"
    input: InstanceExternalAuditEventDestinationUpdateInput!
  ): InstanceExternalAuditEventDestinationUpdatePayload
  instanceGoogleCloudLoggingConfigurationCreate(
    "Parameters for InstanceGoogleCloudLoggingConfigurationCreate"
    input: InstanceGoogleCloudLoggingConfigurationCreateInput!
  ): InstanceGoogleCloudLoggingConfigurationCreatePayload
  instanceGoogleCloudLoggingConfigurationDestroy(
    "Parameters for InstanceGoogleCloudLoggingConfigurationDestroy"
    input: InstanceGoogleCloudLoggingConfigurationDestroyInput!
  ): InstanceGoogleCloudLoggingConfigurationDestroyPayload
  instanceGoogleCloudLoggingConfigurationUpdate(
    "Parameters for InstanceGoogleCloudLoggingConfigurationUpdate"
    input: InstanceGoogleCloudLoggingConfigurationUpdateInput!
  ): InstanceGoogleCloudLoggingConfigurationUpdatePayload
  issuableResourceLinkCreate(
    "Parameters for IssuableResourceLinkCreate"
    input: IssuableResourceLinkCreateInput!
  ): IssuableResourceLinkCreatePayload
  issuableResourceLinkDestroy(
    "Parameters for IssuableResourceLinkDestroy"
    input: IssuableResourceLinkDestroyInput!
  ): IssuableResourceLinkDestroyPayload
  issueLinkAlerts(
    "Parameters for IssueLinkAlerts"
    input: IssueLinkAlertsInput!
  ): IssueLinkAlertsPayload
  issueMove(
    "Parameters for IssueMove"
    input: IssueMoveInput!
  ): IssueMovePayload
  issueMoveList(
    "Parameters for IssueMoveList"
    input: IssueMoveListInput!
  ): IssueMoveListPayload
  issueSetAssignees(
    "Parameters for IssueSetAssignees"
    input: IssueSetAssigneesInput!
  ): IssueSetAssigneesPayload
  issueSetConfidential(
    "Parameters for IssueSetConfidential"
    input: IssueSetConfidentialInput!
  ): IssueSetConfidentialPayload
  issueSetCrmContacts(
    "Parameters for IssueSetCrmContacts"
    input: IssueSetCrmContactsInput!
  ): IssueSetCrmContactsPayload
  issueSetDueDate(
    "Parameters for IssueSetDueDate"
    input: IssueSetDueDateInput!
  ): IssueSetDueDatePayload
  issueSetEpic(
    "Parameters for IssueSetEpic"
    input: IssueSetEpicInput!
  ): IssueSetEpicPayload
  issueSetEscalationPolicy(
    "Parameters for IssueSetEscalationPolicy"
    input: IssueSetEscalationPolicyInput!
  ): IssueSetEscalationPolicyPayload
  issueSetEscalationStatus(
    "Parameters for IssueSetEscalationStatus"
    input: IssueSetEscalationStatusInput!
  ): IssueSetEscalationStatusPayload
  issueSetIteration(
    "Parameters for IssueSetIteration"
    input: IssueSetIterationInput!
  ): IssueSetIterationPayload
  issueSetLocked(
    "Parameters for IssueSetLocked"
    input: IssueSetLockedInput!
  ): IssueSetLockedPayload
  issueSetSeverity(
    "Parameters for IssueSetSeverity"
    input: IssueSetSeverityInput!
  ): IssueSetSeverityPayload
  issueSetSubscription(
    "Parameters for IssueSetSubscription"
    input: IssueSetSubscriptionInput!
  ): IssueSetSubscriptionPayload
  issueSetWeight(
    "Parameters for IssueSetWeight"
    input: IssueSetWeightInput!
  ): IssueSetWeightPayload
  issueUnlinkAlert(
    "Parameters for IssueUnlinkAlert"
    input: IssueUnlinkAlertInput!
  ): IssueUnlinkAlertPayload
  "Allows updating several properties for a set of issues. Does nothing if the `bulk_update_issues_mutation` feature flag is disabled. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  issuesBulkUpdate(
    "Parameters for IssuesBulkUpdate"
    input: IssuesBulkUpdateInput!
  ): IssuesBulkUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  iterationCadenceCreate(
    "Parameters for IterationCadenceCreate"
    input: IterationCadenceCreateInput!
  ): IterationCadenceCreatePayload
  iterationCadenceDestroy(
    "Parameters for IterationCadenceDestroy"
    input: IterationCadenceDestroyInput!
  ): IterationCadenceDestroyPayload
  iterationCadenceUpdate(
    "Parameters for IterationCadenceUpdate"
    input: IterationCadenceUpdateInput!
  ): IterationCadenceUpdatePayload
  iterationCreate(
    "Parameters for iterationCreate"
    input: iterationCreateInput!
  ): iterationCreatePayload
  iterationDelete(
    "Parameters for IterationDelete"
    input: IterationDeleteInput!
  ): IterationDeletePayload
  jiraImportStart(
    "Parameters for JiraImportStart"
    input: JiraImportStartInput!
  ): JiraImportStartPayload
  jiraImportUsers(
    "Parameters for JiraImportUsers"
    input: JiraImportUsersInput!
  ): JiraImportUsersPayload
  jobArtifactsDestroy(
    "Parameters for JobArtifactsDestroy"
    input: JobArtifactsDestroyInput!
  ): JobArtifactsDestroyPayload
  jobCancel(
    "Parameters for JobCancel"
    input: JobCancelInput!
  ): JobCancelPayload
  jobPlay(
    "Parameters for JobPlay"
    input: JobPlayInput!
  ): JobPlayPayload
  jobRetry(
    "Parameters for JobRetry"
    input: JobRetryInput!
  ): JobRetryPayload
  jobUnschedule(
    "Parameters for JobUnschedule"
    input: JobUnscheduleInput!
  ): JobUnschedulePayload
  labelCreate(
    "Parameters for LabelCreate"
    input: LabelCreateInput!
  ): LabelCreatePayload
  markAsSpamSnippet(
    "Parameters for MarkAsSpamSnippet"
    input: MarkAsSpamSnippetInput!
  ): MarkAsSpamSnippetPayload
  memberRoleCreate(
    "Parameters for MemberRoleCreate"
    input: MemberRoleCreateInput!
  ): MemberRoleCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  memberRoleDelete(
    "Parameters for MemberRoleDelete"
    input: MemberRoleDeleteInput!
  ): MemberRoleDeletePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  memberRoleUpdate(
    "Parameters for MemberRoleUpdate"
    input: MemberRoleUpdateInput!
  ): MemberRoleUpdatePayload
  """

  Accepts a merge request.
  When accepted, the source branch will be scheduled to merge into the target branch, either
  immediately if possible, or using one of the automatic merge strategies.

  [In GitLab 16.5](https://gitlab.com/gitlab-org/gitlab/-/issues/421510), the merging happens asynchronously.
  This results in `mergeRequest` and `state` not updating after a mutation request,
  because the merging may not have happened yet.
  """
  mergeRequestAccept(
    "Parameters for MergeRequestAccept"
    input: MergeRequestAcceptInput!
  ): MergeRequestAcceptPayload
  mergeRequestCreate(
    "Parameters for MergeRequestCreate"
    input: MergeRequestCreateInput!
  ): MergeRequestCreatePayload
  mergeRequestReviewerRereview(
    "Parameters for MergeRequestReviewerRereview"
    input: MergeRequestReviewerRereviewInput!
  ): MergeRequestReviewerRereviewPayload
  mergeRequestSetAssignees(
    "Parameters for MergeRequestSetAssignees"
    input: MergeRequestSetAssigneesInput!
  ): MergeRequestSetAssigneesPayload
  mergeRequestSetDraft(
    "Parameters for MergeRequestSetDraft"
    input: MergeRequestSetDraftInput!
  ): MergeRequestSetDraftPayload
  mergeRequestSetLabels(
    "Parameters for MergeRequestSetLabels"
    input: MergeRequestSetLabelsInput!
  ): MergeRequestSetLabelsPayload
  mergeRequestSetLocked(
    "Parameters for MergeRequestSetLocked"
    input: MergeRequestSetLockedInput!
  ): MergeRequestSetLockedPayload
  mergeRequestSetMilestone(
    "Parameters for MergeRequestSetMilestone"
    input: MergeRequestSetMilestoneInput!
  ): MergeRequestSetMilestonePayload
  mergeRequestSetReviewers(
    "Parameters for MergeRequestSetReviewers"
    input: MergeRequestSetReviewersInput!
  ): MergeRequestSetReviewersPayload
  mergeRequestSetSubscription(
    "Parameters for MergeRequestSetSubscription"
    input: MergeRequestSetSubscriptionInput!
  ): MergeRequestSetSubscriptionPayload
  "Update attributes of a merge request"
  mergeRequestUpdate(
    "Parameters for MergeRequestUpdate"
    input: MergeRequestUpdateInput!
  ): MergeRequestUpdatePayload
  mergeRequestUpdateApprovalRule(
    "Parameters for MergeRequestUpdateApprovalRule"
    input: MergeRequestUpdateApprovalRuleInput!
  ): MergeRequestUpdateApprovalRulePayload
  mlModelCreate(
    "Parameters for MlModelCreate"
    input: MlModelCreateInput!
  ): MlModelCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  namespaceBanDestroy(
    "Parameters for NamespaceBanDestroy"
    input: NamespaceBanDestroyInput!
  ): NamespaceBanDestroyPayload
  namespaceCiCdSettingsUpdate(
    "Parameters for NamespaceCiCdSettingsUpdate"
    input: NamespaceCiCdSettingsUpdateInput!
  ): NamespaceCiCdSettingsUpdatePayload
  namespaceIncreaseStorageTemporarily(
    "Parameters for NamespaceIncreaseStorageTemporarily"
    input: NamespaceIncreaseStorageTemporarilyInput!
  ): NamespaceIncreaseStorageTemporarilyPayload
  oncallRotationCreate(
    "Parameters for OncallRotationCreate"
    input: OncallRotationCreateInput!
  ): OncallRotationCreatePayload
  oncallRotationDestroy(
    "Parameters for OncallRotationDestroy"
    input: OncallRotationDestroyInput!
  ): OncallRotationDestroyPayload
  oncallRotationUpdate(
    "Parameters for OncallRotationUpdate"
    input: OncallRotationUpdateInput!
  ): OncallRotationUpdatePayload
  oncallScheduleCreate(
    "Parameters for OncallScheduleCreate"
    input: OncallScheduleCreateInput!
  ): OncallScheduleCreatePayload
  oncallScheduleDestroy(
    "Parameters for OncallScheduleDestroy"
    input: OncallScheduleDestroyInput!
  ): OncallScheduleDestroyPayload
  oncallScheduleUpdate(
    "Parameters for OncallScheduleUpdate"
    input: OncallScheduleUpdateInput!
  ): OncallScheduleUpdatePayload
  organizationCreate(
    "Parameters for OrganizationCreate"
    input: OrganizationCreateInput!
  ): OrganizationCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  organizationUpdate(
    "Parameters for OrganizationUpdate"
    input: OrganizationUpdateInput!
  ): OrganizationUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  pagesMarkOnboardingComplete(
    "Parameters for PagesMarkOnboardingComplete"
    input: PagesMarkOnboardingCompleteInput!
  ): PagesMarkOnboardingCompletePayload
  pipelineCancel(
    "Parameters for PipelineCancel"
    input: PipelineCancelInput!
  ): PipelineCancelPayload
  pipelineDestroy(
    "Parameters for PipelineDestroy"
    input: PipelineDestroyInput!
  ): PipelineDestroyPayload
  pipelineRetry(
    "Parameters for PipelineRetry"
    input: PipelineRetryInput!
  ): PipelineRetryPayload
  pipelineScheduleCreate(
    "Parameters for PipelineScheduleCreate"
    input: PipelineScheduleCreateInput!
  ): PipelineScheduleCreatePayload
  pipelineScheduleDelete(
    "Parameters for PipelineScheduleDelete"
    input: PipelineScheduleDeleteInput!
  ): PipelineScheduleDeletePayload
  pipelineSchedulePlay(
    "Parameters for PipelineSchedulePlay"
    input: PipelineSchedulePlayInput!
  ): PipelineSchedulePlayPayload
  pipelineScheduleTakeOwnership(
    "Parameters for PipelineScheduleTakeOwnership"
    input: PipelineScheduleTakeOwnershipInput!
  ): PipelineScheduleTakeOwnershipPayload
  pipelineScheduleUpdate(
    "Parameters for PipelineScheduleUpdate"
    input: PipelineScheduleUpdateInput!
  ): PipelineScheduleUpdatePayload
  pipelineTriggerCreate(
    "Parameters for PipelineTriggerCreate"
    input: PipelineTriggerCreateInput!
  ): PipelineTriggerCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  pipelineTriggerDelete(
    "Parameters for PipelineTriggerDelete"
    input: PipelineTriggerDeleteInput!
  ): PipelineTriggerDeletePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  pipelineTriggerUpdate(
    "Parameters for PipelineTriggerUpdate"
    input: PipelineTriggerUpdateInput!
  ): PipelineTriggerUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  projectCiCdSettingsUpdate(
    "Parameters for ProjectCiCdSettingsUpdate"
    input: ProjectCiCdSettingsUpdateInput!
  ): ProjectCiCdSettingsUpdatePayload
  projectInitializeProductAnalytics(
    "Parameters for ProjectInitializeProductAnalytics"
    input: ProjectInitializeProductAnalyticsInput!
  ): ProjectInitializeProductAnalyticsPayload
  "Updates multiple members of a project. To use this mutation, you must have at least the Maintainer role."
  projectMemberBulkUpdate(
    "Parameters for ProjectMemberBulkUpdate"
    input: ProjectMemberBulkUpdateInput!
  ): ProjectMemberBulkUpdatePayload
  "Assign (or unset) a compliance framework to a project."
  projectSetComplianceFramework(
    "Parameters for ProjectSetComplianceFramework"
    input: ProjectSetComplianceFrameworkInput!
  ): ProjectSetComplianceFrameworkPayload
  """

  Enable/disable Continuous Vulnerability Scanning for the given project.
  """
  projectSetContinuousVulnerabilityScanning(
    "Parameters for ProjectSetContinuousVulnerabilityScanning"
    input: ProjectSetContinuousVulnerabilityScanningInput!
  ): ProjectSetContinuousVulnerabilityScanningPayload
  projectSetLocked(
    "Parameters for ProjectSetLocked"
    input: ProjectSetLockedInput!
  ): ProjectSetLockedPayload
  projectSubscriptionCreate(
    "Parameters for ProjectSubscriptionCreate"
    input: ProjectSubscriptionCreateInput!
  ): ProjectSubscriptionCreatePayload
  projectSubscriptionDelete(
    "Parameters for ProjectSubscriptionDelete"
    input: ProjectSubscriptionDeleteInput!
  ): ProjectSubscriptionDeletePayload
  projectSyncFork(
    "Parameters for ProjectSyncFork"
    input: ProjectSyncForkInput!
  ): ProjectSyncForkPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  prometheusIntegrationCreate(
    "Parameters for PrometheusIntegrationCreate"
    input: PrometheusIntegrationCreateInput!
  ): PrometheusIntegrationCreatePayload
  prometheusIntegrationResetToken(
    "Parameters for PrometheusIntegrationResetToken"
    input: PrometheusIntegrationResetTokenInput!
  ): PrometheusIntegrationResetTokenPayload
  prometheusIntegrationUpdate(
    "Parameters for PrometheusIntegrationUpdate"
    input: PrometheusIntegrationUpdateInput!
  ): PrometheusIntegrationUpdatePayload
  promoteToEpic(
    "Parameters for PromoteToEpic"
    input: PromoteToEpicInput!
  ): PromoteToEpicPayload
  releaseAssetLinkCreate(
    "Parameters for ReleaseAssetLinkCreate"
    input: ReleaseAssetLinkCreateInput!
  ): ReleaseAssetLinkCreatePayload
  releaseAssetLinkDelete(
    "Parameters for ReleaseAssetLinkDelete"
    input: ReleaseAssetLinkDeleteInput!
  ): ReleaseAssetLinkDeletePayload
  releaseAssetLinkUpdate(
    "Parameters for ReleaseAssetLinkUpdate"
    input: ReleaseAssetLinkUpdateInput!
  ): ReleaseAssetLinkUpdatePayload
  releaseCreate(
    "Parameters for ReleaseCreate"
    input: ReleaseCreateInput!
  ): ReleaseCreatePayload
  releaseDelete(
    "Parameters for ReleaseDelete"
    input: ReleaseDeleteInput!
  ): ReleaseDeletePayload
  releaseUpdate(
    "Parameters for ReleaseUpdate"
    input: ReleaseUpdateInput!
  ): ReleaseUpdatePayload
  removeProjectFromSecurityDashboard(
    "Parameters for RemoveProjectFromSecurityDashboard"
    input: RemoveProjectFromSecurityDashboardInput!
  ): RemoveProjectFromSecurityDashboardPayload
  "Repositions a DiffNote on an image (a `Note` where the `position.positionType` is `\"image\"`)"
  repositionImageDiffNote(
    "Parameters for RepositionImageDiffNote"
    input: RepositionImageDiffNoteInput!
  ): RepositionImageDiffNotePayload
  runnerCreate(
    "Parameters for RunnerCreate"
    input: RunnerCreateInput!
  ): RunnerCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  runnerDelete(
    "Parameters for RunnerDelete"
    input: RunnerDeleteInput!
  ): RunnerDeletePayload
  runnerUpdate(
    "Parameters for RunnerUpdate"
    input: RunnerUpdateInput!
  ): RunnerUpdatePayload
  runnersExportUsage(
    "Parameters for RunnersExportUsage"
    input: RunnersExportUsageInput!
  ): RunnersExportUsagePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  runnersRegistrationTokenReset(
    "Parameters for RunnersRegistrationTokenReset"
    input: RunnersRegistrationTokenResetInput!
  ): RunnersRegistrationTokenResetPayload
  savedReplyCreate(
    "Parameters for SavedReplyCreate"
    input: SavedReplyCreateInput!
  ): SavedReplyCreatePayload
  savedReplyDestroy(
    "Parameters for SavedReplyDestroy"
    input: SavedReplyDestroyInput!
  ): SavedReplyDestroyPayload
  savedReplyUpdate(
    "Parameters for SavedReplyUpdate"
    input: SavedReplyUpdateInput!
  ): SavedReplyUpdatePayload
  "Commits the `policy_yaml` content to the assigned security policy project for the given project (`full_path`)"
  scanExecutionPolicyCommit(
    "Parameters for ScanExecutionPolicyCommit"
    input: ScanExecutionPolicyCommitInput!
  ): ScanExecutionPolicyCommitPayload
  securityFindingCreateIssue(
    "Parameters for SecurityFindingCreateIssue"
    input: SecurityFindingCreateIssueInput!
  ): SecurityFindingCreateIssuePayload
  securityFindingCreateMergeRequest(
    "Parameters for SecurityFindingCreateMergeRequest"
    input: SecurityFindingCreateMergeRequestInput!
  ): SecurityFindingCreateMergeRequestPayload
  securityFindingDismiss(
    "Parameters for SecurityFindingDismiss"
    input: SecurityFindingDismissInput!
  ): SecurityFindingDismissPayload
  securityFindingRevertToDetected(
    "Parameters for SecurityFindingRevertToDetected"
    input: SecurityFindingRevertToDetectedInput!
  ): SecurityFindingRevertToDetectedPayload
  "Assigns the specified project(`security_policy_project_id`) as security policy project for the given project(`full_path`). If the project already has a security policy project, this reassigns the project's security policy project with the given `security_policy_project_id`"
  securityPolicyProjectAssign(
    "Parameters for SecurityPolicyProjectAssign"
    input: SecurityPolicyProjectAssignInput!
  ): SecurityPolicyProjectAssignPayload
  "Creates and assigns a security policy project for the given project or group (`full_path`)"
  securityPolicyProjectCreate(
    "Parameters for SecurityPolicyProjectCreate"
    input: SecurityPolicyProjectCreateInput!
  ): SecurityPolicyProjectCreatePayload
  "Unassigns the security policy project for the given project (`full_path`)."
  securityPolicyProjectUnassign(
    "Parameters for SecurityPolicyProjectUnassign"
    input: SecurityPolicyProjectUnassignInput!
  ): SecurityPolicyProjectUnassignPayload
  securityTrainingUpdate(
    "Parameters for SecurityTrainingUpdate"
    input: SecurityTrainingUpdateInput!
  ): SecurityTrainingUpdatePayload
  starProject(
    "Parameters for StarProject"
    input: StarProjectInput!
  ): StarProjectPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  terraformStateDelete(
    "Parameters for TerraformStateDelete"
    input: TerraformStateDeleteInput!
  ): TerraformStateDeletePayload
  terraformStateLock(
    "Parameters for TerraformStateLock"
    input: TerraformStateLockInput!
  ): TerraformStateLockPayload
  terraformStateUnlock(
    "Parameters for TerraformStateUnlock"
    input: TerraformStateUnlockInput!
  ): TerraformStateUnlockPayload
  timelineEventCreate(
    "Parameters for TimelineEventCreate"
    input: TimelineEventCreateInput!
  ): TimelineEventCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.")
  timelineEventDestroy(
    "Parameters for TimelineEventDestroy"
    input: TimelineEventDestroyInput!
  ): TimelineEventDestroyPayload
  timelineEventPromoteFromNote(
    "Parameters for TimelineEventPromoteFromNote"
    input: TimelineEventPromoteFromNoteInput!
  ): TimelineEventPromoteFromNotePayload
  timelineEventTagCreate(
    "Parameters for TimelineEventTagCreate"
    input: TimelineEventTagCreateInput!
  ): TimelineEventTagCreatePayload
  timelineEventUpdate(
    "Parameters for TimelineEventUpdate"
    input: TimelineEventUpdateInput!
  ): TimelineEventUpdatePayload
  timelogCreate(
    "Parameters for TimelogCreate"
    input: TimelogCreateInput!
  ): TimelogCreatePayload
  timelogDelete(
    "Parameters for TimelogDelete"
    input: TimelogDeleteInput!
  ): TimelogDeletePayload
  todoCreate(
    "Parameters for TodoCreate"
    input: TodoCreateInput!
  ): TodoCreatePayload
  todoMarkDone(
    "Parameters for TodoMarkDone"
    input: TodoMarkDoneInput!
  ): TodoMarkDonePayload
  todoRestore(
    "Parameters for TodoRestore"
    input: TodoRestoreInput!
  ): TodoRestorePayload
  todoRestoreMany(
    "Parameters for TodoRestoreMany"
    input: TodoRestoreManyInput!
  ): TodoRestoreManyPayload
  todosMarkAllDone(
    "Parameters for TodosMarkAllDone"
    input: TodosMarkAllDoneInput!
  ): TodosMarkAllDonePayload
  updateAlertStatus(
    "Parameters for UpdateAlertStatus"
    input: UpdateAlertStatusInput!
  ): UpdateAlertStatusPayload
  updateBoard(
    "Parameters for UpdateBoard"
    input: UpdateBoardInput!
  ): UpdateBoardPayload
  updateBoardEpicUserPreferences(
    "Parameters for UpdateBoardEpicUserPreferences"
    input: UpdateBoardEpicUserPreferencesInput!
  ): UpdateBoardEpicUserPreferencesPayload
  updateBoardList(
    "Parameters for UpdateBoardList"
    input: UpdateBoardListInput!
  ): UpdateBoardListPayload
  updateComplianceFramework(
    "Parameters for UpdateComplianceFramework"
    input: UpdateComplianceFrameworkInput!
  ): UpdateComplianceFrameworkPayload
  updateContainerExpirationPolicy(
    "Parameters for UpdateContainerExpirationPolicy"
    input: UpdateContainerExpirationPolicyInput!
  ): UpdateContainerExpirationPolicyPayload
  "Updates a container registry protection rule to restrict access to project containers. You can prevent users without certain roles from altering containers. Available only when feature flag `container_registry_protected_containers` is enabled. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  updateContainerRegistryProtectionRule(
    "Parameters for UpdateContainerRegistryProtectionRule"
    input: UpdateContainerRegistryProtectionRuleInput!
  ): UpdateContainerRegistryProtectionRulePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  """

  These settings can be adjusted by the group Owner or Maintainer.
  [Issue 370471](https://gitlab.com/gitlab-org/gitlab/-/issues/370471) proposes limiting
  this to Owners only to match the permissions level in the user interface.
  """
  updateDependencyProxyImageTtlGroupPolicy(
    "Parameters for UpdateDependencyProxyImageTtlGroupPolicy"
    input: UpdateDependencyProxyImageTtlGroupPolicyInput!
  ): UpdateDependencyProxyImageTtlGroupPolicyPayload
  """

  Updates or creates dependency proxy for packages settings.
  Requires the packages and dependency proxy to be enabled in the config.
  Requires the packages feature to be enabled at the project level.
  Error is raised if `packages_dependency_proxy_maven` feature flag is disabled. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time.
  """
  updateDependencyProxyPackagesSettings(
    "Parameters for UpdateDependencyProxyPackagesSettings"
    input: UpdateDependencyProxyPackagesSettingsInput!
  ): UpdateDependencyProxyPackagesSettingsPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  """

  These settings can be adjusted by the group Owner or Maintainer.
  [Issue 370471](https://gitlab.com/gitlab-org/gitlab/-/issues/370471) proposes limiting
  this to Owners only to match the permissions level in the user interface.
  """
  updateDependencyProxySettings(
    "Parameters for UpdateDependencyProxySettings"
    input: UpdateDependencyProxySettingsInput!
  ): UpdateDependencyProxySettingsPayload
  updateEpic(
    "Parameters for UpdateEpic"
    input: UpdateEpicInput!
  ): UpdateEpicPayload
  updateEpicBoardList(
    "Parameters for UpdateEpicBoardList"
    input: UpdateEpicBoardListInput!
  ): UpdateEpicBoardListPayload
  """

  Updates a DiffNote on an image (a `Note` where the `position.positionType` is `"image"`).
  If the body of the Note contains only quick actions,
  the Note will be destroyed during an update, and no Note will be
  returned.
  """
  updateImageDiffNote(
    "Parameters for UpdateImageDiffNote"
    input: UpdateImageDiffNoteInput!
  ): UpdateImageDiffNotePayload
  updateIssue(
    "Parameters for UpdateIssue"
    input: UpdateIssueInput!
  ): UpdateIssuePayload
  updateIteration(
    "Parameters for UpdateIteration"
    input: UpdateIterationInput!
  ): UpdateIterationPayload
  """

  These settings can be adjusted by the group Owner or Maintainer.
  [Issue 370471](https://gitlab.com/gitlab-org/gitlab/-/issues/370471) proposes limiting
  this to Owners only to match the permissions level in the user interface.
  """
  updateNamespacePackageSettings(
    "Parameters for UpdateNamespacePackageSettings"
    input: UpdateNamespacePackageSettingsInput!
  ): UpdateNamespacePackageSettingsPayload
  """

  Updates a Note.
  If the body of the Note contains only quick actions,
  the Note will be destroyed during an update, and no Note will be
  returned.
  """
  updateNote(
    "Parameters for UpdateNote"
    input: UpdateNoteInput!
  ): UpdateNotePayload
  updatePackagesCleanupPolicy(
    "Parameters for UpdatePackagesCleanupPolicy"
    input: UpdatePackagesCleanupPolicyInput!
  ): UpdatePackagesCleanupPolicyPayload
  "Updates a package protection rule to restrict access to project packages. You can prevent users without certain permissions from altering packages. Available only when feature flag `packages_protected_packages` is enabled. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  updatePackagesProtectionRule(
    "Parameters for UpdatePackagesProtectionRule"
    input: UpdatePackagesProtectionRuleInput!
  ): UpdatePackagesProtectionRulePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  updateRequirement(
    "Parameters for UpdateRequirement"
    input: UpdateRequirementInput!
  ): UpdateRequirementPayload
  updateSnippet(
    "Parameters for UpdateSnippet"
    input: UpdateSnippetInput!
  ): UpdateSnippetPayload
  "Deletes an upload."
  uploadDelete(
    "Parameters for UploadDelete"
    input: UploadDeleteInput!
  ): UploadDeletePayload
  userAchievementPrioritiesUpdate(
    "Parameters for UserAchievementPrioritiesUpdate"
    input: UserAchievementPrioritiesUpdateInput!
  ): UserAchievementPrioritiesUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  userAchievementsDelete(
    "Parameters for UserAchievementsDelete"
    input: UserAchievementsDeleteInput!
  ): UserAchievementsDeletePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  userAddOnAssignmentCreate(
    "Parameters for UserAddOnAssignmentCreate"
    input: UserAddOnAssignmentCreateInput!
  ): UserAddOnAssignmentCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  userAddOnAssignmentRemove(
    "Parameters for UserAddOnAssignmentRemove"
    input: UserAddOnAssignmentRemoveInput!
  ): UserAddOnAssignmentRemovePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  userCalloutCreate(
    "Parameters for UserCalloutCreate"
    input: UserCalloutCreateInput!
  ): UserCalloutCreatePayload
  userPreferencesUpdate(
    "Parameters for UserPreferencesUpdate"
    input: UserPreferencesUpdateInput!
  ): UserPreferencesUpdatePayload
  userSetNamespaceCommitEmail(
    "Parameters for UserSetNamespaceCommitEmail"
    input: UserSetNamespaceCommitEmailInput!
  ): UserSetNamespaceCommitEmailPayload
  "Creates a value stream. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  valueStreamCreate(
    "Parameters for ValueStreamCreate"
    input: ValueStreamCreateInput!
  ): ValueStreamCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Destroy a value stream. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  valueStreamDestroy(
    "Parameters for ValueStreamDestroy"
    input: ValueStreamDestroyInput!
  ): ValueStreamDestroyPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Updates a value stream. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  valueStreamUpdate(
    "Parameters for ValueStreamUpdate"
    input: ValueStreamUpdateInput!
  ): ValueStreamUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  vulnerabilitiesDismiss(
    "Parameters for VulnerabilitiesDismiss"
    input: VulnerabilitiesDismissInput!
  ): VulnerabilitiesDismissPayload
  vulnerabilitiesRemoveAllFromProject(
    "Parameters for VulnerabilitiesRemoveAllFromProject"
    input: VulnerabilitiesRemoveAllFromProjectInput!
  ): VulnerabilitiesRemoveAllFromProjectPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  vulnerabilityConfirm(
    "Parameters for VulnerabilityConfirm"
    input: VulnerabilityConfirmInput!
  ): VulnerabilityConfirmPayload
  vulnerabilityCreate(
    "Parameters for VulnerabilityCreate"
    input: VulnerabilityCreateInput!
  ): VulnerabilityCreatePayload
  vulnerabilityDismiss(
    "Parameters for VulnerabilityDismiss"
    input: VulnerabilityDismissInput!
  ): VulnerabilityDismissPayload
  vulnerabilityExternalIssueLinkCreate(
    "Parameters for VulnerabilityExternalIssueLinkCreate"
    input: VulnerabilityExternalIssueLinkCreateInput!
  ): VulnerabilityExternalIssueLinkCreatePayload
  vulnerabilityExternalIssueLinkDestroy(
    "Parameters for VulnerabilityExternalIssueLinkDestroy"
    input: VulnerabilityExternalIssueLinkDestroyInput!
  ): VulnerabilityExternalIssueLinkDestroyPayload
  vulnerabilityIssueLinkCreate(
    "Parameters for VulnerabilityIssueLinkCreate"
    input: VulnerabilityIssueLinkCreateInput!
  ): VulnerabilityIssueLinkCreatePayload
  vulnerabilityResolve(
    "Parameters for VulnerabilityResolve"
    input: VulnerabilityResolveInput!
  ): VulnerabilityResolvePayload
  vulnerabilityRevertToDetected(
    "Parameters for VulnerabilityRevertToDetected"
    input: VulnerabilityRevertToDetectedInput!
  ): VulnerabilityRevertToDetectedPayload
  "Add linked items to the work item. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  workItemAddLinkedItems(
    "Parameters for WorkItemAddLinkedItems"
    input: WorkItemAddLinkedItemsInput!
  ): WorkItemAddLinkedItemsPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Converts the work item to a new type Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  workItemConvert(
    "Parameters for WorkItemConvert"
    input: WorkItemConvertInput!
  ): WorkItemConvertPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "Creates a work item. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time."
  workItemCreate(
    "Parameters for WorkItemCreate"
    input: WorkItemCreateInput!
  ): WorkItemCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.")
  "Creates a work item from a task in another work item's description. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time."
  workItemCreateFromTask(
    "Parameters for WorkItemCreateFromTask"
    input: WorkItemCreateFromTaskInput!
  ): WorkItemCreateFromTaskPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.")
  "Deletes a work item. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time."
  workItemDelete(
    "Parameters for WorkItemDelete"
    input: WorkItemDeleteInput!
  ): WorkItemDeletePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.")
  workItemExport(
    "Parameters for WorkItemExport"
    input: WorkItemExportInput!
  ): WorkItemExportPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Remove items linked to the work item. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  workItemRemoveLinkedItems(
    "Parameters for WorkItemRemoveLinkedItems"
    input: WorkItemRemoveLinkedItemsInput!
  ): WorkItemRemoveLinkedItemsPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  workItemSubscribe(
    "Parameters for WorkItemSubscribe"
    input: WorkItemSubscribeInput!
  ): WorkItemSubscribePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Updates a work item by Global ID. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time."
  workItemUpdate(
    "Parameters for WorkItemUpdate"
    input: WorkItemUpdateInput!
  ): WorkItemUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.")
  "Updates a work item's task by Global ID. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time."
  workItemUpdateTask(
    "Parameters for WorkItemUpdateTask"
    input: WorkItemUpdateTaskInput!
  ): WorkItemUpdateTaskPayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.")
  workspaceCreate(
    "Parameters for WorkspaceCreate"
    input: WorkspaceCreateInput!
  ): WorkspaceCreatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
  workspaceUpdate(
    "Parameters for WorkspaceUpdate"
    input: WorkspaceUpdateInput!
  ): WorkspaceUpdatePayload @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
}

type Namespace {
  "Achievements for the namespace. Returns `null` if the `achievements` feature flag is disabled. Introduced in 15.8: This feature is an Experiment. It can be changed or removed at any time."
  achievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter achievements by IDs."
    ids: [AchievementsAchievementID!],
    "Returns the last _n_ elements from the list."
    last: Int
  ): AchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.8.")
  "Size limit for repositories in the namespace in bytes. This limit only applies to namespaces under Project limit enforcement."
  actualRepositorySizeLimit: Float
  "The actual storage size limit (in bytes) based on the enforcement type of either repository or namespace. This limit is agnostic of enforcement type."
  actualSizeLimit: Float
  "Users in the namespace hierarchy that add ons are applicable for. This only applies to root namespaces. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  addOnEligibleUsers(
    "Type of add on to filter the eligible users by."
    addOnType: GitlabSubscriptionsAddOnType!,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search the user list."
    search: String
  ): AddOnUserConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "AddOnPurchase associated with the namespace"
  addOnPurchase(
    "AddOn name."
    addOnName: String!
  ): AddOnPurchase
  "Additional storage purchased for the root namespace in bytes."
  additionalPurchasedStorageSize: Float
  "Compliance frameworks available to projects in this namespace."
  complianceFrameworks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of a specific compliance framework to return."
    id: ComplianceManagementFrameworkID,
    "List of Global IDs of compliance frameworks to return."
    ids: [ComplianceManagementFrameworkID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search framework with most similar names."
    search: String
  ): ComplianceFrameworkConnection
  "Includes at least one project where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement."
  containsLockedProjects: Boolean
  "Indicates if the cross_project_pipeline feature is available for the namespace."
  crossProjectPipelineAvailable: Boolean!
  "Description of the namespace."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Full name of the namespace."
  fullName: String!
  "Full path of the namespace."
  fullPath: ID!
  "ID of the namespace."
  id: ID!
  "Status of the temporary storage increase. Deprecated in 16.7: Feature removal, will be completely removed in 17.0."
  isTemporaryStorageIncreaseEnabled: Boolean @deprecated(reason: "Feature removal, will be completely removed in 17.0. Deprecated in 16.7.")
  "Indicates if Large File Storage (LFS) is enabled for namespace."
  lfsEnabled: Boolean
  "Name of the namespace."
  name: String!
  "Package settings for the namespace."
  packageSettings: PackageSettings
  "Path of the namespace."
  path: String!
  "Projects within this namespace."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filters applied when selecting a compliance framework."
    complianceFrameworkFilters: ComplianceFrameworkFilters,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only the projects which have code coverage."
    hasCodeCoverage: Boolean = false,
    "Returns only the projects which have vulnerabilities."
    hasVulnerabilities: Boolean = false,
    "Filter projects by IDs."
    ids: [ID!],
    "Include also subgroup projects."
    includeSubgroups: Boolean = false,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Include projects that are not aimed for deletion."
    notAimedForDeletion: Boolean = false,
    "Return only the projects related to the specified SBOM component."
    sbomComponentId: ID,
    "Search project with most similar names or paths."
    search: String,
    "Sort projects by this criteria."
    sort: NamespaceProjectSort,
    "Return only projects with issues enabled."
    withIssuesEnabled: Boolean,
    "Return only projects with merge requests enabled."
    withMergeRequestsEnabled: Boolean
  ): ProjectConnection!
  "Number of projects in the root namespace where the repository size exceeds the limit. This only applies to namespaces under Project limit enforcement."
  repositorySizeExcessProjectCount: Int
  "Indicates if users can request access to namespace."
  requestAccessEnabled: Boolean
  "Aggregated storage statistics of the namespace. Only available for root namespaces."
  rootStorageStatistics: RootStorageStatistics
  "Scan Execution Policies of the namespace."
  scanExecutionPolicies(
    "Filters policies by the action scan type. Only these scan types are supported: `dast`, `secret_detection`, `cluster_image_scanning`, `container_scanning`, `sast`, `sast_iac`, `dependency_scanning`."
    actionScanTypes: [SecurityReportTypeEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter policies by the given policy relationship."
    relationship: SecurityPolicyRelationType = DIRECT
  ): ScanExecutionPolicyConnection
  "Scan Result Policies of the project"
  scanResultPolicies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter policies by the given policy relationship."
    relationship: SecurityPolicyRelationType = DIRECT
  ): ScanResultPolicyConnection
  "Shared runners availability for the namespace and its descendants."
  sharedRunnersSetting: SharedRunnersSetting
  "The storage limit (in bytes) included with the root namespace plan. This limit only applies to namespaces under namespace limit enforcement."
  storageSizeLimit: Float
  "Date until the temporary storage increase is active. Deprecated in 16.7: Feature removal, will be completely removed in 17.0."
  temporaryStorageIncreaseEndsOn: Time @deprecated(reason: "Feature removal, will be completely removed in 17.0. Deprecated in 16.7.")
  "Timelog categories for the namespace. Introduced in 15.3: This feature is an Experiment. It can be changed or removed at any time."
  timelogCategories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimeTrackingTimelogCategoryConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.")
  "Total repository size of all projects in the root namespace in bytes."
  totalRepositorySize: Float
  "Total excess repository size of all projects in the root namespace in bytes. This only applies to namespaces under Project limit enforcement."
  totalRepositorySizeExcess: Float
  "Visibility of the namespace."
  visibility: String
}

type NamespaceBan {
  "Global ID of the namespace ban."
  id: GlobalID!
  "Root namespace to which the ban applies."
  namespace: Namespace!
  "User to which the namespace ban applies."
  user: UserCore!
}

"Autogenerated return type of NamespaceBanDestroy."
type NamespaceBanDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Namespace Ban."
  namespaceBan: NamespaceBan
}

type NamespaceCiCdSetting {
  "Indicates if stale runners directly belonging to this namespace should be periodically pruned."
  allowStaleRunnerPruning: Boolean
  "Namespace the CI/CD settings belong to."
  namespace: Namespace
}

"Autogenerated return type of NamespaceCiCdSettingsUpdate."
type NamespaceCiCdSettingsUpdatePayload {
  "CI/CD settings after mutation."
  ciCdSettings: NamespaceCiCdSetting!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type NamespaceCommitEmail {
  "Timestamp the namespace commit email was created."
  createdAt: Time!
  "Email."
  email: Email!
  "Internal ID of the namespace commit email."
  id: ID!
  "Namespace."
  namespace: Namespace!
  "Timestamp the namespace commit email was last updated."
  updatedAt: Time!
}

"The connection type for NamespaceCommitEmail."
type NamespaceCommitEmailConnection {
  "A list of edges."
  edges: [NamespaceCommitEmailEdge]
  "A list of nodes."
  nodes: [NamespaceCommitEmail]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NamespaceCommitEmailEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: NamespaceCommitEmail
}

"The connection type for Namespace."
type NamespaceConnection {
  "A list of edges."
  edges: [NamespaceEdge]
  "A list of nodes."
  nodes: [Namespace]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NamespaceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Namespace
}

"Autogenerated return type of NamespaceIncreaseStorageTemporarily."
type NamespaceIncreaseStorageTemporarilyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Namespace after mutation."
  namespace: Namespace
}

"Describes where code is deployed for a project organized by folder."
type NestedEnvironment {
  "Latest environment in the folder."
  environment: Environment
  "Human-readable name of the environment."
  name: String!
  "Number of environments nested in the folder."
  size: Int!
}

"The connection type for NestedEnvironment."
type NestedEnvironmentConnection {
  "A list of edges."
  edges: [NestedEnvironmentEdge]
  "A list of nodes."
  nodes: [NestedEnvironment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NestedEnvironmentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: NestedEnvironment
}

"Represents the network policy"
type NetworkPolicy {
  "Indicates whether this policy is enabled."
  enabled: Boolean!
  "Environments where this policy is applied."
  environments(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EnvironmentConnection
  "Indicates whether this policy is created from AutoDevops."
  fromAutoDevops: Boolean!
  "Kind of the policy."
  kind: NetworkPolicyKind!
  "Name of the policy."
  name: String!
  "Namespace of the policy."
  namespace: String!
  "Timestamp of when the policy YAML was last updated."
  updatedAt: Time!
  "YAML definition of the policy."
  yaml: String!
}

"The connection type for NetworkPolicy."
type NetworkPolicyConnection {
  "A list of edges."
  edges: [NetworkPolicyEdge]
  "A list of nodes."
  nodes: [NetworkPolicy]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NetworkPolicyEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: NetworkPolicy
}

type Note implements ResolvableInterface {
  "User who wrote this note."
  author: UserCore!
  "Indicates whether the note author is a contributor."
  authorIsContributor: Boolean
  "List of emoji reactions associated with the note."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Content of the note."
  body: String!
  "GitLab Flavored Markdown rendering of `note`"
  bodyHtml: String
  "Indicates if this note is confidential. Deprecated in 15.5: This was renamed."
  confidential: Boolean @deprecated(reason: "This was renamed. Please use `internal`. Deprecated in 15.5.")
  "Timestamp of the note creation."
  createdAt: Time!
  "Discussion this note is a part of."
  discussion: Discussion
  "ID of the note."
  id: NoteID!
  "Indicates if this note is internal."
  internal: Boolean
  "Timestamp when note was last edited."
  lastEditedAt: Time
  "User who last edited the note."
  lastEditedBy: UserCore
  "Max access level of the note author in the project."
  maxAccessLevelOfAuthor: String
  "Position of this note on a diff."
  position: DiffPosition
  "Project associated with the note."
  project: Project
  "Indicates if the object can be resolved."
  resolvable: Boolean!
  "Indicates if the object is resolved."
  resolved: Boolean!
  "Timestamp of when the object was resolved."
  resolvedAt: Time
  "User who resolved the object."
  resolvedBy: UserCore
  "Indicates whether this note was created by the system or by a user."
  system: Boolean!
  "Name of the icon corresponding to a system note."
  systemNoteIconName: String
  "Metadata for the given note if it is a system note."
  systemNoteMetadata: SystemNoteMetadata
  "Timestamp of the note's last activity."
  updatedAt: Time!
  "URL to view this Note in the Web UI."
  url: String
  "Permissions for the current user on the resource"
  userPermissions: NotePermissions!
}

"The connection type for Note."
type NoteConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [NoteEdge]
  "A list of nodes."
  nodes: [Note]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type NoteEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Note
}

type NotePermissions {
  "If `true`, the user can perform `admin_note` on this resource"
  adminNote: Boolean!
  "If `true`, the user can perform `award_emoji` on this resource"
  awardEmoji: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `read_note` on this resource"
  readNote: Boolean!
  "If `true`, the user can perform `reposition_note` on this resource"
  repositionNote: Boolean!
  "If `true`, the user can perform `resolve_note` on this resource"
  resolveNote: Boolean!
}

"Nuget dependency link metadata"
type NugetDependencyLinkMetadata {
  "ID of the metadatum."
  id: PackagesNugetDependencyLinkMetadatumID!
  "Target framework of the dependency link package."
  targetFramework: String!
}

"Nuget metadata"
type NugetMetadata {
  "Icon URL of the Nuget package."
  iconUrl: String
  "ID of the metadatum."
  id: PackagesNugetMetadatumID!
  "License URL of the Nuget package."
  licenseUrl: String
  "Project URL of the Nuget package."
  projectUrl: String
}

"The rotation participant and color palette"
type OncallParticipantType {
  "Color palette to assign to the on-call user. For example \"blue\"."
  colorPalette: String
  "Color weight to assign to for the on-call user, for example \"500\". Max 4 chars. For easy identification of the user."
  colorWeight: String
  "ID of the on-call participant."
  id: IncidentManagementOncallParticipantID!
  "User who is participating."
  user: UserCore!
}

"The connection type for OncallParticipantType."
type OncallParticipantTypeConnection {
  "A list of edges."
  edges: [OncallParticipantTypeEdge]
  "A list of nodes."
  nodes: [OncallParticipantType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OncallParticipantTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OncallParticipantType
}

"Active period time range for on-call rotation"
type OncallRotationActivePeriodType {
  "End of the rotation active period."
  endTime: String
  "Start of the rotation active period."
  startTime: String
}

"Autogenerated return type of OncallRotationCreate."
type OncallRotationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "On-call rotation."
  oncallRotation: IncidentManagementOncallRotation
}

"Autogenerated return type of OncallRotationDestroy."
type OncallRotationDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "On-call rotation."
  oncallRotation: IncidentManagementOncallRotation
}

"Autogenerated return type of OncallRotationUpdate."
type OncallRotationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "On-call rotation."
  oncallRotation: IncidentManagementOncallRotation
}

"Autogenerated return type of OncallScheduleCreate."
type OncallScheduleCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "On-call schedule."
  oncallSchedule: IncidentManagementOncallSchedule
}

"Autogenerated return type of OncallScheduleDestroy."
type OncallScheduleDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "On-call schedule."
  oncallSchedule: IncidentManagementOncallSchedule
}

"Autogenerated return type of OncallScheduleUpdate."
type OncallScheduleUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "On-call schedule."
  oncallSchedule: IncidentManagementOncallSchedule
}

type Organization {
  "Avatar URL of the organization. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  avatarUrl: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Description of the organization. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  description: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "GitLab Flavored Markdown rendering of `description` Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  descriptionHtml: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Groups within this organization that the user has access to. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupConnection! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "ID of the organization. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  id: ID! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Name of the organization. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  name: String! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Users with access to the organization. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  organizationUsers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationUserConnection! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Path of the organization. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  path: String! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Projects within this organization that the user has access to. Introduced in 16.8: This feature is an Experiment. It can be changed or removed at any time."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  "Web URL of the organization. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  webUrl: String! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"The connection type for Organization."
type OrganizationConnection {
  "A list of edges."
  edges: [OrganizationEdge]
  "A list of nodes."
  nodes: [Organization]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of OrganizationCreate."
type OrganizationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after mutation."
  organization: Organization
}

"An edge in a connection."
type OrganizationEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Organization
}

"Represents the total number of organizations for the represented states."
type OrganizationStateCounts {
  "Number of organizations with state `ACTIVE`"
  active: Int
  "Number of organizations with state `ALL`"
  all: Int
  "Number of organizations with state `INACTIVE`"
  inactive: Int
}

"Autogenerated return type of OrganizationUpdate."
type OrganizationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Organization after mutation."
  organization: Organization
}

"A user with access to the organization."
type OrganizationUser {
  "Badges describing the user within the organization. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  badges: [OrganizationUserBadge!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "ID of the organization user. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  id: ID! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "User that is associated with the organization. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  user: UserCore! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
}

"An organization user badge."
type OrganizationUserBadge {
  "Badge text."
  text: String!
  "Badge variant."
  variant: String!
}

"The connection type for OrganizationUser."
type OrganizationUserConnection {
  "A list of edges."
  edges: [OrganizationUserEdge]
  "A list of nodes."
  nodes: [OrganizationUser]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type OrganizationUserEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OrganizationUser
}

"Represents a package with pipelines in the Package Registry"
type Package {
  "Map of links to perform actions on the package."
  _links: PackageLinks!
  "Whether the user can destroy the package. Deprecated in 16.6: Superseded by `user_permissions` field. See `Types::PermissionTypes::Package` type."
  canDestroy: Boolean! @deprecated(reason: "Superseded by `user_permissions` field. See `Types::PermissionTypes::Package` type. Deprecated in 16.6.")
  "Date of creation."
  createdAt: Time!
  "ID of the package."
  id: PackagesPackageID!
  "Package metadata."
  metadata: PackageMetadata
  "Name of the package."
  name: String!
  "Package type."
  packageType: PackageTypeEnum!
  """

  Pipelines that built the package. Max page size 20.
  """
  pipelines(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Project where the package is stored."
  project: Project!
  "Package status."
  status: PackageStatus!
  "Status message."
  statusMessage: String
  "Package tags."
  tags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageTagConnection
  "Date of most recent update."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PackagePermissions!
  "Version string."
  version: String
}

"Represents a package in the Package Registry"
type PackageBase {
  "Map of links to perform actions on the package."
  _links: PackageLinks!
  "Whether the user can destroy the package. Deprecated in 16.6: Superseded by `user_permissions` field. See `Types::PermissionTypes::Package` type."
  canDestroy: Boolean! @deprecated(reason: "Superseded by `user_permissions` field. See `Types::PermissionTypes::Package` type. Deprecated in 16.6.")
  "Date of creation."
  createdAt: Time!
  "ID of the package."
  id: PackagesPackageID!
  "Package metadata."
  metadata: PackageMetadata
  "Name of the package."
  name: String!
  "Package type."
  packageType: PackageTypeEnum!
  "Project where the package is stored."
  project: Project!
  "Package status."
  status: PackageStatus!
  "Status message."
  statusMessage: String
  "Package tags."
  tags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageTagConnection
  "Date of most recent update."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PackagePermissions!
  "Version string."
  version: String
}

"The connection type for PackageBase."
type PackageBaseConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PackageBaseEdge]
  "A list of nodes."
  nodes: [PackageBase]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PackageBaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageBase
}

"Represents a composer JSON file"
type PackageComposerJsonType {
  "License set in the Composer JSON file."
  license: String
  "Name set in the Composer JSON file."
  name: String
  "Type set in the Composer JSON file."
  type: String
  "Version set in the Composer JSON file."
  version: String
}

"The connection type for Package."
type PackageConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PackageEdge]
  "A list of nodes."
  nodes: [Package]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Represents a package dependency."
type PackageDependency {
  "ID of the dependency."
  id: PackagesDependencyID!
  "Name of the dependency."
  name: String!
  "Version pattern of the dependency."
  versionPattern: String!
}

"Represents a package dependency link"
type PackageDependencyLink {
  "Dependency."
  dependency: PackageDependency
  "Dependency type."
  dependencyType: PackageDependencyType!
  "ID of the dependency link."
  id: PackagesDependencyLinkID!
  "Dependency link metadata."
  metadata: DependencyLinkMetadata
}

"The connection type for PackageDependencyLink."
type PackageDependencyLinkConnection {
  "A list of edges."
  edges: [PackageDependencyLinkEdge]
  "A list of nodes."
  nodes: [PackageDependencyLink]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PackageDependencyLinkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageDependencyLink
}

"Represents a package details in the Package Registry"
type PackageDetailsType {
  "Map of links to perform actions on the package."
  _links: PackageLinks!
  "Whether the user can destroy the package. Deprecated in 16.6: Superseded by `user_permissions` field. See `Types::PermissionTypes::Package` type."
  canDestroy: Boolean! @deprecated(reason: "Superseded by `user_permissions` field. See `Types::PermissionTypes::Package` type. Deprecated in 16.6.")
  "Url of the Composer setup endpoint."
  composerConfigRepositoryUrl: String
  "Url of the Composer endpoint."
  composerUrl: String
  "Url of the Conan project endpoint."
  conanUrl: String
  "Date of creation."
  createdAt: Time!
  "Dependency link."
  dependencyLinks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageDependencyLinkConnection
  "ID of the package."
  id: PackagesPackageID!
  "Last time that a file of this package was downloaded."
  lastDownloadedAt: Time
  "Url of the Maven project endpoint."
  mavenUrl: String
  "Package metadata."
  metadata: PackageMetadata
  "Name of the package."
  name: String!
  "Url of the NPM project endpoint."
  npmUrl: String
  "Url of the Nuget project endpoint."
  nugetUrl: String
  "Package files."
  packageFiles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageFileConnection
  "Package type."
  packageType: PackageTypeEnum!
  """

  Pipelines that built the package. Max page size 20.
  """
  pipelines(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Project where the package is stored."
  project: Project!
  "Indicates if there is public access to the package."
  publicPackage: Boolean
  "Url of the PyPi project setup endpoint."
  pypiSetupUrl: String
  "Url of the PyPi project endpoint."
  pypiUrl: String
  "Package status."
  status: PackageStatus!
  "Status message."
  statusMessage: String
  "Package tags."
  tags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageTagConnection
  "Date of most recent update."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PackagePermissions!
  "Version string."
  version: String
  "Other versions of the package."
  versions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackageBaseConnection
}

"An edge in a connection."
type PackageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Package
}

"Represents a package file"
type PackageFile {
  "Created date."
  createdAt: Time!
  "Download path of the package file."
  downloadPath: String!
  "Md5 of the package file."
  fileMd5: String
  "File metadata."
  fileMetadata: PackageFileMetadata
  "Name of the package file."
  fileName: String!
  "Sha1 of the package file."
  fileSha1: String
  "Sha256 of the package file."
  fileSha256: String
  "ID of the file."
  id: PackagesPackageFileID!
  "Size of the package file."
  size: String!
  "Updated date."
  updatedAt: Time!
}

"The connection type for PackageFile."
type PackageFileConnection {
  "A list of edges."
  edges: [PackageFileEdge]
  "A list of nodes."
  nodes: [PackageFile]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PackageFileEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageFile
}

"Represents the Geo sync and verification state of a package file"
type PackageFileRegistry {
  "Timestamp when the PackageFileRegistry was created"
  createdAt: Time
  "ID of the PackageFileRegistry"
  id: ID!
  "Error message during sync of the PackageFileRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the PackageFileRegistry"
  lastSyncedAt: Time
  "ID of the PackageFile."
  packageFileId: ID!
  "Timestamp after which the PackageFileRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the PackageFileRegistry"
  retryCount: Int
  "Sync state of the PackageFileRegistry"
  state: RegistryState
  "The local checksum of the PackageFileRegistry"
  verificationChecksum: String
  "Error message during verification of the PackageFileRegistry"
  verificationFailure: String
  "Timestamp after which the PackageFileRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the PackageFileRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of PackageFileRegistry"
  verificationStartedAt: Time
  "Verification state of the PackageFileRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the PackageFileRegistry"
  verifiedAt: Time
}

"The connection type for PackageFileRegistry."
type PackageFileRegistryConnection {
  "A list of edges."
  edges: [PackageFileRegistryEdge]
  "A list of nodes."
  nodes: [PackageFileRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PackageFileRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageFileRegistry
}

"Represents a Helm dependency"
type PackageHelmDependencyType {
  "Alias of the dependency."
  alias: String
  "Condition of the dependency."
  condition: String
  "Indicates the dependency is enabled."
  enabled: Boolean
  "Import-values of the dependency."
  importValues: [JSON!]
  "Name of the dependency."
  name: String
  "Repository of the dependency."
  repository: String
  "Tags of the dependency."
  tags: [String!]
  "Version of the dependency."
  version: String
}

"Represents a Helm maintainer"
type PackageHelmMaintainerType {
  "Email of the maintainer."
  email: String
  "Name of the maintainer."
  name: String
  "URL of the maintainer."
  url: String
}

"Represents the contents of a Helm Chart.yml file"
type PackageHelmMetadataType {
  "Annotations for the chart."
  annotations: JSON
  "API version of the chart."
  apiVersion: String!
  "App version of the chart."
  appVersion: String
  "Condition for the chart."
  condition: String
  "Dependencies of the chart."
  dependencies: [PackageHelmDependencyType!]
  "Indicates if the chart is deprecated."
  deprecated: Boolean
  "Description of the chart."
  description: String
  "URL of the home page."
  home: String
  "URL to an SVG or PNG image for the chart."
  icon: String
  "Keywords for the chart."
  keywords: [String!]
  "Kubernetes versions for the chart."
  kubeVersion: String
  "Maintainers of the chart."
  maintainers: [PackageHelmMaintainerType!]
  "Name of the chart."
  name: String!
  "URLs of the source code for the chart."
  sources: [String!]
  "Tags for the chart."
  tags: String
  "Type of the chart."
  type: String
  "Version of the chart."
  version: String!
}

"Represents links to perform actions on the package"
type PackageLinks {
  "Path to the package details page."
  webPath: String
}

type PackagePermissions {
  "If `true`, the user can perform `destroy_package` on this resource"
  destroyPackage: Boolean!
}

"Namespace-level Package Registry settings"
type PackageSettings {
  "When generic_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  genericDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate generic packages are allowed for this namespace."
  genericDuplicatesAllowed: Boolean!
  "Indicates whether Maven package forwarding is locked for all descendent namespaces."
  lockMavenPackageRequestsForwarding: Boolean!
  "Indicates whether npm package forwarding is locked for all descendent namespaces."
  lockNpmPackageRequestsForwarding: Boolean!
  "Indicates whether PyPI package forwarding is locked for all descendent namespaces."
  lockPypiPackageRequestsForwarding: Boolean!
  "When maven_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  mavenDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate Maven packages are allowed for this namespace."
  mavenDuplicatesAllowed: Boolean!
  "Indicates whether Maven package forwarding is allowed for this namespace."
  mavenPackageRequestsForwarding: Boolean
  "Indicates whether Maven package forwarding settings are locked by a parent namespace."
  mavenPackageRequestsForwardingLocked: Boolean!
  "Indicates whether npm package forwarding is allowed for this namespace."
  npmPackageRequestsForwarding: Boolean
  "Indicates whether npm package forwarding settings are locked by a parent namespace."
  npmPackageRequestsForwardingLocked: Boolean!
  "When nuget_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. "
  nugetDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate NuGet packages are allowed for this namespace."
  nugetDuplicatesAllowed: Boolean!
  "Indicates wheather the NuGet symbol server is enabled for this namespace."
  nugetSymbolServerEnabled: Boolean!
  "Indicates whether PyPI package forwarding is allowed for this namespace."
  pypiPackageRequestsForwarding: Boolean
  "Indicates whether PyPI package forwarding settings are locked by a parent namespace."
  pypiPackageRequestsForwardingLocked: Boolean!
  "When terraform_module_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  terraformModuleDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate Terraform packages are allowed for this namespace."
  terraformModuleDuplicatesAllowed: Boolean!
}

"Represents a package tag"
type PackageTag {
  "Created date."
  createdAt: Time!
  "ID of the tag."
  id: ID!
  "Name of the tag."
  name: String!
  "Updated date."
  updatedAt: Time!
}

"The connection type for PackageTag."
type PackageTagConnection {
  "A list of edges."
  edges: [PackageTagEdge]
  "A list of nodes."
  nodes: [PackageTag]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PackageTagEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackageTag
}

"A packages cleanup policy designed to keep only packages and packages assets that matter most"
type PackagesCleanupPolicy {
  "Number of duplicated package files to retain."
  keepNDuplicatedPackageFiles: PackagesCleanupKeepDuplicatedPackageFilesEnum!
  "Next time that this packages cleanup policy will be executed."
  nextRunAt: Time
}

"A packages protection rule designed to protect packages from being pushed by users with a certain access level."
type PackagesProtectionRule {
  "ID of the package protection rule."
  id: PackagesProtectionRuleID!
  "Package name protected by the protection rule. For example `@my-scope/my-package-*`. Wildcard character `*` allowed."
  packageNamePattern: String!
  "Package type protected by the protection rule. For example `NPM`."
  packageType: PackagesProtectionRulePackageType!
  "Max GitLab access level unable to push a package. For example `DEVELOPER`, `MAINTAINER`, `OWNER`."
  pushProtectedUpToAccessLevel: PackagesProtectionRuleAccessLevel!
}

"The connection type for PackagesProtectionRule."
type PackagesProtectionRuleConnection {
  "A list of edges."
  edges: [PackagesProtectionRuleEdge]
  "A list of nodes."
  nodes: [PackagesProtectionRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PackagesProtectionRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PackagesProtectionRule
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

"Represents the Geo replication and verification state of a pages_deployment"
type PagesDeploymentRegistry {
  "Timestamp when the PagesDeploymentRegistry was created"
  createdAt: Time
  "ID of the PagesDeploymentRegistry"
  id: ID!
  "Error message during sync of the PagesDeploymentRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the PagesDeploymentRegistry"
  lastSyncedAt: Time
  "ID of the Pages Deployment."
  pagesDeploymentId: ID!
  "Timestamp after which the PagesDeploymentRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the PagesDeploymentRegistry"
  retryCount: Int
  "Sync state of the PagesDeploymentRegistry"
  state: RegistryState
  "The local checksum of the PagesDeploymentRegistry"
  verificationChecksum: String
  "Error message during verification of the PagesDeploymentRegistry"
  verificationFailure: String
  "Timestamp after which the PagesDeploymentRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the PagesDeploymentRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of PagesDeploymentRegistry"
  verificationStartedAt: Time
  "Verification state of the PagesDeploymentRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the PagesDeploymentRegistry"
  verifiedAt: Time
}

"The connection type for PagesDeploymentRegistry."
type PagesDeploymentRegistryConnection {
  "A list of edges."
  edges: [PagesDeploymentRegistryEdge]
  "A list of nodes."
  nodes: [PagesDeploymentRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PagesDeploymentRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PagesDeploymentRegistry
}

"Autogenerated return type of PagesMarkOnboardingComplete."
type PagesMarkOnboardingCompletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Indicates the new onboarding_complete state of the project's Pages metadata."
  onboardingComplete: Boolean!
}

"Represents a file or directory in the project repository that has been locked."
type PathLock {
  "ID of the path lock."
  id: PathLockID!
  "Locked path."
  path: String
  "User that has locked this path."
  user: UserCore
}

"The connection type for PathLock."
type PathLockConnection {
  "A list of edges."
  edges: [PathLockEdge]
  "A list of nodes."
  nodes: [PathLock]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PathLockEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PathLock
}

"Represents a Pending Group Membership"
type PendingGroupMember implements MemberInterface {
  "GitLab::Access level."
  accessLevel: AccessLevel
  "Whether the pending group member has been approved."
  approved: Boolean
  "URL to avatar image file of the pending group member."
  avatarUrl: String
  "Date and time the membership was created."
  createdAt: Time
  "User that authorized membership."
  createdBy: UserCore
  "Public email of the pending group member."
  email: String
  "Date and time the membership expires."
  expiresAt: Time
  "Group that a user is a member of."
  group: Group
  "ID of the member."
  id: ID!
  "Whether the pending group member has been invited."
  invited: Boolean
  "Find a merge request."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Name of the pending group member."
  name: String
  "Group notification email for user. Only available for admins."
  notificationEmail: String
  "Date and time the membership was last updated."
  updatedAt: Time
  "User that is associated with the member object."
  user: UserCore
  "Permissions for the current user on the resource"
  userPermissions: GroupPermissions!
  "Username of the pending group member."
  username: String
  "Web URL of the pending group member."
  webUrl: String
}

"The connection type for PendingGroupMember."
type PendingGroupMemberConnection {
  "A list of edges."
  edges: [PendingGroupMemberEdge]
  "A list of nodes."
  nodes: [PendingGroupMember]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PendingGroupMemberEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PendingGroupMember
}

type Pipeline {
  "Indicates if the pipeline is active."
  active: Boolean!
  "Base SHA of the source branch."
  beforeSha: String
  "Specifies if a pipeline can be canceled."
  cancelable: Boolean!
  "If the pipeline is a child or not"
  child: Boolean!
  "Code Quality report summary for a pipeline."
  codeQualityReportSummary: CodeQualityReportSummary
  "Code Quality degradations reported on the pipeline."
  codeQualityReports(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CodeQualityDegradationConnection
  "Git commit of the pipeline."
  commit: Commit
  "Path to the commit that triggered the pipeline."
  commitPath: String
  "Timestamp of the pipeline's commit."
  committedAt: Time
  "Indicates if a pipeline is complete."
  complete: Boolean!
  "Total minutes consumed by the pipeline."
  computeMinutes: Float
  "Configuration source of the pipeline (UNKNOWN_SOURCE, REPOSITORY_SOURCE, AUTO_DEVOPS_SOURCE, WEBIDE_SOURCE, REMOTE_SOURCE, EXTERNAL_PROJECT_SOURCE, BRIDGE_SOURCE, PARAMETER_SOURCE, COMPLIANCE_SOURCE, SECURITY_POLICIES_DEFAULT_SOURCE)"
  configSource: PipelineConfigSourceEnum
  "Coverage percentage."
  coverage: Float
  "Timestamp of the pipeline's creation."
  createdAt: Time!
  "DAST profile associated with the pipeline."
  dastProfile: DastProfile
  "Detailed status of the pipeline."
  detailedStatus: DetailedStatus!
  "Pipelines this pipeline will trigger."
  downstream(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineConnection
  "Duration of the pipeline in seconds."
  duration: Int
  "The reason why the pipeline failed"
  failureReason: String
  "Timestamp of the pipeline's completion."
  finishedAt: Time
  "ID of the pipeline."
  id: ID!
  "Internal ID of the pipeline."
  iid: String!
  "Specific job in this pipeline, either by name or ID."
  job(
    "ID of the job."
    id: JobID,
    "Name of the job."
    name: String
  ): CiJob
  "Job artifacts of the pipeline."
  jobArtifacts: [CiJobArtifact!]
  "Jobs belonging to the pipeline."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter jobs by kind."
    jobKind: CiJobKind,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter jobs by retry-status."
    retried: Boolean,
    "Filter jobs by the type of security report they produce."
    securityReportTypes: [SecurityReportTypeEnum!],
    "Filter jobs by status."
    statuses: [CiJobStatus!],
    "Filter jobs by when they are executed."
    whenExecuted: [String!]
  ): CiJobConnection
  "If the pipeline is the latest one or not"
  latest: Boolean!
  "The MR which the Pipeline is attached to"
  mergeRequest: MergeRequest
  "Event type of the pipeline associated with a merge request."
  mergeRequestEventType: PipelineMergeRequestEventType
  "Name of the pipeline."
  name: String
  "Relative path to the pipeline's page."
  path: String
  "Project the pipeline belongs to."
  project: Project
  "How long the pipeline was queued before starting."
  queuedDuration: Duration
  "Reference to the branch from which the pipeline was triggered."
  ref: String
  "Reference path to the branch from which the pipeline was triggered."
  refPath: String
  "The reference text from the presenter"
  refText: String!
  "Specifies if a pipeline can be retried."
  retryable: Boolean!
  "Vulnerability finding reported on the pipeline."
  securityReportFinding(
    "UUID of the security report finding."
    uuid: String!
  ): PipelineSecurityReportFinding
  "Vulnerability findings reported on the pipeline. By default all the states except dismissed are included in the response."
  securityReportFindings(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter vulnerability findings by report type."
    reportType: [String!],
    "Filter vulnerability findings by Scanner.externalId."
    scanner: [String!],
    "Filter vulnerability findings by severity."
    severity: [String!],
    "Filter vulnerability findings by state."
    state: [VulnerabilityState!]
  ): PipelineSecurityReportFindingConnection
  "Vulnerability and scanned resource counts for each security scanner of the pipeline."
  securityReportSummary: SecurityReportSummary
  "SHA of the pipeline's commit."
  sha(
    "Format of the SHA."
    format: ShaFormat
  ): String
  "The source of the pipeline"
  source: String
  "Job where pipeline was triggered from."
  sourceJob: CiJob
  "Stages of the pipeline."
  stages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiStageConnection
  "Timestamp when the pipeline was started."
  startedAt: Time
  "Status of the pipeline (CREATED, WAITING_FOR_RESOURCE, PREPARING, WAITING_FOR_CALLBACK, PENDING, RUNNING, FAILED, SUCCESS, CANCELED, SKIPPED, MANUAL, SCHEDULED)"
  status: PipelineStatusEnum!
  "If the pipeline is stuck."
  stuck: Boolean!
  "Summary of the test report generated by the pipeline."
  testReportSummary: TestReportSummary!
  "A specific test suite in a pipeline test report."
  testSuite(
    "IDs of the builds used to run the test suite."
    buildIds: [ID!]!
  ): TestSuite
  "The total number of jobs in the pipeline"
  totalJobs: Int!
  "The path that triggered this pipeline"
  triggeredByPath: String
  "Timestamp of the pipeline's last activity."
  updatedAt: Time!
  "Pipeline that triggered the pipeline."
  upstream: Pipeline
  "Pipeline user."
  user: UserCore
  "Permissions for the current user on the resource"
  userPermissions: PipelinePermissions!
  "Indicates if the pipeline has jobs with `needs` dependencies."
  usesNeeds: Boolean
  "Pipeline warning messages."
  warningMessages: [PipelineMessage!]
  "Indicates if a pipeline has warnings."
  warnings: Boolean!
}

type PipelineAnalytics {
  "Labels for the monthly pipeline count."
  monthPipelinesLabels: [String!]
  "Total monthly successful pipeline count."
  monthPipelinesSuccessful: [Int!]
  "Total monthly pipeline count."
  monthPipelinesTotals: [Int!]
  "Pipeline times labels."
  pipelineTimesLabels: [String!]
  "Pipeline times."
  pipelineTimesValues: [Int!]
  "Labels for the weekly pipeline count."
  weekPipelinesLabels: [String!]
  "Total weekly successful pipeline count."
  weekPipelinesSuccessful: [Int!]
  "Total weekly pipeline count."
  weekPipelinesTotals: [Int!]
  "Labels for the yearly pipeline count."
  yearPipelinesLabels: [String!]
  "Total yearly successful pipeline count."
  yearPipelinesSuccessful: [Int!]
  "Total yearly pipeline count."
  yearPipelinesTotals: [Int!]
}

"Represents the Geo sync and verification state of a pipeline artifact"
type PipelineArtifactRegistry {
  "Timestamp when the PipelineArtifactRegistry was created"
  createdAt: Time
  "ID of the PipelineArtifactRegistry"
  id: ID!
  "Error message during sync of the PipelineArtifactRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the PipelineArtifactRegistry"
  lastSyncedAt: Time
  "ID of the pipeline artifact."
  pipelineArtifactId: ID!
  "Timestamp after which the PipelineArtifactRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the PipelineArtifactRegistry"
  retryCount: Int
  "Sync state of the PipelineArtifactRegistry"
  state: RegistryState
  "The local checksum of the PipelineArtifactRegistry"
  verificationChecksum: String
  "Error message during verification of the PipelineArtifactRegistry"
  verificationFailure: String
  "Timestamp after which the PipelineArtifactRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the PipelineArtifactRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of PipelineArtifactRegistry"
  verificationStartedAt: Time
  "Verification state of the PipelineArtifactRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the PipelineArtifactRegistry"
  verifiedAt: Time
}

"The connection type for PipelineArtifactRegistry."
type PipelineArtifactRegistryConnection {
  "A list of edges."
  edges: [PipelineArtifactRegistryEdge]
  "A list of nodes."
  nodes: [PipelineArtifactRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PipelineArtifactRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineArtifactRegistry
}

"Autogenerated return type of PipelineCancel."
type PipelineCancelPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"The connection type for Pipeline."
type PipelineConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PipelineEdge]
  "A list of nodes."
  nodes: [Pipeline]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Represents pipeline counts for the project"
type PipelineCounts {
  "Total number of pipelines for the project."
  all: Int
  "Number of pipelines with scope FINISHED for the project"
  finished: Int
  "Number of pipelines with scope PENDING for the project"
  pending: Int
  "Number of pipelines with scope RUNNING for the project"
  running: Int
}

"Autogenerated return type of PipelineDestroy."
type PipelineDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type PipelineEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Pipeline
}

type PipelineMessage {
  "Content of the pipeline message."
  content: String!
  "ID of the pipeline message."
  id: ID!
}

type PipelinePermissions {
  "If `true`, the user can perform `admin_pipeline` on this resource"
  adminPipeline: Boolean!
  "If `true`, the user can perform `cancel_pipeline` on this resource"
  cancelPipeline: Boolean!
  "If `true`, the user can perform `destroy_pipeline` on this resource"
  destroyPipeline: Boolean!
  "If `true`, the user can perform `update_pipeline` on this resource"
  updatePipeline: Boolean!
}

"Autogenerated return type of PipelineRetry."
type PipelineRetryPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Pipeline after mutation."
  pipeline: Pipeline
}

"Represents a pipeline schedule"
type PipelineSchedule {
  "Indicates if the pipeline schedule is active."
  active: Boolean!
  "Timestamp of when the pipeline schedule was created."
  createdAt: Time!
  "Cron notation for the schedule."
  cron: String!
  "Timezone for the pipeline schedule."
  cronTimezone: String!
  "Description of the pipeline schedule."
  description: String
  "Edit path of the pipeline schedule."
  editPath: String
  "Indicates if a pipelines schedule belongs to a tag."
  forTag: Boolean!
  "ID of the pipeline schedule."
  id: ID!
  "Last pipeline object."
  lastPipeline: Pipeline
  "Time when the next pipeline will run."
  nextRunAt: Time!
  "Owner of the pipeline schedule."
  owner: UserCore
  "Project of the pipeline schedule."
  project: Project
  "Time when the next pipeline will run."
  realNextRun: Time!
  "Ref of the pipeline schedule."
  ref: String
  "Git ref for the pipeline schedule."
  refForDisplay: String
  "Path to the ref that triggered the pipeline."
  refPath: String
  "Timestamp of when the pipeline schedule was last updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: PipelineSchedulePermissions!
  "Pipeline schedule variables."
  variables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineScheduleVariableConnection
}

"The connection type for PipelineSchedule."
type PipelineScheduleConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PipelineScheduleEdge]
  "A list of nodes."
  nodes: [PipelineSchedule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of PipelineScheduleCreate."
type PipelineScheduleCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created pipeline schedule."
  pipelineSchedule: PipelineSchedule
}

"Autogenerated return type of PipelineScheduleDelete."
type PipelineScheduleDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type PipelineScheduleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineSchedule
}

type PipelineSchedulePermissions {
  "If `true`, the user can perform `admin_pipeline_schedule` on this resource"
  adminPipelineSchedule: Boolean!
  "If `true`, the user can perform `play_pipeline_schedule` on this resource"
  playPipelineSchedule: Boolean!
  "If `true`, the user can perform `take_ownership_pipeline_schedule` on this resource Deprecated in 15.9: Use admin_pipeline_schedule permission to determine if the user can take ownership of a pipeline schedule."
  takeOwnershipPipelineSchedule: Boolean! @deprecated(reason: "Use admin_pipeline_schedule permission to determine if the user can take ownership of a pipeline schedule. Deprecated in 15.9.")
  "If `true`, the user can perform `update_pipeline_schedule` on this resource"
  updatePipelineSchedule: Boolean!
}

"Autogenerated return type of PipelineSchedulePlay."
type PipelineSchedulePlayPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Pipeline schedule after mutation."
  pipelineSchedule: PipelineSchedule
}

"Autogenerated return type of PipelineScheduleTakeOwnership."
type PipelineScheduleTakeOwnershipPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated pipeline schedule ownership."
  pipelineSchedule: PipelineSchedule
}

"Autogenerated return type of PipelineScheduleUpdate."
type PipelineScheduleUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated pipeline schedule."
  pipelineSchedule: PipelineSchedule
}

type PipelineScheduleVariable implements CiVariable {
  "ID of the variable."
  id: ID!
  "Name of the variable."
  key: String
  "Indicates whether the variable is raw."
  raw: Boolean
  "Value of the variable."
  value: String
  "Type of the variable."
  variableType: CiVariableType
}

"The connection type for PipelineScheduleVariable."
type PipelineScheduleVariableConnection {
  "A list of edges."
  edges: [PipelineScheduleVariableEdge]
  "A list of nodes."
  nodes: [PipelineScheduleVariable]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PipelineScheduleVariableEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineScheduleVariable
}

"Represents vulnerability finding of a security report on the pipeline."
type PipelineSecurityReportFinding {
  "List of assets associated with the vulnerability."
  assets: [AssetType!]
  "Description of the vulnerability finding."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Details of the security finding."
  details: [VulnerabilityDetail!]!
  "Reason for the dismissal of the security report finding."
  dismissalReason: VulnerabilityDismissalReason
  "Time of the dismissal of the security report finding."
  dismissedAt: Time
  "User who dismissed the security report finding."
  dismissedBy: UserCore
  "Evidence for the vulnerability."
  evidence: VulnerabilityEvidence
  "Indicates whether the vulnerability is a false positive."
  falsePositive: Boolean
  "Identifiers of the vulnerability finding."
  identifiers: [VulnerabilityIdentifier!]!
  "List of issue links related to the vulnerability."
  issueLinks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityIssueLinkConnection
  "List of links associated with the vulnerability."
  links: [VulnerabilityLink!]
  "Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability."
  location: VulnerabilityLocation
  "Merge request that fixes the vulnerability."
  mergeRequest: MergeRequest
  "Project on which the vulnerability finding was found."
  project: Project
  "Same as uuid. It is strongly suggested to use the uuid field instead. Deprecated in 16.1: Use uuid instead."
  projectFingerprint: String @deprecated(reason: "Use uuid instead. Deprecated in 16.1.")
  "Remediations of the security report finding."
  remediations: [VulnerabilityRemediationType!]
  "Type of the security report that found the vulnerability finding."
  reportType: VulnerabilityReportType
  "Scanner metadata for the vulnerability."
  scanner: VulnerabilityScanner
  "Severity of the vulnerability finding."
  severity: VulnerabilitySeverity
  "Solution for resolving the security report finding."
  solution: String
  "Finding status."
  state: VulnerabilityState
  "Comment for the state of the security report finding."
  stateComment: String
  "Title of the vulnerability finding."
  title: String
  "UUIDv5 digest based on the vulnerability's report type, primary identifier, location, fingerprint, project identifier."
  uuid: String
  "Vulnerability related to the security report finding."
  vulnerability: Vulnerability
}

"The connection type for PipelineSecurityReportFinding."
type PipelineSecurityReportFindingConnection {
  "A list of edges."
  edges: [PipelineSecurityReportFindingEdge]
  "A list of nodes."
  nodes: [PipelineSecurityReportFinding]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PipelineSecurityReportFindingEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineSecurityReportFinding
}

type PipelineTrigger {
  "Indicates if the pipeline trigger token has access to the project."
  canAccessProject: Boolean!
  "Description of the pipeline trigger token."
  description: String
  "Indicates if the token is exposed."
  hasTokenExposed: Boolean!
  "ID of the pipeline trigger token."
  id: ID!
  "Timestamp of the last usage of the pipeline trigger token."
  lastUsed: Time
  "Owner of the pipeline trigger token."
  owner: UserCore!
  "Value of the pipeline trigger token."
  token: String!
}

"The connection type for PipelineTrigger."
type PipelineTriggerConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [PipelineTriggerEdge]
  "A list of nodes."
  nodes: [PipelineTrigger]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of PipelineTriggerCreate."
type PipelineTriggerCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mutated pipeline trigger token."
  pipelineTrigger: PipelineTrigger
}

"Autogenerated return type of PipelineTriggerDelete."
type PipelineTriggerDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type PipelineTriggerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PipelineTrigger
}

"Autogenerated return type of PipelineTriggerUpdate."
type PipelineTriggerUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mutated pipeline trigger token."
  pipelineTrigger: PipelineTrigger
}

type PolicyApprovalGroup {
  "Avatar URL of the group."
  avatarUrl: String
  "Full path of the namespace."
  fullPath: ID!
  "ID of the namespace."
  id: ID!
  "Web URL of the group."
  webUrl: String!
}

type PreviewBillableUserChange {
  "Total number of billable users after change."
  newBillableUserCount: Int
  "Number of seats in subscription."
  seatsInSubscription: Int
  " If the group will have an increased overage after change."
  willIncreaseOverage: Boolean
}

type Project {
  "Size limit for the repository in bytes."
  actualRepositorySizeLimit: Float
  "Agent configurations defined by the project"
  agentConfigurations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AgentConfigurationConnection
  "A single Alert Management alert of the project."
  alertManagementAlert(
    "Username of a user assigned to the issue."
    assigneeUsername: String,
    "Filter query for given domain."
    domain: AlertManagementDomainFilter! = operations,
    "IID of the alert. For example, \"1\"."
    iid: String,
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Sort alerts by this criteria."
    sort: AlertManagementAlertSort,
    "Alerts with the specified statues. For example, `[TRIGGERED]`."
    statuses: [AlertManagementStatus!]
  ): AlertManagementAlert
  "Counts of alerts by status for the project."
  alertManagementAlertStatusCounts(
    "Username of a user assigned to the issue."
    assigneeUsername: String,
    "Search query for title, description, service, or monitoring_tool."
    search: String
  ): AlertManagementAlertStatusCountsType
  "Alert Management alerts of the project."
  alertManagementAlerts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Username of a user assigned to the issue."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter query for given domain."
    domain: AlertManagementDomainFilter! = operations,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the alert. For example, \"1\"."
    iid: String,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for title, description, service, or monitoring_tool."
    search: String,
    "Sort alerts by this criteria."
    sort: AlertManagementAlertSort,
    "Alerts with the specified statues. For example, `[TRIGGERED]`."
    statuses: [AlertManagementStatus!]
  ): AlertManagementAlertConnection
  "HTTP Integrations which can receive alerts for the project."
  alertManagementHttpIntegrations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of the integration."
    id: AlertManagementHttpIntegrationID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AlertManagementHttpIntegrationConnection
  "Integrations which can receive alerts for the project."
  alertManagementIntegrations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of the integration."
    id: GlobalID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AlertManagementIntegrationConnection
  "Extract alert fields from payload for custom mapping."
  alertManagementPayloadFields(
    "Sample payload for extracting alert fields for custom mappings."
    payloadExample: String!
  ): [AlertManagementPayloadAlertField!]
  "If `only_allow_merge_if_pipeline_succeeds` is true, indicates if merge requests of the project can also be merged with skipped jobs."
  allowMergeOnSkippedPipeline: Boolean
  "Project allows assigning multiple users to a merge request."
  allowsMultipleMergeRequestAssignees: Boolean!
  "Project allows assigning multiple reviewers to a merge request."
  allowsMultipleMergeRequestReviewers: Boolean!
  "API fuzzing configuration for the project. "
  apiFuzzingCiConfiguration: ApiFuzzingCiConfiguration
  "Indicates the archived status of the project."
  archived: Boolean
  "Indicates if issues referenced by merge requests and commits within the default branch are closed automatically."
  autocloseReferencedIssues: Boolean
  "Search users for autocompletion"
  autocompleteUsers(
    "Query to search users by name, username, or public email."
    search: String
  ): [AutocompletedUser!]
  "URL to avatar image file of the project."
  avatarUrl: String
  "A single board of the project."
  board(
    "ID of the board."
    id: BoardID!
  ): Board
  "Boards of the project."
  boards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Find a board by its ID."
    id: BoardID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "Branch rules configured for the project."
  branchRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BranchRuleConnection
  "Authorized cluster agents for the project through ci_access keyword."
  ciAccessAuthorizedAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentAuthorizationCiAccessConnection
  "CI/CD settings for the project."
  ciCdSettings: ProjectCiCdSetting
  "Path of the CI configuration file."
  ciConfigPathOrDefault: String!
  "CI/CD config variable. Introduced in 15.3: This feature is an Experiment. It can be changed or removed at any time."
  ciConfigVariables(
    "Ref."
    ref: String!
  ): [CiConfigVariable!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.")
  "The CI Job Tokens scope of access."
  ciJobTokenScope: CiJobTokenScopeType
  "Pipeline subscriptions for projects subscribed to the project."
  ciSubscribedProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiSubscriptionsProjectConnection
  "Pipeline subscriptions for the project."
  ciSubscriptionsProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CiSubscriptionsProjectConnection
  "Find a single CI/CD template by name."
  ciTemplate(
    "Name of the CI/CD template to search for. Template must be formatted as `Name.gitlab-ci.yml`."
    name: String!
  ): CiTemplate
  "List of the project's CI/CD variables."
  ciVariables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Sort order of results."
    sort: CiVariableSort
  ): CiProjectVariableConnection
  "Find a single cluster agent by name."
  clusterAgent(
    "Returns only cluster agents which have an associated remote development agent config."
    hasRemoteDevelopmentAgentConfig: Boolean,
    "Returns only cluster agents which have been enabled with the remote development feature."
    hasRemoteDevelopmentEnabled: Boolean,
    "Returns only cluster agents which have vulnerabilities."
    hasVulnerabilities: Boolean,
    "Name of the cluster agent."
    name: String!
  ): ClusterAgent
  "Cluster agents associated with the project."
  clusterAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only cluster agents which have an associated remote development agent config."
    hasRemoteDevelopmentAgentConfig: Boolean,
    "Returns only cluster agents which have been enabled with the remote development feature."
    hasRemoteDevelopmentEnabled: Boolean,
    "Returns only cluster agents which have vulnerabilities."
    hasVulnerabilities: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentConnection
  "Code coverage summary associated with the project."
  codeCoverageSummary: CodeCoverageSummary
  "Get tag names containing a given commit. Introduced in 16.0: This feature is an Experiment. It can be changed or removed at any time."
  commitReferences(
    "Project commit SHA identifier. For example, `287774414568010855642518513f085491644061`."
    commitSha: String!
  ): CommitReferences @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
  "Compliance frameworks associated with the project."
  complianceFrameworks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ComplianceFrameworkConnection
  "Container expiration policy of the project."
  containerExpirationPolicy: ContainerExpirationPolicy
  "Indicates if Container Registry is enabled for the current user"
  containerRegistryEnabled: Boolean
  "Container repositories of the project."
  containerRepositories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter the container repositories by their name."
    name: String,
    "Sort container repositories by this criteria."
    sort: ContainerRepositorySort = created_desc
  ): ContainerRepositoryConnection
  "Number of container repositories in the project."
  containerRepositoriesCount: Int!
  "Find corpuses of the project."
  corpuses(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CoverageFuzzingCorpusConnection
  "Timestamp of the project creation."
  createdAt: Time
  "Visualizations of the project or associated configuration project. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  customizableDashboardVisualizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Slug of the visualization to return."
    slug: String
  ): CustomizableDashboardVisualizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Customizable dashboards for the project. Introduced in 15.6: This feature is an Experiment. It can be changed or removed at any time."
  customizableDashboards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Find by dashboard type."
    category: CustomizableDashboardCategory,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Find by dashboard slug."
    slug: String
  ): CustomizableDashboardConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.")
  "DAST Profile associated with the project."
  dastProfile(
    "Filter DAST Profiles by whether or not they have a schedule."
    hasDastProfileSchedule: Boolean,
    "ID of the DAST Profile."
    id: DastProfileID!
  ): DastProfile
  "DAST Profiles associated with the project."
  dastProfiles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter DAST Profiles by whether or not they have a schedule."
    hasDastProfileSchedule: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DastProfileConnection
  "DAST scanner profiles associated with the project."
  dastScannerProfiles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DastScannerProfileConnection
  "DAST Site Profile associated with the project."
  dastSiteProfile(
    "ID of the site profile."
    id: DastSiteProfileID!
  ): DastSiteProfile
  "DAST Site Profiles associated with the project."
  dastSiteProfiles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DastSiteProfileConnection
  "DAST Site Validations associated with the project."
  dastSiteValidations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Normalized URL of the target to be scanned."
    normalizedTargetUrls: [String!],
    "Status of the site validation."
    status: DastSiteValidationStatusEnum
  ): DastSiteValidationConnection
  "Data transfer data point for a specific period. This is mocked data under a development feature flag."
  dataTransfer(
    "Retain egress data for one year. Data for the current month will increase dynamically as egress occurs."
    from: Date,
    "End date for the data."
    to: Date
  ): ProjectDataTransfer
  "Software dependencies used by the project. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  dependencies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter dependencies by component names."
    componentNames: [String!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter dependencies by package managers."
    packageManagers: [PackageManager!],
    "Sort dependencies by given criteria."
    sort: DependencySort
  ): DependencyConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "Packages Dependency Proxy settings for the project. Requires the packages and dependency proxy to be enabled in the config. Requires the packages feature to be enabled at the project level. Returns `null` if `packages_dependency_proxy_maven` feature flag is disabled. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  dependencyProxyPackagesSetting: DependencyProxyPackagesSetting @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Details of the deployment of the project."
  deployment(
    "Project-level internal ID of the Deployment."
    iid: ID!
  ): Deployment
  "Short description of the project."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Detailed import status of the project."
  detailedImportStatus: DetailedImportStatus
  "Project's DORA metrics."
  dora: Dora
  "A single environment of the project."
  environment(
    "Name of the environment."
    name: String,
    "Search query for environment name."
    search: String,
    "States of environments that should be included in result."
    states: [String!],
    "Search query for environment type."
    type: String
  ): Environment
  "Environments of the project. This field can only be resolved for one project in any single request."
  environments(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Name of the environment."
    name: String,
    "Search query for environment name."
    search: String,
    "States of environments that should be included in result."
    states: [String!],
    "Search query for environment type."
    type: String
  ): EnvironmentConnection
  "Flow metrics for value stream analytics. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  flowMetrics: ProjectValueStreamAnalyticsFlowMetrics @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Details of the fork project compared to its upstream project. Introduced in 15.7: This feature is an Experiment. It can be changed or removed at any time."
  forkDetails(
    "Ref of the fork. Default value is HEAD."
    ref: String
  ): ForkDetails @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.7.")
  "Namespaces in which the current user can fork the project into."
  forkTargets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for path or name."
    search: String
  ): NamespaceConnection
  "Access level required for forking access."
  forkingAccessLevel: ProjectFeatureAccess
  "Number of times the project has been forked."
  forksCount: Int!
  "Full path of the project."
  fullPath: ID!
  "Preview Billable User Changes"
  gitlabSubscriptionsPreviewBillableUserChange(
    "Group ID to add."
    addGroupId: Int,
    "User emails to add."
    addUserEmails: [String!],
    "User IDs to add."
    addUserIds: [Int!],
    "Custom role assigned to the users."
    memberRoleId: Int,
    "Role of users being added to group."
    role: GitlabSubscriptionsUserRole!
  ): PreviewBillableUserChange
  "Grafana integration details for the project."
  grafanaIntegration: GrafanaIntegration
  "Group of the project."
  group: Group
  "Indicates whether Jira issue creation from vulnerabilities is enabled."
  hasJiraVulnerabilityIssueCreationEnabled: Boolean!
  "URL to connect to the project via HTTPS."
  httpUrlToRepo: String
  "ID of the project."
  id: ID!
  "Status of import background job of the project."
  importStatus: String
  "Incident Management escalation policies of the project."
  incidentManagementEscalationPolicies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Fuzzy search by escalation policy name."
    name: String
  ): EscalationPolicyTypeConnection
  "Incident Management escalation policy of the project."
  incidentManagementEscalationPolicy(
    "ID of the escalation policy."
    id: IncidentManagementEscalationPolicyID!,
    "Fuzzy search by escalation policy name."
    name: String
  ): EscalationPolicyType
  "Incident Management On-call schedules of the project."
  incidentManagementOncallSchedules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IIDs of on-call schedules."
    iids: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int
  ): IncidentManagementOncallScheduleConnection
  "Incident Management Timeline event associated with the incident."
  incidentManagementTimelineEvent(
    "ID of the timeline event."
    id: IncidentManagementTimelineEventID!,
    "ID of the incident."
    incidentId: IssueID!
  ): TimelineEventType
  "Timeline event tags for the project."
  incidentManagementTimelineEventTags: [TimelineEventTagType!]
  "Incident Management Timeline events associated with the incident."
  incidentManagementTimelineEvents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of the incident."
    incidentId: IssueID!,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelineEventTypeConnection
  "List of CI/CD variables the project inherited from its parent group and ancestors."
  inheritedCiVariables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Sort variables by the criteria."
    sort: CiGroupVariablesSort = CREATED_DESC
  ): InheritedCiVariableConnection
  "Indicates if a project is a catalog resource. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  isCatalogResource: Boolean @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "A single issue of the project."
  issue(
    "ID of a user assigned to the issues. Wildcard values \"NONE\" and \"ANY\" are supported."
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Issues closed after this date."
    closedAfter: Time,
    "Issues closed before this date."
    closedBefore: Time,
    "Filter for confidential issues. If \"false\", excludes confidential issues. If \"true\", returns only confidential issues."
    confidential: Boolean,
    "Issues created after this date."
    createdAfter: Time,
    "Issues created before this date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "ID of an epic associated with the issues, \"none\" and \"any\" values are supported."
    epicId: String,
    "Filter by epic ID wildcard. Incompatible with epicId."
    epicWildcardId: EpicWildcardId,
    "Health status of the issue, \"none\" and \"any\" values are supported."
    healthStatusFilter: HealthStatusFilter,
    "IID of the issue. For example, \"1\"."
    iid: String,
    "List of IIDs of issues. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Whether to include subepics when filtering issues by epicId."
    includeSubepics: Boolean,
    "Filter by a list of iteration cadence IDs."
    iterationCadenceId: [IterationsCadenceID!],
    "List of iteration Global IDs applied to the issue."
    iterationId: [ID],
    "Filter by iteration title."
    iterationTitle: String,
    "Filter by iteration ID wildcard."
    iterationWildcardId: IterationWildcardId,
    "Labels applied to this issue."
    labelName: [String],
    "Milestone applied to this issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Release tag associated with the issue's milestone."
    releaseTag: [String!],
    "Filter issues by release tag ID wildcard."
    releaseTagWildcardId: ReleaseTagWildcardId,
    "Search query for title or description."
    search: String,
    "Sort issues by this criteria."
    sort: IssueSort = created_desc,
    "Current state of this issue."
    state: IssuableState,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after this date."
    updatedAfter: Time,
    "Issues updated before this date."
    updatedBefore: Time,
    "Weight applied to the issue, \"none\" and \"any\" values are supported."
    weight: String,
    "Filter by weight ID wildcard. Incompatible with weight."
    weightWildcardId: WeightWildcardId
  ): Issue
  "Counts of issues by status for the project."
  issueStatusCounts(
    "ID of a user assigned to the issues. Wildcard values \"NONE\" and \"ANY\" are supported."
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Issues closed after this date."
    closedAfter: Time,
    "Issues closed before this date."
    closedBefore: Time,
    "Filter for confidential issues. If \"false\", excludes confidential issues. If \"true\", returns only confidential issues."
    confidential: Boolean,
    "Issues created after this date."
    createdAfter: Time,
    "Issues created before this date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "ID of an epic associated with the issues, \"none\" and \"any\" values are supported."
    epicId: String,
    "Filter by epic ID wildcard. Incompatible with epicId."
    epicWildcardId: EpicWildcardId,
    "Health status of the issue, \"none\" and \"any\" values are supported."
    healthStatusFilter: HealthStatusFilter,
    "IID of the issue. For example, \"1\"."
    iid: String,
    "List of IIDs of issues. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Whether to include subepics when filtering issues by epicId."
    includeSubepics: Boolean,
    "Filter by a list of iteration cadence IDs."
    iterationCadenceId: [IterationsCadenceID!],
    "List of iteration Global IDs applied to the issue."
    iterationId: [ID],
    "Filter by iteration title."
    iterationTitle: String,
    "Filter by iteration ID wildcard."
    iterationWildcardId: IterationWildcardId,
    "Labels applied to this issue."
    labelName: [String],
    "Milestone applied to this issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Release tag associated with the issue's milestone."
    releaseTag: [String!],
    "Filter issues by release tag ID wildcard."
    releaseTagWildcardId: ReleaseTagWildcardId,
    "Search query for title or description."
    search: String,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after this date."
    updatedAfter: Time,
    "Issues updated before this date."
    updatedBefore: Time,
    "Weight applied to the issue, \"none\" and \"any\" values are supported."
    weight: String,
    "Filter by weight ID wildcard. Incompatible with weight."
    weightWildcardId: WeightWildcardId
  ): IssueStatusCountsType
  "Issues of the project."
  issues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of a user assigned to the issues. Wildcard values \"NONE\" and \"ANY\" are supported."
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Issues closed after this date."
    closedAfter: Time,
    "Issues closed before this date."
    closedBefore: Time,
    "Filter for confidential issues. If \"false\", excludes confidential issues. If \"true\", returns only confidential issues."
    confidential: Boolean,
    "Issues created after this date."
    createdAfter: Time,
    "Issues created before this date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "ID of an epic associated with the issues, \"none\" and \"any\" values are supported."
    epicId: String,
    "Filter by epic ID wildcard. Incompatible with epicId."
    epicWildcardId: EpicWildcardId,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Health status of the issue, \"none\" and \"any\" values are supported."
    healthStatusFilter: HealthStatusFilter,
    "IID of the issue. For example, \"1\"."
    iid: String,
    "List of IIDs of issues. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Whether to include subepics when filtering issues by epicId."
    includeSubepics: Boolean,
    "Filter by a list of iteration cadence IDs."
    iterationCadenceId: [IterationsCadenceID!],
    "List of iteration Global IDs applied to the issue."
    iterationId: [ID],
    "Filter by iteration title."
    iterationTitle: String,
    "Filter by iteration ID wildcard."
    iterationWildcardId: IterationWildcardId,
    "Labels applied to this issue."
    labelName: [String],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Milestone applied to this issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Release tag associated with the issue's milestone."
    releaseTag: [String!],
    "Filter issues by release tag ID wildcard."
    releaseTagWildcardId: ReleaseTagWildcardId,
    "Search query for title or description."
    search: String,
    "Sort issues by this criteria."
    sort: IssueSort = created_desc,
    "Current state of this issue."
    state: IssuableState,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after this date."
    updatedAfter: Time,
    "Issues updated before this date."
    updatedBefore: Time,
    "Weight applied to the issue, \"none\" and \"any\" values are supported."
    weight: String,
    "Filter by weight ID wildcard. Incompatible with weight."
    weightWildcardId: WeightWildcardId
  ): IssueConnection
  "Access level required for issues access."
  issuesAccessLevel: ProjectFeatureAccess
  "Indicates if Issues are enabled for the current user"
  issuesEnabled: Boolean
  "Find iteration cadences."
  iterationCadences(
    "Whether the iteration cadence is active."
    active: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Whether the iteration cadence should automatically generate upcoming iterations."
    automatic: Boolean,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Duration in weeks of the iterations within this cadence."
    durationInWeeks: Int,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of the iteration cadence to look up."
    id: IterationsCadenceID,
    "Whether to include ancestor groups to search iterations cadences in."
    includeAncestorGroups: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Fuzzy search by title."
    title: String
  ): IterationCadenceConnection
  "Find iterations."
  iterations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of the Iteration to look up."
    id: ID,
    "Internal ID of the Iteration to look up."
    iid: ID,
    "Fields in which the fuzzy-search should be performed with the query given in the argument `search`. Defaults to `[title]`."
    in: [IterationSearchableField!],
    "Whether to include ancestor iterations. Defaults to true."
    includeAncestors: Boolean,
    "Whether to include descendant iterations."
    includeDescendants: Boolean,
    "Global iteration cadence IDs by which to look up the iterations."
    iterationCadenceIds: [IterationsCadenceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Query used for fuzzy-searching in the fields selected in the argument `in`. Returns all iterations if empty."
    search: String,
    "List iterations by sort order. If unspecified, an arbitrary order (subject to change) is used."
    sort: IterationSort,
    "Filter iterations by state."
    state: IterationState,
    "List items overlapping the given timeframe."
    timeframe: Timeframe
  ): IterationConnection
  "Status of Jira import background job of the project."
  jiraImportStatus: String
  "Jira imports into the project."
  jiraImports(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): JiraImportConnection
  "One job belonging to the project, selected by ID."
  job(
    "ID of the job."
    id: JobID!
  ): CiJob
  "Jobs of a project. This field can only be resolved for one project in any single request."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter jobs by status."
    statuses: [CiJobStatus!],
    "Filter by artifacts presence."
    withArtifacts: Boolean
  ): CiJobConnection
  "Indicates if CI/CD pipeline jobs are enabled for the current user."
  jobsEnabled: Boolean
  "Label available on this project."
  label(
    "Title of the label."
    title: String!
  ): Label
  "Labels available on this project."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Include labels from ancestor groups."
    includeAncestorGroups: Boolean = false,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search term to find labels with."
    searchTerm: String
  ): LabelConnection
  "Programming languages used in the project."
  languages: [RepositoryLanguage!]
  "Timestamp of the project last activity."
  lastActivityAt: Time
  "Indicates if the project has Large File Storage (LFS) enabled."
  lfsEnabled: Boolean
  "Member roles available for the group. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  memberRoles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of the member role to look up."
    id: MemberRoleID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MemberRoleConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "Template used to create merge commit message in merge requests."
  mergeCommitTemplate: String
  "A single merge request of the project."
  mergeRequest(
    "IID of the merge request, for example `1`."
    iid: String!
  ): MergeRequest
  "Merge requests of the project."
  mergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Access level required for merge requests access."
  mergeRequestsAccessLevel: ProjectFeatureAccess
  "Indicates that committers of the given merge request cannot approve."
  mergeRequestsDisableCommittersApproval: Boolean!
  "Indicates if Merge Requests are enabled for the current user"
  mergeRequestsEnabled: Boolean
  "Indicates if no merge commits should be created and all merges should instead be fast-forwarded, which means that merging is only allowed if the branch could be fast-forwarded."
  mergeRequestsFfOnlyEnabled: Boolean
  "Milestones of the project."
  milestones(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Date the milestone contains."
    containingDate: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global milestone IDs, e.g., `\"gid://gitlab/Milestone/1\"`."
    ids: [ID!],
    "Also return milestones in the project's parent group and its ancestors."
    includeAncestors: Boolean,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search string for the title."
    searchTitle: String,
    "Sort milestones by this criteria."
    sort: MilestoneSort = DUE_DATE_ASC,
    "Filter milestones by state."
    state: MilestoneStateEnum,
    "List items overlapping the given timeframe."
    timeframe: Timeframe,
    "Title of the milestone."
    title: String
  ): MilestoneConnection
  "Finds machine learning models Introduced in 16.8: This feature is an Experiment. It can be changed or removed at any time."
  mlModels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search for names that include the string."
    name: String,
    "Ordering column. Default is created_at."
    orderBy: MlModelsOrderBy,
    "Ordering column. Default is desc."
    sort: SortDirectionEnum
  ): MlModelConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  "Name of the project (without namespace)."
  name: String!
  "Full name of the project with its namespace."
  nameWithNamespace: String!
  "Namespace of the project."
  namespace: Namespace
  "Environments for this project with nested folders, can only be resolved for one project in any single request"
  nestedEnvironments(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Name of the environment."
    name: String,
    "Search query for environment name."
    search: String,
    "States of environments that should be included in result."
    states: [String!],
    "Search query for environment type."
    type: String
  ): NestedEnvironmentConnection
  "Network Policies of the project Deprecated in 14.8: Network policies are deprecated and will be removed in GitLab 17.0. This field returns no data in GitLab 15.0 and later."
  networkPolicies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Global ID of the environment to filter policies."
    environmentId: EnvironmentID,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NetworkPolicyConnection @deprecated(reason: "Network policies are deprecated and will be removed in GitLab 17.0. This field returns no data in GitLab 15.0 and later. Deprecated in 14.8.")
  "Indicates if merge requests of the project can only be merged when all the discussions are resolved."
  onlyAllowMergeIfAllDiscussionsAreResolved: Boolean
  "Indicates that merges of merge requests should be blocked unless all status checks have passed."
  onlyAllowMergeIfAllStatusChecksPassed: Boolean
  "Indicates if merge requests of the project can only be merged with successful jobs."
  onlyAllowMergeIfPipelineSucceeds: Boolean
  "Number of open issues for the project."
  openIssuesCount: Int
  "Number of open merge requests for the project."
  openMergeRequestsCount: Int
  "Packages of the project."
  packages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Include versionless packages."
    includeVersionless: Boolean = false,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search a package by name."
    packageName: String,
    "Filter a package by type."
    packageType: PackageTypeEnum,
    """

    Filter a package by version. If used in combination with `include_versionless`,
    then no versionless packages are returned.
    """
    packageVersion: String,
    "Sort packages by this criteria."
    sort: PackageSort = CREATED_DESC,
    "Filter a package by status."
    status: PackageStatus
  ): PackageConnection
  "Packages cleanup policy for the project."
  packagesCleanupPolicy: PackagesCleanupPolicy
  "Packages protection rules for the project."
  packagesProtectionRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PackagesProtectionRuleConnection
  "Path of the project."
  path: String!
  "The project's path locks."
  pathLocks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PathLockConnection
  "Build pipeline of the project."
  pipeline(
    "IID of the Pipeline. For example, \"1\"."
    iid: ID,
    "SHA of the Pipeline. For example, \"dyd0f15ay83993f5ab66k927w28673882x99100b\"."
    sha: String
  ): Pipeline
  "Pipeline analytics."
  pipelineAnalytics: PipelineAnalytics
  "Build pipeline counts of the project."
  pipelineCounts(
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by the SHA of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String
  ): PipelineCounts
  "Pipeline schedules of the project. This field can only be resolved for one project per request."
  pipelineSchedules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter pipeline schedules by IDs."
    ids: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter pipeline schedules by active status."
    status: PipelineScheduleStatus
  ): PipelineScheduleConnection
  "List of pipeline trigger tokens. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  pipelineTriggers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): PipelineTriggerConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Build pipelines of the project."
  pipelines(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter pipelines by the ref they are run for."
    ref: String,
    "Filter pipelines by scope."
    scope: PipelineScopeEnum,
    "Filter pipelines by the sha of the commit they are run for."
    sha: String,
    "Filter pipelines by their source."
    source: String,
    "Filter pipelines by their status."
    status: PipelineStatusEnum,
    "Pipelines updated after this date."
    updatedAfter: Time,
    "Pipelines updated before this date."
    updatedBefore: Time,
    "Filter pipelines by the user that triggered the pipeline."
    username: String
  ): PipelineConnection
  "Indicates if an associated issue from Jira is required."
  preventMergeWithoutJiraIssueEnabled: Boolean!
  "Indicates if a link to create or view a merge request should display after a push to Git repositories of the project from the command line."
  printingMergeRequestLinkEnabled: Boolean
  "Count of all events used, broken down by month Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  productAnalyticsEventsStored(
    "Selection for the period to return."
    monthSelection: [MonthSelectionInput!]!
  ): [MonthlyUsage!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Product Analytics instrumentation key assigned to the project. Introduced in 16.0: This feature is an Experiment. It can be changed or removed at any time."
  productAnalyticsInstrumentationKey: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
  "Current state of the product analytics stack for this project.Can only be called for one project in a single request Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  productAnalyticsState: ProductAnalyticsState @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Members of the project."
  projectMembers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter members by the given member relations."
    relations: [ProjectMemberRelation!] = [DIRECT, INHERITED],
    "Search query."
    search: String,
    "sort query."
    sort: MemberSort
  ): MemberInterfaceConnection
  "Indicates if there is public access to pipelines and job details of the project, including output logs and artifacts."
  publicJobs: Boolean
  "Project's push rules settings."
  pushRules: PushRules
  "List of recently visited boards of the project. Maximum size is 4."
  recentIssueBoards(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BoardConnection
  "A single release of the project."
  release(
    "Name of the tag associated to the release."
    tagName: String!
  ): Release
  "Releases of the project."
  releases(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Sort releases by given criteria."
    sort: ReleaseSort = RELEASED_AT_DESC
  ): ReleaseConnection
  "Indicates if `Delete source branch` option should be enabled by default for all new merge requests of the project."
  removeSourceBranchAfterMerge: Boolean
  "Git repository of the project."
  repository: Repository
  "Size of repository that exceeds the limit in bytes."
  repositorySizeExcess: Float
  "Indicates if users can request member access to the project."
  requestAccessEnabled: Boolean
  "Find a single requirement."
  requirement(
    "Filter requirements by author username."
    authorUsername: [String!],
    "State of latest requirement test report."
    lastTestReportState: RequirementStatusFilter,
    "Search query for requirement title."
    search: String,
    "List requirements by sort order."
    sort: Sort,
    "Filter requirements by state."
    state: RequirementState,
    "IID of the requirement work item, for example, \"1\"."
    workItemIid: ID,
    "List of IIDs of requirement work items, for example, `[1, 2]`."
    workItemIids: [ID!]
  ): Requirement
  "Number of requirements for the project by their state."
  requirementStatesCount: RequirementStatesCount
  "Find requirements."
  requirements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter requirements by author username."
    authorUsername: [String!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of latest requirement test report."
    lastTestReportState: RequirementStatusFilter,
    "Search query for requirement title."
    search: String,
    "List requirements by sort order."
    sort: Sort,
    "Filter requirements by state."
    state: RequirementState,
    "IID of the requirement work item, for example, \"1\"."
    workItemIid: ID,
    "List of IIDs of requirement work items, for example, `[1, 2]`."
    workItemIids: [ID!]
  ): RequirementConnection
  "Find runners visible to the current user."
  runners(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter runners by creator ID."
    creatorId: UserID,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter runners by `paused` (true) or `active` (false) status."
    paused: Boolean,
    "Filter by full token or partial text in description field."
    search: String,
    "Sort order of results."
    sort: CiRunnerSort,
    "Filter runners by status."
    status: CiRunnerStatus,
    "Filter by tags associated with the runner (comma-separated or array)."
    tagList: [String!],
    "Filter runners by type."
    type: CiRunnerType,
    "Filter by upgrade status."
    upgradeStatus: CiRunnerUpgradeStatus
  ): CiRunnerConnection
  "SAST CI configuration for the project."
  sastCiConfiguration: SastCiConfiguration
  "Scan Execution Policies of the project"
  scanExecutionPolicies(
    "Filters policies by the action scan type. Only these scan types are supported: `dast`, `secret_detection`, `cluster_image_scanning`, `container_scanning`, `sast`, `sast_iac`, `dependency_scanning`."
    actionScanTypes: [SecurityReportTypeEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter policies by the given policy relationship."
    relationship: SecurityPolicyRelationType = DIRECT
  ): ScanExecutionPolicyConnection
  "Scan Result Policies of the project"
  scanResultPolicies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter policies by the given policy relationship."
    relationship: SecurityPolicyRelationType = DIRECT
  ): ScanResultPolicyConnection
  "Path to project's security dashboard."
  securityDashboardPath: String
  "Information about security analyzers used in the project."
  securityScanners: SecurityScanners
  "List of security training providers for the project"
  securityTrainingProviders(
    "Filter the list by only enabled security trainings."
    onlyEnabled: Boolean
  ): [ProjectSecurityTraining!]
  "Security training URLs for the enabled training providers of the project."
  securityTrainingUrls(
    "Filename to filter security training URLs by programming language."
    filename: String,
    "List of external IDs of vulnerability identifiers."
    identifierExternalIds: [String!]!
  ): [SecurityTrainingUrl!]
  "Detailed version of a Sentry error on the project."
  sentryDetailedError(
    "ID of the Sentry issue."
    id: GitlabErrorTrackingDetailedErrorID!
  ): SentryDetailedError
  "Paginated collection of Sentry errors on the project."
  sentryErrors: SentryErrorCollection
  "E-mail address of the Service Desk."
  serviceDeskAddress: String
  "Indicates if the project has Service Desk enabled."
  serviceDeskEnabled: Boolean
  "Project services. Deprecated in 15.9: This will be renamed to `Project.integrations`."
  services(
    "Indicates if the integration is active."
    active: Boolean,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of integration."
    type: ServiceType
  ): ServiceConnection @deprecated(reason: "This will be renamed to `Project.integrations`. Deprecated in 15.9.")
  "Indicates if shared runners are enabled for the project."
  sharedRunnersEnabled: Boolean
  "Snippets of the project."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Indicates if Snippets are enabled for the current user"
  snippetsEnabled: Boolean
  "Template used to create squash commit message in merge requests."
  squashCommitTemplate: String
  "Indicates if `squashReadOnly` is enabled."
  squashReadOnly: Boolean!
  "URL to connect to the project via SSH."
  sshUrlToRepo: String
  "Number of times the project has been starred."
  starCount: Int!
  "Statistics of the project."
  statistics: ProjectStatistics
  "Redirects for Statistics of the project."
  statisticsDetailsPaths: ProjectStatisticsRedirect
  "Commit message used to apply merge request suggestions."
  suggestionCommitMessage: String
  "List of project topics (not Git tags). Deprecated in 13.12: Use `topics`."
  tagList: String @deprecated(reason: "Use `topics`. Deprecated in 13.12.")
  "Find a single Terraform state by name."
  terraformState(
    "Name of the Terraform state."
    name: String!
  ): TerraformState
  "Terraform states associated with the project."
  terraformStates(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TerraformStateConnection
  "Timelog categories for the project. Introduced in 15.3: This feature is an Experiment. It can be changed or removed at any time."
  timelogCategories(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimeTrackingTimelogCategoryConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.")
  "Time logged on issues and merge requests in the project."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "List of project topics."
  topics: [String!]
  "Tracking key assigned to the project. Introduced in 16.0: This feature is an Experiment. It can be changed or removed at any time."
  trackingKey: String @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
  "Authorized cluster agents for the project through user_access keyword."
  userAccessAuthorizedAgents(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ClusterAgentAuthorizationUserAccessConnection
  "Permissions for the current user on the resource"
  userPermissions: ProjectPermissions!
  "Value streams available to the project."
  valueStreams(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ValueStreamConnection
  "Visibility of the project."
  visibility: String
  "Visible forks of the project. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  visibleForks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Minimum access level."
    minimumAccessLevel: AccessLevelEnum
  ): ProjectConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Vulnerabilities reported on the project."
  vulnerabilities(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter vulnerabilities by `cluster_agent_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterAgentId: [ClustersAgentID!],
    "Filter vulnerabilities by `cluster_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterId: [ClustersClusterID!],
    "Filter by dismissal reason. Only dismissed Vulnerabilities will be included with the filter."
    dismissalReason: [VulnerabilityDismissalReason!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only the vulnerabilities which have linked issues."
    hasIssues: Boolean,
    "Returns only the vulnerabilities which have linked merge requests."
    hasMergeRequest: Boolean,
    "Returns only the vulnerabilities which have remediations."
    hasRemediations: Boolean,
    "Returns only the vulnerabilities which have been resolved on default branch."
    hasResolution: Boolean,
    "Filter vulnerabilities by location image. When this filter is present, the response only matches entries for a `reportType` that includes `container_scanning`, `cluster_image_scanning`."
    image: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter vulnerabilities by OWASP Top 10 category."
    owaspTopTen: [VulnerabilityOwaspTop10!],
    "Filter vulnerabilities by project."
    projectId: [ID!],
    "Filter vulnerabilities by report type."
    reportType: [VulnerabilityReportType!],
    "Filter vulnerabilities by VulnerabilityScanner.externalId."
    scanner: [String!],
    "Filter vulnerabilities by scanner ID."
    scannerId: [VulnerabilitiesScannerID!],
    "Filter vulnerabilities by severity."
    severity: [VulnerabilitySeverity!],
    "List vulnerabilities by sort order."
    sort: VulnerabilitySort = severity_desc,
    "Filter vulnerabilities by state."
    state: [VulnerabilityState!]
  ): VulnerabilityConnection
  "The historical number of vulnerabilities per day for the project."
  vulnerabilitiesCountByDay(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Last day for which to fetch vulnerability history."
    endDate: ISO8601Date!,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "First day for which to fetch vulnerability history."
    startDate: ISO8601Date!
  ): VulnerabilitiesCountByDayConnection
  "Container images reported on the project vulnerabilities."
  vulnerabilityImages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityContainerImageConnection
  "Vulnerability scanners reported on the project vulnerabilities."
  vulnerabilityScanners(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityScannerConnection
  "Counts for each vulnerability severity in the project."
  vulnerabilitySeveritiesCount(
    "Filter vulnerabilities by `cluster_agent_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterAgentId: [ClustersAgentID!],
    "Filter by dismissal reason."
    dismissalReason: [VulnerabilityDismissalReason!],
    "Filter vulnerabilities that do or do not have issues."
    hasIssues: Boolean,
    "Filter vulnerabilities that do or do not have a merge request."
    hasMergeRequest: Boolean,
    "Filter vulnerabilities that do or do not have remediations."
    hasRemediations: Boolean,
    "Filter vulnerabilities that do or do not have a resolution."
    hasResolution: Boolean,
    "Filter vulnerabilities by location image. When this filter is present, the response only matches entries for a `reportType` that includes `container_scanning`, `cluster_image_scanning`."
    image: [String!],
    "Filter vulnerabilities by OWASP Top 10 category."
    owaspTopTen: [VulnerabilityOwaspTop10!],
    "Filter vulnerabilities by project."
    projectId: [ID!],
    "Filter vulnerabilities by report type."
    reportType: [VulnerabilityReportType!],
    "Filter vulnerabilities by scanner."
    scanner: [String!],
    "Filter vulnerabilities by scanner ID."
    scannerId: [VulnerabilitiesScannerID!],
    "Filter vulnerabilities by severity."
    severity: [VulnerabilitySeverity!],
    "Filter vulnerabilities by state."
    state: [VulnerabilityState!]
  ): VulnerabilitySeveritiesCount
  "Web URL of the project."
  webUrl: String
  "Indicates if Wikis are enabled for the current user"
  wikiEnabled: Boolean
  "Counts of work items by state for the project. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  workItemStateCounts(
    "IID of the work item. For example, \"1\"."
    iid: String,
    "List of IIDs of work items. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Search query for title or description."
    search: String,
    "Sort work items by criteria."
    sort: WorkItemSort = created_desc,
    "Current state of the work item."
    state: IssuableState,
    "Input for status widget filter. Ignored if `work_items_mvc_2` is disabled."
    statusWidget: StatusFilterInput,
    "Filter work items by the given work item types."
    types: [IssueType!]
  ): WorkItemStateCountsType @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Work item types available to the project."
  workItemTypes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "If `true`, only taskable work item types will be returned. Argument is experimental and can be removed in the future without notice."
    taskable: Boolean
  ): WorkItemTypeConnection
  "Work items of the project. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time."
  workItems(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "IID of the work item. For example, \"1\"."
    iid: String,
    "List of IIDs of work items. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for title or description."
    search: String,
    "Sort work items by criteria."
    sort: WorkItemSort = created_desc,
    "Current state of the work item."
    state: IssuableState,
    "Input for status widget filter. Ignored if `work_items_mvc_2` is disabled."
    statusWidget: StatusFilterInput,
    "Filter work items by the given work item types."
    types: [IssueType!]
  ): WorkItemConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.")
}

type ProjectCiCdSetting {
  "Indicates CI/CD job tokens generated in other projects have restricted access to this project."
  inboundJobTokenScopeEnabled: Boolean
  "Indicates CI/CD job tokens generated in this project have restricted access to other projects."
  jobTokenScopeEnabled: Boolean
  "Whether to keep the latest builds artifacts."
  keepLatestArtifact: Boolean
  "Whether merged results pipelines are enabled."
  mergePipelinesEnabled: Boolean
  "Whether merge trains are enabled."
  mergeTrainsEnabled: Boolean
  "Whether merge immediately is allowed for merge trains."
  mergeTrainsSkipTrainAllowed: Boolean!
  "Project the CI/CD settings belong to."
  project: Project
}

"Autogenerated return type of ProjectCiCdSettingsUpdate."
type ProjectCiCdSettingsUpdatePayload {
  "CI/CD settings after mutation."
  ciCdSettings: ProjectCiCdSetting!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"The connection type for Project."
type ProjectConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ProjectEdge]
  "A list of nodes."
  nodes: [Project]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

type ProjectDataTransfer {
  "Data nodes."
  egressNodes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EgressNodeConnection
  "Total egress for that project in that period of time."
  totalEgress: BigInt
}

"An edge in a connection."
type ProjectEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Project
}

"Represents the access level required by the user to access a project feature"
type ProjectFeatureAccess {
  "Integer representation of access level."
  integerValue: Int
  "String representation of access level."
  stringValue: ProjectFeatureAccessLevel
}

"Autogenerated return type of ProjectInitializeProductAnalytics."
type ProjectInitializeProductAnalyticsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project on which the initialization took place."
  project: Project
}

"Represents a Project Membership"
type ProjectMember implements MemberInterface {
  "GitLab::Access level."
  accessLevel: AccessLevel
  "Date and time the membership was created."
  createdAt: Time
  "User that authorized membership."
  createdBy: UserCore
  "Date and time the membership expires."
  expiresAt: Time
  "ID of the member."
  id: ID!
  "Find a merge request."
  mergeRequestInteraction(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): UserMergeRequestInteraction
  "Project that User is a member of."
  project: Project
  "Date and time the membership was last updated."
  updatedAt: Time
  "User that is associated with the member object."
  user: UserCore
  "Permissions for the current user on the resource"
  userPermissions: ProjectPermissions!
}

"Autogenerated return type of ProjectMemberBulkUpdate."
type ProjectMemberBulkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project members after mutation."
  projectMembers: [ProjectMember!]
}

"The connection type for ProjectMember."
type ProjectMemberConnection {
  "A list of edges."
  edges: [ProjectMemberEdge]
  "A list of nodes."
  nodes: [ProjectMember]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ProjectMemberEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ProjectMember
}

type ProjectPermissions {
  "If `true`, the user can perform `admin_operations` on this resource"
  adminOperations: Boolean!
  "If `true`, the user can perform `admin_path_locks` on this resource"
  adminPathLocks: Boolean!
  "If `true`, the user can perform `admin_project` on this resource"
  adminProject: Boolean!
  "If `true`, the user can perform `admin_remote_mirror` on this resource"
  adminRemoteMirror: Boolean!
  "If `true`, the user can perform `admin_wiki` on this resource"
  adminWiki: Boolean!
  "If `true`, the user can perform `archive_project` on this resource"
  archiveProject: Boolean!
  "If `true`, the user can perform `change_namespace` on this resource"
  changeNamespace: Boolean!
  "If `true`, the user can perform `change_visibility_level` on this resource"
  changeVisibilityLevel: Boolean!
  "If `true`, the user can perform `create_deployment` on this resource"
  createDeployment: Boolean!
  "If `true`, the user can perform `create_design` on this resource"
  createDesign: Boolean!
  "If `true`, the user can perform `create_issue` on this resource"
  createIssue: Boolean!
  "If `true`, the user can perform `create_label` on this resource"
  createLabel: Boolean!
  "If `true`, the user can perform `create_merge_request_from` on this resource"
  createMergeRequestFrom: Boolean!
  "If `true`, the user can perform `create_merge_request_in` on this resource"
  createMergeRequestIn: Boolean!
  "If `true`, the user can perform `create_pages` on this resource"
  createPages: Boolean!
  "If `true`, the user can perform `create_pipeline` on this resource"
  createPipeline: Boolean!
  "If `true`, the user can perform `create_pipeline_schedule` on this resource"
  createPipelineSchedule: Boolean!
  "If `true`, the user can perform `create_snippet` on this resource"
  createSnippet: Boolean!
  "If `true`, the user can perform `create_wiki` on this resource"
  createWiki: Boolean!
  "If `true`, the user can perform `destroy_design` on this resource"
  destroyDesign: Boolean!
  "If `true`, the user can perform `destroy_pages` on this resource"
  destroyPages: Boolean!
  "If `true`, the user can perform `destroy_wiki` on this resource"
  destroyWiki: Boolean!
  "If `true`, the user can perform `download_code` on this resource"
  downloadCode: Boolean!
  "If `true`, the user can perform `download_wiki_code` on this resource"
  downloadWikiCode: Boolean!
  "If `true`, the user can perform `fork_project` on this resource"
  forkProject: Boolean!
  "If `true`, the user can perform `push_code` on this resource"
  pushCode: Boolean!
  "If `true`, the user can perform `push_to_delete_protected_branch` on this resource"
  pushToDeleteProtectedBranch: Boolean!
  "If `true`, the user can perform `read_commit_status` on this resource"
  readCommitStatus: Boolean!
  "If `true`, the user can perform `read_cycle_analytics` on this resource"
  readCycleAnalytics: Boolean!
  "If `true`, the user can perform `read_design` on this resource"
  readDesign: Boolean!
  "If `true`, the user can perform `read_environment` on this resource"
  readEnvironment: Boolean!
  "If `true`, the user can perform `read_merge_request` on this resource"
  readMergeRequest: Boolean!
  "If `true`, the user can perform `read_pages_content` on this resource"
  readPagesContent: Boolean!
  "If `true`, the user can perform `read_project` on this resource"
  readProject: Boolean!
  "If `true`, the user can perform `read_project_member` on this resource"
  readProjectMember: Boolean!
  "If `true`, the user can perform `read_wiki` on this resource"
  readWiki: Boolean!
  "If `true`, the user can perform `remove_fork_project` on this resource"
  removeForkProject: Boolean!
  "If `true`, the user can perform `remove_pages` on this resource"
  removePages: Boolean!
  "If `true`, the user can perform `remove_project` on this resource"
  removeProject: Boolean!
  "If `true`, the user can perform `rename_project` on this resource"
  renameProject: Boolean!
  "If `true`, the user can perform `request_access` on this resource"
  requestAccess: Boolean!
  "If `true`, the user can perform `update_pages` on this resource"
  updatePages: Boolean!
  "If `true`, the user can perform `update_wiki` on this resource"
  updateWiki: Boolean!
  "If `true`, the user can perform `upload_file` on this resource"
  uploadFile: Boolean!
}

"Represents the Geo replication and verification state of a project repository"
type ProjectRepositoryRegistry {
  "Timestamp when the ProjectRepositoryRegistry was created"
  createdAt: Time
  "ID of the ProjectRepositoryRegistry"
  id: ID!
  "Error message during sync of the ProjectRepositoryRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the ProjectRepositoryRegistry"
  lastSyncedAt: Time
  "ID of the Project."
  projectId: ID!
  "Timestamp after which the ProjectRepositoryRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the ProjectRepositoryRegistry"
  retryCount: Int
  "Sync state of the ProjectRepositoryRegistry"
  state: RegistryState
  "The local checksum of the ProjectRepositoryRegistry"
  verificationChecksum: String
  "Error message during verification of the ProjectRepositoryRegistry"
  verificationFailure: String
  "Timestamp after which the ProjectRepositoryRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the ProjectRepositoryRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of ProjectRepositoryRegistry"
  verificationStartedAt: Time
  "Verification state of the ProjectRepositoryRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the ProjectRepositoryRegistry"
  verifiedAt: Time
}

"The connection type for ProjectRepositoryRegistry."
type ProjectRepositoryRegistryConnection {
  "A list of edges."
  edges: [ProjectRepositoryRegistryEdge]
  "A list of nodes."
  nodes: [ProjectRepositoryRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ProjectRepositoryRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ProjectRepositoryRegistry
}

"Represents the source of a security policy belonging to a project"
type ProjectSecurityPolicySource {
  "Project the policy is associated with."
  project: Project
}

type ProjectSecurityTraining {
  "Description of the training provider."
  description: String
  "ID of the training provider."
  id: GlobalID!
  "Represents whether the provider is enabled or not."
  isEnabled: Boolean!
  "Represents whether the provider is set as primary or not."
  isPrimary: Boolean!
  "Logo URL of the provider."
  logoUrl: String
  "Name of the training provider."
  name: String!
  "URL of the provider."
  url: String!
}

"Autogenerated return type of ProjectSetComplianceFramework."
type ProjectSetComplianceFrameworkPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project after mutation."
  project: Project
}

"Autogenerated return type of ProjectSetContinuousVulnerabilityScanning."
type ProjectSetContinuousVulnerabilityScanningPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Whether feature is enabled."
  continuousVulnerabilityScanningEnabled: Boolean!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of ProjectSetLocked."
type ProjectSetLockedPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project after mutation."
  project: Project
}

type ProjectStatistics {
  "Build artifacts size of the project in bytes."
  buildArtifactsSize: Float!
  "Commit count of the project."
  commitCount: Float!
  "Container Registry size of the project in bytes."
  containerRegistrySize: Float
  "Build artifacts size in bytes with any applicable cost factor for forks applied. This will equal build_artifacts_size if there is no applicable cost factor. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredBuildArtifactsSize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "LFS objects size in bytes with any applicable cost factor for forks applied. This will equal lfs_objects_size if there is no applicable cost factor. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredLfsObjectsSize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Packages size in bytes with any applicable cost factor for forks applied. This will equal packages_size if there is no applicable cost factor. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredPackagesSize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Repository size in bytes with any applicable cost factor for forks applied. This will equal repository_size if there is no applicable cost factor. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredRepositorySize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Snippets size in bytes with any applicable cost factor for forks applied. This will equal snippets_size if there is no applicable cost factor. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredSnippetsSize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Storage size in bytes with any applicable cost factor for forks applied. This will equal storage_size if there is no applicable cost factor. Introduced in 16.2: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredStorageSize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.")
  "Wiki size in bytes with any applicable cost factor for forks applied. This will equal wiki_size if there is no applicable cost factor. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredWikiSize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Large File Storage (LFS) object size of the project in bytes."
  lfsObjectsSize: Float!
  "Packages size of the project in bytes."
  packagesSize: Float!
  "CI Pipeline artifacts size in bytes."
  pipelineArtifactsSize: Float
  "Repository size of the project in bytes."
  repositorySize: Float!
  "Snippets size of the project in bytes."
  snippetsSize: Float
  "Storage size of the project in bytes."
  storageSize: Float!
  "Uploads size of the project in bytes."
  uploadsSize: Float
  "Wiki size of the project in bytes."
  wikiSize: Float
}

type ProjectStatisticsRedirect {
  "Redirection Route for job_artifacts."
  buildArtifacts: String!
  "Redirection Route for container_registry."
  containerRegistry: String!
  "Redirection Route for packages."
  packages: String!
  "Redirection Route for repository."
  repository: String!
  "Redirection Route for snippets."
  snippets: String!
  "Redirection Route for wiki."
  wiki: String!
}

"Autogenerated return type of ProjectSubscriptionCreate."
type ProjectSubscriptionCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project Subscription created by the mutation."
  subscription: CiSubscriptionsProject
}

"Autogenerated return type of ProjectSubscriptionDelete."
type ProjectSubscriptionDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project after mutation."
  project: Project
}

"Autogenerated return type of ProjectSyncFork."
type ProjectSyncForkPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Updated fork details."
  details: ForkDetails
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Exposes aggregated value stream flow metrics"
type ProjectValueStreamAnalyticsFlowMetrics {
  "Median time from first commit to issue closed"
  cycleTime(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Number of production deployments in the given period."
  deploymentCount(
    "Timestamp marking the start date and time."
    from: Time!,
    "Timestamp marking the end date and time."
    to: Time!
  ): ValueStreamAnalyticsMetric
  "Number of issues opened in the given period."
  issueCount(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Number of open issues closed (completed) in the given period. Maximum value is 10,001."
  issuesCompletedCount(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Median time from when the issue was created to when it was closed."
  leadTime(
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Username of the author of the issue."
    authorUsername: String,
    "ID of an epic associated with the issues."
    epicId: ID,
    "Timestamp marking the start date and time."
    from: Time!,
    "ID of an iteration associated with the issues."
    iterationId: ID,
    "Labels applied to the issue."
    labelNames: [String!],
    "Milestone applied to the issue."
    milestoneTitle: String,
    "Filter by reaction emoji applied by the current user."
    myReactionEmoji: String,
    "Argument used for adding negated filters."
    not: NegatedValueStreamAnalyticsIssueFilterInput,
    "Timestamp marking the end date and time."
    to: Time!,
    "Weight applied to the issue."
    weight: Int
  ): ValueStreamAnalyticsMetric
  "Median time from merge request creation to merge request merged."
  timeToMerge(
    "Usernames of users assigned to the merge request."
    assigneeUsernames: [String!],
    "Username of the author of the merge request."
    authorUsername: String,
    "Timestamp marking the start date and time."
    from: Time!,
    "Labels applied to the merge request."
    labelNames: [String!],
    "Milestone applied to the merge request."
    milestoneTitle: String,
    "Timestamp marking the end date and time."
    to: Time!
  ): ValueStreamAnalyticsMetric
}

"Represents the Geo replication and verification state of a project_wiki_repository"
type ProjectWikiRepositoryRegistry {
  "Timestamp when the ProjectWikiRepositoryRegistry was created"
  createdAt: Time
  "ID of the ProjectWikiRepositoryRegistry"
  id: ID!
  "Error message during sync of the ProjectWikiRepositoryRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the ProjectWikiRepositoryRegistry"
  lastSyncedAt: Time
  "ID of the Project Wiki Repository."
  projectWikiRepositoryId: ID!
  "Timestamp after which the ProjectWikiRepositoryRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the ProjectWikiRepositoryRegistry"
  retryCount: Int
  "Sync state of the ProjectWikiRepositoryRegistry"
  state: RegistryState
  "The local checksum of the ProjectWikiRepositoryRegistry"
  verificationChecksum: String
  "Error message during verification of the ProjectWikiRepositoryRegistry"
  verificationFailure: String
  "Timestamp after which the ProjectWikiRepositoryRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the ProjectWikiRepositoryRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of ProjectWikiRepositoryRegistry"
  verificationStartedAt: Time
  "Verification state of the ProjectWikiRepositoryRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the ProjectWikiRepositoryRegistry"
  verifiedAt: Time
}

"The connection type for ProjectWikiRepositoryRegistry."
type ProjectWikiRepositoryRegistryConnection {
  "A list of edges."
  edges: [ProjectWikiRepositoryRegistryEdge]
  "A list of nodes."
  nodes: [ProjectWikiRepositoryRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ProjectWikiRepositoryRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ProjectWikiRepositoryRegistry
}

"The alert condition for Prometheus"
type PrometheusAlert {
  "Human-readable text of the alert condition."
  humanizedText: String!
  "ID of the alert condition."
  id: ID!
}

"Autogenerated return type of PrometheusIntegrationCreate."
type PrometheusIntegrationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Newly created integration."
  integration: AlertManagementPrometheusIntegration
}

"Autogenerated return type of PrometheusIntegrationResetToken."
type PrometheusIntegrationResetTokenPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Newly created integration."
  integration: AlertManagementPrometheusIntegration
}

"Autogenerated return type of PrometheusIntegrationUpdate."
type PrometheusIntegrationUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Newly created integration."
  integration: AlertManagementPrometheusIntegration
}

"Autogenerated return type of PromoteToEpic."
type PromoteToEpicPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Epic after issue promotion."
  epic: Epic
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Protected Environments of the environment."
type ProtectedEnvironment {
  "Which group, user or role is allowed to approve deployments to the environment."
  approvalRules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProtectedEnvironmentApprovalRuleConnection
  "Which group, user or role is allowed to execute deployments to the environment."
  deployAccessLevels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProtectedEnvironmentDeployAccessLevelConnection
  "Group details. Present if it's group-level protected environment."
  group: Group
  "Name of the environment if it's a project-level protected environment. Tier of the environment if it's a group-level protected environment."
  name: String
  "Project details. Present if it's project-level protected environment."
  project: Project
  "Required approval count for Unified Approval Setting."
  requiredApprovalCount: Int
}

"Which group, user or role is allowed to approve deployments to the environment."
type ProtectedEnvironmentApprovalRule {
  "Role details. Present if it's role specific access control."
  accessLevel: AccessLevel
  "Group details. Present if it's group specific access control."
  group: Group
  "Number of required approvals."
  requiredApprovals: Int
  "User details. Present if it's user specific access control."
  user: UserCore
}

"The connection type for ProtectedEnvironmentApprovalRule."
type ProtectedEnvironmentApprovalRuleConnection {
  "A list of edges."
  edges: [ProtectedEnvironmentApprovalRuleEdge]
  "A list of nodes."
  nodes: [ProtectedEnvironmentApprovalRule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ProtectedEnvironmentApprovalRuleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ProtectedEnvironmentApprovalRule
}

"Which group, user or role is allowed to approve deployments to the environment."
type ProtectedEnvironmentApprovalRuleForSummary {
  "Role details. Present if it's role specific access control."
  accessLevel: AccessLevel
  "Current approvals of the deployment."
  approvals: [DeploymentApproval!]
  "Approved count."
  approvedCount: Int
  "Group details. Present if it's group specific access control."
  group: Group
  "Pending approval count."
  pendingApprovalCount: Int
  "Number of required approvals."
  requiredApprovals: Int
  "Status of the approval summary."
  status: DeploymentApprovalSummaryStatus
  "User details. Present if it's user specific access control."
  user: UserCore
}

"The connection type for ProtectedEnvironment."
type ProtectedEnvironmentConnection {
  "A list of edges."
  edges: [ProtectedEnvironmentEdge]
  "A list of nodes."
  nodes: [ProtectedEnvironment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Which group, user or role is allowed to execute deployments to the environment."
type ProtectedEnvironmentDeployAccessLevel {
  "Role details. Present if it's role specific access control."
  accessLevel: AccessLevel
  "Group details. Present if it's group specific access control."
  group: Group
  "User details. Present if it's user specific access control."
  user: UserCore
}

"The connection type for ProtectedEnvironmentDeployAccessLevel."
type ProtectedEnvironmentDeployAccessLevelConnection {
  "A list of edges."
  edges: [ProtectedEnvironmentDeployAccessLevelEdge]
  "A list of nodes."
  nodes: [ProtectedEnvironmentDeployAccessLevel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ProtectedEnvironmentDeployAccessLevelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ProtectedEnvironmentDeployAccessLevel
}

"An edge in a connection."
type ProtectedEnvironmentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ProtectedEnvironment
}

"Defines which user roles, users, or groups can push to a protected branch."
type PushAccessLevel {
  "GitLab::Access level."
  accessLevel: Int!
  "Human readable representation for this access level."
  accessLevelDescription: String!
  "Deploy key assigned to the access level."
  deployKey: AccessLevelDeployKey
  "Group associated with this access level."
  group: AccessLevelGroup
  "User associated with this access level."
  user: AccessLevelUser
}

"The connection type for PushAccessLevel."
type PushAccessLevelConnection {
  "A list of edges."
  edges: [PushAccessLevelEdge]
  "A list of nodes."
  nodes: [PushAccessLevel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type PushAccessLevelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PushAccessLevel
}

"Represents rules that commit pushes must follow."
type PushRules {
  "Indicates whether commits not signed through GPG will be rejected."
  rejectUnsignedCommits: Boolean!
}

"Pypi metadata"
type PypiMetadata {
  "Author email address(es) in RFC-822 format."
  authorEmail: String
  "Longer description that can run to several paragraphs."
  description: String
  "Markup syntax used in the description field."
  descriptionContentType: String
  "ID of the metadatum."
  id: PackagesPypiMetadatumID!
  "List of keywords, separated by commas."
  keywords: String
  "Metadata version."
  metadataVersion: String
  "Required Python version of the Pypi package."
  requiredPython: String
  "One-line summary of the description."
  summary: String
}

type Query {
  "Find an abuse report. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  abuseReport(
    "ID of the abuse report."
    id: AbuseReportID!
  ): AbuseReport @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Abuse report labels. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  abuseReportLabels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search term to find labels with."
    searchTerm: String
  ): LabelConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Retrieve the active add-on purchase. This query can be used in GitLab SaaS and self-managed environments. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  addOnPurchase(
    "Type of add-on for the add-on purchase."
    addOnType: GitlabSubscriptionsAddOnType!,
    "ID of namespace that the add-on was purchased for."
    namespaceId: NamespaceID
  ): AddOnPurchase @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Find GitLab Duo Chat messages. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  aiMessages(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Array of request IDs to fetch."
    requestIds: [ID!],
    "Array of roles to fetch."
    roles: [AiMessageRole!]
  ): AiMessageConnection! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Definitions for all audit events available on the instance."
  auditEventDefinitions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AuditEventDefinitionConnection!
  "Instance-level Amazon S3 configurations for audit events."
  auditEventsInstanceAmazonS3Configurations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): InstanceAmazonS3ConfigurationTypeConnection
  "Find an issue board list."
  boardList(
    "Global ID of the list."
    id: ListID!,
    "Filters applied when getting issue metadata in the board list."
    issueFilters: BoardIssueInput
  ): BoardList
  "CI related settings that apply to the entire instance."
  ciApplicationSettings: CiApplicationSettings
  "A single CI/CD Catalog resource visible to an authorized user Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  ciCatalogResource(
    "CI/CD Catalog resource full path."
    fullPath: ID,
    "CI/CD Catalog resource global ID."
    id: CiCatalogResourceID
  ): CiCatalogResource @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "All CI/CD Catalog resources under a common namespace, visible to an authorized user Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  ciCatalogResources(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Project with the namespace catalog."
    projectPath: ID,
    "Scope of the returned catalog resources."
    scope: CiCatalogResourceScope = ALL,
    "Search term to filter the catalog resources by name or description."
    search: String,
    "Sort catalog resources by given criteria."
    sort: CiCatalogResourceSort
  ): CiCatalogResourceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  """

  Linted and processed contents of a CI config.
  Should not be requested more than once per request.
  """
  ciConfig(
    "Contents of `.gitlab-ci.yml`."
    content: String!,
    "Run pipeline creation simulation, or only do static check."
    dryRun: Boolean,
    "Project of the CI config."
    projectPath: ID!,
    "Sha for the pipeline."
    sha: String
  ): CiConfig
  "Compute usage data for a namespace."
  ciMinutesUsage(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Date for which to retrieve the usage data, should be the first day of a month."
    date: Date,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Global ID of the Namespace for the monthly compute usage."
    namespaceId: NamespaceID
  ): CiMinutesNamespaceMonthlyUsageConnection
  "Stage belonging to a CI pipeline."
  ciPipelineStage(
    "Global ID of the CI stage."
    id: CiStageID!
  ): CiStage
  "Time it took for ci job to be picked up by runner in percentiles. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  ciQueueingHistory(
    "Start of the requested time frame. Defaults to 3 hours ago."
    fromTime: Time,
    "Filter jobs by the type of runner that executed them."
    runnerType: CiRunnerType,
    "End of the requested time frame. Defaults to current time."
    toTime: Time
  ): QueueingDelayHistory @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "List of the instance's CI/CD variables."
  ciVariables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Sort order of results."
    sort: CiVariableSort
  ): CiInstanceVariableConnection
  "Find a container repository."
  containerRepository(
    "Global ID of the container repository."
    id: ContainerRepositoryID!
  ): ContainerRepositoryDetails
  "Fields related to the current license."
  currentLicense: CurrentLicense
  "Get information about current user."
  currentUser: CurrentUser
  "Fields related to design management."
  designManagement: DesignManagement!
  "Get configured DevOps adoption namespaces. **BETA** This endpoint is subject to change without notice."
  devopsAdoptionEnabledNamespaces(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter by display namespace."
    displayNamespaceId: NamespaceID,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DevopsAdoptionEnabledNamespaceConnection
  "Testing endpoint to validate the API with"
  echo(
    "Text to echo back."
    text: String!
  ): String!
  epicBoardList(
    "Filters applied when getting epic metadata in the epic board list."
    epicFilters: EpicFilters,
    "Global ID of the list."
    id: BoardsEpicListID!
  ): EpicList
  "GitLab Duo Vulnerability summary prompt for a specified vulnerability Introduced in 16.2: This feature is an Experiment. It can be changed or removed at any time."
  explainVulnerabilityPrompt(
    "Vulnerability to generate a prompt for."
    vulnerabilityId: VulnerabilityID!
  ): ExplainVulnerabilityPrompt @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.")
  "A user's frecently visited groups"
  frecentGroups: [Group!]
  "A user's frecently visited projects"
  frecentProjects: [Project!]
  "Find a Geo node."
  geoNode(
    "Name of the Geo node. Defaults to the current Geo node name."
    name: String
  ): GeoNode
  "Whether Gitpod is enabled in application settings."
  gitpodEnabled: Boolean
  "Find a group."
  group(
    "Full path of the group. For example, `gitlab-org/gitlab-foss`."
    fullPath: ID!
  ): Group
  "Find groups."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for group name or group full path."
    search: String
  ): GroupConnection
  "Instance level external audit event destinations."
  instanceExternalAuditEventDestinations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): InstanceExternalAuditEventDestinationConnection
  "Instance level google cloud logging configurations."
  instanceGoogleCloudLoggingConfigurations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): InstanceGoogleCloudLoggingConfigurationTypeConnection
  "Fields related to Instance Security Dashboard."
  instanceSecurityDashboard: InstanceSecurityDashboard
  "Find an issue."
  issue(
    "Global ID of the issue."
    id: IssueID!
  ): Issue
  "Find issues visible to the current user. At least one filter must be provided. Introduced in 15.6: This feature is an Experiment. It can be changed or removed at any time."
  issues(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of a user assigned to the issues. Wildcard values \"NONE\" and \"ANY\" are supported."
    assigneeId: String,
    "Usernames of users assigned to the issue."
    assigneeUsernames: [String!],
    "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
    assigneeWildcardId: AssigneeWildcardId,
    "Username of the author of the issue."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Issues closed after this date."
    closedAfter: Time,
    "Issues closed before this date."
    closedBefore: Time,
    "Filter for confidential issues. If \"false\", excludes confidential issues. If \"true\", returns only confidential issues."
    confidential: Boolean,
    "Issues created after this date."
    createdAfter: Time,
    "Issues created before this date."
    createdBefore: Time,
    "ID of a contact assigned to the issues."
    crmContactId: String,
    "ID of an organization assigned to the issues."
    crmOrganizationId: String,
    "ID of an epic associated with the issues, \"none\" and \"any\" values are supported."
    epicId: String,
    "Filter by epic ID wildcard. Incompatible with epicId."
    epicWildcardId: EpicWildcardId,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Health status of the issue, \"none\" and \"any\" values are supported."
    healthStatusFilter: HealthStatusFilter,
    "IID of the issue. For example, \"1\"."
    iid: String,
    "List of IIDs of issues. For example, `[\"1\", \"2\"]`."
    iids: [String!],
    """

    Specify the fields to perform the search in.
    Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
    """
    in: [IssuableSearchableField!],
    "Whether to include issues from archived projects. Defaults to `false`."
    includeArchived: Boolean = false,
    "Whether to include subepics when filtering issues by epicId."
    includeSubepics: Boolean,
    "Filter by a list of iteration cadence IDs."
    iterationCadenceId: [IterationsCadenceID!],
    "List of iteration Global IDs applied to the issue."
    iterationId: [ID],
    "Filter by iteration title."
    iterationTitle: String,
    "Filter by iteration ID wildcard."
    iterationWildcardId: IterationWildcardId,
    "Labels applied to this issue."
    labelName: [String],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Milestone applied to this issue."
    milestoneTitle: [String],
    "Filter issues by milestone ID wildcard."
    milestoneWildcardId: MilestoneWildcardId,
    "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
    myReactionEmoji: String,
    "Negated arguments."
    not: NegatedIssueFilterInput,
    "List of arguments with inclusive OR."
    or: UnionedIssueFilterInput,
    "Search query for title or description."
    search: String,
    "Sort issues by this criteria."
    sort: IssueSort = created_desc,
    "Current state of this issue."
    state: IssuableState,
    "Filter issues by the given issue types."
    types: [IssueType!],
    "Issues updated after this date."
    updatedAfter: Time,
    "Issues updated before this date."
    updatedBefore: Time,
    "Weight applied to the issue, \"none\" and \"any\" values are supported."
    weight: String,
    "Filter by weight ID wildcard. Incompatible with weight."
    weightWildcardId: WeightWildcardId
  ): IssueConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.")
  "Find an iteration."
  iteration(
    "Find an iteration by its ID."
    id: IterationID!
  ): Iteration
  "All jobs on this GitLab instance. Returns an empty result for users without administrator access."
  jobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter jobs by status."
    statuses: [CiJobStatus!]
  ): CiJobConnection
  "Fields related to entries in the license history."
  licenseHistoryEntries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LicenseHistoryEntryConnection
  "Finds a single custom role. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  memberRole(
    "Global ID of the member role to look up."
    id: MemberRoleID
  ): MemberRole @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "List of all customizable permissions. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  memberRolePermissions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): CustomizablePermissionConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Member roles available for the instance. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  memberRoles(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Global ID of the member role to look up."
    id: MemberRoleID,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MemberRoleConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Find a merge request."
  mergeRequest(
    "Global ID of the merge request."
    id: MergeRequestID!
  ): MergeRequest
  "Metadata about GitLab."
  metadata: Metadata
  "Find a milestone."
  milestone(
    "Find a milestone by its ID."
    id: MilestoneID!
  ): Milestone
  "Find machine learning models. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  mlModel(
    "ID of the model."
    id: MlModelID!
  ): MlModel @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Find a namespace."
  namespace(
    "Full path of the namespace. For example, `gitlab-org/gitlab-foss`."
    fullPath: ID!
  ): Namespace
  "Find a note. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  note(
    "Global ID of the note."
    id: NoteID!
  ): Note @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "Find an organization. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  organization(
    "ID of the organization."
    id: OrganizationsOrganizationID!
  ): Organization @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "List organizations. Introduced in 16.8: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.8.")
  "Find a package. This field can only be resolved for one query in any single request. Returns `null` if a package has no `default` status."
  package(
    "Global ID of the package."
    id: PackagesPackageID!
  ): PackageDetailsType
  "Find a project."
  project(
    "Full path of the project. For example, `gitlab-org/gitlab-foss`."
    fullPath: ID!
  ): Project
  "Find projects visible to the current user."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter projects by full paths. You cannot provide more than 50 full paths."
    fullPaths: [String!],
    "Filter projects by IDs."
    ids: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Return only projects that the current user is a member of."
    membership: Boolean,
    "Search query, which can be for the project name, a path, or a description."
    search: String,
    "Include namespace in project search."
    searchNamespaces: Boolean,
    "Sort order of results. Format: `<field_name>_<sort_direction>`, for example: `id_desc` or `name_asc`"
    sort: String,
    "Filter projects by topics."
    topics: [String!],
    "Return only projects with issues enabled."
    withIssuesEnabled: Boolean,
    "Return only projects with merge requests enabled."
    withMergeRequestsEnabled: Boolean
  ): ProjectConnection
  "Information about the complexity of the GraphQL query."
  queryComplexity: QueryComplexity
  "Find a runner."
  runner(
    "Runner ID."
    id: CiRunnerID!
  ): CiRunner
  "Supported runner platforms. Deprecated in 15.9: No longer used, use gitlab-runner documentation to learn about supported platforms."
  runnerPlatforms(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): RunnerPlatformConnection @deprecated(reason: "No longer used, use gitlab-runner documentation to learn about supported platforms. Deprecated in 15.9.")
  "Runner setup instructions. Deprecated in 15.9: No longer used, use gitlab-runner documentation to learn about runner registration commands."
  runnerSetup(
    "Architecture to generate the instructions for."
    architecture: String!,
    "Platform to generate the instructions for."
    platform: String!
  ): RunnerSetup @deprecated(reason: "No longer used, use gitlab-runner documentation to learn about runner registration commands. Deprecated in 15.9.")
  "Get all runners in the GitLab instance (project and shared). Access is restricted to users with administrator access."
  runners(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter runners by creator ID."
    creatorId: UserID,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter runners by `paused` (true) or `active` (false) status."
    paused: Boolean,
    "Filter by full token or partial text in description field."
    search: String,
    "Sort order of results."
    sort: CiRunnerSort,
    "Filter runners by status."
    status: CiRunnerStatus,
    "Filter by tags associated with the runner (comma-separated or array)."
    tagList: [String!],
    "Filter runners by type."
    type: CiRunnerType,
    "Filter by upgrade status."
    upgradeStatus: CiRunnerUpgradeStatus
  ): CiRunnerConnection
  "Users within the self-managed instance who are eligible for add-ons. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  selfManagedAddOnEligibleUsers(
    "Type of add on to filter the eligible users by."
    addOnType: GitlabSubscriptionsAddOnType!,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search the user list."
    search: String
  ): AddOnUserConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Find Snippets visible to the current user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: UserID,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Explore personal snippets."
    explore: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: ProjectID,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Fields related to entries in future subscriptions."
  subscriptionFutureEntries(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SubscriptionFutureEntryConnection
  "Find a synthetic note Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  syntheticNote(
    "Global ID of the resource to search synthetic note on."
    noteableId: NoteableID!,
    "Global ID of the note."
    sha: String!
  ): Note @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "Find timelogs visible to the current user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "Retrieve a single to-do item"
  todo(
    "ID of the to-do item."
    id: TodoID!
  ): Todo
  "Find project topics."
  topics(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for topic name."
    search: String
  ): TopicConnection
  "Get statistics on the instance."
  usageTrendsMeasurements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Type of measurement or statistics to retrieve."
    identifier: MeasurementIdentifier!,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Measurement recorded after this date."
    recordedAfter: Time,
    "Measurement recorded before this date."
    recordedBefore: Time
  ): UsageTrendsMeasurementConnection
  "Find a user."
  user(
    "ID of the User."
    id: UserID,
    "Username of the User."
    username: String
  ): UserCore
  "Find users."
  users(
    "Return only admin users."
    admins: Boolean = false,
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Return users member of a given group."
    groupId: GroupID,
    "List of user Global IDs."
    ids: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Query to search users by name, username, or primary email."
    search: String,
    "Sort users by this criteria."
    sort: Sort = created_desc,
    "List of usernames."
    usernames: [String!]
  ): UserCoreConnection
  "Vulnerabilities reported on projects on the current user's instance security dashboard."
  vulnerabilities(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter vulnerabilities by `cluster_agent_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterAgentId: [ClustersAgentID!],
    "Filter vulnerabilities by `cluster_id`. Vulnerabilities with a `reportType` of `cluster_image_scanning` are only included with this filter."
    clusterId: [ClustersClusterID!],
    "Filter by dismissal reason. Only dismissed Vulnerabilities will be included with the filter."
    dismissalReason: [VulnerabilityDismissalReason!],
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns only the vulnerabilities which have linked issues."
    hasIssues: Boolean,
    "Returns only the vulnerabilities which have linked merge requests."
    hasMergeRequest: Boolean,
    "Returns only the vulnerabilities which have remediations."
    hasRemediations: Boolean,
    "Returns only the vulnerabilities which have been resolved on default branch."
    hasResolution: Boolean,
    "Filter vulnerabilities by location image. When this filter is present, the response only matches entries for a `reportType` that includes `container_scanning`, `cluster_image_scanning`."
    image: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter vulnerabilities by OWASP Top 10 category."
    owaspTopTen: [VulnerabilityOwaspTop10!],
    "Filter vulnerabilities by project."
    projectId: [ID!],
    "Filter vulnerabilities by report type."
    reportType: [VulnerabilityReportType!],
    "Filter vulnerabilities by VulnerabilityScanner.externalId."
    scanner: [String!],
    "Filter vulnerabilities by scanner ID."
    scannerId: [VulnerabilitiesScannerID!],
    "Filter vulnerabilities by severity."
    severity: [VulnerabilitySeverity!],
    "List vulnerabilities by sort order."
    sort: VulnerabilitySort = severity_desc,
    "Filter vulnerabilities by state."
    state: [VulnerabilityState!]
  ): VulnerabilityConnection
  "The historical number of vulnerabilities per day for the projects on the current user's instance security dashboard."
  vulnerabilitiesCountByDay(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Last day for which to fetch vulnerability history."
    endDate: ISO8601Date!,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "First day for which to fetch vulnerability history."
    startDate: ISO8601Date!
  ): VulnerabilitiesCountByDayConnection
  "Find a vulnerability."
  vulnerability(
    "Global ID of the Vulnerability."
    id: VulnerabilityID!
  ): Vulnerability
  "Find a work item. Introduced in 15.1: This feature is an Experiment. It can be changed or removed at any time."
  workItem(
    "Global ID of the work item."
    id: WorkItemID!
  ): WorkItem @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.1.")
  "Find work items by their reference. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  workItemsByReference(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Full path of the context namespace (project or group)."
    contextNamespacePath: ID,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Work item references. Can be either a short reference or URL."
    refs: [String!]!
  ): WorkItemConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Find a workspace. Introduced in 16.0: This feature is an Experiment. It can be changed or removed at any time."
  workspace(
    "Find a workspace by its ID."
    id: RemoteDevelopmentWorkspaceID!
  ): Workspace @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
  "Find workspaces across the entire instance. This field is only available to instance admins, it will return an empty result for all non-admins. Introduced in 16.0: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!],
    "Filter workspaces by user GlobalIDs."
    userIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.0.")
}

type QueryComplexity {
  "GraphQL query complexity limit."
  limit: Int
  "GraphQL query complexity score."
  score: Int
}

"Aggregated statistics about queueing times for CI jobs"
type QueueingDelayHistory {
  "Time series."
  timeSeries: [QueueingHistoryTimeSeries!]
}

"The amount of time for a job to be picked up by a runner, in percentiles."
type QueueingHistoryTimeSeries {
  "50th percentile. 50% of the durations are lower than this value. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  p50: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "75th percentile. 75% of the durations are lower than this value. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  p75: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "90th percentile. 90% of the durations are lower than this value. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  p90: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "95th percentile. 95% of the durations are lower than this value. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  p95: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "99th percentile. 99% of the durations are lower than this value. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  p99: Duration @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Start of the time interval."
  time: Time!
}

"Recent failure history of a test case."
type RecentFailures {
  "Name of the base branch of the project."
  baseBranch: String
  "Number of times the test case has failed in the past 14 days."
  count: Int
}

"Represents a release"
type Release {
  "Assets of the release."
  assets: ReleaseAssets
  "User that created the release."
  author: UserCore
  "Commit associated with the release."
  commit: Commit
  "Timestamp of when the release was created."
  createdAt: Time
  "Description (also known as \"release notes\") of the release."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Evidence for the release."
  evidences(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseEvidenceConnection
  "Indicates the release is an historical release."
  historicalRelease: Boolean
  "Global ID of the release."
  id: ReleaseID!
  "Links of the release."
  links: ReleaseLinks
  "Milestones associated to the release."
  milestones(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): MilestoneConnection
  "Name of the release."
  name: String
  "Timestamp of when the release was released."
  releasedAt: Time
  "Name of the tag associated with the release."
  tagName: String
  "Relative web path to the tag associated with the release."
  tagPath: String
  "Indicates the release is an upcoming release."
  upcomingRelease: Boolean
}

"Represents an asset link associated with a release"
type ReleaseAssetLink {
  "Relative path for the direct asset link."
  directAssetPath: String
  "Direct asset URL of the link."
  directAssetUrl: String
  "ID of the link."
  id: ID!
  "Type of the link: `other`, `runbook`, `image`, `package`; defaults to `other`."
  linkType: ReleaseAssetLinkType
  "Name of the link."
  name: String
  "URL of the link."
  url: String
}

"The connection type for ReleaseAssetLink."
type ReleaseAssetLinkConnection {
  "A list of edges."
  edges: [ReleaseAssetLinkEdge]
  "A list of nodes."
  nodes: [ReleaseAssetLink]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of ReleaseAssetLinkCreate."
type ReleaseAssetLinkCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Asset link after mutation."
  link: ReleaseAssetLink
}

"Autogenerated return type of ReleaseAssetLinkDelete."
type ReleaseAssetLinkDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted release asset link."
  link: ReleaseAssetLink
}

"An edge in a connection."
type ReleaseAssetLinkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ReleaseAssetLink
}

"Autogenerated return type of ReleaseAssetLinkUpdate."
type ReleaseAssetLinkUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Asset link after mutation."
  link: ReleaseAssetLink
}

"A container for all assets associated with a release"
type ReleaseAssets {
  "Number of assets of the release."
  count: Int
  "Asset links of the release."
  links(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseAssetLinkConnection
  "Sources of the release."
  sources(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ReleaseSourceConnection
}

"The connection type for Release."
type ReleaseConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [ReleaseEdge]
  "A list of nodes."
  nodes: [Release]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of ReleaseCreate."
type ReleaseCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Release after mutation."
  release: Release
}

"Autogenerated return type of ReleaseDelete."
type ReleaseDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted release."
  release: Release
}

"An edge in a connection."
type ReleaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Release
}

"Evidence for a release"
type ReleaseEvidence {
  "Timestamp when the evidence was collected."
  collectedAt: Time
  "URL from where the evidence can be downloaded."
  filepath: String
  "ID of the evidence."
  id: ID!
  "SHA1 ID of the evidence hash."
  sha: String
}

"The connection type for ReleaseEvidence."
type ReleaseEvidenceConnection {
  "A list of edges."
  edges: [ReleaseEvidenceEdge]
  "A list of nodes."
  nodes: [ReleaseEvidence]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ReleaseEvidenceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ReleaseEvidence
}

type ReleaseLinks {
  "HTTP URL of the issues page, filtered by this release and `state=closed`."
  closedIssuesUrl: String
  "HTTP URL of the merge request page , filtered by this release and `state=closed`."
  closedMergeRequestsUrl: String
  "HTTP URL of the release's edit page."
  editUrl: String
  "HTTP URL of the merge request page , filtered by this release and `state=merged`."
  mergedMergeRequestsUrl: String
  "HTTP URL of the issues page, filtered by this release and `state=open`."
  openedIssuesUrl: String
  "HTTP URL of the merge request page, filtered by this release and `state=open`."
  openedMergeRequestsUrl: String
  "HTTP URL of the release."
  selfUrl: String
}

"Represents the source code attached to a release in a particular format"
type ReleaseSource {
  "Format of the source."
  format: String
  "Download URL of the source."
  url: String
}

"The connection type for ReleaseSource."
type ReleaseSourceConnection {
  "A list of edges."
  edges: [ReleaseSourceEdge]
  "A list of nodes."
  nodes: [ReleaseSource]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ReleaseSourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ReleaseSource
}

"Autogenerated return type of ReleaseUpdate."
type ReleaseUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Release after mutation."
  release: Release
}

"Autogenerated return type of RemoveProjectFromSecurityDashboard."
type RemoveProjectFromSecurityDashboardPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of RepositionImageDiffNote."
type RepositionImageDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
}

type Repository {
  "Blobs contained within the repository"
  blobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Array of desired blob paths."
    paths: [String!]!,
    "Commit ref to get the blobs from. Default value is HEAD."
    ref: String,
    "Type of ref."
    refType: RefType
  ): RepositoryBlobConnection
  "Names of branches available in this repository that match the search pattern."
  branchNames(
    "Number of branch names to return."
    limit: Int!,
    "Number of branch names to skip."
    offset: Int!,
    "Pattern to search for branch names by."
    searchPattern: String!
  ): [String!]
  "Path to CODEOWNERS file in a ref."
  codeOwnersPath(
    "Name of the ref."
    ref: String
  ): String
  "Shows a disk path of the repository."
  diskPath: String
  "Indicates repository has no visible content."
  empty: Boolean!
  "Indicates a corresponding Git repository exists on disk."
  exists: Boolean!
  "Paginated tree of the repository."
  paginatedTree(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Path to get the tree for. Default value is the root of the repository."
    path: String = "",
    "Used to get a recursive tree. Default is false."
    recursive: Boolean = false,
    "Commit ref to get the tree for. Default value is HEAD."
    ref: String,
    "Type of ref."
    refType: RefType
  ): TreeConnection
  "Default branch of the repository."
  rootRef: String
  "Tree of the repository."
  tree(
    "Path to get the tree for. Default value is the root of the repository."
    path: String = "",
    "Used to get a recursive tree. Default is false."
    recursive: Boolean = false,
    "Commit ref to get the tree for. Default value is HEAD."
    ref: String,
    "Type of ref."
    refType: RefType
  ): Tree
  "Shows linting errors in the CODEOWNER file of the repository."
  validateCodeownerFile(
    "Path of a file called CODEOWNERS that should be validated. Default to file in use."
    path: String,
    "Ref where code owners file needs to be  checked. Defaults to the repository's default branch."
    ref: String
  ): RepositoryCodeownerValidation
}

type RepositoryBlob {
  "Whether the current project is archived."
  archived: Boolean
  "Blob blame.  Available only when feature flag `graphql_git_blame` is enabled. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  blame(
    "Range starting from the line. Cannot be less than 1 or greater than `to_line`."
    fromLine: Int = 1,
    "Range ending on the line. Cannot be smaller than `from_line` or greater than `from_line` + 100."
    toLine: Int = 1
  ): Blame @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Web path to blob blame page."
  blamePath: String
  "Whether the current user can push to the branch."
  canCurrentUserPushToBranch: Boolean
  "Whether the current user can modify the blob."
  canModifyBlob: Boolean
  "Web path for code navigation."
  codeNavigationPath: String
  "List of code owners for the blob."
  codeOwners: [UserCore!]
  "Web path to edit the blob in the old-style editor."
  editBlobPath: String
  "Web path to blob on an environment."
  environmentExternalUrlForRouteMap: String
  "Environment on which the blob is available."
  environmentFormattedExternalUrl: String
  "External storage being used, if enabled (for instance, 'LFS')."
  externalStorage: String
  "Web path to download the raw blob via external storage, if enabled."
  externalStorageUrl: String
  "Expected format of the blob based on the extension."
  fileType: String
  "Web path to find file."
  findFilePath: String
  "Web path to edit this blob using a forked project."
  forkAndEditPath: String
  "Web path to view this blob using a forked project."
  forkAndViewPath: String
  "URL to the blob within Gitpod."
  gitpodBlobUrl: String
  "Web path to blob history page."
  historyPath: String
  "ID of the blob."
  id: ID!
  "Web path to edit this blob in the Web IDE."
  ideEditPath: String
  "Web path to edit this blob in the Web IDE using a forked project."
  ideForkAndEditPath: String
  "Blob language."
  language: String
  "LFS OID of the blob."
  lfsOid: String
  "Blob mode."
  mode: String
  "Blob name."
  name: String
  "OID of the blob."
  oid: String!
  "Path of the blob."
  path: String!
  "Web path to blob permalink."
  permalinkPath: String
  "Web path to edit .gitlab-ci.yml file."
  pipelineEditorPath: String
  "Blob plain highlighted data."
  plainData: String
  "Web path for the root of the blob."
  projectBlobPathRoot: String
  "Raw content of the blob."
  rawBlob: String
  "Web path to download the raw blob."
  rawPath: String
  "Size (in bytes) of the blob, or the blob target if stored externally."
  rawSize: BigInt
  "Raw content of the blob, if the blob is text data."
  rawTextBlob: String
  "Web path to replace the blob content."
  replacePath: String
  "Blob content rich viewer."
  richViewer: BlobViewer
  "Blob content simple viewer."
  simpleViewer: BlobViewer!
  "Size (in bytes) of the blob."
  size: BigInt
  "Whether the blob's content is stored externally (for instance, in LFS)."
  storedExternally: Boolean
  "Web path of the blob."
  webPath: String
}

"The connection type for RepositoryBlob."
type RepositoryBlobConnection {
  "A list of edges."
  edges: [RepositoryBlobEdge]
  "A list of nodes."
  nodes: [RepositoryBlob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type RepositoryBlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RepositoryBlob
}

type RepositoryCodeownerError {
  "Linting error code."
  code: String!
  "Lines where the error occurred."
  lines: [Int!]!
}

type RepositoryCodeownerValidation {
  "Total number of validation error in the file."
  total: Int!
  "Specific lint error code."
  validationErrors: [RepositoryCodeownerError!]!
}

type RepositoryLanguage {
  "Color to visualize the repository language."
  color: Color
  "Name of the repository language."
  name: String!
  "Percentage of the repository's languages."
  share: Float
}

"Represents a requirement"
type Requirement {
  "Author of the requirement."
  author: UserCore!
  "Timestamp of when the requirement was created."
  createdAt: Time!
  "Description of the requirement."
  description: String
  "GitLab Flavored Markdown rendering of `description`."
  descriptionHtml: String
  "ID of the requirement."
  id: ID!
  "Internal ID of the requirement. Deprecated in 15.8: Use work_item_iid instead."
  iid: ID! @deprecated(reason: "Use work_item_iid instead. Deprecated in 15.8.")
  "Indicates if latest test report was created by user."
  lastTestReportManuallyCreated: Boolean
  "Latest requirement test report state."
  lastTestReportState: TestReportState
  "Project to which the requirement belongs."
  project: Project!
  "State of the requirement."
  state: RequirementState!
  "Test reports of the requirement."
  testReports(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List test reports by sort order."
    sort: Sort
  ): TestReportConnection
  "Title of the requirement."
  title: String
  "GitLab Flavored Markdown rendering of `title`."
  titleHtml: String
  "Timestamp of when the requirement was last updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: RequirementPermissions!
  "Work item IID of the requirement, will replace current IID as identifier soon."
  workItemIid: ID!
}

"The connection type for Requirement."
type RequirementConnection {
  "A list of edges."
  edges: [RequirementEdge]
  "A list of nodes."
  nodes: [Requirement]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type RequirementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Requirement
}

"Check permissions for the current user on a requirement"
type RequirementPermissions {
  "If `true`, the user can perform `admin_requirement` on this resource"
  adminRequirement: Boolean!
  "If `true`, the user can perform `create_requirement` on this resource"
  createRequirement: Boolean!
  "If `true`, the user can perform `destroy_requirement` on this resource"
  destroyRequirement: Boolean!
  "If `true`, the user can perform `read_requirement` on this resource"
  readRequirement: Boolean!
  "If `true`, the user can perform `update_requirement` on this resource"
  updateRequirement: Boolean!
}

"Counts of requirements by their state"
type RequirementStatesCount {
  "Number of archived requirements."
  archived: Int
  "Number of opened requirements."
  opened: Int
}

type RootStorageStatistics {
  "CI artifacts size in bytes."
  buildArtifactsSize: Float!
  "Container Registry size in bytes."
  containerRegistrySize: Float!
  "Indicates whether the deduplicated Container Registry size for the namespace is an estimated value or not."
  containerRegistrySizeIsEstimated: Boolean!
  "Total storage in bytes with any applicable cost factor for forks applied. This will equal storage_size if there is no applicable cost factor. Introduced in 16.2: This feature is an Experiment. It can be changed or removed at any time."
  costFactoredStorageSize: Float! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.")
  "Dependency Proxy sizes in bytes."
  dependencyProxySize: Float!
  "LFS objects size in bytes."
  lfsObjectsSize: Float!
  "Packages size in bytes."
  packagesSize: Float!
  "CI pipeline artifacts size in bytes."
  pipelineArtifactsSize: Float!
  "Indicates whether the deduplicated Container Registry size for the namespace is an estimated value or not. Deprecated in 16.2: Use `container_registry_size_is_estimated`."
  registrySizeEstimated: Boolean! @deprecated(reason: "Use `container_registry_size_is_estimated`. Deprecated in 16.2.")
  "Git repository size in bytes."
  repositorySize: Float!
  "Snippets size in bytes."
  snippetsSize: Float!
  "Total storage in bytes."
  storageSize: Float!
  "Uploads size in bytes."
  uploadsSize: Float!
  "Wiki size in bytes."
  wikiSize: Float!
}

type RunnerArchitecture {
  "Download location for the runner for the platform architecture."
  downloadLocation: String!
  "Name of the runner platform architecture."
  name: String!
}

"The connection type for RunnerArchitecture."
type RunnerArchitectureConnection {
  "A list of edges."
  edges: [RunnerArchitectureEdge]
  "A list of nodes."
  nodes: [RunnerArchitecture]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type RunnerArchitectureEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RunnerArchitecture
}

"Autogenerated return type of RunnerCreate."
type RunnerCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Runner after mutation."
  runner: CiRunner
}

"Autogenerated return type of RunnerDelete."
type RunnerDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type RunnerPermissions {
  "If `true`, the user can perform `assign_runner` on this resource"
  assignRunner: Boolean!
  "If `true`, the user can perform `delete_runner` on this resource"
  deleteRunner: Boolean!
  "If `true`, the user can perform `read_runner` on this resource"
  readRunner: Boolean!
  "If `true`, the user can perform `update_runner` on this resource"
  updateRunner: Boolean!
}

type RunnerPlatform {
  "Runner architectures supported for the platform."
  architectures(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): RunnerArchitectureConnection
  "Human readable name of the runner platform."
  humanReadableName: String!
  "Name slug of the runner platform."
  name: String!
}

"The connection type for RunnerPlatform."
type RunnerPlatformConnection {
  "A list of edges."
  edges: [RunnerPlatformEdge]
  "A list of nodes."
  nodes: [RunnerPlatform]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type RunnerPlatformEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: RunnerPlatform
}

type RunnerSetup {
  "Instructions for installing the runner on the specified architecture."
  installInstructions: String!
  "Instructions for registering the runner. The actual registration tokens are not included in the commands. Instead, a placeholder `$REGISTRATION_TOKEN` is shown."
  registerInstructions: String
}

"Autogenerated return type of RunnerUpdate."
type RunnerUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Runner after mutation."
  runner: CiRunner
}

"Autogenerated return type of RunnersExportUsage."
type RunnersExportUsagePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of RunnersRegistrationTokenReset."
type RunnersRegistrationTokenResetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Runner token after mutation."
  token: String
}

"Represents a CI configuration of SAST"
type SastCiConfiguration {
  "List of analyzers entities attached to SAST configuration."
  analyzers(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationAnalyzersEntityConnection
  "List of global entities related to SAST configuration."
  global(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationEntityConnection
  "List of pipeline entities related to SAST configuration."
  pipeline(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationEntityConnection
}

"Represents an analyzer entity in SAST CI configuration"
type SastCiConfigurationAnalyzersEntity {
  "Analyzer description that is displayed on the form."
  description: String
  "Indicates whether an analyzer is enabled."
  enabled: Boolean
  "Analyzer label used in the config UI."
  label: String
  "Name of the analyzer."
  name: String
  "List of supported variables."
  variables(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationEntityConnection
}

"The connection type for SastCiConfigurationAnalyzersEntity."
type SastCiConfigurationAnalyzersEntityConnection {
  "A list of edges."
  edges: [SastCiConfigurationAnalyzersEntityEdge]
  "A list of nodes."
  nodes: [SastCiConfigurationAnalyzersEntity]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SastCiConfigurationAnalyzersEntityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SastCiConfigurationAnalyzersEntity
}

"Represents an entity in SAST CI configuration"
type SastCiConfigurationEntity {
  "Default value that is used if value is empty."
  defaultValue: String
  "Entity description that is displayed on the form."
  description: String
  "CI keyword of entity."
  field: String
  "Label for entity used in the form."
  label: String
  "Different possible values of the field."
  options(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SastCiConfigurationOptionsEntityConnection
  "Size of the UI component."
  size: SastUiComponentSize
  "Type of the field value."
  type: String
  "Current value of the entity."
  value: String
}

"The connection type for SastCiConfigurationEntity."
type SastCiConfigurationEntityConnection {
  "A list of edges."
  edges: [SastCiConfigurationEntityEdge]
  "A list of nodes."
  nodes: [SastCiConfigurationEntity]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SastCiConfigurationEntityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SastCiConfigurationEntity
}

"Represents an entity for options in SAST CI configuration"
type SastCiConfigurationOptionsEntity {
  "Label of option entity."
  label: String
  "Value of option entity."
  value: String
}

"The connection type for SastCiConfigurationOptionsEntity."
type SastCiConfigurationOptionsEntityConnection {
  "A list of edges."
  edges: [SastCiConfigurationOptionsEntityEdge]
  "A list of nodes."
  nodes: [SastCiConfigurationOptionsEntity]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SastCiConfigurationOptionsEntityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SastCiConfigurationOptionsEntity
}

type SavedReply {
  "Content of the saved reply."
  content: String!
  "Global ID of the saved reply."
  id: UsersSavedReplyID!
  "Name of the saved reply."
  name: String!
}

"The connection type for SavedReply."
type SavedReplyConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [SavedReplyEdge]
  "A list of nodes."
  nodes: [SavedReply]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of SavedReplyCreate."
type SavedReplyCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Saved reply after mutation."
  savedReply: SavedReply
}

"Autogenerated return type of SavedReplyDestroy."
type SavedReplyDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Saved reply after mutation."
  savedReply: SavedReply
}

"An edge in a connection."
type SavedReplyEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SavedReply
}

"Autogenerated return type of SavedReplyUpdate."
type SavedReplyUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Saved reply after mutation."
  savedReply: SavedReply
}

"Represents the security scan information"
type Scan {
  "List of errors."
  errors: [String!]!
  "Name of the scan."
  name: String!
  "Indicates the status of the scan."
  status: ScanStatus!
  "List of warnings."
  warnings: [String!]!
}

"The connection type for Scan."
type ScanConnection {
  "A list of edges."
  edges: [ScanEdge]
  "A list of nodes."
  nodes: [Scan]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ScanEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Scan
}

"Represents the scan execution policy"
type ScanExecutionPolicy implements OrchestrationPolicy {
  "Description of the policy."
  description: String!
  "URL of policy edit page."
  editPath: String!
  "Indicates whether this policy is enabled."
  enabled: Boolean!
  "Name of the policy."
  name: String!
  "Source of the policy. Its fields depend on the source type."
  source: SecurityPolicySource!
  "Timestamp of when the policy YAML was last updated."
  updatedAt: Time!
  "YAML definition of the policy."
  yaml: String!
}

"Autogenerated return type of ScanExecutionPolicyCommit."
type ScanExecutionPolicyCommitPayload {
  "Name of the branch to which the policy changes are committed."
  branch: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Validation errors encountered during execution of the mutation."
  validationErrors: [SecurityPolicyValidationError!]
}

"The connection type for ScanExecutionPolicy."
type ScanExecutionPolicyConnection {
  "A list of edges."
  edges: [ScanExecutionPolicyEdge]
  "A list of nodes."
  nodes: [ScanExecutionPolicy]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ScanExecutionPolicyEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ScanExecutionPolicy
}

"Represents the scan result policy"
type ScanResultPolicy implements OrchestrationPolicy {
  "All potential approvers of the group type, including groups inaccessible to the user."
  allGroupApprovers: [PolicyApprovalGroup!]
  "Description of the policy."
  description: String!
  "URL of policy edit page."
  editPath: String!
  "Indicates whether this policy is enabled."
  enabled: Boolean!
  "Approvers of the group type. Deprecated in 16.5: Use `allGroupApprovers`."
  groupApprovers: [Group!] @deprecated(reason: "Use `allGroupApprovers`. Deprecated in 16.5.")
  "Name of the policy."
  name: String!
  "Approvers of the role type. Users belonging to these role(s) alone will be approvers."
  roleApprovers: [MemberAccessLevelName!]
  "Source of the policy. Its fields depend on the source type."
  source: SecurityPolicySource!
  "Timestamp of when the policy YAML was last updated."
  updatedAt: Time!
  "Approvers of the user type."
  userApprovers: [UserCore!]
  "YAML definition of the policy."
  yaml: String!
}

"The connection type for ScanResultPolicy."
type ScanResultPolicyConnection {
  "A list of edges."
  edges: [ScanResultPolicyEdge]
  "A list of nodes."
  nodes: [ScanResultPolicy]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ScanResultPolicyEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ScanResultPolicy
}

"Represents a resource scanned by a security scan"
type ScannedResource {
  "HTTP request method used to access the URL."
  requestMethod: String
  "URL scanned by the scanner."
  url: String
}

"The connection type for ScannedResource."
type ScannedResourceConnection {
  "A list of edges."
  edges: [ScannedResourceEdge]
  "A list of nodes."
  nodes: [ScannedResource]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ScannedResourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ScannedResource
}

"Autogenerated return type of SecurityFindingCreateIssue."
type SecurityFindingCreateIssuePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
}

"Autogenerated return type of SecurityFindingCreateMergeRequest."
type SecurityFindingCreateMergeRequestPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Merge Request created after mutation."
  mergeRequest: MergeRequest
}

"Autogenerated return type of SecurityFindingDismiss."
type SecurityFindingDismissPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Dismissed finding."
  securityFinding: PipelineSecurityReportFinding
  "UUID of dismissed finding."
  uuid: String
}

"Autogenerated return type of SecurityFindingRevertToDetected."
type SecurityFindingRevertToDetectedPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Finding reverted to detected."
  securityFinding: PipelineSecurityReportFinding
}

"Autogenerated return type of SecurityPolicyProjectAssign."
type SecurityPolicyProjectAssignPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of SecurityPolicyProjectCreate."
type SecurityPolicyProjectCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Security Policy Project that was created."
  project: Project
}

"Autogenerated return type of SecurityPolicyProjectUnassign."
type SecurityPolicyProjectUnassignPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Security policy validation error"
type SecurityPolicyValidationError {
  "Error field."
  field: String!
  "Error level."
  level: String!
  "Error message."
  message: String!
  "Error title."
  title: String
}

"Represents summary of a security report"
type SecurityReportSummary {
  "Aggregated counts for the `api_fuzzing` scan"
  apiFuzzing: SecurityReportSummarySection
  "Aggregated counts for the `cluster_image_scanning` scan"
  clusterImageScanning: SecurityReportSummarySection
  "Aggregated counts for the `container_scanning` scan"
  containerScanning: SecurityReportSummarySection
  "Aggregated counts for the `coverage_fuzzing` scan"
  coverageFuzzing: SecurityReportSummarySection
  "Aggregated counts for the `dast` scan"
  dast: SecurityReportSummarySection
  "Aggregated counts for the `dependency_scanning` scan"
  dependencyScanning: SecurityReportSummarySection
  "Aggregated counts for the `generic` scan"
  generic: SecurityReportSummarySection
  "Aggregated counts for the `sast` scan"
  sast: SecurityReportSummarySection
  "Aggregated counts for the `secret_detection` scan"
  secretDetection: SecurityReportSummarySection
}

"Represents a section of a summary of a security report"
type SecurityReportSummarySection {
  "List of the first 20 scanned resources."
  scannedResources(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ScannedResourceConnection
  "Total number of scanned resources."
  scannedResourcesCount: Int
  "Path to download all the scanned resources in CSV format."
  scannedResourcesCsvPath: String
  "List of security scans ran for the type."
  scans(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ScanConnection!
  "Total number of vulnerabilities."
  vulnerabilitiesCount: Int
}

"Represents a list of security scanners"
type SecurityScanners {
  "List of analyzers which are available for the project."
  available: [SecurityScannerType!]
  "List of analyzers which are enabled for the project."
  enabled: [SecurityScannerType!]
  "List of analyzers which ran successfully in the latest pipeline."
  pipelineRun: [SecurityScannerType!]
}

"Autogenerated return type of SecurityTrainingUpdate."
type SecurityTrainingUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Represents the training entity subject to mutation."
  training: ProjectSecurityTraining
}

"Represents a URL related to a security training"
type SecurityTrainingUrl {
  "Name of the vulnerability identifier."
  identifier: String
  "Name of the training provider."
  name: String
  "Status of the request to training provider."
  status: TrainingUrlRequestStatus
  "URL of the link for security training content."
  url: String
}

"A Sentry error"
type SentryDetailedError {
  "Count of occurrences."
  count: Int!
  "Culprit of the error."
  culprit: String!
  "External Base URL of the Sentry Instance."
  externalBaseUrl: String!
  "External URL of the error."
  externalUrl: String!
  "Commit the error was first seen."
  firstReleaseLastCommit: String
  "Release short version the error was first seen."
  firstReleaseShortVersion: String
  "Release version the error was first seen."
  firstReleaseVersion: String
  "Timestamp when the error was first seen."
  firstSeen: Time!
  "Last 24hr stats of the error."
  frequency: [SentryErrorFrequency!]!
  "GitLab commit SHA attributed to the Error based on the release version."
  gitlabCommit: String
  "Path to the GitLab page for the GitLab commit attributed to the error."
  gitlabCommitPath: String
  "URL of GitLab Issue."
  gitlabIssuePath: String
  "ID (global ID) of the error."
  id: ID!
  "Error tracking backend."
  integrated: Boolean
  "Commit the error was last seen."
  lastReleaseLastCommit: String
  "Release short version the error was last seen."
  lastReleaseShortVersion: String
  "Release version the error was last seen."
  lastReleaseVersion: String
  "Timestamp when the error was last seen."
  lastSeen: Time!
  "Sentry metadata message of the error."
  message: String
  "ID (Sentry ID) of the error."
  sentryId: String!
  "ID of the project (Sentry project)."
  sentryProjectId: ID!
  "Name of the project affected by the error."
  sentryProjectName: String!
  "Slug of the project affected by the error."
  sentryProjectSlug: String!
  "Short ID (Sentry ID) of the error."
  shortId: String!
  "Status of the error."
  status: SentryErrorStatus!
  "Tags associated with the Sentry Error."
  tags: SentryErrorTags!
  "Title of the error."
  title: String!
  "Type of the error."
  type: String!
  "Count of users affected by the error."
  userCount: Int!
}

"A Sentry error. A simplified version of SentryDetailedError"
type SentryError {
  "Count of occurrences."
  count: Int!
  "Culprit of the error."
  culprit: String!
  "External URL of the error."
  externalUrl: String!
  "Timestamp when the error was first seen."
  firstSeen: Time!
  "Last 24hr stats of the error."
  frequency: [SentryErrorFrequency!]!
  "ID (global ID) of the error."
  id: ID!
  "Timestamp when the error was last seen."
  lastSeen: Time!
  "Sentry metadata message of the error."
  message: String
  "ID (Sentry ID) of the error."
  sentryId: String!
  "ID of the project (Sentry project)."
  sentryProjectId: ID!
  "Name of the project affected by the error."
  sentryProjectName: String!
  "Slug of the project affected by the error."
  sentryProjectSlug: String!
  "Short ID (Sentry ID) of the error."
  shortId: String!
  "Status of the error."
  status: SentryErrorStatus!
  "Title of the error."
  title: String!
  "Type of the error."
  type: String!
  "Count of users affected by the error."
  userCount: Int!
}

"An object containing a collection of Sentry errors, and a detailed error"
type SentryErrorCollection {
  "Detailed version of a Sentry error on the project."
  detailedError(
    "ID of the Sentry issue."
    id: GitlabErrorTrackingDetailedErrorID!
  ): SentryDetailedError
  "Stack Trace of Sentry Error."
  errorStackTrace(
    "ID of the Sentry issue."
    id: GitlabErrorTrackingDetailedErrorID!
  ): SentryErrorStackTrace
  "Collection of Sentry Errors."
  errors(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query for the Sentry error details."
    searchTerm: String,
    "Attribute to sort on. Options are frequency, first_seen, last_seen. last_seen is default."
    sort: String
  ): SentryErrorConnection
  "External URL for Sentry."
  externalUrl: String
}

"The connection type for SentryError."
type SentryErrorConnection {
  "A list of edges."
  edges: [SentryErrorEdge]
  "A list of nodes."
  nodes: [SentryError]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SentryErrorEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SentryError
}

type SentryErrorFrequency {
  "Count of errors received since the previously recorded time."
  count: Int!
  "Time the error frequency stats were recorded."
  time: Time!
}

"An object containing a stack trace entry for a Sentry error"
type SentryErrorStackTrace {
  "Time the stack trace was received by Sentry."
  dateReceived: String!
  "ID of the Sentry error."
  issueId: String!
  "Stack trace entries for the Sentry error."
  stackTraceEntries: [SentryErrorStackTraceEntry!]!
}

"An object context for a Sentry error stack trace"
type SentryErrorStackTraceContext {
  "Code number of the context."
  code: String!
  "Line number of the context."
  line: Int!
}

"An object containing a stack trace entry for a Sentry error"
type SentryErrorStackTraceEntry {
  "Function in which the Sentry error occurred."
  col: String
  "File in which the Sentry error occurred."
  fileName: String
  "Function in which the Sentry error occurred."
  function: String
  "Function in which the Sentry error occurred."
  line: String
  "Context of the Sentry error."
  traceContext: [SentryErrorStackTraceContext!]
}

"State of a Sentry error"
type SentryErrorTags {
  "Severity level of the Sentry Error."
  level: String
  "Logger of the Sentry Error."
  logger: String
}

"The connection type for Service."
type ServiceConnection {
  "A list of edges."
  edges: [ServiceEdge]
  "A list of nodes."
  nodes: [Service]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type ServiceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Service
}

"Represents a snippet entry"
type Snippet implements NoteableInterface {
  "Owner of the snippet."
  author: UserCore
  "Snippet blobs."
  blobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Paths of the blobs."
    paths: [String!]
  ): SnippetBlobConnection
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Timestamp this snippet was created."
  createdAt: Time!
  "Description of the snippet."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "File Name of the snippet."
  fileName: String
  "Indicates the snippet is hidden because the author has been banned."
  hidden: Boolean!
  "HTTP URL to the snippet repository."
  httpUrlToRepo: String
  "ID of the snippet."
  id: SnippetID!
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Project the snippet is associated with."
  project: Project
  "Raw URL of the snippet."
  rawUrl: String!
  "SSH URL to the snippet repository."
  sshUrlToRepo: String
  "Title of the snippet."
  title: String!
  "Timestamp this snippet was updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: SnippetPermissions!
  "Visibility Level of the snippet."
  visibilityLevel: VisibilityLevelsEnum!
  "Web URL of the snippet."
  webUrl: String!
}

"Represents the snippet blob"
type SnippetBlob {
  "Shows whether the blob is binary."
  binary: Boolean!
  "Blob external storage."
  externalStorage: String
  "Blob mode."
  mode: String
  "Blob name."
  name: String
  "Blob path."
  path: String
  "Blob plain highlighted data."
  plainData: String
  "Blob raw content endpoint path."
  rawPath: String!
  "Raw content of the blob, if the blob is text data."
  rawPlainData: String
  "Shows whether the blob is rendered as text."
  renderedAsText: Boolean!
  "Blob highlighted data."
  richData: String
  "Blob content rich viewer."
  richViewer: SnippetBlobViewer
  "Blob content simple viewer."
  simpleViewer: SnippetBlobViewer!
  "Blob size."
  size: Int!
}

"The connection type for SnippetBlob."
type SnippetBlobConnection {
  "A list of edges."
  edges: [SnippetBlobEdge]
  "Indicates if the snippet has unretrievable blobs."
  hasUnretrievableBlobs: Boolean!
  "A list of nodes."
  nodes: [SnippetBlob]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SnippetBlobEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SnippetBlob
}

"Represents how the blob content should be displayed"
type SnippetBlobViewer {
  "Shows whether the blob should be displayed collapsed."
  collapsed: Boolean!
  "Content file type."
  fileType: String!
  "Shows whether the blob content is loaded asynchronously."
  loadAsync: Boolean!
  "Loading partial name."
  loadingPartialName: String!
  "Error rendering the blob content."
  renderError: String
  "Shows whether the blob is too large to be displayed."
  tooLarge: Boolean!
  "Type of blob viewer."
  type: BlobViewersType!
}

"The connection type for Snippet."
type SnippetConnection {
  "A list of edges."
  edges: [SnippetEdge]
  "A list of nodes."
  nodes: [Snippet]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SnippetEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Snippet
}

type SnippetPermissions {
  "If `true`, the user can perform `admin_snippet` on this resource"
  adminSnippet: Boolean!
  "If `true`, the user can perform `award_emoji` on this resource"
  awardEmoji: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `read_snippet` on this resource"
  readSnippet: Boolean!
  "If `true`, the user can perform `report_snippet` on this resource"
  reportSnippet: Boolean!
  "If `true`, the user can perform `update_snippet` on this resource"
  updateSnippet: Boolean!
}

"Represents the Geo sync and verification state of a snippet repository"
type SnippetRepositoryRegistry {
  "Timestamp when the SnippetRepositoryRegistry was created"
  createdAt: Time
  "ID of the SnippetRepositoryRegistry"
  id: ID!
  "Error message during sync of the SnippetRepositoryRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the SnippetRepositoryRegistry"
  lastSyncedAt: Time
  "Timestamp after which the SnippetRepositoryRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the SnippetRepositoryRegistry"
  retryCount: Int
  "ID of the Snippet Repository."
  snippetRepositoryId: ID!
  "Sync state of the SnippetRepositoryRegistry"
  state: RegistryState
  "The local checksum of the SnippetRepositoryRegistry"
  verificationChecksum: String
  "Error message during verification of the SnippetRepositoryRegistry"
  verificationFailure: String
  "Timestamp after which the SnippetRepositoryRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the SnippetRepositoryRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of SnippetRepositoryRegistry"
  verificationStartedAt: Time
  "Verification state of the SnippetRepositoryRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the SnippetRepositoryRegistry"
  verifiedAt: Time
}

"The connection type for SnippetRepositoryRegistry."
type SnippetRepositoryRegistryConnection {
  "A list of edges."
  edges: [SnippetRepositoryRegistryEdge]
  "A list of nodes."
  nodes: [SnippetRepositoryRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SnippetRepositoryRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SnippetRepositoryRegistry
}

"SSH signature for a signed commit"
type SshSignature implements CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "SSH key used for the signature."
  key: Key
  "Fingerprint of the key."
  keyFingerprintSha256: String
  "Project of the associated commit."
  project: Project
  "User associated with the key."
  user: UserCore
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
}

"Autogenerated return type of StarProject."
type StarProjectPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of stars for the project."
  count: String!
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type StatusAction {
  "Title for the button, for example: Retry this job."
  buttonTitle: String
  "Icon used in the action button."
  icon: String
  "ID for a status action."
  id: String!
  "Method for the action, for example: :post."
  method: String
  "Path for the action."
  path: String
  "Title for the action, for example: Retry."
  title: String
}

type Submodule implements Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "Last commit SHA for the entry."
  sha: String!
  "Tree URL for the sub-module."
  treeUrl: String
  "Type of tree entry."
  type: EntryType!
  "Web URL for the sub-module."
  webUrl: String
}

"The connection type for Submodule."
type SubmoduleConnection {
  "A list of edges."
  edges: [SubmoduleEdge]
  "A list of nodes."
  nodes: [Submodule]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SubmoduleEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Submodule
}

type Subscription {
  "Triggered when a response from AI integration is received. Introduced in 15.11: This feature is an Experiment. It can be changed or removed at any time."
  aiCompletionResponse(
    "Name of the Ai action performed as part of the mutaton."
    aiAction: AiAction,
    "Client generated ID that be subscribed to, to receive a response for the mutation."
    clientSubscriptionId: String,
    "ID of the resource."
    resourceId: AiModelID,
    "ID of the user."
    userId: UserID
  ): AiMessage @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.11.")
  "Triggered when the assignees of an issuable are updated."
  issuableAssigneesUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the due date or start date of an issuable is updated."
  issuableDatesUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the description of an issuable is updated."
  issuableDescriptionUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the epic of an issuable is updated."
  issuableEpicUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the health status of an issuable is updated."
  issuableHealthStatusUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the iteration of an issuable is updated."
  issuableIterationUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the labels of an issuable are updated."
  issuableLabelsUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the milestone of an issuable is updated."
  issuableMilestoneUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the title of an issuable is updated."
  issuableTitleUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the weight of an issuable is updated."
  issuableWeightUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the crm contacts of an issuable are updated."
  issueCrmContactsUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when approval state of a merge request is updated."
  mergeRequestApprovalStateUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when a merge request diff is generated."
  mergeRequestDiffGenerated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the merge status of a merge request is updated."
  mergeRequestMergeStatusUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when the reviewers of a merge request are updated."
  mergeRequestReviewersUpdated(
    "ID of the issuable."
    issuableId: IssuableID!
  ): Issuable
  "Triggered when a note is created. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  workItemNoteCreated(
    "ID of the noteable."
    noteableId: NoteableID
  ): Note @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "Triggered when a note is deleted. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  workItemNoteDeleted(
    "ID of the noteable."
    noteableId: NoteableID
  ): DeletedNote @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "Triggered when a note is updated. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  workItemNoteUpdated(
    "ID of the noteable."
    noteableId: NoteableID
  ): Note @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "Triggered when a work item is updated."
  workItemUpdated(
    "ID of the work item."
    workItemId: WorkItemID!
  ): WorkItem
}

"Represents an entry from the future subscriptions"
type SubscriptionFutureEntry {
  "Company of the licensee."
  company: String
  "Email of the licensee."
  email: String
  "Date when the license expires."
  expiresAt: Date
  "Name of the licensee."
  name: String
  "Name of the subscription plan."
  plan: String!
  "Date when the license started."
  startsAt: Date
  "Type of license the subscription will yield."
  type: String!
  "Number of paid user seats."
  usersInLicenseCount: Int
}

"The connection type for SubscriptionFutureEntry."
type SubscriptionFutureEntryConnection {
  "A list of edges."
  edges: [SubscriptionFutureEntryEdge]
  "A list of nodes."
  nodes: [SubscriptionFutureEntry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type SubscriptionFutureEntryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: SubscriptionFutureEntry
}

"Represents a Suggested Reviewers result set"
type SuggestedReviewersType {
  "List of accepted reviewer usernames."
  accepted: [String!]
  "Timestamp of when the suggestions were created."
  createdAt: Time!
  "List of suggested reviewer usernames."
  suggested: [String!]!
  "Timestamp of when the suggestions were updated."
  updatedAt: Time!
}

type SystemNoteMetadata {
  "System note metadata action."
  action: String
  "Version of the changed description."
  descriptionVersion: DescriptionVersion
  "Global ID of the specific system note metadata."
  id: SystemNoteMetadataID!
}

"Completion status of tasks"
type TaskCompletionStatus {
  "Number of completed tasks."
  completedCount: Int!
  "Number of total tasks."
  count: Int!
}

type TerraformState {
  "Timestamp the Terraform state was created."
  createdAt: Time!
  "Timestamp the Terraform state was deleted."
  deletedAt: Time
  "ID of the Terraform state."
  id: ID!
  "Latest version of the Terraform state."
  latestVersion: TerraformStateVersion
  "Timestamp the Terraform state was locked."
  lockedAt: Time
  "User currently holding a lock on the Terraform state."
  lockedByUser: UserCore
  "Name of the Terraform state."
  name: String!
  "Timestamp the Terraform state was updated."
  updatedAt: Time!
}

"The connection type for TerraformState."
type TerraformStateConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TerraformStateEdge]
  "A list of nodes."
  nodes: [TerraformState]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of TerraformStateDelete."
type TerraformStateDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type TerraformStateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TerraformState
}

"Autogenerated return type of TerraformStateLock."
type TerraformStateLockPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of TerraformStateUnlock."
type TerraformStateUnlockPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

type TerraformStateVersion {
  "Timestamp the version was created."
  createdAt: Time!
  "User that created this version."
  createdByUser: UserCore
  "URL for downloading the version's JSON file."
  downloadPath: String
  "ID of the Terraform state version."
  id: ID!
  "Job that created this version."
  job: CiJob
  "Serial number of the version."
  serial: Int
  "Timestamp the version was updated."
  updatedAt: Time!
}

"Represents the Geo sync and verification state of a terraform state version"
type TerraformStateVersionRegistry {
  "Timestamp when the TerraformStateVersionRegistry was created"
  createdAt: Time
  "ID of the TerraformStateVersionRegistry"
  id: ID!
  "Error message during sync of the TerraformStateVersionRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the TerraformStateVersionRegistry"
  lastSyncedAt: Time
  "Timestamp after which the TerraformStateVersionRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the TerraformStateVersionRegistry"
  retryCount: Int
  "Sync state of the TerraformStateVersionRegistry"
  state: RegistryState
  "ID of the terraform state version."
  terraformStateVersionId: ID!
  "The local checksum of the TerraformStateVersionRegistry"
  verificationChecksum: String
  "Error message during verification of the TerraformStateVersionRegistry"
  verificationFailure: String
  "Timestamp after which the TerraformStateVersionRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the TerraformStateVersionRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of TerraformStateVersionRegistry"
  verificationStartedAt: Time
  "Verification state of the TerraformStateVersionRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the TerraformStateVersionRegistry"
  verifiedAt: Time
}

"The connection type for TerraformStateVersionRegistry."
type TerraformStateVersionRegistryConnection {
  "A list of edges."
  edges: [TerraformStateVersionRegistryEdge]
  "A list of nodes."
  nodes: [TerraformStateVersionRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TerraformStateVersionRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TerraformStateVersionRegistry
}

"Test case in pipeline test report."
type TestCase {
  "URL of the test case attachment file."
  attachmentUrl: String
  "Classname of the test case."
  classname: String
  "Test case execution time in seconds."
  executionTime: Float
  "Path to the file of the test case."
  file: String
  "Name of the test case."
  name: String
  "Recent failure history of the test case on the base branch."
  recentFailures: RecentFailures
  "Stack trace of the test case."
  stackTrace: String
  "Status of the test case (error, failed, success, skipped)."
  status: TestCaseStatus
  "System output of the test case."
  systemOutput: String
}

"The connection type for TestCase."
type TestCaseConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TestCaseEdge]
  "A list of nodes."
  nodes: [TestCase]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TestCaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TestCase
}

"Represents a requirement test report"
type TestReport {
  "Author of the test report."
  author: UserCore
  "Timestamp of when the test report was created."
  createdAt: Time!
  "ID of the test report."
  id: ID!
  "State of the test report."
  state: TestReportState!
  "Indicates whether the test report was generated with references to legacy requirement IIDs."
  usesLegacyIid: Boolean
}

"The connection type for TestReport."
type TestReportConnection {
  "A list of edges."
  edges: [TestReportEdge]
  "A list of nodes."
  nodes: [TestReport]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TestReportEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TestReport
}

"Test report for a pipeline"
type TestReportSummary {
  "Test suites belonging to a pipeline test report."
  testSuites(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TestSuiteSummaryConnection!
  "Total report statistics for a pipeline test report."
  total: TestReportTotal!
}

"Total test report statistics."
type TestReportTotal {
  "Total number of the test cases."
  count: Int
  "Total number of test cases that had an error."
  error: Int
  "Total number of test cases that failed."
  failed: Int
  "Total number of test cases that were skipped."
  skipped: Int
  "Total number of test cases that succeeded."
  success: Int
  "Test suite error message."
  suiteError: String
  "Total duration of the tests."
  time: Float
}

"Test suite in a pipeline test report."
type TestSuite {
  "Total number of test cases that had an error."
  errorCount: Int
  "Total number of test cases that failed in the test suite."
  failedCount: Int
  "Name of the test suite."
  name: String
  "Total number of test cases that were skipped in the test suite."
  skippedCount: Int
  "Total number of test cases that succeeded in the test suite."
  successCount: Int
  "Test suite error message."
  suiteError: String
  "Test cases in the test suite."
  testCases(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TestCaseConnection
  "Total number of the test cases in the test suite."
  totalCount: Int
  "Total duration of the tests in the test suite."
  totalTime: Float
}

"Test suite summary in a pipeline test report."
type TestSuiteSummary {
  "IDs of the builds used to run the test suite."
  buildIds: [ID!]
  "Total number of test cases that had an error."
  errorCount: Int
  "Total number of test cases that failed in the test suite."
  failedCount: Int
  "Name of the test suite."
  name: String
  "Total number of test cases that were skipped in the test suite."
  skippedCount: Int
  "Total number of test cases that succeeded in the test suite."
  successCount: Int
  "Test suite error message."
  suiteError: String
  "Total number of the test cases in the test suite."
  totalCount: Int
  "Total duration of the tests in the test suite."
  totalTime: Float
}

"The connection type for TestSuiteSummary."
type TestSuiteSummaryConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TestSuiteSummaryEdge]
  "A list of nodes."
  nodes: [TestSuiteSummary]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TestSuiteSummaryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TestSuiteSummary
}

"Represents the time report stats for timeboxes"
type TimeReportStats {
  "Completed issues metrics."
  complete: TimeboxMetrics
  "Incomplete issues metrics."
  incomplete: TimeboxMetrics
  "Total issues metrics."
  total: TimeboxMetrics
}

type TimeTrackingTimelogCategory {
  "Whether the category is billable or not."
  billable: Boolean
  "Billing rate for the category."
  billingRate: Float
  "Color assigned to the category."
  color: Color
  "When the category was created."
  createdAt: Time!
  "Description of the category."
  description: String
  "Internal ID of the timelog category."
  id: ID!
  "Name of the category."
  name: String!
  "When the category was last updated."
  updatedAt: Time!
}

"The connection type for TimeTrackingTimelogCategory."
type TimeTrackingTimelogCategoryConnection {
  "A list of edges."
  edges: [TimeTrackingTimelogCategoryEdge]
  "A list of nodes."
  nodes: [TimeTrackingTimelogCategory]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TimeTrackingTimelogCategoryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TimeTrackingTimelogCategory
}

"Represents measured stats metrics for timeboxes"
type TimeboxMetrics {
  "Count metric."
  count: Int!
  "Weight metric."
  weight: Int!
}

"Represents a historically accurate report about the timebox"
type TimeboxReport {
  "Daily scope and completed totals for burnup charts."
  burnupTimeSeries: [BurnupChartDailyTotals!]
  "If the report cannot be generated, information about why."
  error: TimeboxReportError
  "Represents the time report stats for the timebox."
  stats: TimeReportStats
}

"Explains why we could not generate a timebox report."
type TimeboxReportError {
  "Machine readable code, categorizing the error."
  code: TimeboxReportErrorReason
  "Human readable message explaining what happened."
  message: String
}

"Autogenerated return type of TimelineEventCreate."
type TimelineEventCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}

"Autogenerated return type of TimelineEventDestroy."
type TimelineEventDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}

"Autogenerated return type of TimelineEventPromoteFromNote."
type TimelineEventPromoteFromNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}

"Autogenerated return type of TimelineEventTagCreate."
type TimelineEventTagCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event tag."
  timelineEventTag: TimelineEventTagType
}

"Describes a tag on an incident management timeline event."
type TimelineEventTagType {
  "ID of the timeline event tag."
  id: IncidentManagementTimelineEventTagID!
  "Name of the timeline event tag."
  name: String!
}

"The connection type for TimelineEventTagType."
type TimelineEventTagTypeConnection {
  "A list of edges."
  edges: [TimelineEventTagTypeEdge]
  "A list of nodes."
  nodes: [TimelineEventTagType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TimelineEventTagTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TimelineEventTagType
}

"Describes an incident management timeline event"
type TimelineEventType {
  "Indicates the timeline event icon."
  action: String!
  "User that created the timeline event."
  author: UserCore
  "Timestamp when the event created."
  createdAt: Time!
  "Indicates the timeline event is editable."
  editable: Boolean!
  "ID of the timeline event."
  id: IncidentManagementTimelineEventID!
  "Incident of the timeline event."
  incident: Issue!
  "Text note of the timeline event."
  note: String
  "HTML note of the timeline event."
  noteHtml: String
  "Timestamp when the event occurred."
  occurredAt: Time!
  "Note from which the timeline event was created."
  promotedFromNote: Note
  "Tags for the incident timeline event."
  timelineEventTags(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TimelineEventTagTypeConnection
  "Timestamp when the event updated."
  updatedAt: Time!
  "User that updated the timeline event."
  updatedByUser: UserCore
}

"The connection type for TimelineEventType."
type TimelineEventTypeConnection {
  "A list of edges."
  edges: [TimelineEventTypeEdge]
  "A list of nodes."
  nodes: [TimelineEventType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TimelineEventTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TimelineEventType
}

"Autogenerated return type of TimelineEventUpdate."
type TimelineEventUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timeline event."
  timelineEvent: TimelineEventType
}

type Timelog {
  "Internal ID of the timelog."
  id: ID!
  "Issue that logged time was added to."
  issue: Issue
  "Merge request that logged time was added to."
  mergeRequest: MergeRequest
  "Note where the quick action was executed to add the logged time."
  note: Note
  "Target project of the timelog merge request or issue."
  project: Project!
  "Timestamp of when the time tracked was spent at."
  spentAt: Time
  "Summary of how the time was spent."
  summary: String
  "Time spent displayed in seconds."
  timeSpent: Int!
  "User that logged the time."
  user: UserCore!
  "Permissions for the current user on the resource"
  userPermissions: TimelogPermissions!
}

"The connection type for Timelog."
type TimelogConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [TimelogEdge]
  "A list of nodes."
  nodes: [Timelog]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Total time spent in seconds."
  totalSpentTime: BigInt!
}

"Autogenerated return type of TimelogCreate."
type TimelogCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timelog."
  timelog: Timelog
}

"Autogenerated return type of TimelogDelete."
type TimelogDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Timelog."
  timelog: Timelog
}

"An edge in a connection."
type TimelogEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Timelog
}

type TimelogPermissions {
  "If `true`, the user can perform `admin_timelog` on this resource"
  adminTimelog: Boolean!
}

"Representing a to-do entry"
type Todo {
  "Action of the to-do item."
  action: TodoActionEnum!
  "Author of this to-do item."
  author: UserCore!
  "Body of the to-do item."
  body: String!
  "Timestamp this to-do item was created."
  createdAt: Time!
  "Group this to-do item is associated with."
  group: Group
  "ID of the to-do item."
  id: ID!
  "Note which created this to-do item."
  note: Note
  "Project this to-do item is associated with."
  project: Project
  "State of the to-do item."
  state: TodoStateEnum!
  "Target of the to-do item."
  target: Todoable!
  "Target type of the to-do item."
  targetType: TodoTargetEnum!
}

"The connection type for Todo."
type TodoConnection {
  "A list of edges."
  edges: [TodoEdge]
  "A list of nodes."
  nodes: [Todo]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of TodoCreate."
type TodoCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "To-do item created."
  todo: Todo
}

"An edge in a connection."
type TodoEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Todo
}

"Autogenerated return type of TodoMarkDone."
type TodoMarkDonePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requested to-do item."
  todo: Todo!
}

"Autogenerated return type of TodoRestoreMany."
type TodoRestoreManyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated to-do items."
  todos: [Todo!]!
}

"Autogenerated return type of TodoRestore."
type TodoRestorePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requested to-do item."
  todo: Todo!
}

"Autogenerated return type of TodosMarkAllDone."
type TodosMarkAllDonePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated to-do items."
  todos: [Todo!]!
}

type Topic {
  "URL to avatar image file of the topic."
  avatarUrl: String
  "Description of the topic."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "ID of the topic."
  id: ID!
  "Name of the topic."
  name: String!
  "Title of the topic."
  title: String!
}

"The connection type for Topic."
type TopicConnection {
  "A list of edges."
  edges: [TopicEdge]
  "A list of nodes."
  nodes: [Topic]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TopicEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Topic
}

type Tree {
  "Blobs of the tree."
  blobs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): BlobConnection!
  "Last commit for the tree."
  lastCommit: Commit
  "Sub-modules of the tree."
  submodules(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SubmoduleConnection!
  "Trees of the tree."
  trees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TreeEntryConnection!
}

"The connection type for Tree."
type TreeConnection {
  "A list of edges."
  edges: [TreeEdge]
  "A list of nodes."
  nodes: [Tree]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TreeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Tree
}

"Represents a directory"
type TreeEntry implements Entry {
  "Flat path of the entry."
  flatPath: String!
  "ID of the entry."
  id: ID!
  "Name of the entry."
  name: String!
  "Path of the entry."
  path: String!
  "Last commit SHA for the entry."
  sha: String!
  "Type of tree entry."
  type: EntryType!
  "Web path for the tree entry (directory)."
  webPath: String
  "Web URL for the tree entry (directory)."
  webUrl: String
}

"The connection type for TreeEntry."
type TreeEntryConnection {
  "A list of edges."
  edges: [TreeEntryEdge]
  "A list of nodes."
  nodes: [TreeEntry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type TreeEntryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: TreeEntry
}

"Defines which user roles, users, or groups can unprotect a protected branch."
type UnprotectAccessLevel {
  "GitLab::Access level."
  accessLevel: Int!
  "Human readable representation for this access level."
  accessLevelDescription: String!
  "Group associated with this access level."
  group: AccessLevelGroup
  "User associated with this access level."
  user: AccessLevelUser
}

"The connection type for UnprotectAccessLevel."
type UnprotectAccessLevelConnection {
  "A list of edges."
  edges: [UnprotectAccessLevelEdge]
  "A list of nodes."
  nodes: [UnprotectAccessLevel]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type UnprotectAccessLevelEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UnprotectAccessLevel
}

"Autogenerated return type of UpdateAlertStatus."
type UpdateAlertStatusPayload {
  "Alert after mutation."
  alert: AlertManagementAlert
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue created after mutation."
  issue: Issue
  "To-do item after mutation."
  todo: Todo
}

"Autogenerated return type of UpdateBoardEpicUserPreferences."
type UpdateBoardEpicUserPreferencesPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "User preferences for the epic in the board after mutation."
  epicUserPreferences: BoardEpicUserPreferences
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateBoardList."
type UpdateBoardListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mutated list."
  list: BoardList
}

"Autogenerated return type of UpdateBoard."
type UpdateBoardPayload {
  "Board after mutation."
  board: Board
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateComplianceFramework."
type UpdateComplianceFrameworkPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Compliance framework after mutation."
  complianceFramework: ComplianceFramework
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateContainerExpirationPolicy."
type UpdateContainerExpirationPolicyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container expiration policy after mutation."
  containerExpirationPolicy: ContainerExpirationPolicy
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateContainerRegistryProtectionRule."
type UpdateContainerRegistryProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Container registry protection rule after mutation."
  containerRegistryProtectionRule: ContainerRegistryProtectionRule
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateDependencyProxyImageTtlGroupPolicy."
type UpdateDependencyProxyImageTtlGroupPolicyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group image TTL policy after mutation."
  dependencyProxyImageTtlPolicy: DependencyProxyImageTtlGroupPolicy
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateDependencyProxyPackagesSettings."
type UpdateDependencyProxyPackagesSettingsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Dependency proxy for packages settings after mutation."
  dependencyProxyPackagesSetting: DependencyProxyPackagesSetting
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateDependencyProxySettings."
type UpdateDependencyProxySettingsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group dependency proxy settings after mutation."
  dependencyProxySetting: DependencyProxySetting
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateEpicBoardList."
type UpdateEpicBoardListPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Mutated epic list."
  list: EpicList
}

"Autogenerated return type of UpdateEpic."
type UpdateEpicPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Epic after mutation."
  epic: Epic
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"Autogenerated return type of UpdateImageDiffNote."
type UpdateImageDiffNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
}

"Autogenerated return type of UpdateIssue."
type UpdateIssuePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Issue after mutation."
  issue: Issue
}

"Autogenerated return type of UpdateIteration."
type UpdateIterationPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated iteration."
  iteration: Iteration
}

"Autogenerated return type of UpdateNamespacePackageSettings."
type UpdateNamespacePackageSettingsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Namespace package setting after mutation."
  packageSettings: PackageSettings
}

"Autogenerated return type of UpdateNote."
type UpdateNotePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Note after mutation."
  note: Note
}

"Autogenerated return type of UpdatePackagesCleanupPolicy."
type UpdatePackagesCleanupPolicyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages cleanup policy after mutation."
  packagesCleanupPolicy: PackagesCleanupPolicy
}

"Autogenerated return type of UpdatePackagesProtectionRule."
type UpdatePackagesProtectionRulePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Packages protection rule after mutation."
  packageProtectionRule: PackagesProtectionRule
}

"Autogenerated return type of UpdateRequirement."
type UpdateRequirementPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Requirement after mutation."
  requirement: Requirement
}

"Autogenerated return type of UpdateSnippet."
type UpdateSnippetPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Snippet after mutation."
  snippet: Snippet
}

"Autogenerated return type of UploadDelete."
type UploadDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted upload."
  upload: FileUpload
}

"Represents the Geo replication and verification state of an upload."
type UploadRegistry {
  "Timestamp when the UploadRegistry was created"
  createdAt: Time
  "ID of the Upload."
  fileId: ID!
  "ID of the UploadRegistry"
  id: ID!
  "Error message during sync of the UploadRegistry"
  lastSyncFailure: String
  "Timestamp of the most recent successful sync of the UploadRegistry"
  lastSyncedAt: Time
  "Timestamp after which the UploadRegistry is resynced"
  retryAt: Time
  "Number of consecutive failed sync attempts of the UploadRegistry"
  retryCount: Int
  "Sync state of the UploadRegistry"
  state: RegistryState
  "The local checksum of the UploadRegistry"
  verificationChecksum: String
  "Error message during verification of the UploadRegistry"
  verificationFailure: String
  "Timestamp after which the UploadRegistry is reverified"
  verificationRetryAt: Time
  "Number of consecutive failed verification attempts of the UploadRegistry"
  verificationRetryCount: Int
  "Timestamp when the verification started of UploadRegistry"
  verificationStartedAt: Time
  "Verification state of the UploadRegistry"
  verificationState: VerificationStateEnum
  "Timestamp of the most recent successful verification of the UploadRegistry"
  verifiedAt: Time
}

"The connection type for UploadRegistry."
type UploadRegistryConnection {
  "A list of edges."
  edges: [UploadRegistryEdge]
  "A list of nodes."
  nodes: [UploadRegistry]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type UploadRegistryEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UploadRegistry
}

"Represents a recorded measurement (object count) for the Admins"
type UsageTrendsMeasurement {
  "Object count."
  count: Int!
  "Type of objects being measured."
  identifier: MeasurementIdentifier!
  "Time the measurement was recorded."
  recordedAt: Time
}

"The connection type for UsageTrendsMeasurement."
type UsageTrendsMeasurementConnection {
  "A list of edges."
  edges: [UsageTrendsMeasurementEdge]
  "A list of nodes."
  nodes: [UsageTrendsMeasurement]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type UsageTrendsMeasurementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UsageTrendsMeasurement
}

type UserAchievement {
  "Achievement awarded."
  achievement: Achievement!
  "Awarded by."
  awardedByUser: UserCore!
  "Timestamp the achievement was created."
  createdAt: Time!
  "ID of the user achievement."
  id: AchievementsUserAchievementID!
  "Priority of the user achievement."
  priority: Int
  "Timestamp the achievement was revoked."
  revokedAt: Time
  "Revoked by."
  revokedByUser: UserCore
  "Timestamp the achievement was last updated."
  updatedAt: Time!
  "Achievement recipient."
  user: UserCore!
}

"The connection type for UserAchievement."
type UserAchievementConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [UserAchievementEdge]
  "A list of nodes."
  nodes: [UserAchievement]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type UserAchievementEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserAchievement
}

"Autogenerated return type of UserAchievementPrioritiesUpdate."
type UserAchievementPrioritiesUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated user achievements."
  userAchievements: [UserAchievement!]!
}

"Autogenerated return type of UserAchievementsDelete."
type UserAchievementsDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Deleted user achievement."
  userAchievement: UserAchievement
}

"An assignment of an AddOnPurchase to a User."
type UserAddOnAssignment {
  "Add-on purchase the user is assigned to."
  addOnPurchase: AddOnPurchase!
}

"The connection type for UserAddOnAssignment."
type UserAddOnAssignmentConnection {
  "A list of edges."
  edges: [UserAddOnAssignmentEdge]
  "A list of nodes."
  nodes: [UserAddOnAssignment]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of UserAddOnAssignmentCreate."
type UserAddOnAssignmentCreatePayload {
  "AddOnPurchase state after mutation."
  addOnPurchase: AddOnPurchase
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User who the add-on purchase was assigned to."
  user: AddOnUser
}

"An edge in a connection."
type UserAddOnAssignmentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserAddOnAssignment
}

"Autogenerated return type of UserAddOnAssignmentRemove."
type UserAddOnAssignmentRemovePayload {
  "AddOnPurchase state after mutation."
  addOnPurchase: AddOnPurchase
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User that the add-on was removed from."
  user: AddOnUser
}

type UserCallout {
  "Date when the callout was dismissed."
  dismissedAt: Time
  "Name of the feature that the callout is for."
  featureName: UserCalloutFeatureNameEnum
}

"The connection type for UserCallout."
type UserCalloutConnection {
  "A list of edges."
  edges: [UserCalloutEdge]
  "A list of nodes."
  nodes: [UserCallout]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of UserCalloutCreate."
type UserCalloutCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User callout dismissed."
  userCallout: UserCallout!
}

"An edge in a connection."
type UserCalloutEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserCallout
}

"Core representation of a GitLab user."
type UserCore implements User {
  "Merge requests assigned to the user."
  assignedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Merge requests authored by the user."
  authoredMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Username of the reviewer."
    reviewerUsername: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "URL of the user's avatar."
  avatarUrl: String
  "Bio of the user."
  bio: String
  "Indicates if the user is a bot."
  bot: Boolean!
  "User callouts that belong to the user."
  callouts(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCalloutConnection
  "User's default commit email."
  commitEmail: String
  "Timestamp of when the user was created."
  createdAt: Time
  "Discord ID of the user."
  discord: String
  "User email. Deprecated in 13.7: This was renamed."
  email: String @deprecated(reason: "This was renamed. Please use `User.publicEmail`. Deprecated in 13.7.")
  "User's email addresses."
  emails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): EmailConnection
  "Whether Gitpod is enabled at the user level."
  gitpodEnabled: Boolean
  "Group count for the user."
  groupCount: Int
  "Group memberships of the user."
  groupMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): GroupMemberConnection
  "Groups where the user has access."
  groups(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter by permissions the user has on groups."
    permissionScope: GroupPermission,
    "Search by group name or path."
    search: String
  ): GroupConnection
  "ID of the user."
  id: ID!
  "IDE settings."
  ide: Ide
  "Job title of the user."
  jobTitle: String
  "Date the user last performed any actions."
  lastActivityOn: Date
  "LinkedIn profile name of the user."
  linkedin: String
  "Location of the user."
  location: String
  "Human-readable name of the user. Returns `****` if the user is a project bot and the requester does not have permission to view the project."
  name: String!
  "Personal namespace of the user."
  namespace: Namespace
  "User's custom namespace commit emails."
  namespaceCommitEmails(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NamespaceCommitEmailConnection
  "Who the user represents or works for."
  organization: String
  "Organizations where the user has access. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  organizations(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): OrganizationConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
  "Web path to the Gitpod section within user preferences."
  preferencesGitpodPath: String
  "Web path to enable Gitpod for the user."
  profileEnableGitpodPath: String
  "Project memberships of the user."
  projectMemberships(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectMemberConnection
  "Pronouns of the user."
  pronouns: String
  "User's public email."
  publicEmail: String
  "Merge requests assigned to the user for review."
  reviewRequestedMergeRequests(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    """

    Limit results to approved merge requests.
    Available only when the feature flag `mr_approved_filter` is enabled.
    """
    approved: Boolean,
    "Username of the assignee."
    assigneeUsername: String,
    "Username of the author."
    authorUsername: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Merge requests created after this timestamp."
    createdAfter: Time,
    "Merge requests created before this timestamp."
    createdBefore: Time,
    "Limit result to draft merge requests."
    draft: Boolean,
    "Returns the first _n_ elements from the list."
    first: Int,
    """

    The global ID of the group the authored merge requests should be in.
    Merge requests in subgroups are included.
    """
    groupId: GroupID,
    "Array of IIDs of merge requests, for example `[1, 2]`."
    iids: [String!],
    "Array of label names. All resolved merge requests will have all of these labels."
    labels: [String!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Merge requests merged after this date."
    mergedAfter: Time,
    "Merge requests merged before this date."
    mergedBefore: Time,
    "Title of the milestone."
    milestoneTitle: String,
    """

    List of negated arguments.
    Warning: this argument is experimental and a subject to change in future.
    """
    not: MergeRequestsResolverNegatedParams,
    """

    The global ID of the project the authored merge requests should be in.
    Incompatible with projectPath.
    """
    projectId: ProjectID,
    """

    The full-path of the project the authored merge requests should be in.
    Incompatible with projectId.
    """
    projectPath: String,
    "Sort merge requests by this criteria."
    sort: MergeRequestSort = created_desc,
    """

    Array of source branch names.
    All resolved merge requests will have one of these branches as their source.
    """
    sourceBranches: [String!],
    "Merge request state. If provided, all resolved merge requests will have this state."
    state: MergeRequestState,
    """

    Array of target branch names.
    All resolved merge requests will have one of these branches as their target.
    """
    targetBranches: [String!],
    "Merge requests updated after this timestamp."
    updatedAfter: Time,
    "Merge requests updated before this timestamp."
    updatedBefore: Time
  ): MergeRequestConnection
  "Saved replies authored by the user."
  savedReplies(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): SavedReplyConnection
  "Saved reply authored by the user."
  savedReply(
    "ID of a saved reply."
    id: UsersSavedReplyID!
  ): SavedReply
  "Snippets authored by the user."
  snippets(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Array of global snippet IDs. For example, `gid://gitlab/ProjectSnippet/1`."
    ids: [SnippetID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Type of snippet."
    type: TypeEnum,
    "Visibility of the snippet."
    visibility: VisibilityScopesEnum
  ): SnippetConnection
  "Projects starred by the user."
  starredProjects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Search query."
    search: String
  ): ProjectConnection
  "State of the user."
  state: UserState!
  "User status."
  status: UserStatus
  "Time logged by the user."
  timelogs(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "List timelogs within a date range where the logged date is equal to or before endDate."
    endDate: Time,
    "List timelogs within a time range where the logged time is equal to or before endTime."
    endTime: Time,
    "Returns the first _n_ elements from the list."
    first: Int,
    "List timelogs for a group."
    groupId: GroupID,
    "Returns the last _n_ elements from the list."
    last: Int,
    "List timelogs for a project."
    projectId: ProjectID,
    "List timelogs in a particular order."
    sort: TimelogSort = SPENT_AT_ASC,
    "List timelogs within a date range where the logged date is equal to or after startDate."
    startDate: Time,
    "List timelogs within a time range where the logged time is equal to or after startTime."
    startTime: Time,
    "List timelogs for a user."
    username: String
  ): TimelogConnection
  "To-do items of the user."
  todos(
    "Action to be filtered."
    action: [TodoActionEnum!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "ID of an author."
    authorId: [ID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "ID of a group."
    groupId: [ID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "ID of a project."
    projectId: [ID!],
    "State of the todo."
    state: [TodoStateEnum!],
    "Type of the todo."
    type: [TodoTargetEnum!]
  ): TodoConnection
  "X (formerly Twitter) username of the user."
  twitter: String
  "Achievements for the user. Only returns for namespaces where the `achievements` feature flag is enabled. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  userAchievements(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserAchievementConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Permissions for the current user on the resource."
  userPermissions: UserPermissions!
  "Username of the user. Unique within this instance of GitLab."
  username: String!
  "Web path of the user."
  webPath: String!
  "Web URL of the user."
  webUrl: String!
  "Workspaces owned by the current user. Introduced in 16.6: This feature is an Experiment. It can be changed or removed at any time."
  workspaces(
    "Filter workspaces by actual states."
    actualStates: [String!],
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Filter workspaces by agent GlobalIDs."
    agentIds: [ClustersAgentID!],
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Filter workspaces by workspace GlobalIDs. For example, `[\"gid://gitlab/RemoteDevelopment::Workspace/1\"]`."
    ids: [RemoteDevelopmentWorkspaceID!],
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter workspaces by project GlobalIDs."
    projectIds: [ProjectID!]
  ): WorkspaceConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.6.")
}

"The connection type for UserCore."
type UserCoreConnection {
  "Total count of collection."
  count: Int!
  "A list of edges."
  edges: [UserCoreEdge]
  "A list of nodes."
  nodes: [UserCore]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type UserCoreEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: UserCore
}

"""

Information about a merge request given a specific user.

This object has two parts to its state: a `User` and a `MergeRequest`. All
fields relate to interactions between the two entities.
"""
type UserMergeRequestInteraction {
  "Approval rules that apply to this user for this merge request."
  applicableApprovalRules: [ApprovalRule!]
  "Whether this user has approved this merge request."
  approved: Boolean!
  "Whether this user can merge this merge request."
  canMerge: Boolean!
  "Whether this user can update this merge request."
  canUpdate: Boolean!
  "State of the review by this user."
  reviewState: MergeRequestReviewState
  "Whether this user has provided a review for this merge request."
  reviewed: Boolean!
}

type UserPermissions {
  "If `true`, the user can perform `create_snippet` on this resource"
  createSnippet: Boolean!
}

type UserPreferences {
  "Sort order for issue lists."
  issuesSort: IssueSort
  "Whether Web IDE Extension Marketplace is enabled for the user."
  useWebIdeExtensionMarketplace: Boolean!
  "Determines whether the pipeline list shows ID or IID."
  visibilityPipelineIdType: VisibilityPipelineIdType
}

"Autogenerated return type of UserPreferencesUpdate."
type UserPreferencesUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User preferences after mutation."
  userPreferences: UserPreferences
}

"Autogenerated return type of UserSetNamespaceCommitEmail."
type UserSetNamespaceCommitEmailPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "User namespace commit email after mutation."
  namespaceCommitEmail: NamespaceCommitEmail
}

type UserStatus {
  "User availability status."
  availability: AvailabilityEnum!
  "String representation of emoji."
  emoji: String
  "User status message."
  message: String
  "HTML of the user status message"
  messageHtml: String
}

type ValueStream {
  "ID of the value stream."
  id: AnalyticsCycleAnalyticsValueStreamID!
  "Name of the value stream."
  name: String!
  "Namespace the value stream belongs to."
  namespace: Namespace!
  "Project the value stream belongs to, returns empty if it belongs to a group. Introduced in 15.6: This feature is an Experiment. It can be changed or removed at any time."
  project: Project @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.")
  "Value Stream stages."
  stages: [ValueStreamStage!]
}

type ValueStreamAnalyticsMetric {
  "Identifier for the metric."
  identifier: String!
  "Optional links for drilling down."
  links: [ValueStreamMetricLinkType!]!
  "Title for the metric."
  title: String!
  "Unit of measurement."
  unit: String
  "Value for the metric."
  value: Float
}

"The connection type for ValueStream."
type ValueStreamConnection {
  "A list of edges."
  edges: [ValueStreamEdge]
  "A list of nodes."
  nodes: [ValueStream]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of ValueStreamCreate."
type ValueStreamCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created value stream."
  valueStream: ValueStream
}

"Represents a recorded measurement (object count) for the requested group"
type ValueStreamDashboardCount {
  "Object count."
  count: Int
  "Type of object being measured."
  identifier: ValueStreamDashboardMetric!
  "Time the measurement was taken."
  recordedAt: Time
}

"Autogenerated return type of ValueStreamDestroy."
type ValueStreamDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Value stream deleted after mutation."
  valueStream: ValueStream
}

"An edge in a connection."
type ValueStreamEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: ValueStream
}

type ValueStreamMetricLinkType {
  "Link to the metric documentation."
  docsLink: Boolean
  "Label for the link."
  label: String!
  "Name of the link group."
  name: String!
  "Drill-down URL."
  url: String!
}

type ValueStreamStage {
  "Whether the stage is customized."
  custom: Boolean!
  "End event identifier."
  endEventIdentifier: ValueStreamStageEvent!
  "Label associated with end event."
  endEventLabel: Label
  "Whether the stage is hidden."
  hidden: Boolean!
  "Name of the stage."
  name: String!
  "Start event identifier."
  startEventIdentifier: ValueStreamStageEvent!
  "Label associated with start event."
  startEventLabel: Label
}

"Autogenerated return type of ValueStreamUpdate."
type ValueStreamUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated value stream."
  valueStream: ValueStream
}

"Represents the count of vulnerabilities by severity on a particular day. This data is retained for 365 days"
type VulnerabilitiesCountByDay {
  "Total number of vulnerabilities on a particular day with critical severity"
  critical: Int!
  "Date for the count."
  date: ISO8601Date!
  "Total number of vulnerabilities on a particular day with high severity"
  high: Int!
  "Total number of vulnerabilities on a particular day with info severity"
  info: Int!
  "Total number of vulnerabilities on a particular day with low severity"
  low: Int!
  "Total number of vulnerabilities on a particular day with medium severity"
  medium: Int!
  "Total number of vulnerabilities on a particular day."
  total: Int!
  "Total number of vulnerabilities on a particular day with unknown severity"
  unknown: Int!
}

"The connection type for VulnerabilitiesCountByDay."
type VulnerabilitiesCountByDayConnection {
  "A list of edges."
  edges: [VulnerabilitiesCountByDayEdge]
  "A list of nodes."
  nodes: [VulnerabilitiesCountByDay]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type VulnerabilitiesCountByDayEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: VulnerabilitiesCountByDay
}

"Autogenerated return type of VulnerabilitiesDismiss."
type VulnerabilitiesDismissPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Vulnerabilities after state change."
  vulnerabilities: [Vulnerability!]!
}

"Autogenerated return type of VulnerabilitiesRemoveAllFromProject."
type VulnerabilitiesRemoveAllFromProjectPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Projects for which the deletion was scheduled."
  projects: [Project!]!
}

"Represents a vulnerability"
type Vulnerability implements NoteableInterface {
  "All commenters on this noteable."
  commenters(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection!
  "Timestamp of when the vulnerability state was changed to confirmed."
  confirmedAt: Time
  "User that confirmed the vulnerability."
  confirmedBy: UserCore
  "Description of the vulnerability."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Details of the vulnerability."
  details: [VulnerabilityDetail!]!
  "Timestamp of when the vulnerability was first detected."
  detectedAt: Time!
  "All discussions on this noteable."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): DiscussionConnection!
  "Reason for dismissal. Returns `null` for states other than `dismissed`."
  dismissalReason: VulnerabilityDismissalReason
  "Timestamp of when the vulnerability state was changed to dismissed."
  dismissedAt: Time
  "User that dismissed the vulnerability."
  dismissedBy: UserCore
  "List of external issue links related to the vulnerability."
  externalIssueLinks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityExternalIssueLinkConnection!
  "Indicates whether the vulnerability is a false positive."
  falsePositive: Boolean
  "Indicates whether there is a remediation available for this vulnerability."
  hasRemediations: Boolean
  "Indicates whether there is a solution available for this vulnerability. Deprecated in 16.3: Use `hasRemediations`."
  hasSolutions: Boolean @deprecated(reason: "Use `hasRemediations`. Deprecated in 16.3.")
  "GraphQL ID of the vulnerability."
  id: ID!
  "Identifiers of the vulnerability."
  identifiers: [VulnerabilityIdentifier!]!
  "List of issue links related to the vulnerability."
  issueLinks(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "Filter issue links by link type."
    linkType: VulnerabilityIssueLinkType
  ): VulnerabilityIssueLinkConnection!
  "List of links associated with the vulnerability."
  links: [VulnerabilityLink!]!
  "Location metadata for the vulnerability. Its fields depend on the type of security scan that found the vulnerability."
  location: VulnerabilityLocation
  "Merge request that fixes the vulnerability."
  mergeRequest: MergeRequest
  "From 16.1 this field always returns null. Deprecated in 16.1: message field has been removed from security reports schema."
  message: String @deprecated(reason: "message field has been removed from security reports schema. Deprecated in 16.1.")
  "All notes on this noteable."
  notes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): NoteConnection!
  "Indicates whether the vulnerability is present on the default branch or not."
  presentOnDefaultBranch: Boolean!
  "Primary identifier of the vulnerability."
  primaryIdentifier: VulnerabilityIdentifier
  "Project on which the vulnerability was found."
  project: Project
  "Type of the security report that found the vulnerability (SAST, DEPENDENCY_SCANNING, CONTAINER_SCANNING, DAST, SECRET_DETECTION, COVERAGE_FUZZING, API_FUZZING, CLUSTER_IMAGE_SCANNING, GENERIC). `Scan Type` in the UI."
  reportType: VulnerabilityReportType
  "Timestamp of when the vulnerability state was changed to resolved."
  resolvedAt: Time
  "User that resolved the vulnerability."
  resolvedBy: UserCore
  "Indicates whether the vulnerability is fixed on the default branch or not."
  resolvedOnDefaultBranch: Boolean!
  "Scanner metadata for the vulnerability."
  scanner: VulnerabilityScanner
  "Severity of the vulnerability (INFO, UNKNOWN, LOW, MEDIUM, HIGH, CRITICAL)"
  severity: VulnerabilitySeverity
  "Recommended solution for the vulnerability."
  solution: String
  "State of the vulnerability (DETECTED, CONFIRMED, RESOLVED, DISMISSED)"
  state: VulnerabilityState
  "Comment given for the vulnerability state change."
  stateComment: String
  "List of state transitions related to the vulnerability."
  stateTransitions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): VulnerabilityStateTransitionTypeConnection
  "Title of the vulnerability."
  title: String
  "Timestamp of when the vulnerability was last updated."
  updatedAt: Time
  "Number of user notes attached to the vulnerability."
  userNotesCount: Int!
  "Permissions for the current user on the resource"
  userPermissions: VulnerabilityPermissions!
  "UUID of the vulnerability finding. Can be used to look up the associated security report finding."
  uuid: String!
  "Path to the vulnerability's details page."
  vulnerabilityPath: String
  "URL to the vulnerability's details page."
  webUrl: String
}

"Autogenerated return type of VulnerabilityConfirm."
type VulnerabilityConfirmPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Vulnerability after state change."
  vulnerability: Vulnerability
}

"The connection type for Vulnerability."
type VulnerabilityConnection {
  "A list of edges."
  edges: [VulnerabilityEdge]
  "A list of nodes."
  nodes: [Vulnerability]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Represents a container image reported on the related vulnerability"
type VulnerabilityContainerImage {
  "Name of the container image."
  name: String
}

"The connection type for VulnerabilityContainerImage."
type VulnerabilityContainerImageConnection {
  "A list of edges."
  edges: [VulnerabilityContainerImageEdge]
  "A list of nodes."
  nodes: [VulnerabilityContainerImage]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type VulnerabilityContainerImageEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: VulnerabilityContainerImage
}

"Autogenerated return type of VulnerabilityCreate."
type VulnerabilityCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Vulnerability created."
  vulnerability: Vulnerability
}

"Represents the vulnerability details base"
type VulnerabilityDetailBase {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
}

"Represents the vulnerability details boolean value"
type VulnerabilityDetailBoolean {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
  "Value of the field."
  value: Boolean!
}

"Represents the vulnerability details code field"
type VulnerabilityDetailCode {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Language of the code."
  lang: String
  "Name of the field."
  name: String
  "Source code."
  value: String!
}

"Represents the vulnerability details commit field"
type VulnerabilityDetailCommit {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
  "Commit SHA value."
  value: String!
}

"Represents the vulnerability details diff field"
type VulnerabilityDetailDiff {
  "Value of the field after the change."
  after: String!
  "Value of the field before the change."
  before: String!
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
}

"Represents the vulnerability details location within a file in the project"
type VulnerabilityDetailFileLocation {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "File name."
  fileName: String!
  "End line number of the file location."
  lineEnd: Int!
  "Start line number of the file location."
  lineStart: Int!
  "Name of the field."
  name: String
}

"Represents the vulnerability details integer value"
type VulnerabilityDetailInt {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
  "Value of the field."
  value: Int!
}

"Represents the vulnerability details list value"
type VulnerabilityDetailList {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "List of details."
  items: [VulnerabilityDetail!]!
  "Name of the field."
  name: String
}

"Represents the vulnerability details Markdown field"
type VulnerabilityDetailMarkdown {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
  "Value of the Markdown field."
  value: String!
}

"Represents the vulnerability details location within a file in the project"
type VulnerabilityDetailModuleLocation {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Module name."
  moduleName: String!
  "Name of the field."
  name: String
  "Offset of the module location."
  offset: Int!
}

"Represents the vulnerability details named list"
type VulnerabilityDetailNamedList {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Named list of details. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  items: [VulnerabilityDetailNamedListItem!]! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
  "Name of the field."
  name: String
}

"Represents the vulnerability details named list item"
type VulnerabilityDetailNamedListItem {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
  "Value of the field. Introduced in 16.1: This feature is an Experiment. It can be changed or removed at any time."
  value: VulnerabilityDetail! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.1.")
}

"Represents an individual row in a table"
type VulnerabilityDetailRow {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
  "Value of the field."
  row: [VulnerabilityDetail!]!
}

"Represents the vulnerability details table value"
type VulnerabilityDetailTable {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Table headers."
  headers: [VulnerabilityDetail!]!
  "Name of the field."
  name: String
  "Table rows."
  rows: [VulnerabilityDetailRow!]!
}

"Represents the vulnerability details text field"
type VulnerabilityDetailText {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Name of the field."
  name: String
  "Value of the text field."
  value: String!
}

"Represents the vulnerability details URL field"
type VulnerabilityDetailUrl {
  "Description of the field."
  description: String
  "Name of the field."
  fieldName: String
  "Href of the URL."
  href: String!
  "Name of the field."
  name: String
  "Text of the URL."
  text: String
}

"Autogenerated return type of VulnerabilityDismiss."
type VulnerabilityDismissPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Vulnerability after state change."
  vulnerability: Vulnerability
}

"An edge in a connection."
type VulnerabilityEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Vulnerability
}

"Represents a Vulnerability Evidence"
type VulnerabilityEvidence {
  "HTTP request of the Vulnerability Evidence."
  request: VulnerabilityRequest
  "HTTP response of the Vulnerability Evidence."
  response: VulnerabilityResponse
  "Source of the Vulnerability Evidence."
  source: VulnerabilityEvidenceSource
  "Summary of the Vulnerability Evidence."
  summary: String
  "Supporting messages of the Vulnerability Evidence."
  supportingMessages: [VulnerabilityEvidenceSupportingMessage!]
}

"Represents a vulnerability evidence"
type VulnerabilityEvidenceSource {
  "ID of the Vulnerability Evidence Source."
  identifier: String!
  "Name of the Vulnerability Evidence Source."
  name: String!
  "URL of the Vulnerability Evidence Source."
  url: String
}

"Represents a vulnerability evidence supporting message"
type VulnerabilityEvidenceSupportingMessage {
  "Name of the vulnerability supporting message."
  name: String!
  "HTTP request of the vulnerability evidence supporting message."
  request: VulnerabilityRequest
  "HTTP response of the vulnerability evidence supporting message."
  response: VulnerabilityResponse
}

"Represents an external issue link of a vulnerability"
type VulnerabilityExternalIssueLink {
  "The external issue attached to the issue link."
  externalIssue: ExternalIssue
  "GraphQL ID of the external issue link."
  id: VulnerabilitiesExternalIssueLinkID!
  "Type of the external issue link."
  linkType: VulnerabilityExternalIssueLinkType!
}

"The connection type for VulnerabilityExternalIssueLink."
type VulnerabilityExternalIssueLinkConnection {
  "A list of edges."
  edges: [VulnerabilityExternalIssueLinkEdge]
  "A list of nodes."
  nodes: [VulnerabilityExternalIssueLink]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of VulnerabilityExternalIssueLinkCreate."
type VulnerabilityExternalIssueLinkCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created external issue link."
  externalIssueLink: VulnerabilityExternalIssueLink
}

"Autogenerated return type of VulnerabilityExternalIssueLinkDestroy."
type VulnerabilityExternalIssueLinkDestroyPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
}

"An edge in a connection."
type VulnerabilityExternalIssueLinkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: VulnerabilityExternalIssueLink
}

"Represents a vulnerability identifier"
type VulnerabilityIdentifier {
  "External ID of the vulnerability identifier."
  externalId: String
  "External type of the vulnerability identifier."
  externalType: String
  "Name of the vulnerability identifier."
  name: String
  "URL of the vulnerability identifier."
  url: String
}

"Represents an issue link of a vulnerability"
type VulnerabilityIssueLink {
  "GraphQL ID of the vulnerability."
  id: ID!
  "Issue attached to issue link."
  issue: Issue
  "Type of the issue link."
  linkType: VulnerabilityIssueLinkType!
}

"The connection type for VulnerabilityIssueLink."
type VulnerabilityIssueLinkConnection {
  "A list of edges."
  edges: [VulnerabilityIssueLinkEdge]
  "A list of nodes."
  nodes: [VulnerabilityIssueLink]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of VulnerabilityIssueLinkCreate."
type VulnerabilityIssueLinkCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created issue links."
  issueLinks: [VulnerabilityIssueLink!]
}

"An edge in a connection."
type VulnerabilityIssueLinkEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: VulnerabilityIssueLink
}

"Represents a link related to a vulnerability"
type VulnerabilityLink {
  "Name of the link."
  name: String
  "URL of the link."
  url: String!
}

"Represents the location of a vulnerability found by a cluster image scan"
type VulnerabilityLocationClusterImageScanning {
  "Dependency containing the vulnerability."
  dependency: VulnerableDependency
  "Name of the vulnerable container image."
  image: String
  "Kubernetes resource which uses the vulnerable container image."
  kubernetesResource: VulnerableKubernetesResource
  "Operating system that runs on the vulnerable container image."
  operatingSystem: String
}

"Represents the location of a vulnerability found by a container security scan"
type VulnerabilityLocationContainerScanning {
  "Dependency containing the vulnerability."
  dependency: VulnerableDependency
  "Name of the vulnerable container image."
  image: String
  "Operating system that runs on the vulnerable container image."
  operatingSystem: String
}

"Represents the location of a vulnerability found by a Coverage Fuzzing scan"
type VulnerabilityLocationCoverageFuzzing {
  "Blob path to the vulnerable file."
  blobPath: String
  "Relative address in memory were the crash occurred."
  crashAddress: String
  "Type of the crash."
  crashType: String
  "Number of the last relevant line in the vulnerable file."
  endLine: String
  "Path to the vulnerable file."
  file: String
  "Stack trace recorded during fuzzing resulting the crash."
  stacktraceSnippet: String
  "Number of the first relevant line in the vulnerable file."
  startLine: String
  "Class containing the vulnerability."
  vulnerableClass: String
  "Method containing the vulnerability."
  vulnerableMethod: String
}

"Represents the location of a vulnerability found by a DAST scan"
type VulnerabilityLocationDast {
  "Domain name of the vulnerable request."
  hostname: String
  "Query parameter for the URL on which the vulnerability occurred."
  param: String
  "URL path and query string of the vulnerable request."
  path: String
  "HTTP method of the vulnerable request."
  requestMethod: String
}

"Represents the location of a vulnerability found by a dependency security scan"
type VulnerabilityLocationDependencyScanning {
  "Blob path to the vulnerable file."
  blobPath: String
  "Dependency containing the vulnerability."
  dependency: VulnerableDependency
  "Path to the vulnerable file."
  file: String
}

"Represents the location of a vulnerability found by a generic scanner."
type VulnerabilityLocationGeneric {
  "Free-form description of where the vulnerability is located."
  description: String
}

"Represents the location of a vulnerability found by a SAST scan"
type VulnerabilityLocationSast {
  "Blob path to the vulnerable file."
  blobPath: String
  "Number of the last relevant line in the vulnerable file."
  endLine: String
  "Path to the vulnerable file."
  file: String
  "Number of the first relevant line in the vulnerable file."
  startLine: String
  "Class containing the vulnerability."
  vulnerableClass: String
  "Method containing the vulnerability."
  vulnerableMethod: String
}

"Represents the location of a vulnerability found by a secret detection scan"
type VulnerabilityLocationSecretDetection {
  "Blob path to the vulnerable file."
  blobPath: String
  "Number of the last relevant line in the vulnerable file."
  endLine: String
  "Path to the vulnerable file."
  file: String
  "Number of the first relevant line in the vulnerable file."
  startLine: String
  "Class containing the vulnerability."
  vulnerableClass: String
  "Method containing the vulnerability."
  vulnerableMethod: String
}

"Check permissions for the current user on a vulnerability"
type VulnerabilityPermissions {
  "If `true`, the user can perform `admin_vulnerability` on this resource"
  adminVulnerability: Boolean!
  "If `true`, the user can perform `admin_vulnerability_external_issue_link` on this resource"
  adminVulnerabilityExternalIssueLink: Boolean!
  "If `true`, the user can perform `admin_vulnerability_issue_link` on this resource"
  adminVulnerabilityIssueLink: Boolean!
  "If `true`, the user can perform `create_vulnerability_export` on this resource"
  createVulnerabilityExport: Boolean!
  "If `true`, the user can perform `create_vulnerability_feedback` on this resource"
  createVulnerabilityFeedback: Boolean!
  "If `true`, the user can perform `destroy_vulnerability_feedback` on this resource"
  destroyVulnerabilityFeedback: Boolean!
  "If `true`, the user can perform `read_vulnerability` on this resource"
  readVulnerability: Boolean!
  "If `true`, the user can perform `read_vulnerability_feedback` on this resource"
  readVulnerabilityFeedback: Boolean!
  "If `true`, the user can perform `update_vulnerability_feedback` on this resource"
  updateVulnerabilityFeedback: Boolean!
}

"Represents a vulnerability remediation type."
type VulnerabilityRemediationType {
  "Diff of the remediation."
  diff: String
  "Summary of the remediation."
  summary: String
}

"Represents a Vulnerability Request"
type VulnerabilityRequest {
  "Body of the Vulnerability Request."
  body: String
  "HTTP headers of the Vulnerability Request."
  headers: [VulnerabilityRequestResponseHeader!]!
  "Method of the Vulnerability Request."
  method: String
  "URL of the Vulnerability Request."
  url: String
}

"Represents a Vulnerability Request/Response Header"
type VulnerabilityRequestResponseHeader {
  "Name of the Vulnerability Request/Response Header."
  name: String
  "Value of the Vulnerability Request/Response Header."
  value: String
}

"Autogenerated return type of VulnerabilityResolve."
type VulnerabilityResolvePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Vulnerability after state change."
  vulnerability: Vulnerability
}

"Represents a Vulnerability Response"
type VulnerabilityResponse {
  "Body of the Vulnerability Response."
  body: String
  "HTTP headers of the Vulnerability Response."
  headers: [VulnerabilityRequestResponseHeader!]!
  "Reason Phrase of the Vulnerability Response."
  reasonPhrase: String
  "Status Code of the Vulnerability Response."
  statusCode: Int
}

"Autogenerated return type of VulnerabilityRevertToDetected."
type VulnerabilityRevertToDetectedPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Vulnerability after state change."
  vulnerability: Vulnerability
}

"Represents a vulnerability scanner"
type VulnerabilityScanner {
  "External ID of the vulnerability scanner."
  externalId: String
  "ID of the scanner."
  id: ID
  "Name of the vulnerability scanner."
  name: String
  "Type of the vulnerability report."
  reportType: VulnerabilityReportType
  "Humanized type of the vulnerability report."
  reportTypeHumanized: String
  "Vendor of the vulnerability scanner."
  vendor: String
}

"The connection type for VulnerabilityScanner."
type VulnerabilityScannerConnection {
  "A list of edges."
  edges: [VulnerabilityScannerEdge]
  "A list of nodes."
  nodes: [VulnerabilityScanner]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type VulnerabilityScannerEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: VulnerabilityScanner
}

"Represents vulnerability counts by severity"
type VulnerabilitySeveritiesCount {
  "Number of vulnerabilities of CRITICAL severity of the project"
  critical: Int
  "Number of vulnerabilities of HIGH severity of the project"
  high: Int
  "Number of vulnerabilities of INFO severity of the project"
  info: Int
  "Number of vulnerabilities of LOW severity of the project"
  low: Int
  "Number of vulnerabilities of MEDIUM severity of the project"
  medium: Int
  "Number of vulnerabilities of UNKNOWN severity of the project"
  unknown: Int
}

"Represents a state transition of a vulnerability"
type VulnerabilityStateTransitionType {
  "User who changed the state of the vulnerability."
  author: UserCore
  "Comment for the state change."
  comment: String
  "Time of the state change of the vulnerability."
  createdAt: Time!
  "Reason for the dismissal."
  dismissalReason: VulnerabilityDismissalReason
  "State of the vulnerability before transition."
  fromState: VulnerabilityState!
  "State of the vulnerability after transition."
  toState: VulnerabilityState!
}

"The connection type for VulnerabilityStateTransitionType."
type VulnerabilityStateTransitionTypeConnection {
  "A list of edges."
  edges: [VulnerabilityStateTransitionTypeEdge]
  "A list of nodes."
  nodes: [VulnerabilityStateTransitionType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type VulnerabilityStateTransitionTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: VulnerabilityStateTransitionType
}

"Represents a vulnerable dependency. Used in vulnerability location data"
type VulnerableDependency {
  "Package associated with the vulnerable dependency."
  package: VulnerablePackage
  "Version of the vulnerable dependency."
  version: String
}

"Represents a vulnerable Kubernetes resource. Used in vulnerability location data"
type VulnerableKubernetesResource {
  "Kubernetes Agent which performed the scan."
  agent: ClusterAgent
  "ID of the Cluster integration which was used to perform the scan."
  clusterId: ClustersClusterID
  "Name of the container that had its image scanned."
  containerName: String!
  "Kind of the Kubernetes resource."
  kind: String!
  "Name of the Kubernetes resource."
  name: String!
  "Kubernetes namespace which the resource resides in."
  namespace: String!
}

"Represents a vulnerable package. Used in vulnerability dependency data"
type VulnerablePackage {
  "Name of the vulnerable package."
  name: String
}

"Represents vulnerability letter grades with associated projects"
type VulnerableProjectsByGrade {
  "Number of projects within this grade."
  count: Int!
  "Grade based on the highest severity vulnerability present."
  grade: VulnerabilityGrade!
  "Projects within this grade."
  projects(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): ProjectConnection!
}

type WorkItem implements Todoable {
  "Whether the work item belongs to an archived project. Always false for group level work items. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  archived: Boolean! @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.5.")
  "User that created the work item. Introduced in 15.9: This feature is an Experiment. It can be changed or removed at any time."
  author: UserCore @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.9.")
  "Timestamp of when the work item was closed."
  closedAt: Time
  "Indicates the work item is confidential."
  confidential: Boolean!
  "User specific email address for the work item."
  createNoteEmail: String
  "Timestamp of when the work item was created."
  createdAt: Time!
  "Description of the work item."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Global ID of the work item."
  id: WorkItemID!
  "Internal ID of the work item."
  iid: ID!
  "Lock version of the work item. Incremented each time the work item is updated."
  lockVersion: Int!
  "Namespace the work item belongs to. Introduced in 15.10: This feature is an Experiment. It can be changed or removed at any time."
  namespace: Namespace @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.10.")
  "Project the work item belongs to. Introduced in 15.3: This feature is an Experiment. It can be changed or removed at any time."
  project: Project @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.3.")
  "Internal reference of the work item. Returned in shortened format by default."
  reference(
    "Boolean option specifying whether the reference should be returned in full."
    full: Boolean = false
  ): String!
  "State of the work item."
  state: WorkItemState!
  "Title of the work item."
  title: String!
  "GitLab Flavored Markdown rendering of `title`"
  titleHtml: String
  "Timestamp of when the work item was last updated."
  updatedAt: Time!
  "Permissions for the current user on the resource"
  userPermissions: WorkItemPermissions!
  "URL of this object."
  webUrl: String
  "Collection of widgets that belong to the work item."
  widgets: [WorkItemWidget!]
  "Type assigned to the work item."
  workItemType: WorkItemType!
}

"Autogenerated return type of WorkItemAddLinkedItems."
type WorkItemAddLinkedItemsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Linked items update result message."
  message: String
  "Updated work item."
  workItem: WorkItem
}

"The connection type for WorkItem."
type WorkItemConnection {
  "A list of edges."
  edges: [WorkItemEdge]
  "A list of nodes."
  nodes: [WorkItem]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of WorkItemConvert."
type WorkItemConvertPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated work item."
  workItem: WorkItem
}

"Autogenerated return type of WorkItemCreateFromTask."
type WorkItemCreateFromTaskPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "New work item created from task."
  newWorkItem: WorkItem
  "Updated work item."
  workItem: WorkItem
}

"Autogenerated return type of WorkItemCreate."
type WorkItemCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created work item."
  workItem: WorkItem
}

"Autogenerated return type of WorkItemDelete."
type WorkItemDeletePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Project the deleted work item belonged to."
  project: Project
}

"An edge in a connection."
type WorkItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItem
}

"Autogenerated return type of WorkItemExport."
type WorkItemExportPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Export request result message."
  message: String
}

"Check permissions for the current user on a work item"
type WorkItemPermissions {
  "If `true`, the user can perform `admin_parent_link` on this resource"
  adminParentLink: Boolean!
  "If `true`, the user can perform `admin_work_item` on this resource"
  adminWorkItem: Boolean!
  "If `true`, the user can perform `admin_work_item_link` on this resource"
  adminWorkItemLink: Boolean!
  "If `true`, the user can perform `create_note` on this resource"
  createNote: Boolean!
  "If `true`, the user can perform `delete_work_item` on this resource"
  deleteWorkItem: Boolean!
  "If `true`, the user can perform `read_work_item` on this resource"
  readWorkItem: Boolean!
  "If `true`, the user can perform `set_work_item_metadata` on this resource"
  setWorkItemMetadata: Boolean!
  "If `true`, the user can perform `update_work_item` on this resource"
  updateWorkItem: Boolean!
}

"Autogenerated return type of WorkItemRemoveLinkedItems."
type WorkItemRemoveLinkedItemsPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Linked items update result message."
  message: String
  "Updated work item."
  workItem: WorkItem
}

"Represents total number of work items for the represented states"
type WorkItemStateCountsType {
  "Number of work items for the project or group."
  all: Int
  "Number of work items with state CLOSED for the project or group."
  closed: Int
  "Number of work items with state OPENED for the project or group."
  opened: Int
}

"Autogenerated return type of WorkItemSubscribe."
type WorkItemSubscribePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Work item after mutation."
  workItem: WorkItem
}

type WorkItemType {
  "Icon name of the work item type."
  iconName: String
  "Global ID of the work item type."
  id: WorkItemsTypeID!
  "Name of the work item type."
  name: String!
  "Available widgets for the work item type. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  widgetDefinitions: [WorkItemWidgetDefinition!] @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
}

"The connection type for WorkItemType."
type WorkItemTypeConnection {
  "A list of edges."
  edges: [WorkItemTypeEdge]
  "A list of nodes."
  nodes: [WorkItemType]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"An edge in a connection."
type WorkItemTypeEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: WorkItemType
}

"Autogenerated return type of WorkItemUpdate."
type WorkItemUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated work item."
  workItem: WorkItem
}

"Autogenerated return type of WorkItemUpdateTask."
type WorkItemUpdateTaskPayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Updated task."
  task: WorkItem
  "Updated work item."
  workItem: WorkItem
}

"Represents an assignees widget"
type WorkItemWidgetAssignees implements WorkItemWidget {
  "Indicates whether multiple assignees are allowed. Deprecated in 16.7: Field moved to workItemType widget definition interface."
  allowsMultipleAssignees: Boolean @deprecated(reason: "Field moved to workItemType widget definition interface. Please use `workitemWidgetDefinitionAssignees.allowsMultipleAssignees`. Deprecated in 16.7.")
  "Assignees of the work item."
  assignees(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): UserCoreConnection
  "Indicates whether the current user can invite members to the work item's project. Deprecated in 16.7: Field moved to workItemType widget definition interface."
  canInviteMembers: Boolean! @deprecated(reason: "Field moved to workItemType widget definition interface. Please use `workitemWidgetDefinitionAssignees.canInviteMembers`. Deprecated in 16.7.")
  "Widget type."
  type: WorkItemWidgetType
}

"Represents the emoji reactions widget"
type WorkItemWidgetAwardEmoji implements WorkItemWidget {
  "Emoji reactions on the work item."
  awardEmoji(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): AwardEmojiConnection
  "Number of downvotes the work item has received."
  downvotes: Int!
  "Widget type."
  type: WorkItemWidgetType
  "Number of upvotes the work item has received."
  upvotes: Int!
}

"Represents a color widget"
type WorkItemWidgetColor implements WorkItemWidget {
  "Color of the Work Item."
  color: String
  "Text color generated for the Work Item."
  textColor: String
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a todos widget"
type WorkItemWidgetCurrentUserTodos implements CurrentUserTodos & WorkItemWidget {
  "To-do items for the current user."
  currentUserTodos(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int,
    "State of the to-do items."
    state: TodoStateEnum
  ): TodoConnection!
  "Widget type."
  type: WorkItemWidgetType
}

"Represents an assignees widget definition"
type WorkItemWidgetDefinitionAssignees implements WorkItemWidgetDefinition {
  "Indicates whether multiple assignees are allowed."
  allowsMultipleAssignees: Boolean!
  "Indicates whether the current user can invite members to the work item's parent."
  canInviteMembers: Boolean!
  "Widget type."
  type: WorkItemWidgetType!
}

"Represents a generic widget definition"
type WorkItemWidgetDefinitionGeneric implements WorkItemWidgetDefinition {
  "Widget type."
  type: WorkItemWidgetType!
}

"Represents a hierarchy widget definition"
type WorkItemWidgetDefinitionHierarchy implements WorkItemWidgetDefinition {
  "Allowed child types for the work item type."
  allowedChildTypes(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemTypeConnection
  "Widget type."
  type: WorkItemWidgetType!
}

"Represents a labels widget definition"
type WorkItemWidgetDefinitionLabels implements WorkItemWidgetDefinition {
  "Indicates whether scoped labels are available."
  allowsScopedLabels: Boolean!
  "Widget type."
  type: WorkItemWidgetType!
}

"Represents a description widget"
type WorkItemWidgetDescription implements WorkItemWidget {
  "Description of the work item."
  description: String
  "GitLab Flavored Markdown rendering of `description`"
  descriptionHtml: String
  "Whether the description has been edited since the work item was created."
  edited: Boolean!
  "Timestamp of when the work item's description was last edited."
  lastEditedAt: Time
  "User that made the last edit to the work item's description."
  lastEditedBy: UserCore
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a health status widget"
type WorkItemWidgetHealthStatus implements WorkItemWidget {
  "Health status of the work item."
  healthStatus: HealthStatus
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a hierarchy widget"
type WorkItemWidgetHierarchy implements WorkItemWidget {
  "Ancestors (parents) of the work item."
  ancestors(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection
  "Child work items."
  children(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): WorkItemConnection
  "Indicates if the work item has children."
  hasChildren: Boolean!
  "Parent work item."
  parent: WorkItem
  "Widget type."
  type: WorkItemWidgetType
}

"Represents an iteration widget"
type WorkItemWidgetIteration implements WorkItemWidget {
  "Iteration of the work item."
  iteration: Iteration
  "Widget type."
  type: WorkItemWidgetType
}

"Represents the labels widget"
type WorkItemWidgetLabels implements WorkItemWidget {
  "Indicates whether a scoped label is allowed. Deprecated in 16.7: Field moved to workItemType widget definition interface."
  allowsScopedLabels: Boolean @deprecated(reason: "Field moved to workItemType widget definition interface. Please use `WorkItemWidgetDefinitionLabels.allowsScopedLabels`. Deprecated in 16.7.")
  "Labels assigned to the work item."
  labels(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LabelConnection
  "Widget type."
  type: WorkItemWidgetType
}

"Represents the linked items widget"
type WorkItemWidgetLinkedItems implements WorkItemWidget {
  "Indicates the work item is blocked. Returns `null`if `linked_work_items` feature flag is disabled."
  blocked: Boolean
  "Count of items blocking the work item. Returns `null`if `linked_work_items` feature flag is disabled."
  blockedByCount: Int
  "Count of items the work item is blocking. Returns `null`if `linked_work_items` feature flag is disabled."
  blockingCount: Int
  "Linked items for the work item. Returns `null` if `linked_work_items` feature flag is disabled. Introduced in 16.3: This feature is an Experiment. It can be changed or removed at any time."
  linkedItems(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Filter by link type. Supported values: RELATED, BLOCKED_BY, and BLOCKS. Returns all types if omitted."
    filter: WorkItemRelatedLinkType,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): LinkedWorkItemTypeConnection @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.3.")
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a milestone widget"
type WorkItemWidgetMilestone implements WorkItemWidget {
  "Milestone of the work item."
  milestone: Milestone
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a notes widget"
type WorkItemWidgetNotes implements WorkItemWidget {
  "Discussion lock attribute of the work item."
  discussionLocked: Boolean
  "Notes on this work item."
  discussions(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Type of notes collection: ALL_NOTES, ONLY_COMMENTS, ONLY_ACTIVITY."
    filter: NotesFilterType = ALL_NOTES,
    "Returns the first _n_ elements from the list."
    first: Int
  ): DiscussionConnection
  "Widget type."
  type: WorkItemWidgetType
}

"Represents the notifications widget"
type WorkItemWidgetNotifications implements WorkItemWidget {
  "Whether the current user is subscribed to notifications on the work item."
  subscribed: Boolean!
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a progress widget"
type WorkItemWidgetProgress implements WorkItemWidget {
  "Current value of the work item."
  currentValue: Int
  "End value of the work item."
  endValue: Int
  "Progress of the work item."
  progress: Int
  "Start value of the work item."
  startValue: Int
  "Widget type."
  type: WorkItemWidgetType
  "Timestamp of last progress update."
  updatedAt: Time
}

"Represents a legacy requirement widget"
type WorkItemWidgetRequirementLegacy implements WorkItemWidget {
  "Legacy requirement IID associated with the work item. Deprecated in 15.9: Use Work Item IID instead."
  legacyIid: Int @deprecated(reason: "Use Work Item IID instead. Deprecated in 15.9.")
  "Widget type."
  type: WorkItemWidgetType
}

"Represents the rolledup dates widget"
type WorkItemWidgetRolledupDates implements WorkItemWidget {
  "Due date for the work item."
  dueDate: Date
  "Indicates if the due date for the work item is fixed."
  dueDateIsFixed: Boolean
  "Indicates which milestone sources the rolledup due date."
  dueDateSourcingMilestone: Milestone
  "Indicates which work_item sources the rolledup due date."
  dueDateSourcingWorkItem: WorkItem
  "Start date for the work item."
  startDate: Date
  "Indicates if the start date for the work item is fixed."
  startDateIsFixed: Boolean
  "Indicates which milestone sources the rolledup start date."
  startDateSourcingMilestone: Milestone
  "Indicates which work_item sources the rolledup start date."
  startDateSourcingWorkItem: WorkItem
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a start and due date widget"
type WorkItemWidgetStartAndDueDate implements WorkItemWidget {
  "Due date of the work item."
  dueDate: Date
  "Start date of the work item."
  startDate: Date
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a status widget"
type WorkItemWidgetStatus implements WorkItemWidget {
  "Status of the work item."
  status: String
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a test reports widget"
type WorkItemWidgetTestReports implements WorkItemWidget {
  "Test reports of the work item."
  testReports(
    "Returns the elements in the list that come after the specified cursor."
    after: String,
    "Returns the elements in the list that come before the specified cursor."
    before: String,
    "Returns the first _n_ elements from the list."
    first: Int,
    "Returns the last _n_ elements from the list."
    last: Int
  ): TestReportConnection
  "Widget type."
  type: WorkItemWidgetType
}

"Represents a weight widget"
type WorkItemWidgetWeight implements WorkItemWidget {
  "Widget type."
  type: WorkItemWidgetType
  "Weight of the work item."
  weight: Int
}

"Represents a remote development workspace"
type Workspace {
  "Actual state of the workspace."
  actualState: String!
  "Kubernetes Agent associated with the workspace."
  clusterAgent: ClusterAgent!
  "Timestamp of workspace creation."
  createdAt: Time!
  "ResourceVersion of the Deployment resource for the workspace."
  deploymentResourceVersion: Int
  "Desired state of the workspace."
  desiredState: String!
  "Timestamp of last update to desired state."
  desiredStateUpdatedAt: Time!
  "Source YAML of the devfile used to configure the workspace."
  devfile: String!
  "Project repo git path containing the devfile used to configure the workspace."
  devfilePath: String!
  "Project repo git ref containing the devfile used to configure the workspace."
  devfileRef: String!
  "Editor used to configure the workspace. Must match a configured template."
  editor: String!
  "Global ID of the workspace."
  id: RemoteDevelopmentWorkspaceID!
  "Maximum hours the workspace can exist before it is automatically terminated."
  maxHoursBeforeTermination: Int!
  "Name of the workspace in Kubernetes."
  name: String!
  "Namespace of the workspace in Kubernetes."
  namespace: String!
  "Processed YAML of the devfile used to configure the workspace."
  processedDevfile: String!
  "ID of the Project providing the Devfile for the workspace."
  projectId: ID!
  "Timestamp of last response sent to GA4K for the workspace."
  respondedToAgentAt: Time
  "Timestamp of last update to any mutable workspace property."
  updatedAt: Time!
  "URL of the workspace."
  url: String!
  "Owner of the workspace."
  user: UserCore!
}

"The connection type for Workspace."
type WorkspaceConnection {
  "A list of edges."
  edges: [WorkspaceEdge]
  "A list of nodes."
  nodes: [Workspace]
  "Information to aid in pagination."
  pageInfo: PageInfo!
}

"Autogenerated return type of WorkspaceCreate."
type WorkspaceCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created workspace."
  workspace: Workspace
}

"An edge in a connection."
type WorkspaceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Workspace
}

"Autogenerated return type of WorkspaceUpdate."
type WorkspaceUpdatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created workspace."
  workspace: Workspace
}

"Represents an X.509 certificate."
type X509Certificate {
  "Indicates if the certificate is good or revoked."
  certificateStatus: String!
  "Timestamp of when the certificate was saved."
  createdAt: Time!
  "Email associated with the cerificate."
  email: String!
  "ID of the certificate."
  id: ID!
  "Serial number of the certificate."
  serialNumber: String!
  "Subject of the certificate."
  subject: String!
  "Subject key identifier of the certificate."
  subjectKeyIdentifier: String!
  "Timestamp of when the certificate was last updated."
  updatedAt: Time!
  "Issuer of the certificate."
  x509Issuer: X509Issuer!
}

"Issuer of an X.509 certificate."
type X509Issuer {
  "Timestamp of when the issuer was created."
  createdAt: Time
  "Certificate revokation list of the issuer."
  crlUrl: String
  "ID of the issuer."
  id: ID
  "Subject of the issuer."
  subject: String
  "Subject key identifier of the issuer."
  subjectKeyIdentifier: String
  "Timestamp of when the issuer was last updated."
  updatedAt: Time
}

"X.509 signature for a signed commit"
type X509Signature implements CommitSignature {
  "SHA of the associated commit."
  commitSha: String
  "Project of the associated commit."
  project: Project
  "User associated with the key."
  user: UserCore
  "Indicates verification status of the associated key or certificate."
  verificationStatus: VerificationStatus
  "Certificate used for the signature."
  x509Certificate: X509Certificate
}

"Autogenerated return type of iterationCreate."
type iterationCreatePayload {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors encountered during execution of the mutation."
  errors: [String!]!
  "Created iteration."
  iteration: Iteration
}

"Access level to a resource"
enum AccessLevelEnum {
  "Admin access."
  ADMIN
  "Developer access."
  DEVELOPER
  "Guest access."
  GUEST
  "Maintainer access."
  MAINTAINER
  "Minimal access."
  MINIMAL_ACCESS
  "No access."
  NO_ACCESS
  "Owner access."
  OWNER
  "Reporter access."
  REPORTER
}

"Agent token statuses"
enum AgentTokenStatus {
  "Active agent token."
  ACTIVE
  "Revoked agent token."
  REVOKED
}

"Action to subscribe to."
enum AiAction {
  "Chat action."
  CHAT
}

"Possible message roles for AI features."
enum AiMessageRole {
  "assistant message."
  ASSISTANT
  "system message."
  SYSTEM
  "user message."
  USER
}

"Types of messages returned from AI features."
enum AiMessageType {
  "Tool selection message."
  TOOL
}

"Values for sorting alerts"
enum AlertManagementAlertSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Created time by ascending order."
  CREATED_TIME_ASC
  "Created time by descending order."
  CREATED_TIME_DESC
  "End time by ascending order."
  ENDED_AT_ASC
  "End time by descending order."
  ENDED_AT_DESC
  "Events count by ascending order."
  EVENT_COUNT_ASC
  "Events count by descending order."
  EVENT_COUNT_DESC
  "Severity from less critical to more critical."
  SEVERITY_ASC
  "Severity from more critical to less critical."
  SEVERITY_DESC
  "Start time by ascending order."
  STARTED_AT_ASC
  "Start time by descending order."
  STARTED_AT_DESC
  "Status by order: `Ignored > Resolved > Acknowledged > Triggered`."
  STATUS_ASC
  "Status by order: `Triggered > Acknowledged > Resolved > Ignored`."
  STATUS_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created time by ascending order."
  UPDATED_TIME_ASC
  "Created time by descending order."
  UPDATED_TIME_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"Filters the alerts based on given domain"
enum AlertManagementDomainFilter {
  "Alerts for operations domain."
  operations
  "Alerts for threat monitoring domain. Deprecated in 15.0: Network policies are deprecated and will be removed in GitLab 16.0."
  threat_monitoring @deprecated(reason: "Network policies are deprecated and will be removed in GitLab 16.0. Deprecated in 15.0.")
}

"Values of types of integrations"
enum AlertManagementIntegrationType {
  "Integration with any monitoring tool."
  HTTP
  "Prometheus integration."
  PROMETHEUS
}

"Values for alert field names used in the custom mapping"
enum AlertManagementPayloadAlertFieldName {
  "A high-level summary of the problem."
  DESCRIPTION
  "The resolved time of the incident."
  END_TIME
  "The unique identifier of the alert. This can be used to group occurrences of the same alert."
  FINGERPRINT
  "The name of the associated GitLab environment."
  GITLAB_ENVIRONMENT_NAME
  "One or more hosts, as to where this incident occurred."
  HOSTS
  "The name of the associated monitoring tool."
  MONITORING_TOOL
  "The affected service."
  SERVICE
  "The severity of the alert."
  SEVERITY
  "The time of the incident."
  START_TIME
  "The title of the incident."
  TITLE
}

"Values for alert field types used in the custom mapping"
enum AlertManagementPayloadAlertFieldType {
  "Array field type."
  ARRAY
  "DateTime field type."
  DATETIME
  "String field type."
  STRING
}

"Alert severity values"
enum AlertManagementSeverity {
  "Critical severity"
  CRITICAL
  "High severity"
  HIGH
  "Info severity"
  INFO
  "Low severity"
  LOW
  "Medium severity"
  MEDIUM
  "Unknown severity"
  UNKNOWN
}

"Alert status values"
enum AlertManagementStatus {
  "Someone is actively investigating the problem."
  ACKNOWLEDGED
  "No action will be taken."
  IGNORED
  "The problem has been addressed."
  RESOLVED
  "Investigation has not started."
  TRIGGERED
}

"All possible ways to specify the API surface for an API fuzzing scan."
enum ApiFuzzingScanMode {
  "The API surface is specified by a HAR file."
  HAR
  "The API surface is specified by a OPENAPI file."
  OPENAPI
  "The API surface is specified by a POSTMAN file."
  POSTMAN
}

enum ApprovalReportType {
  "Represents report_type for any_merge_request related approval rules."
  ANY_MERGE_REQUEST
  "Represents report_type for license scanning related approval rules."
  LICENSE_SCANNING
  "Represents report_type for vulnerability check related approval rules."
  SCAN_FINDING
}

"The kind of an approval rule."
enum ApprovalRuleType {
  "A `any_approver` approval rule."
  ANY_APPROVER
  "A `code_owner` approval rule."
  CODE_OWNER
  "A `regular` approval rule."
  REGULAR
  "A `report_approver` approval rule."
  REPORT_APPROVER
}

"Assignee ID wildcard values"
enum AssigneeWildcardId {
  "An assignee is assigned."
  ANY
  "No assignee is assigned."
  NONE
}

"User availability status"
enum AvailabilityEnum {
  "Busy"
  BUSY
  "Not Set"
  NOT_SET
}

"Available fields to be exported as CSV"
enum AvailableExportFields {
  "Author name."
  AUTHOR
  "Author username."
  AUTHOR_USERNAME
  "Date of creation."
  CREATED_AT
  "Description."
  DESCRIPTION
  "Unique identifier."
  ID
  "Title."
  TITLE
  "Type of the work item."
  TYPE
}

"Types of blob viewers"
enum BlobViewersType {
  "Auxiliary blob viewers type."
  auxiliary
  "Rich blob viewers type."
  rich
  "Simple blob viewers type."
  simple
}

"Values for scoping catalog resources"
enum CiCatalogResourceScope {
  "All catalog resources visible to the current user."
  ALL
  "Catalog resources belonging to authorized namespaces of the user."
  NAMESPACES
}

"Values for sorting catalog resources"
enum CiCatalogResourceSort {
  "Created date by ascending order."
  CREATED_ASC
  "Created date by descending order."
  CREATED_DESC
  "Latest release date by ascending order."
  LATEST_RELEASED_AT_ASC
  "Latest release date by descending order."
  LATEST_RELEASED_AT_DESC
  "Name by ascending order."
  NAME_ASC
  "Name by descending order."
  NAME_DESC
}

"Values for sorting catalog resource versions"
enum CiCatalogResourceVersionSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Released at by ascending order."
  RELEASED_AT_ASC
  "Released at by descending order."
  RELEASED_AT_DESC
}

"Include type."
enum CiConfigIncludeType {
  "Component include."
  component
  "Project file include."
  file
  "Local include."
  local
  "Remote include."
  remote
  "Template include."
  template
}

"Values for YAML processor result"
enum CiConfigStatus {
  "Configuration file is not valid."
  INVALID
  "Configuration file is valid."
  VALID
}

"Deploy freeze period status"
enum CiFreezePeriodStatus {
  "Freeze period is active."
  ACTIVE
  "Freeze period is inactive."
  INACTIVE
}

"Values for sorting inherited variables"
enum CiGroupVariablesSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Key by ascending order."
  KEY_ASC
  "Key by descending order."
  KEY_DESC
}

enum CiJobFailureReason {
  "A job that failed due to api failure."
  API_FAILURE
  "A job that failed due to archived failure."
  ARCHIVED_FAILURE
  "A job that failed due to bridge pipeline is child pipeline."
  BRIDGE_PIPELINE_IS_CHILD_PIPELINE
  "A job that failed due to builds disabled."
  BUILDS_DISABLED
  "A job that failed due to ci quota exceeded."
  CI_QUOTA_EXCEEDED
  "A job that failed due to data integrity failure."
  DATA_INTEGRITY_FAILURE
  "A job that failed due to deployment rejected."
  DEPLOYMENT_REJECTED
  "A job that failed due to downstream bridge project not found."
  DOWNSTREAM_BRIDGE_PROJECT_NOT_FOUND
  "A job that failed due to downstream pipeline creation failed."
  DOWNSTREAM_PIPELINE_CREATION_FAILED
  "A job that failed due to environment creation failure."
  ENVIRONMENT_CREATION_FAILURE
  "A job that failed due to failed outdated deployment job."
  FAILED_OUTDATED_DEPLOYMENT_JOB
  "A job that failed due to forward deployment failure."
  FORWARD_DEPLOYMENT_FAILURE
  "A job that failed due to insufficient bridge permissions."
  INSUFFICIENT_BRIDGE_PERMISSIONS
  "A job that failed due to insufficient upstream permissions."
  INSUFFICIENT_UPSTREAM_PERMISSIONS
  "A job that failed due to invalid bridge trigger."
  INVALID_BRIDGE_TRIGGER
  "A job that failed due to ip restriction failure."
  IP_RESTRICTION_FAILURE
  "A job that failed due to job execution timeout."
  JOB_EXECUTION_TIMEOUT
  "A job that failed due to missing dependency failure."
  MISSING_DEPENDENCY_FAILURE
  "A job that failed due to no matching runner."
  NO_MATCHING_RUNNER
  "A job that failed due to pipeline loop detected."
  PIPELINE_LOOP_DETECTED
  "A job that failed due to project deleted."
  PROJECT_DELETED
  "A job that failed due to protected environment failure."
  PROTECTED_ENVIRONMENT_FAILURE
  "A job that failed due to reached max descendant pipelines depth."
  REACHED_MAX_DESCENDANT_PIPELINES_DEPTH
  "A job that failed due to reached max pipeline hierarchy size."
  REACHED_MAX_PIPELINE_HIERARCHY_SIZE
  "A job that failed due to runner system failure."
  RUNNER_SYSTEM_FAILURE
  "A job that failed due to runner unsupported."
  RUNNER_UNSUPPORTED
  "A job that failed due to scheduler failure."
  SCHEDULER_FAILURE
  "A job that failed due to script failure."
  SCRIPT_FAILURE
  "A job that failed due to secrets provider not found."
  SECRETS_PROVIDER_NOT_FOUND
  "A job that failed due to stale schedule."
  STALE_SCHEDULE
  "A job that failed due to stuck or timeout failure."
  STUCK_OR_TIMEOUT_FAILURE
  "A job that failed due to trace size exceeded."
  TRACE_SIZE_EXCEEDED
  "A job that failed due to unknown failure."
  UNKNOWN_FAILURE
  "A job that failed due to unmet prerequisites."
  UNMET_PREREQUISITES
  "A job that failed due to upstream bridge project not found."
  UPSTREAM_BRIDGE_PROJECT_NOT_FOUND
  "A job that failed due to user blocked."
  USER_BLOCKED
}

enum CiJobKind {
  "Bridge CI job connecting a parent and child pipeline."
  BRIDGE
  "Standard CI job."
  BUILD
}

enum CiJobStatus {
  "A job that is canceled."
  CANCELED
  "A job that is created."
  CREATED
  "A job that is failed."
  FAILED
  "A job that is manual."
  MANUAL
  "A job that is pending."
  PENDING
  "A job that is preparing."
  PREPARING
  "A job that is running."
  RUNNING
  "A job that is scheduled."
  SCHEDULED
  "A job that is skipped."
  SKIPPED
  "A job that is success."
  SUCCESS
  "A job that is waiting for callback."
  WAITING_FOR_CALLBACK
  "A job that is waiting for resource."
  WAITING_FOR_RESOURCE
}

"Direction of access."
enum CiJobTokenScopeDirection {
  "Target projects in the inbound allowlist can access the scope project through their job tokens."
  INBOUND
  "Job token scope project can access target project in the outbound allowlist."
  OUTBOUND
}

enum CiRunnerAccessLevel {
  "A runner that is not protected."
  NOT_PROTECTED
  "A runner that is ref protected."
  REF_PROTECTED
}

enum CiRunnerJobExecutionStatus {
  "Runner is idle. Introduced in 15.7: This feature is an Experiment. It can be changed or removed at any time."
  IDLE @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.7.")
  "Runner is executing jobs. Introduced in 15.7: This feature is an Experiment. It can be changed or removed at any time."
  RUNNING @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.7.")
}

"Values for filtering runners in namespaces. The previous type name `RunnerMembershipFilter` was deprecated in 15.4."
enum CiRunnerMembershipFilter {
  "Include all runners. This list includes runners for all projects in the group and subgroups, as well as for the parent groups and instance. Introduced in 15.5: This feature is an Experiment. It can be changed or removed at any time."
  ALL_AVAILABLE @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.5.")
  "Include runners that have either a direct or inherited relationship. These runners can be specific to a project or a group."
  DESCENDANTS
  "Include runners that have a direct relationship."
  DIRECT
}

"Values for sorting runners"
enum CiRunnerSort {
  "Ordered by contacted_at in ascending order."
  CONTACTED_ASC
  "Ordered by contacted_at in descending order."
  CONTACTED_DESC
  "Ordered by created_at in ascending order."
  CREATED_ASC
  "Ordered by created_at in descending order."
  CREATED_DESC
  "Ordered by number of running jobs in descending order (only available on Ultimate plans). Introduced in 16.2: This feature is an Experiment. It can be changed or removed at any time."
  MOST_ACTIVE_DESC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.2.")
  "Ordered by token_expires_at in ascending order."
  TOKEN_EXPIRES_AT_ASC
  "Ordered by token_expires_at in descending order."
  TOKEN_EXPIRES_AT_DESC
}

enum CiRunnerStatus {
  "Runner that is not paused. Deprecated in 14.6: This was renamed."
  ACTIVE @deprecated(reason: "This was renamed. Please use `CiRunner.paused`. Deprecated in 14.6.")
  "Runner that has never contacted this instance."
  NEVER_CONTACTED
  "Runner that has not contacted this instance within the last 2 hours. Will be considered `STALE` if offline for more than 3 months."
  OFFLINE
  "Runner that contacted this instance within the last 2 hours."
  ONLINE
  "Runner that is paused. Deprecated in 14.6: This was renamed."
  PAUSED @deprecated(reason: "This was renamed. Please use `CiRunner.paused`. Deprecated in 14.6.")
  "Runner that has not contacted this instance within the last 3 months."
  STALE
}

enum CiRunnerType {
  "A runner that is group type."
  GROUP_TYPE
  "A runner that is instance type."
  INSTANCE_TYPE
  "A runner that is project type."
  PROJECT_TYPE
}

enum CiRunnerUpgradeStatus {
  "Upgrade is available for the runner."
  AVAILABLE
  "Runner version is not valid."
  INVALID
  "Upgrade is not available for the runner."
  NOT_AVAILABLE
  "Upgrade is available and recommended for the runner."
  RECOMMENDED
}

"Values for sorting variables"
enum CiVariableSort {
  "Sorted by key in ascending order."
  KEY_ASC
  "Sorted by key in descending order."
  KEY_DESC
}

enum CiVariableType {
  "Env var type."
  ENV_VAR
  "File type."
  FILE
}

enum CodeQualityDegradationSeverity {
  "Code Quality degradation has a status of blocker."
  BLOCKER
  "Code Quality degradation has a status of critical."
  CRITICAL
  "Code Quality degradation has a status of info."
  INFO
  "Code Quality degradation has a status of major."
  MAJOR
  "Code Quality degradation has a status of minor."
  MINOR
  "Code Quality degradation has a status of unknown."
  UNKNOWN
}

"Represents the generation status of the compared codequality report."
enum CodequalityReportsComparerReportGenerationStatus {
  "An error happened while generating the report."
  ERROR
  "Report was generated."
  PARSED
  "Report is being generated."
  PARSING
}

"Represents the state of the code quality report."
enum CodequalityReportsComparerStatus {
  "Report generated and there are new code quality degradations."
  FAILED
  "Head report or base report not found."
  NOT_FOUND
  "No degradations found in the head pipeline report."
  SUCCESS
}

"Mode of a commit action"
enum CommitActionMode {
  "Chmod command."
  CHMOD
  "Create command."
  CREATE
  "Delete command."
  DELETE
  "Move command."
  MOVE
  "Update command."
  UPDATE
}

enum CommitEncoding {
  "Base64 encoding."
  BASE64
  "Text encoding."
  TEXT
}

"Comparable security report type"
enum ComparableSecurityReportType {
  "API Fuzzing report"
  API_FUZZING
  "Container Scanning report"
  CONTAINER_SCANNING
  "Coverage Fuzzing report"
  COVERAGE_FUZZING
  "DAST report"
  DAST
  "Dependency Scanning report"
  DEPENDENCY_SCANNING
  "SAST report"
  SAST
  "Secret Detection report"
  SECRET_DETECTION
}

"ComplianceFramework of a project for filtering"
enum ComplianceFrameworkPresenceFilter {
  "Any compliance framework is assigned."
  ANY
  "No compliance framework is assigned."
  NONE
}

"Name of the check for the compliance standard."
enum ComplianceStandardsAdherenceCheckName {
  "At least two approvals"
  AT_LEAST_TWO_APPROVALS
  "Prevent approval by merge request author"
  PREVENT_APPROVAL_BY_MERGE_REQUEST_AUTHOR
  "Prevent approval by merge request committers"
  PREVENT_APPROVAL_BY_MERGE_REQUEST_COMMITTERS
}

"Name of the compliance standard."
enum ComplianceStandardsAdherenceStandard {
  "Gitlab"
  GITLAB
}

"Status of the compliance standards adherence."
enum ComplianceStandardsAdherenceStatus {
  "Fail"
  FAIL
  "Success"
  SUCCESS
}

"Reason for the compliance violation."
enum ComplianceViolationReason {
  "Approved by committer"
  APPROVED_BY_COMMITTER
  "Approved by insufficient users"
  APPROVED_BY_INSUFFICIENT_USERS
  "Approved by merge request author"
  APPROVED_BY_MERGE_REQUEST_AUTHOR
}

"Severity of the compliance violation."
enum ComplianceViolationSeverity {
  "Critical severity"
  CRITICAL
  "High severity"
  HIGH
  "Info severity"
  INFO
  "Low severity"
  LOW
  "Medium severity"
  MEDIUM
}

"Compliance violation sort values."
enum ComplianceViolationSort {
  "Date merged in ascending order, further sorted by ID in ascending order."
  MERGED_AT_ASC
  "Date merged in descending order, further sorted by ID in descending order."
  MERGED_AT_DESC
  "Merge request title in ascending order, further sorted by ID in ascending order."
  MERGE_REQUEST_TITLE_ASC
  "Merge request title in descending order, further sorted by ID in descending order."
  MERGE_REQUEST_TITLE_DESC
  "Severity in ascending order, further sorted by ID in ascending order."
  SEVERITY_LEVEL_ASC
  "Severity in descending order, further sorted by ID in descending order."
  SEVERITY_LEVEL_DESC
  "Violation reason in ascending order, further sorted by ID in ascending order."
  VIOLATION_REASON_ASC
  "Violation reason in descending order, further sorted by ID in descending order."
  VIOLATION_REASON_DESC
}

"Conan file types"
enum ConanMetadatumFileTypeEnum {
  "A package file type."
  PACKAGE_FILE
  "A recipe file type."
  RECIPE_FILE
}

"Values for sorting contacts"
enum ContactSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Description in ascending order."
  DESCRIPTION_ASC
  "Description in descending order."
  DESCRIPTION_DESC
  "Email in ascending order."
  EMAIL_ASC
  "Email in descending order."
  EMAIL_DESC
  "First name in ascending order."
  FIRST_NAME_ASC
  "First name in descending order."
  FIRST_NAME_DESC
  "Last name in ascending order."
  LAST_NAME_ASC
  "Last name in descending order."
  LAST_NAME_DESC
  "Organization in ascending order."
  ORGANIZATION_ASC
  "Organization in descending order."
  ORGANIZATION_DESC
  "Phone in ascending order."
  PHONE_ASC
  "Phone in descending order."
  PHONE_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

enum ContainerExpirationPolicyCadenceEnum {
  "Every day"
  EVERY_DAY
  "Every month"
  EVERY_MONTH
  "Every three months"
  EVERY_THREE_MONTHS
  "Every two weeks"
  EVERY_TWO_WEEKS
  "Every week"
  EVERY_WEEK
}

enum ContainerExpirationPolicyKeepEnum {
  "50 tags per image name"
  FIFTY_TAGS
  "5 tags per image name"
  FIVE_TAGS
  "100 tags per image name"
  ONE_HUNDRED_TAGS
  "1 tag per image name"
  ONE_TAG
  "10 tags per image name"
  TEN_TAGS
  "25 tags per image name"
  TWENTY_FIVE_TAGS
}

enum ContainerExpirationPolicyOlderThanEnum {
  "14 days until tags are automatically removed"
  FOURTEEN_DAYS
  "90 days until tags are automatically removed"
  NINETY_DAYS
  "7 days until tags are automatically removed"
  SEVEN_DAYS
  "60 days until tags are automatically removed"
  SIXTY_DAYS
  "30 days until tags are automatically removed"
  THIRTY_DAYS
}

"Access level of a container registry protection rule resource"
enum ContainerRegistryProtectionRuleAccessLevel {
  "Developer access."
  DEVELOPER
  "Maintainer access."
  MAINTAINER
  "Owner access."
  OWNER
}

"Status of the tags cleanup of a container repository"
enum ContainerRepositoryCleanupStatus {
  "Tags cleanup is ongoing."
  ONGOING
  "Tags cleanup is scheduled and is going to be executed shortly."
  SCHEDULED
  "Tags cleanup has been partially executed. There are still remaining tags to delete."
  UNFINISHED
  "Tags cleanup is not scheduled. This is the default state."
  UNSCHEDULED
}

"Values for sorting container repositories"
enum ContainerRepositorySort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Name by ascending order."
  NAME_ASC
  "Name by descending order."
  NAME_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"Status of a container repository"
enum ContainerRepositoryStatus {
  "Delete Failed status."
  DELETE_FAILED
  "Delete Ongoing status."
  DELETE_ONGOING
  "Delete Scheduled status."
  DELETE_SCHEDULED
}

"Values for sorting tags"
enum ContainerRepositoryTagSort {
  "Ordered by name in ascending order."
  NAME_ASC
  "Ordered by name in descending order."
  NAME_DESC
}

enum CustomerRelationsContactState {
  "Active contacts."
  active
  "All available contacts."
  all
  "Inactive contacts."
  inactive
}

enum CustomerRelationsOrganizationState {
  "Active organizations."
  active
  "All available organizations."
  all
  "Inactive organizations."
  inactive
}

"Categories for customizable dashboards."
enum CustomizableDashboardCategory {
  "Analytics category for customizable dashboards."
  ANALYTICS
}

"Check type of the pre scan verification step."
enum DastPreScanVerificationCheckType {
  "Authentication check"
  AUTHENTICATION
  "Connection check"
  CONNECTION
  "Crawling check"
  CRAWLING
}

"Status of DAST pre scan verification."
enum DastPreScanVerificationStatus {
  "Pre Scan Verification complete without errors."
  COMPLETE
  "Pre Scan Verification finished with one or more errors."
  COMPLETE_WITH_ERRORS
  "Pre Scan Validation unable to finish."
  FAILED
  "Pre Scan Verification in execution."
  RUNNING
}

"Unit for the duration of Dast Profile Cadence."
enum DastProfileCadenceUnit {
  "DAST Profile Cadence duration in days."
  DAY
  "DAST Profile Cadence duration in months."
  MONTH
  "DAST Profile Cadence duration in weeks."
  WEEK
  "DAST Profile Cadence duration in years."
  YEAR
}

"Scan method to be used by the scanner."
enum DastScanMethodType {
  "GraphQL scan method."
  GRAPHQL
  "HAR scan method."
  HAR
  "OpenAPI scan method."
  OPENAPI
  "Postman scan method."
  POSTMAN_COLLECTION
  "Website scan method."
  WEBSITE
}

enum DastScanTypeEnum {
  "Active DAST scan. This scan will make active attacks against the target site."
  ACTIVE
  "Passive DAST scan. This scan will not make active attacks against the target site."
  PASSIVE
}

enum DastSiteProfileValidationStatusEnum {
  "Site validation process finished but failed."
  FAILED_VALIDATION
  "Site validation process is in progress."
  INPROGRESS_VALIDATION
  "No site validation exists."
  NONE
  "Site validation process finished successfully."
  PASSED_VALIDATION
  "Site validation process has not started."
  PENDING_VALIDATION
}

enum DastSiteValidationStatusEnum {
  "Site validation process finished but failed."
  FAILED_VALIDATION
  "Site validation process is in progress."
  INPROGRESS_VALIDATION
  "Site validation process finished successfully."
  PASSED_VALIDATION
  "Site validation process has not started."
  PENDING_VALIDATION
}

enum DastSiteValidationStrategyEnum {
  "Header validation."
  HEADER
  "Meta tag validation."
  META_TAG
  "Text file validation."
  TEXT_FILE
}

enum DastTargetTypeEnum {
  "API target."
  API
  "Website target."
  WEBSITE
}

"Color of the data visualization palette"
enum DataVisualizationColorEnum {
  "Aqua color"
  AQUA
  "Blue color"
  BLUE
  "Green color"
  GREEN
  "Magenta color"
  MAGENTA
  "Orange color"
  ORANGE
}

"Weight of the data visualization palette"
enum DataVisualizationWeightEnum {
  "100 weight"
  WEIGHT_100
  "200 weight"
  WEIGHT_200
  "300 weight"
  WEIGHT_300
  "400 weight"
  WEIGHT_400
  "50 weight"
  WEIGHT_50
  "500 weight"
  WEIGHT_500
  "600 weight"
  WEIGHT_600
  "700 weight"
  WEIGHT_700
  "800 weight"
  WEIGHT_800
  "900 weight"
  WEIGHT_900
  "950 weight"
  WEIGHT_950
}

enum DependencyProxyManifestStatus {
  "Dependency proxy manifest has a status of default."
  DEFAULT
  "Dependency proxy manifest has a status of error."
  ERROR
  "Dependency proxy manifest has a status of pending_destruction."
  PENDING_DESTRUCTION
  "Dependency proxy manifest has a status of processing."
  PROCESSING
}

"Values for sorting dependencies"
enum DependencySort {
  "Name by ascending order."
  NAME_ASC
  "Name by descending order."
  NAME_DESC
  "Packager by ascending order."
  PACKAGER_ASC
  "Packager by descending order."
  PACKAGER_DESC
  "Severity by ascending order."
  SEVERITY_ASC
  "Severity by descending order."
  SEVERITY_DESC
}

"Status of the deployment approval summary."
enum DeploymentApprovalSummaryStatus {
  "Summarized deployment approval status that is approved."
  APPROVED
  "Summarized deployment approval status that is pending approval."
  PENDING_APPROVAL
  "Summarized deployment approval status that is rejected."
  REJECTED
}

"All deployment statuses."
enum DeploymentStatus {
  "A deployment that is blocked."
  BLOCKED
  "A deployment that is canceled."
  CANCELED
  "A deployment that is created."
  CREATED
  "A deployment that is failed."
  FAILED
  "A deployment that is running."
  RUNNING
  "A deployment that is skipped."
  SKIPPED
  "A deployment that is success."
  SUCCESS
}

"All environment deployment tiers."
enum DeploymentTier {
  "Development."
  DEVELOPMENT
  "Other."
  OTHER
  "Production."
  PRODUCTION
  "Staging."
  STAGING
  "Testing."
  TESTING
}

"Status of the deployment approval."
enum DeploymentsApprovalStatus {
  "A deployment approval that is approved."
  APPROVED
  "A deployment approval that is rejected."
  REJECTED
}

"Copy state of a DesignCollection"
enum DesignCollectionCopyState {
  "The DesignCollection encountered an error during a copy"
  ERROR
  "The DesignCollection is being copied"
  IN_PROGRESS
  "The DesignCollection has no copy in progress"
  READY
}

"Mutation event of a design within a version"
enum DesignVersionEvent {
  "A creation event"
  CREATION
  "A deletion event"
  DELETION
  "A modification event"
  MODIFICATION
  "No change."
  NONE
}

"Detailed representation of whether a GitLab merge request can be merged."
enum DetailedMergeStatus {
  "Merge request is blocked by another merge request."
  BLOCKED_STATUS
  "Can not merge the source into the target branch, potential conflict."
  BROKEN_STATUS
  "Currently checking for mergeability."
  CHECKING
  "Pipeline must succeed before merging."
  CI_MUST_PASS
  "Pipeline is still running."
  CI_STILL_RUNNING
  "Discussions must be resolved before merging."
  DISCUSSIONS_NOT_RESOLVED
  "Merge request must not be draft before merging."
  DRAFT_STATUS
  "Status checks must pass."
  EXTERNAL_STATUS_CHECKS
  "Either the title or description must reference a Jira issue."
  JIRA_ASSOCIATION
  "Branch can be merged."
  MERGEABLE
  "Merge request must be approved before merging."
  NOT_APPROVED
  "Merge request must be open before merging."
  NOT_OPEN
  "There are denied policies for the merge request."
  POLICIES_DENIED
  "Merge request diff is being created."
  PREPARING
  "Merge status has not been checked."
  UNCHECKED
}

"Type of file the position refers to"
enum DiffPositionType {
  "Unknown file type."
  file
  "An image."
  image
  "Text file."
  text
}

"All possible ways that DORA metrics can be aggregated."
enum DoraMetricBucketingInterval {
  "All data points are combined into a single value."
  ALL
  "Data points are combined into chunks by day."
  DAILY
  "Data points are combined into chunks by month."
  MONTHLY
}

"All supported DORA metric types."
enum DoraMetricType {
  "Change failure rate."
  CHANGE_FAILURE_RATE
  "Deployment frequency."
  DEPLOYMENT_FREQUENCY
  "Lead time for changes."
  LEAD_TIME_FOR_CHANGES
  "Time to restore service."
  TIME_TO_RESTORE_SERVICE
}

"Type of a tree entry"
enum EntryType {
  "File tree type."
  blob
  "Commit tree type."
  commit
  "Directory tree type."
  tree
}

"Roadmap sort values"
enum EpicSort {
  "Sort by created_at by ascending order."
  CREATED_AT_ASC
  "Sort by created_at by descending order."
  CREATED_AT_DESC
  "Sort by end date in ascending order."
  END_DATE_ASC
  "Sort by end date in descending order."
  END_DATE_DESC
  "Sort by start date in ascending order."
  START_DATE_ASC
  "Sort by start date in descending order."
  START_DATE_DESC
  "Sort by title in ascending order."
  TITLE_ASC
  "Sort by title in descending order."
  TITLE_DESC
  "Sort by updated_at by ascending order."
  UPDATED_AT_ASC
  "Sort by updated_at by descending order."
  UPDATED_AT_DESC
  "End date at ascending order. Deprecated in 13.11: Use END_DATE_ASC."
  end_date_asc @deprecated(reason: "Use END_DATE_ASC. Deprecated in 13.11.")
  "End date at descending order. Deprecated in 13.11: Use END_DATE_DESC."
  end_date_desc @deprecated(reason: "Use END_DATE_DESC. Deprecated in 13.11.")
  "Start date at ascending order. Deprecated in 13.11: Use START_DATE_ASC."
  start_date_asc @deprecated(reason: "Use START_DATE_ASC. Deprecated in 13.11.")
  "Start date at descending order. Deprecated in 13.11: Use START_DATE_DESC."
  start_date_desc @deprecated(reason: "Use START_DATE_DESC. Deprecated in 13.11.")
}

"State of an epic"
enum EpicState {
  "All epics."
  all
  "Closed epics."
  closed
  "Open epics."
  opened
}

"State event of an epic"
enum EpicStateEvent {
  "Close the epic."
  CLOSE
  "Reopen the epic."
  REOPEN
}

"Epic ID wildcard values"
enum EpicWildcardId {
  "Any epic is assigned."
  ANY
  "No epic is assigned."
  NONE
}

"Escalation rule statuses"
enum EscalationRuleStatus {
  "."
  ACKNOWLEDGED
  "."
  RESOLVED
}

"Event action"
enum EventAction {
  "Approved action"
  APPROVED
  "Closed action"
  CLOSED
  "Commented action"
  COMMENTED
  "Created action"
  CREATED
  "Destroyed action"
  DESTROYED
  "Expired action"
  EXPIRED
  "Joined action"
  JOINED
  "Left action"
  LEFT
  "Merged action"
  MERGED
  "Pushed action"
  PUSHED
  "Reopened action"
  REOPENED
  "Updated action"
  UPDATED
}

"Report comparison status"
enum FindingReportsComparerStatus {
  "An error happened while generating the report."
  ERROR
  "Report was generated."
  PARSED
  "Report is being generated."
  PARSING
}

"List of statuses for forecasting model."
enum ForecastStatus {
  "Forecast is ready."
  READY
  "Forecast is unavailable."
  UNAVAILABLE
}

"Action to trigger on multiple Geo registries"
enum GeoRegistriesBulkAction {
  "Resync multiple registries."
  RESYNC_ALL
  "Reverify multiple registries."
  REVERIFY_ALL
}

"Action to trigger on an individual Geo registry"
enum GeoRegistryAction {
  "Resync a registry."
  RESYNC
  "Reverify a registry."
  REVERIFY
}

"Geo registry class"
enum GeoRegistryClass {
  "Geo::CiSecureFileRegistry registry class"
  CI_SECURE_FILE_REGISTRY
  "Geo::ContainerRepositoryRegistry registry class"
  CONTAINER_REPOSITORY_REGISTRY
  "Geo::DependencyProxyBlobRegistry registry class"
  DEPENDENCY_PROXY_BLOB_REGISTRY
  "Geo::DependencyProxyManifestRegistry registry class"
  DEPENDENCY_PROXY_MANIFEST_REGISTRY
  "Geo::DesignManagementRepositoryRegistry registry class"
  DESIGN_MANAGEMENT_REPOSITORY_REGISTRY
  "Geo::GroupWikiRepositoryRegistry registry class"
  GROUP_WIKI_REPOSITORY_REGISTRY
  "Geo::JobArtifactRegistry registry class"
  JOB_ARTIFACT_REGISTRY
  "Geo::LfsObjectRegistry registry class"
  LFS_OBJECT_REGISTRY
  "Geo::MergeRequestDiffRegistry registry class"
  MERGE_REQUEST_DIFF_REGISTRY
  "Geo::PackageFileRegistry registry class"
  PACKAGE_FILE_REGISTRY
  "Geo::PagesDeploymentRegistry registry class"
  PAGES_DEPLOYMENT_REGISTRY
  "Geo::PipelineArtifactRegistry registry class"
  PIPELINE_ARTIFACT_REGISTRY
  "Geo::ProjectRepositoryRegistry registry class"
  PROJECT_REPOSITORY_REGISTRY
  "Geo::ProjectWikiRepositoryRegistry registry class"
  PROJECT_WIKI_REPOSITORY_REGISTRY
  "Geo::SnippetRepositoryRegistry registry class"
  SNIPPET_REPOSITORY_REGISTRY
  "Geo::TerraformStateVersionRegistry registry class"
  TERRAFORM_STATE_VERSION_REGISTRY
  "Geo::UploadRegistry registry class"
  UPLOAD_REGISTRY
}

"Types of add-ons"
enum GitlabSubscriptionsAddOnType {
  "Code suggestions seat add-on."
  CODE_SUGGESTIONS
}

"Role of User"
enum GitlabSubscriptionsUserRole {
  "Developer."
  DEVELOPER
  "Guest."
  GUEST
  "Maintainer."
  MAINTAINER
  "Owner."
  OWNER
  "Reporter."
  REPORTER
}

"Group member relation"
enum GroupMemberRelation {
  "Members in the group's subgroups."
  DESCENDANTS
  "Members in the group itself."
  DIRECT
  "Members in the group's ancestor groups."
  INHERITED
  "Invited group's members."
  SHARED_FROM_GROUPS
}

"User permission on groups"
enum GroupPermission {
  "Groups where the user can create projects."
  CREATE_PROJECTS
  "Groups where the user can import projects to."
  IMPORT_PROJECTS
  "Groups where the user can transfer projects to."
  TRANSFER_PROJECTS
}

"Values for sorting releases belonging to a group"
enum GroupReleaseSort {
  "Released at by ascending order."
  RELEASED_AT_ASC
  "Released at by descending order."
  RELEASED_AT_DESC
}

"Health status of an issue or epic"
enum HealthStatus {
  "At risk"
  atRisk
  "Needs attention"
  needsAttention
  "On track"
  onTrack
}

"Health status of an issue or epic for filtering"
enum HealthStatusFilter {
  "Any health status is assigned."
  ANY
  "No health status is assigned."
  NONE
  "At risk"
  atRisk
  "Needs attention"
  needsAttention
  "On track"
  onTrack
}

"Issuable resource link type enum"
enum IssuableResourceLinkType {
  "General link type"
  general
  "Pagerduty link type"
  pagerduty
  "Slack link type"
  slack
  "Zoom link type"
  zoom
}

"Fields to perform the search in"
enum IssuableSearchableField {
  "Search in description field."
  DESCRIPTION
  "Search in title field."
  TITLE
}

"Incident severity"
enum IssuableSeverity {
  "Critical severity"
  CRITICAL
  "High severity"
  HIGH
  "Low severity"
  LOW
  "Medium severity"
  MEDIUM
  "Unknown severity"
  UNKNOWN
}

"State of a GitLab issue or merge request"
enum IssuableState {
  "All available."
  all
  "In closed state."
  closed
  "Discussion has been locked."
  locked
  "In open state."
  opened
}

"Values for subscribing and unsubscribing from issuables"
enum IssuableSubscriptionEvent {
  "Subscribe to an issuable."
  SUBSCRIBE
  "Unsubscribe from an issuable."
  UNSUBSCRIBE
}

"Iteration ID wildcard values for issue creation"
enum IssueCreationIterationWildcardId {
  "Current iteration."
  CURRENT
}

"Issue escalation status values"
enum IssueEscalationStatus {
  "Someone is actively investigating the problem."
  ACKNOWLEDGED
  "No action will be taken."
  IGNORED
  "The problem has been addressed."
  RESOLVED
  "Investigation has not started."
  TRIGGERED
}

"Values for sorting issues"
enum IssueSort {
  "Blocking issues count by ascending order."
  BLOCKING_ISSUES_ASC
  "Blocking issues count by descending order."
  BLOCKING_ISSUES_DESC
  "Closed time by ascending order."
  CLOSED_AT_ASC
  "Closed time by descending order."
  CLOSED_AT_DESC
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Due date by ascending order."
  DUE_DATE_ASC
  "Due date by descending order."
  DUE_DATE_DESC
  "Status from triggered to resolved."
  ESCALATION_STATUS_ASC
  "Status from resolved to triggered."
  ESCALATION_STATUS_DESC
  "Issues with healthy issues first."
  HEALTH_STATUS_ASC
  "Issues with unhealthy issues first."
  HEALTH_STATUS_DESC
  "Label priority by ascending order."
  LABEL_PRIORITY_ASC
  "Label priority by descending order."
  LABEL_PRIORITY_DESC
  "Milestone due date by ascending order."
  MILESTONE_DUE_ASC
  "Milestone due date by descending order."
  MILESTONE_DUE_DESC
  "Number of upvotes (awarded \"thumbs up\" emoji) by ascending order."
  POPULARITY_ASC
  "Number of upvotes (awarded \"thumbs up\" emoji) by descending order."
  POPULARITY_DESC
  "Priority by ascending order."
  PRIORITY_ASC
  "Priority by descending order."
  PRIORITY_DESC
  "Published issues shown last."
  PUBLISHED_ASC
  "Published issues shown first."
  PUBLISHED_DESC
  "Relative position by ascending order."
  RELATIVE_POSITION_ASC
  "Severity from less critical to more critical."
  SEVERITY_ASC
  "Severity from more critical to less critical."
  SEVERITY_DESC
  "Issues with earliest SLA due time shown first."
  SLA_DUE_AT_ASC
  "Issues with latest SLA due time shown first."
  SLA_DUE_AT_DESC
  "Title by ascending order."
  TITLE_ASC
  "Title by descending order."
  TITLE_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Weight by ascending order."
  WEIGHT_ASC
  "Weight by descending order."
  WEIGHT_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"State of a GitLab issue"
enum IssueState {
  "All available."
  all
  "In closed state."
  closed
  "Discussion has been locked."
  locked
  "In open state."
  opened
}

"Values for issue state events"
enum IssueStateEvent {
  "Closes the issue."
  CLOSE
  "Reopens the issue."
  REOPEN
}

"Issue type"
enum IssueType {
  "Epic issue type. Available only when feature flag `namespace_level_work_items` is enabled. Introduced in 16.7: This feature is an Experiment. It can be changed or removed at any time."
  EPIC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.7.")
  "Incident issue type"
  INCIDENT
  "Issue issue type"
  ISSUE
  "Key Result issue type. Available only when feature flag `okrs_mvc` is enabled. Introduced in 15.7: This feature is an Experiment. It can be changed or removed at any time."
  KEY_RESULT @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.7.")
  "Objective issue type. Available only when feature flag `okrs_mvc` is enabled. Introduced in 15.6: This feature is an Experiment. It can be changed or removed at any time."
  OBJECTIVE @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 15.6.")
  "Requirement issue type"
  REQUIREMENT
  "Task issue type"
  TASK
  "Test Case issue type"
  TEST_CASE
}

"Fields to perform the search in"
enum IterationSearchableField {
  "Search in cadence_title field."
  CADENCE_TITLE
  "Search in title field."
  TITLE
}

"Iteration sort values"
enum IterationSort {
  "Sort by cadence id in ascending and due date in ascending order."
  CADENCE_AND_DUE_DATE_ASC
  "Sort by cadence id in ascending and due date in descending order."
  CADENCE_AND_DUE_DATE_DESC
}

"State of a GitLab iteration"
enum IterationState {
  "Any iteration."
  all
  "Closed iteration."
  closed
  "Current iteration."
  current
  "Open iteration."
  opened
  "Upcoming iteration."
  upcoming
}

"Iteration ID wildcard values"
enum IterationWildcardId {
  "An iteration is assigned."
  ANY
  "Current iteration."
  CURRENT
  "No iteration is assigned."
  NONE
}

enum JobArtifactFileType {
  "ACCESSIBILITY job artifact file type."
  ACCESSIBILITY
  "ANNOTATIONS job artifact file type."
  ANNOTATIONS
  "API FUZZING job artifact file type."
  API_FUZZING
  "ARCHIVE job artifact file type."
  ARCHIVE
  "BROWSER PERFORMANCE job artifact file type."
  BROWSER_PERFORMANCE
  "CLUSTER APPLICATIONS job artifact file type."
  CLUSTER_APPLICATIONS
  "CLUSTER IMAGE SCANNING job artifact file type."
  CLUSTER_IMAGE_SCANNING
  "COBERTURA job artifact file type."
  COBERTURA
  "CODE QUALITY job artifact file type."
  CODEQUALITY
  "CONTAINER SCANNING job artifact file type."
  CONTAINER_SCANNING
  "COVERAGE FUZZING job artifact file type."
  COVERAGE_FUZZING
  "CYCLONEDX job artifact file type."
  CYCLONEDX
  "DAST job artifact file type."
  DAST
  "DEPENDENCY SCANNING job artifact file type."
  DEPENDENCY_SCANNING
  "DOTENV job artifact file type."
  DOTENV
  "JUNIT job artifact file type."
  JUNIT
  "LICENSE SCANNING job artifact file type."
  LICENSE_SCANNING
  "LOAD PERFORMANCE job artifact file type."
  LOAD_PERFORMANCE
  "LSIF job artifact file type."
  LSIF
  "METADATA job artifact file type."
  METADATA
  "METRICS job artifact file type."
  METRICS
  "METRICS REFEREE job artifact file type."
  METRICS_REFEREE
  "NETWORK REFEREE job artifact file type."
  NETWORK_REFEREE
  "PERFORMANCE job artifact file type."
  PERFORMANCE
  "REPOSITORY XRAY job artifact file type."
  REPOSITORY_XRAY
  "REQUIREMENTS job artifact file type."
  REQUIREMENTS
  "REQUIREMENTS V2 job artifact file type."
  REQUIREMENTS_V2
  "SAST job artifact file type."
  SAST
  "SECRET DETECTION job artifact file type."
  SECRET_DETECTION
  "TERRAFORM job artifact file type."
  TERRAFORM
  "TRACE job artifact file type."
  TRACE
}

"List limit metric setting"
enum ListLimitMetric {
  "Limit list by number and total weight of issues."
  all_metrics
  "Limit list by number of issues."
  issue_count
  "Limit list by total weight of issues."
  issue_weights
}

"Possible identifier types for a measurement"
enum MeasurementIdentifier {
  "Group count."
  GROUPS
  "Issue count."
  ISSUES
  "Merge request count."
  MERGE_REQUESTS
  "Pipeline count."
  PIPELINES
  "Pipeline count with canceled status."
  PIPELINES_CANCELED
  "Pipeline count with failed status."
  PIPELINES_FAILED
  "Pipeline count with skipped status."
  PIPELINES_SKIPPED
  "Pipeline count with success status."
  PIPELINES_SUCCEEDED
  "Project count."
  PROJECTS
  "User count."
  USERS
}

"Access level of a group or project member"
enum MemberAccessLevel {
  "Developer access."
  DEVELOPER
  "Guest access."
  GUEST
  "Maintainer access."
  MAINTAINER
  "Minimal access."
  MINIMAL_ACCESS
  "Owner access."
  OWNER
  "Reporter access."
  REPORTER
}

"Name of access levels of a group or project member"
enum MemberAccessLevelName {
  "Developer access."
  DEVELOPER
  "Guest access."
  GUEST
  "Maintainer access."
  MAINTAINER
  "Owner access."
  OWNER
  "Reporter access."
  REPORTER
}

"Member role permission"
enum MemberRolePermission {
  "Allows admin of group members."
  ADMIN_GROUP_MEMBER
  "Allows approval of merge requests."
  ADMIN_MERGE_REQUEST
  "Allows to admin terraform state"
  ADMIN_TERRAFORM_STATE
  "Allows admin access to the vulnerability reports."
  ADMIN_VULNERABILITY
  "Allows archiving of projects."
  ARCHIVE_PROJECT
  "Allows manage access to the group access tokens."
  MANAGE_GROUP_ACCESS_TOKENS
  "Allows manage access to the project access tokens."
  MANAGE_PROJECT_ACCESS_TOKENS
  "Allows read-only access to the source code."
  READ_CODE
  "Allows read-only access to the dependencies."
  READ_DEPENDENCY
  "Allows read-only access to the vulnerability reports."
  READ_VULNERABILITY
  "Allows deletion of projects."
  REMOVE_PROJECT
}

"Values for sorting members"
enum MemberSort {
  "Access level ascending order."
  ACCESS_LEVEL_ASC
  "Access level descending order."
  ACCESS_LEVEL_DESC
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "User's full name ascending order."
  USER_FULL_NAME_ASC
  "User's full name descending order."
  USER_FULL_NAME_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"New state to apply to a merge request."
enum MergeRequestNewState {
  "Close the merge request if it is open."
  CLOSED
  "Open the merge request if it is closed."
  OPEN
}

"State of a review of a GitLab merge request."
enum MergeRequestReviewState {
  "Merge request reviewer has requested changes."
  REQUESTED_CHANGES
  "Merge request reviewer has reviewed."
  REVIEWED
  "Awaiting review from merge request reviewer."
  UNREVIEWED
}

"Values for sorting merge requests"
enum MergeRequestSort {
  "Closed time by ascending order."
  CLOSED_AT_ASC
  "Closed time by descending order."
  CLOSED_AT_DESC
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Label priority by ascending order."
  LABEL_PRIORITY_ASC
  "Label priority by descending order."
  LABEL_PRIORITY_DESC
  "Merge time by ascending order."
  MERGED_AT_ASC
  "Merge time by descending order."
  MERGED_AT_DESC
  "Milestone due date by ascending order."
  MILESTONE_DUE_ASC
  "Milestone due date by descending order."
  MILESTONE_DUE_DESC
  "Priority by ascending order."
  PRIORITY_ASC
  "Priority by descending order."
  PRIORITY_DESC
  "Title by ascending order."
  TITLE_ASC
  "Title by descending order."
  TITLE_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"State of a GitLab merge request"
enum MergeRequestState {
  "All available."
  all
  "In closed state."
  closed
  "Discussion has been locked."
  locked
  "Merge request has been merged."
  merged
  "Opened merge request."
  opened
}

"Representation of whether a GitLab merge request can be merged."
enum MergeStatus {
  "There are conflicts between the source and target branches."
  CANNOT_BE_MERGED
  "Currently unchecked. The previous state was `CANNOT_BE_MERGED`."
  CANNOT_BE_MERGED_RECHECK
  "There are no conflicts between the source and target branches."
  CAN_BE_MERGED
  "Currently checking for mergeability."
  CHECKING
  "Merge status has not been checked."
  UNCHECKED
}

enum MergeStrategyEnum {
  "Use the add_to_merge_train_when_pipeline_succeeds merge strategy."
  ADD_TO_MERGE_TRAIN_WHEN_PIPELINE_SUCCEEDS
  "Use the merge_train merge strategy."
  MERGE_TRAIN
  "Use the merge_when_checks_pass merge strategy."
  MERGE_WHEN_CHECKS_PASS
  "Use the merge_when_pipeline_succeeds merge strategy."
  MERGE_WHEN_PIPELINE_SUCCEEDS
}

"Representation of mergeability check identifier."
enum MergeabilityCheckIdentifier {
  "Checks whether the merge request is broken"
  BROKEN_STATUS
  "Checks whether CI has passed"
  CI_MUST_PASS
  "Checks whether the merge request has a conflict"
  CONFLICT
  "Checks whether the merge request has open discussions"
  DISCUSSIONS_NOT_RESOLVED
  "Checks whether the merge request is draft"
  DRAFT_STATUS
  "Checks whether the title or description references a Jira issue."
  JIRA_ASSOCIATION_MISSING
  "Checks whether the merge request is blocked"
  MERGE_REQUEST_BLOCKED
  "Checks whether the merge request needs to be rebased"
  NEED_REBASE
  "Checks whether the merge request is approved"
  NOT_APPROVED
  "Checks whether the merge request is open"
  NOT_OPEN
  "Checks whether the external status checks pass"
  STATUS_CHECKS_MUST_PASS
}

"Representation of whether a mergeability check passed, failed or is inactive."
enum MergeabilityCheckStatus {
  "Mergeability check has failed. The merge request cannot be merged."
  FAILED
  "Mergeability check is disabled via settings."
  INACTIVE
  "Mergeability check has passed."
  SUCCESS
}

"Values for sorting milestones"
enum MilestoneSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Milestone due date by ascending order."
  DUE_DATE_ASC
  "Milestone due date by descending order."
  DUE_DATE_DESC
  "Group milestones in this order: non-expired milestones with due dates, non-expired milestones without due dates and expired milestones then sort by due date in ascending order."
  EXPIRED_LAST_DUE_DATE_ASC
  "Group milestones in this order: non-expired milestones with due dates, non-expired milestones without due dates and expired milestones then sort by due date in descending order."
  EXPIRED_LAST_DUE_DATE_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"Current state of milestone"
enum MilestoneStateEnum {
  "Milestone is currently active."
  active
  "Milestone is closed."
  closed
}

"Milestone ID wildcard values"
enum MilestoneWildcardId {
  "Milestone is assigned."
  ANY
  "No milestone is assigned."
  NONE
  "Milestone assigned is open and started (start date <= today)."
  STARTED
  "Milestone assigned is due in the future (due date > today)."
  UPCOMING
}

"Values for ordering machine learning models by a specific field"
enum MlModelsOrderBy {
  "Ordered by creation time."
  CREATED_AT
  "Ordered by id."
  ID
  "Ordered by name."
  NAME
  "Ordered by update time."
  UPDATED_AT
}

"The position to which the adjacent object should be moved"
enum MoveType {
  "Adjacent object is moved after the object that is being moved."
  after
  "Adjacent object is moved before the object that is being moved."
  before
}

"Different toggles for changing mutator behavior"
enum MutationOperationMode {
  "Performs an append operation."
  APPEND
  "Performs a removal operation."
  REMOVE
  "Performs a replace operation."
  REPLACE
}

"Values for sorting projects"
enum NamespaceProjectSort {
  "Sort by latest activity, descending order."
  ACTIVITY_DESC
  "Most similar to the search query."
  SIMILARITY
  "Sort by excess repository storage size, descending order."
  STORAGE
  "Sort by total storage size, ascending order."
  STORAGE_SIZE_ASC
  "Sort by total storage size, descending order."
  STORAGE_SIZE_DESC
}

"Negated Iteration ID wildcard values"
enum NegatedIterationWildcardId {
  "Current iteration."
  CURRENT
}

"Negated Milestone ID wildcard values"
enum NegatedMilestoneWildcardId {
  "Milestone assigned is open and yet to be started (start date > today)."
  STARTED
  "Milestone assigned is open but due in the past (due date <= today)."
  UPCOMING
}

"Kind of the network policy"
enum NetworkPolicyKind {
  "Policy kind of Cilium Network Policy."
  CiliumNetworkPolicy
  "Policy kind of Network Policy."
  NetworkPolicy
}

"Work item notes collection type."
enum NotesFilterType {
  "Show all activity"
  ALL_NOTES
  "Show history only"
  ONLY_ACTIVITY
  "Show comments only"
  ONLY_COMMENTS
}

"Rotation length unit of an on-call rotation"
enum OncallRotationUnitEnum {
  "Days"
  DAYS
  "Hours"
  HOURS
  "Weeks"
  WEEKS
}

"Values for sorting organization groups"
enum OrganizationGroupSort {
  "Created at in ascending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  CREATED_AT_ASC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Created at in descending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  CREATED_AT_DESC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "ID in ascending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  ID_ASC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "ID in descending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  ID_DESC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Name in ascending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  NAME_ASC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Name in descending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  NAME_DESC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Path in ascending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  PATH_ASC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Path in descending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  PATH_DESC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Updated at in ascending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  UPDATED_AT_ASC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
  "Updated at in descending order. Introduced in 16.4: This feature is an Experiment. It can be changed or removed at any time."
  UPDATED_AT_DESC @deprecated(reason: "This feature is an Experiment. It can be changed or removed at any time. Introduced in 16.4.")
}

"Values for sorting organizations"
enum OrganizationSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Default Rate in ascending order."
  DEFAULT_RATE_ASC
  "Default Rate in descending order."
  DEFAULT_RATE_DESC
  "Description in ascending order."
  DESCRIPTION_ASC
  "Description in descending order."
  DESCRIPTION_DESC
  "Name in ascending order."
  NAME_ASC
  "Name in descending order."
  NAME_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

enum PackageDependencyType {
  "bundleDependencies dependency type"
  BUNDLE_DEPENDENCIES
  "dependencies dependency type"
  DEPENDENCIES
  "devDependencies dependency type"
  DEV_DEPENDENCIES
  "peerDependencies dependency type"
  PEER_DEPENDENCIES
}

"Values for sorting group packages"
enum PackageGroupSort {
  "Ordered by created_at in ascending order."
  CREATED_ASC
  "Ordered by created_at in descending order."
  CREATED_DESC
  "Ordered by name in ascending order."
  NAME_ASC
  "Ordered by name in descending order."
  NAME_DESC
  "Ordered by project path in ascending order."
  PROJECT_PATH_ASC
  "Ordered by project path in descending order."
  PROJECT_PATH_DESC
  "Ordered by type in ascending order."
  TYPE_ASC
  "Ordered by type in descending order."
  TYPE_DESC
  "Ordered by version in ascending order."
  VERSION_ASC
  "Ordered by version in descending order."
  VERSION_DESC
}

"Values for package manager"
enum PackageManager {
  "Package manager: bundler."
  BUNDLER
  "Package manager: composer."
  COMPOSER
  "Package manager: conan."
  CONAN
  "Package manager: go."
  GO
  "Package manager: gradle."
  GRADLE
  "Package manager: maven."
  MAVEN
  "Package manager: npm."
  NPM
  "Package manager: nuget."
  NUGET
  "Package manager: pip."
  PIP
  "Package manager: pipenv."
  PIPENV
  "Package manager: pnpm."
  PNPM
  "Package manager: poetry."
  POETRY
  "Package manager: sbt."
  SBT
  "Package manager: setuptools."
  SETUPTOOLS
  "Package manager: yarn."
  YARN
}

"Values for sorting package"
enum PackageSort {
  "Ordered by created_at in ascending order."
  CREATED_ASC
  "Ordered by created_at in descending order."
  CREATED_DESC
  "Ordered by name in ascending order."
  NAME_ASC
  "Ordered by name in descending order."
  NAME_DESC
  "Ordered by type in ascending order."
  TYPE_ASC
  "Ordered by type in descending order."
  TYPE_DESC
  "Ordered by version in ascending order."
  VERSION_ASC
  "Ordered by version in descending order."
  VERSION_DESC
}

enum PackageStatus {
  "Packages with a default status"
  DEFAULT
  "Packages with a error status"
  ERROR
  "Packages with a hidden status"
  HIDDEN
  "Packages with a pending_destruction status"
  PENDING_DESTRUCTION
  "Packages with a processing status"
  PROCESSING
}

enum PackageTypeEnum {
  "Packages from the Composer package manager"
  COMPOSER
  "Packages from the Conan package manager"
  CONAN
  "Packages from the Debian package manager"
  DEBIAN
  "Packages from the Generic package manager"
  GENERIC
  "Packages from the Golang package manager"
  GOLANG
  "Packages from the Helm package manager"
  HELM
  "Packages from the Maven package manager"
  MAVEN
  "Packages from the Ml_model package manager"
  ML_MODEL
  "Packages from the npm package manager"
  NPM
  "Packages from the Nuget package manager"
  NUGET
  "Packages from the PyPI package manager"
  PYPI
  "Packages from the Rpm package manager"
  RPM
  "Packages from the Rubygems package manager"
  RUBYGEMS
  "Packages from the Terraform Module package manager"
  TERRAFORM_MODULE
}

enum PackagesCleanupKeepDuplicatedPackageFilesEnum {
  "Value to keep all package files"
  ALL_PACKAGE_FILES
  "Value to keep 50 package files"
  FIFTY_PACKAGE_FILES
  "Value to keep 40 package files"
  FORTY_PACKAGE_FILES
  "Value to keep 1 package files"
  ONE_PACKAGE_FILE
  "Value to keep 10 package files"
  TEN_PACKAGE_FILES
  "Value to keep 30 package files"
  THIRTY_PACKAGE_FILES
  "Value to keep 20 package files"
  TWENTY_PACKAGE_FILES
}

"Access level of a package protection rule resource"
enum PackagesProtectionRuleAccessLevel {
  "Developer access."
  DEVELOPER
  "Maintainer access."
  MAINTAINER
  "Owner access."
  OWNER
}

"Package type of a package protection rule resource"
enum PackagesProtectionRulePackageType {
  "Packages of the npm format"
  NPM
}

enum PipelineConfigSourceEnum {
  "Auto DevOps source."
  AUTO_DEVOPS_SOURCE
  "Bridge source."
  BRIDGE_SOURCE
  "Compliance source."
  COMPLIANCE_SOURCE
  "External project source."
  EXTERNAL_PROJECT_SOURCE
  "Parameter source."
  PARAMETER_SOURCE
  "Remote source."
  REMOTE_SOURCE
  "Repository source."
  REPOSITORY_SOURCE
  "Security policies default source."
  SECURITY_POLICIES_DEFAULT_SOURCE
  "Unknown source."
  UNKNOWN_SOURCE
  "Webide source."
  WEBIDE_SOURCE
}

"Event type of the pipeline associated with a merge request"
enum PipelineMergeRequestEventType {
  "Pipeline run on the changes in the merge request source branch."
  DETACHED
  "Pipeline run on the changes from the source branch combined with the target branch."
  MERGED_RESULT
  "Pipeline ran as part of a merge train."
  MERGE_TRAIN
}

enum PipelineScheduleStatus {
  "Active pipeline schedules."
  ACTIVE
  "Inactive pipeline schedules."
  INACTIVE
}

enum PipelineScopeEnum {
  "Branches."
  BRANCHES
  "Pipeline has completed."
  FINISHED
  "Pipeline has not started running yet."
  PENDING
  "Pipeline is running."
  RUNNING
  "Tags."
  TAGS
}

enum PipelineStatusEnum {
  "Pipeline was canceled before completion."
  CANCELED
  "Pipeline has been created."
  CREATED
  "At least one stage of the pipeline failed."
  FAILED
  "Pipeline needs to be manually started."
  MANUAL
  "Pipeline has not started running yet."
  PENDING
  "Pipeline is preparing to run."
  PREPARING
  "Pipeline is running."
  RUNNING
  "Pipeline is scheduled to run."
  SCHEDULED
  "Pipeline was skipped."
  SKIPPED
  "Pipeline completed successfully."
  SUCCESS
  "Pipeline is waiting for an external action."
  WAITING_FOR_CALLBACK
  "A resource (for example, a runner) that the pipeline requires to run is unavailable."
  WAITING_FOR_RESOURCE
}

"Current state of the product analytics stack."
enum ProductAnalyticsState {
  "Stack has been initialized and has data."
  COMPLETE
  "Stack has not been created yet."
  CREATE_INSTANCE
  "Stack is currently initializing."
  LOADING_INSTANCE
  "Stack is waiting for events from users."
  WAITING_FOR_EVENTS
}

"Access level of a project feature"
enum ProjectFeatureAccessLevel {
  "Not enabled for anyone."
  DISABLED
  "Enabled for everyone able to access the project."
  ENABLED
  "Enabled only for team members."
  PRIVATE
}

"Project member relation"
enum ProjectMemberRelation {
  "Descendants members"
  DESCENDANTS
  "Direct members"
  DIRECT
  "Inherited members"
  INHERITED
  "Invited Groups members"
  INVITED_GROUPS
  "Shared Into Ancestors members"
  SHARED_INTO_ANCESTORS
}

"Type of ref"
enum RefType {
  "Ref type for branches."
  HEADS
  "Ref type for tags."
  TAGS
}

"State of a Geo registry"
enum RegistryState {
  "Registry that failed to sync."
  FAILED
  "Registry waiting to be synced."
  PENDING
  "Registry currently syncing."
  STARTED
  "Registry that is synced."
  SYNCED
}

"The position to which the object should be moved"
enum RelativePositionType {
  "Object is moved after an adjacent object."
  AFTER
  "Object is moved before an adjacent object."
  BEFORE
}

"Type of the link: `other`, `runbook`, `image`, `package`"
enum ReleaseAssetLinkType {
  "Image link type"
  IMAGE
  "Other link type"
  OTHER
  "Package link type"
  PACKAGE
  "Runbook link type"
  RUNBOOK
}

"Values for sorting releases"
enum ReleaseSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Released at by ascending order."
  RELEASED_AT_ASC
  "Released at by descending order."
  RELEASED_AT_DESC
}

"Release tag ID wildcard values"
enum ReleaseTagWildcardId {
  "Release tag is assigned."
  ANY
  "No release tag is assigned."
  NONE
}

enum ReplicationStateEnum {
  "Replication process finished but failed."
  FAILED
  "Replication process has not started."
  PENDING
  "Replication process is in progress."
  STARTED
  "Replication process finished successfully."
  SYNCED
}

"State of a requirement"
enum RequirementState {
  "Archived requirement."
  ARCHIVED
  "Open requirement."
  OPENED
}

"Status of a requirement based on last test report"
enum RequirementStatusFilter {
  "Failed test report."
  FAILED
  "Requirements without any test report."
  MISSING
  "Passed test report."
  PASSED
}

"Size of UI component in SAST configuration page"
enum SastUiComponentSize {
  "Size of UI component in SAST configuration page is large."
  LARGE
  "Size of UI component in SAST configuration page is medium."
  MEDIUM
  "Size of UI component in SAST configuration page is small."
  SMALL
}

"The status of the security scan"
enum ScanStatus {
  "The scan has been created."
  CREATED
  "The related CI build failed."
  JOB_FAILED
  "Report couldn't be prepared."
  PREPARATION_FAILED
  "Preparing the report for the scan."
  PREPARING
  "Report for the scan has been removed from the database."
  PURGED
  "The report artifact provided by the CI build couldn't be parsed."
  REPORT_ERROR
  "The report has been successfully prepared."
  SUCCEEDED
}

enum SecurityPolicyRelationType {
  "Policies defined for the project/group only."
  DIRECT
  "Policies defined for the project/group and ancestor groups."
  INHERITED
  "Policies defined for the project/group's ancestor groups only."
  INHERITED_ONLY
}

enum SecurityReportTypeEnum {
  "API FUZZING scan report"
  API_FUZZING
  "BREACH AND ATTACK SIMULATION scan report"
  BREACH_AND_ATTACK_SIMULATION
  "CLUSTER IMAGE SCANNING scan report"
  CLUSTER_IMAGE_SCANNING
  "CONTAINER SCANNING scan report"
  CONTAINER_SCANNING
  "COVERAGE FUZZING scan report"
  COVERAGE_FUZZING
  "DAST scan report"
  DAST
  "DEPENDENCY SCANNING scan report"
  DEPENDENCY_SCANNING
  "SAST scan report"
  SAST
  "SAST IAC scan report"
  SAST_IAC
  "SECRET DETECTION scan report"
  SECRET_DETECTION
}

"The type of the security scanner"
enum SecurityScannerType {
  "API Fuzzing scanner"
  API_FUZZING
  "Breach And Attack Simulation scanner"
  BREACH_AND_ATTACK_SIMULATION
  "Cluster Image Scanning scanner"
  CLUSTER_IMAGE_SCANNING
  "Container Scanning scanner"
  CONTAINER_SCANNING
  "Coverage Fuzzing scanner"
  COVERAGE_FUZZING
  "DAST scanner"
  DAST
  "Dependency Scanning scanner"
  DEPENDENCY_SCANNING
  "SAST scanner"
  SAST
  "Sast Iac scanner"
  SAST_IAC
  "Secret Detection scanner"
  SECRET_DETECTION
}

"State of a Sentry error"
enum SentryErrorStatus {
  "Error has been ignored."
  IGNORED
  "Error has been resolved."
  RESOLVED
  "Error has been ignored until next release."
  RESOLVED_IN_NEXT_RELEASE
  "Error is unresolved."
  UNRESOLVED
}

enum ServiceType {
  "AppleAppStoreService type"
  APPLE_APP_STORE_SERVICE
  "AsanaService type"
  ASANA_SERVICE
  "AssemblaService type"
  ASSEMBLA_SERVICE
  "BambooService type"
  BAMBOO_SERVICE
  "BugzillaService type"
  BUGZILLA_SERVICE
  "BuildkiteService type"
  BUILDKITE_SERVICE
  "CampfireService type"
  CAMPFIRE_SERVICE
  "ClickupService type"
  CLICKUP_SERVICE
  "ConfluenceService type"
  CONFLUENCE_SERVICE
  "CustomIssueTrackerService type"
  CUSTOM_ISSUE_TRACKER_SERVICE
  "DatadogService type"
  DATADOG_SERVICE
  "DiffblueCoverService type"
  DIFFBLUE_COVER_SERVICE
  "DiscordService type"
  DISCORD_SERVICE
  "DroneCiService type"
  DRONE_CI_SERVICE
  "EmailsOnPushService type"
  EMAILS_ON_PUSH_SERVICE
  "EwmService type"
  EWM_SERVICE
  "ExternalWikiService type"
  EXTERNAL_WIKI_SERVICE
  "GithubService type"
  GITHUB_SERVICE
  "GitlabSlackApplicationService type"
  GITLAB_SLACK_APPLICATION_SERVICE
  "GooglePlayService type"
  GOOGLE_PLAY_SERVICE
  "HangoutsChatService type"
  HANGOUTS_CHAT_SERVICE
  "HarborService type"
  HARBOR_SERVICE
  "IrkerService type"
  IRKER_SERVICE
  "JenkinsService type"
  JENKINS_SERVICE
  "JiraService type"
  JIRA_SERVICE
  "MattermostService type"
  MATTERMOST_SERVICE
  "MattermostSlashCommandsService type"
  MATTERMOST_SLASH_COMMANDS_SERVICE
  "MicrosoftTeamsService type"
  MICROSOFT_TEAMS_SERVICE
  "PackagistService type"
  PACKAGIST_SERVICE
  "PipelinesEmailService type"
  PIPELINES_EMAIL_SERVICE
  "PivotaltrackerService type"
  PIVOTALTRACKER_SERVICE
  "PrometheusService type"
  PROMETHEUS_SERVICE
  "PumbleService type"
  PUMBLE_SERVICE
  "PushoverService type"
  PUSHOVER_SERVICE
  "RedmineService type"
  REDMINE_SERVICE
  "SlackService type"
  SLACK_SERVICE
  "SlackSlashCommandsService type"
  SLACK_SLASH_COMMANDS_SERVICE
  "SquashTmService type"
  SQUASH_TM_SERVICE
  "TeamcityService type"
  TEAMCITY_SERVICE
  "TelegramService type"
  TELEGRAM_SERVICE
  "UnifyCircuitService type"
  UNIFY_CIRCUIT_SERVICE
  "WebexTeamsService type"
  WEBEX_TEAMS_SERVICE
  "YoutrackService type"
  YOUTRACK_SERVICE
  "ZentaoService type"
  ZENTAO_SERVICE
}

"How to format SHA strings."
enum ShaFormat {
  "Unabbreviated format."
  LONG
  "Abbreviated format. Short SHAs are typically eight characters long."
  SHORT
}

enum SharedRunnersSetting {
  "Sharing of runners is disabled and overridable."
  DISABLED_AND_OVERRIDABLE
  "Sharing of runners is disabled and unoverridable."
  DISABLED_AND_UNOVERRIDABLE
  "Sharing of runners is disabled and overridable. Deprecated in 17.0: This was renamed."
  DISABLED_WITH_OVERRIDE @deprecated(reason: "This was renamed. Please use `disabled_and_overridable`. Deprecated in 17.0.")
  "Sharing of runners is enabled."
  ENABLED
}

"Type of a snippet blob input action"
enum SnippetBlobActionEnum {
  "Create a snippet blob."
  create
  "Delete a snippet blob."
  delete
  "Move a snippet blob."
  move
  "Update a snippet blob."
  update
}

"Common sort values"
enum Sort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"Values for sort direction"
enum SortDirectionEnum {
  "Ascending order."
  ASC
  "Descending order."
  DESC
}

enum TestCaseStatus {
  "Test case that has a status of error."
  error
  "Test case that has a status of failed."
  failed
  "Test case that has a status of skipped."
  skipped
  "Test case that has a status of success."
  success
}

"State of a test report"
enum TestReportState {
  "Failed test report."
  FAILED
  "Passed test report."
  PASSED
}

"Category of error."
enum TimeboxReportErrorReason {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Label priority by ascending order."
  LABEL_PRIORITY_ASC
  "Label priority by descending order."
  LABEL_PRIORITY_DESC
  "Milestone due date by ascending order."
  MILESTONE_DUE_ASC
  "Milestone due date by descending order."
  MILESTONE_DUE_DESC
  "One or both of start_date and due_date is missing."
  MISSING_DATES
  "Priority by ascending order."
  PRIORITY_ASC
  "Priority by descending order."
  PRIORITY_DESC
  "There are too many events."
  TOO_MANY_EVENTS
  "This type does not support timebox reports."
  UNSUPPORTED
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"Values for sorting timelogs"
enum TimelogSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Spent at ascending order."
  SPENT_AT_ASC
  "Spent at descending order."
  SPENT_AT_DESC
  "Time spent ascending order."
  TIME_SPENT_ASC
  "Time spent descending order."
  TIME_SPENT_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

enum TodoActionEnum {
  "User was set as an approver."
  approval_required
  "User was assigned."
  assigned
  "Build triggered by the user failed."
  build_failed
  "User was directly addressed."
  directly_addressed
  "User added a to-do item."
  marked
  "Group or project access requested from the user."
  member_access_requested
  "User was mentioned."
  mentioned
  "Merge request authored by the user was removed from the merge train."
  merge_train_removed
  "An OKR assigned to the user requires an update."
  okr_checkin_requested
  "Review was requested from the user."
  review_requested
  "Merge request authored by the user received a review."
  review_submitted
  "Merge request authored by the user could not be merged."
  unmergeable
}

enum TodoStateEnum {
  "State of the todo is done."
  done
  "State of the todo is pending."
  pending
}

enum TodoTargetEnum {
  "Alert."
  ALERT
  "Commit."
  COMMIT
  "Design."
  DESIGN
  "An Epic."
  EPIC
  "Issue."
  ISSUE
  "Merge request."
  MERGEREQUEST
  "Work item."
  WORKITEM
}

"Status of the request to the training provider. The URL of a TrainingUrl is calculated asynchronously. When PENDING, the URL of the TrainingUrl will be null. When COMPLETED, the URL of the TrainingUrl will be available."
enum TrainingUrlRequestStatus {
  "Completed request."
  COMPLETED
  "Pending request."
  PENDING
}

enum TypeEnum {
  "Snippet created independent of any project."
  personal
  "Snippet related to a specific project."
  project
}

"Name of the feature that the callout is for."
enum UserCalloutFeatureNameEnum {
  "Callout feature name for active_user_count_threshold."
  ACTIVE_USER_COUNT_THRESHOLD
  "Callout feature name for branch_rules_info_callout."
  BRANCH_RULES_INFO_CALLOUT
  "Callout feature name for buy_pipeline_minutes_notification_dot."
  BUY_PIPELINE_MINUTES_NOTIFICATION_DOT
  "Callout feature name for canary_deployment."
  CANARY_DEPLOYMENT
  "Callout feature name for ci_deprecation_warning_for_types_keyword."
  CI_DEPRECATION_WARNING_FOR_TYPES_KEYWORD
  "Callout feature name for cloud_licensing_subscription_activation_banner."
  CLOUD_LICENSING_SUBSCRIPTION_ACTIVATION_BANNER
  "Callout feature name for cluster_security_warning."
  CLUSTER_SECURITY_WARNING
  "Callout feature name for code_suggestions_ga_non_owner_alert."
  CODE_SUGGESTIONS_GA_NON_OWNER_ALERT
  "Callout feature name for code_suggestions_ga_owner_alert."
  CODE_SUGGESTIONS_GA_OWNER_ALERT
  "Callout feature name for duo_chat_callout."
  DUO_CHAT_CALLOUT
  "Callout feature name for eoa_bronze_plan_banner."
  EOA_BRONZE_PLAN_BANNER
  "Callout feature name for feature_flags_new_version."
  FEATURE_FLAGS_NEW_VERSION
  "Callout feature name for gcp_signup_offer."
  GCP_SIGNUP_OFFER
  "Callout feature name for geo_enable_hashed_storage."
  GEO_ENABLE_HASHED_STORAGE
  "Callout feature name for geo_migrate_hashed_storage."
  GEO_MIGRATE_HASHED_STORAGE
  "Callout feature name for gke_cluster_integration."
  GKE_CLUSTER_INTEGRATION
  "Callout feature name for gold_trial_billings."
  GOLD_TRIAL_BILLINGS
  "Callout feature name for merge_request_settings_moved_callout."
  MERGE_REQUEST_SETTINGS_MOVED_CALLOUT
  "Callout feature name for mr_experience_survey."
  MR_EXPERIENCE_SURVEY
  "Callout feature name for namespace_over_storage_users_combined_alert."
  NAMESPACE_OVER_STORAGE_USERS_COMBINED_ALERT
  "Callout feature name for namespace_storage_limit_alert_alert_threshold."
  NAMESPACE_STORAGE_LIMIT_ALERT_ALERT_THRESHOLD
  "Callout feature name for namespace_storage_limit_alert_error_threshold."
  NAMESPACE_STORAGE_LIMIT_ALERT_ERROR_THRESHOLD
  "Callout feature name for namespace_storage_limit_alert_warning_threshold."
  NAMESPACE_STORAGE_LIMIT_ALERT_WARNING_THRESHOLD
  "Callout feature name for namespace_storage_pre_enforcement_banner."
  NAMESPACE_STORAGE_PRE_ENFORCEMENT_BANNER
  "Callout feature name for new_nav_for_everyone_callout."
  NEW_NAV_FOR_EVERYONE_CALLOUT
  "Callout feature name for new_top_level_group_alert."
  NEW_TOP_LEVEL_GROUP_ALERT
  "Callout feature name for new_user_signups_cap_reached."
  NEW_USER_SIGNUPS_CAP_REACHED
  "Callout feature name for personal_access_token_expiry."
  PERSONAL_ACCESS_TOKEN_EXPIRY
  "Callout feature name for personal_project_limitations_banner."
  PERSONAL_PROJECT_LIMITATIONS_BANNER
  "Callout feature name for pipeline_needs_banner."
  PIPELINE_NEEDS_BANNER
  "Callout feature name for pipeline_needs_hover_tip."
  PIPELINE_NEEDS_HOVER_TIP
  "Callout feature name for preview_user_over_limit_free_plan_alert."
  PREVIEW_USER_OVER_LIMIT_FREE_PLAN_ALERT
  "Callout feature name for product_analytics_dashboard_feedback."
  PRODUCT_ANALYTICS_DASHBOARD_FEEDBACK
  "Callout feature name for profile_personal_access_token_expiry."
  PROFILE_PERSONAL_ACCESS_TOKEN_EXPIRY
  "Callout feature name for project_quality_summary_feedback."
  PROJECT_QUALITY_SUMMARY_FEEDBACK
  "Callout feature name for project_repository_limit_alert_alert_threshold."
  PROJECT_REPOSITORY_LIMIT_ALERT_ALERT_THRESHOLD
  "Callout feature name for project_repository_limit_alert_error_threshold."
  PROJECT_REPOSITORY_LIMIT_ALERT_ERROR_THRESHOLD
  "Callout feature name for project_repository_limit_alert_warning_threshold."
  PROJECT_REPOSITORY_LIMIT_ALERT_WARNING_THRESHOLD
  "Callout feature name for registration_enabled_callout."
  REGISTRATION_ENABLED_CALLOUT
  "Callout feature name for security_configuration_devops_alert."
  SECURITY_CONFIGURATION_DEVOPS_ALERT
  "Callout feature name for security_configuration_upgrade_banner."
  SECURITY_CONFIGURATION_UPGRADE_BANNER
  "Callout feature name for security_newsletter_callout."
  SECURITY_NEWSLETTER_CALLOUT
  "Callout feature name for security_policy_protected_branch_modification."
  SECURITY_POLICY_PROTECTED_BRANCH_MODIFICATION
  "Callout feature name for security_training_feature_promotion."
  SECURITY_TRAINING_FEATURE_PROMOTION
  "Callout feature name for submit_license_usage_data_banner."
  SUBMIT_LICENSE_USAGE_DATA_BANNER
  "Callout feature name for suggest_pipeline."
  SUGGEST_PIPELINE
  "Callout feature name for suggest_popover_dismissed."
  SUGGEST_POPOVER_DISMISSED
  "Callout feature name for tabs_position_highlight."
  TABS_POSITION_HIGHLIGHT
  "Callout feature name for terraform_notification_dismissed."
  TERRAFORM_NOTIFICATION_DISMISSED
  "Callout feature name for threat_monitoring_info."
  THREAT_MONITORING_INFO
  "Callout feature name for trial_status_reminder_d14."
  TRIAL_STATUS_REMINDER_D14
  "Callout feature name for trial_status_reminder_d3."
  TRIAL_STATUS_REMINDER_D3
  "Callout feature name for two_factor_auth_recovery_settings_check."
  TWO_FACTOR_AUTH_RECOVERY_SETTINGS_CHECK
  "Callout feature name for ultimate_trial."
  ULTIMATE_TRIAL
  "Callout feature name for unfinished_tag_cleanup_callout."
  UNFINISHED_TAG_CLEANUP_CALLOUT
  "Callout feature name for user_reached_limit_free_plan_alert."
  USER_REACHED_LIMIT_FREE_PLAN_ALERT
  "Callout feature name for verification_reminder."
  VERIFICATION_REMINDER
  "Callout feature name for vsd_feedback_banner."
  VSD_FEEDBACK_BANNER
  "Callout feature name for vulnerability_report_grouping."
  VULNERABILITY_REPORT_GROUPING
  "Callout feature name for web_ide_alert_dismissed."
  WEB_IDE_ALERT_DISMISSED
  "Callout feature name for web_ide_ci_environments_guidance."
  WEB_IDE_CI_ENVIRONMENTS_GUIDANCE
}

"Possible states of a user"
enum UserState {
  "User is active and can use the system."
  active
  "User is blocked, and their contributions are hidden."
  banned
  "User has been blocked by an administrator and cannot use the system."
  blocked
  "User is blocked and pending approval."
  blocked_pending_approval
  "User is no longer active and cannot use the system."
  deactivated
  "User has been blocked by the system."
  ldap_blocked
}

"Possible identifier types for a measurement"
enum ValueStreamDashboardMetric {
  "Contributor count. EXPERIMENTAL: Only available on the SaaS version of GitLab when the ClickHouse database backend is enabled."
  CONTRIBUTORS
  "Group count."
  GROUPS
  "Issue count."
  ISSUES
  "Merge request count."
  MERGE_REQUESTS
  "Pipeline count."
  PIPELINES
  "Project count."
  PROJECTS
}

"Stage event identifiers"
enum ValueStreamStageEvent {
  "Code stage start event."
  CODE_STAGE_START
  "Issue closed event."
  ISSUE_CLOSED
  "Issue created event."
  ISSUE_CREATED
  "Issue deployed to production event."
  ISSUE_DEPLOYED_TO_PRODUCTION
  "Issue first added to board event."
  ISSUE_FIRST_ADDED_TO_BOARD
  "Issue first assigned at event."
  ISSUE_FIRST_ASSIGNED_AT
  "Issue first associated with milestone event."
  ISSUE_FIRST_ASSOCIATED_WITH_MILESTONE
  "Issue first mentioned in commit event."
  ISSUE_FIRST_MENTIONED_IN_COMMIT
  "Issue label added event."
  ISSUE_LABEL_ADDED
  "Issue label removed event."
  ISSUE_LABEL_REMOVED
  "Issue last edited event."
  ISSUE_LAST_EDITED
  "Issue stage end event."
  ISSUE_STAGE_END
  "Merge request closed event."
  MERGE_REQUEST_CLOSED
  "Merge request created event."
  MERGE_REQUEST_CREATED
  "Merge request first assigned at event."
  MERGE_REQUEST_FIRST_ASSIGNED_AT
  "Merge request first commit at event."
  MERGE_REQUEST_FIRST_COMMIT_AT
  "Merge request first deployed to production event."
  MERGE_REQUEST_FIRST_DEPLOYED_TO_PRODUCTION
  "Merge request label added event."
  MERGE_REQUEST_LABEL_ADDED
  "Merge request label removed event."
  MERGE_REQUEST_LABEL_REMOVED
  "Merge request last build finished event."
  MERGE_REQUEST_LAST_BUILD_FINISHED
  "Merge request last build started event."
  MERGE_REQUEST_LAST_BUILD_STARTED
  "Merge request last edited event."
  MERGE_REQUEST_LAST_EDITED
  "Merge request merged event."
  MERGE_REQUEST_MERGED
  "Plan stage start event."
  PLAN_STAGE_START
}

enum VerificationStateEnum {
  "Verification process is disabled."
  DISABLED
  "Verification process finished but failed."
  FAILED
  "Verification process has not started."
  PENDING
  "Verification process is in progress."
  STARTED
  "Verification process finished successfully."
  SUCCEEDED
}

"Verification status of a GPG, X.509 or SSH signature for a commit."
enum VerificationStatus {
  "multiple_signatures verification status."
  MULTIPLE_SIGNATURES
  "other_user verification status."
  OTHER_USER
  "revoked_key verification status."
  REVOKED_KEY
  "same_user_different_email verification status."
  SAME_USER_DIFFERENT_EMAIL
  "unknown_key verification status."
  UNKNOWN_KEY
  "unverified verification status."
  UNVERIFIED
  "unverified_key verification status."
  UNVERIFIED_KEY
  "verified verification status."
  VERIFIED
  "verified_ca verification status."
  VERIFIED_CA
  "verified_system verification status."
  VERIFIED_SYSTEM
}

enum VisibilityLevelsEnum {
  "Internal visibility level."
  internal
  "Private visibility level."
  private
  "Public visibility level."
  public
}

"Determines whether the pipeline list shows ID or IID"
enum VisibilityPipelineIdType {
  "Display pipeline ID."
  ID
  "Display pipeline IID."
  IID
}

enum VisibilityScopesEnum {
  "Snippet is visible for any logged in user except external users."
  internal
  "Snippet is visible only to the snippet creator."
  private
  "Snippet can be accessed without any authentication."
  public
}

"Confidence that a given vulnerability is present in the codebase."
enum VulnerabilityConfidence {
  "Confirmed confidence"
  CONFIRMED
  "Experimental confidence"
  EXPERIMENTAL
  "High confidence"
  HIGH
  "Ignore confidence"
  IGNORE
  "Low confidence"
  LOW
  "Medium confidence"
  MEDIUM
  "Unknown confidence"
  UNKNOWN
}

"The dismissal reason of the Vulnerability"
enum VulnerabilityDismissalReason {
  "The vulnerability is known, and has not been remediated or mitigated, but is considered to be an acceptable business risk."
  ACCEPTABLE_RISK
  "An error in reporting in which a test result incorrectly indicates the presence of a vulnerability in a system when the vulnerability is not present."
  FALSE_POSITIVE
  "A management, operational, or technical control (that is, safeguard or countermeasure) employed by an organization that provides equivalent or comparable protection for an information system."
  MITIGATING_CONTROL
  "The vulnerability is known, and has not been remediated or mitigated, but is considered to be in a part of the application that will not be updated."
  NOT_APPLICABLE
  "The finding is not a vulnerability because it is part of a test or is test data."
  USED_IN_TESTS
}

"The external tracker of the external issue link related to a vulnerability"
enum VulnerabilityExternalIssueLinkExternalTracker {
  "Jira external tracker"
  JIRA
}

"The type of the external issue link related to a vulnerability"
enum VulnerabilityExternalIssueLinkType {
  "Created link type."
  CREATED
}

"The grade of the vulnerable project"
enum VulnerabilityGrade {
  "A grade"
  A
  "B grade"
  B
  "C grade"
  C
  "D grade"
  D
  "F grade"
  F
}

"The type of the issue link related to a vulnerability"
enum VulnerabilityIssueLinkType {
  "Issue is created for the vulnerability"
  CREATED
  "Has a related issue"
  RELATED
}

"OwaspTop10 category of the vulnerability"
enum VulnerabilityOwaspTop10 {
  "A10:2017-Insufficient Logging & Monitoring, OWASP top 10 category."
  A10_2017
  "A10:2021-Server-Side Request Forgery, OWASP top 10 category."
  A10_2021
  "A1:2017-Injection, OWASP top 10 category."
  A1_2017
  "A1:2021-Broken Access Control, OWASP top 10 category."
  A1_2021
  "A2:2017-Broken Authentication, OWASP top 10 category."
  A2_2017
  "A2:2021-Cryptographic Failures, OWASP top 10 category."
  A2_2021
  "A3:2017-Sensitive Data Exposure, OWASP top 10 category."
  A3_2017
  "A3:2021-Injection, OWASP top 10 category."
  A3_2021
  "A4:2017-XML External Entities (XXE), OWASP top 10 category."
  A4_2017
  "A4:2021-Insecure Design, OWASP top 10 category."
  A4_2021
  "A5:2017-Broken Access Control, OWASP top 10 category."
  A5_2017
  "A5:2021-Security Misconfiguration, OWASP top 10 category."
  A5_2021
  "A6:2017-Security Misconfiguration, OWASP top 10 category."
  A6_2017
  "A6:2021-Vulnerable and Outdated Components, OWASP top 10 category."
  A6_2021
  "A7:2017-Cross-Site Scripting (XSS), OWASP top 10 category."
  A7_2017
  "A7:2021-Identification and Authentication Failures, OWASP top 10 category."
  A7_2021
  "A8:2017-Insecure Deserialization, OWASP top 10 category."
  A8_2017
  "A8:2021-Software and Data Integrity Failures, OWASP top 10 category."
  A8_2021
  "A9:2017-Using Components with Known Vulnerabilities, OWASP top 10 category."
  A9_2017
  "A9:2021-Security Logging and Monitoring Failures, OWASP top 10 category."
  A9_2021
}

"The type of the security scan that found the vulnerability"
enum VulnerabilityReportType {
  "API Fuzzing report"
  API_FUZZING
  "Cluster Image Scanning report"
  CLUSTER_IMAGE_SCANNING
  "Container Scanning report"
  CONTAINER_SCANNING
  "Coverage Fuzzing report"
  COVERAGE_FUZZING
  "DAST report"
  DAST
  "Dependency Scanning report"
  DEPENDENCY_SCANNING
  "Generic report"
  GENERIC
  "SAST report"
  SAST
  "Secret Detection report"
  SECRET_DETECTION
}

"The severity of the vulnerability"
enum VulnerabilitySeverity {
  "Critical severity"
  CRITICAL
  "High severity"
  HIGH
  "Info severity"
  INFO
  "Low severity"
  LOW
  "Medium severity"
  MEDIUM
  "Unknown severity"
  UNKNOWN
}

"Vulnerability sort values"
enum VulnerabilitySort {
  "Detection timestamp in ascending order."
  detected_asc
  "Detection timestamp in descending order."
  detected_desc
  "Severity in ascending order."
  severity_asc
  "Severity in descending order."
  severity_desc
}

"The state of the vulnerability"
enum VulnerabilityState {
  "For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values)."
  CONFIRMED
  "For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values)."
  DETECTED
  "For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values)."
  DISMISSED
  "For details, see [vulnerability status values](https://docs.gitlab.com/ee/user/application_security/vulnerabilities/index.html#vulnerability-status-values)."
  RESOLVED
}

"Weight ID wildcard values"
enum WeightWildcardId {
  "Weight is assigned."
  ANY
  "No weight is assigned."
  NONE
}

"Values for work item award emoji update enum"
enum WorkItemAwardEmojiUpdateAction {
  "Adds the emoji."
  ADD
  "Removes the emoji."
  REMOVE
  "Toggles the status of the emoji."
  TOGGLE
}

"Values for work item link types"
enum WorkItemRelatedLinkType {
  "Blocked by type."
  BLOCKED_BY
  "Blocks type."
  BLOCKS
  "Related type."
  RELATED
}

"Values for sorting work items"
enum WorkItemSort {
  "Created at ascending order."
  CREATED_ASC
  "Created at descending order."
  CREATED_DESC
  "Title by ascending order."
  TITLE_ASC
  "Title by descending order."
  TITLE_DESC
  "Updated at ascending order."
  UPDATED_ASC
  "Updated at descending order."
  UPDATED_DESC
  "Created at ascending order. Deprecated in 13.5: This was renamed."
  created_asc @deprecated(reason: "This was renamed. Please use `CREATED_ASC`. Deprecated in 13.5.")
  "Created at descending order. Deprecated in 13.5: This was renamed."
  created_desc @deprecated(reason: "This was renamed. Please use `CREATED_DESC`. Deprecated in 13.5.")
  "Updated at ascending order. Deprecated in 13.5: This was renamed."
  updated_asc @deprecated(reason: "This was renamed. Please use `UPDATED_ASC`. Deprecated in 13.5.")
  "Updated at descending order. Deprecated in 13.5: This was renamed."
  updated_desc @deprecated(reason: "This was renamed. Please use `UPDATED_DESC`. Deprecated in 13.5.")
}

"State of a GitLab work item"
enum WorkItemState {
  "In closed state."
  CLOSED
  "In open state."
  OPEN
}

"Values for work item state events"
enum WorkItemStateEvent {
  "Closes the work item."
  CLOSE
  "Reopens the work item."
  REOPEN
}

"Values for work item to-do update enum"
enum WorkItemTodoUpdateAction {
  "Adds the to-do."
  ADD
  "Marks the to-do as done."
  MARK_AS_DONE
}

"Type of a work item widget"
enum WorkItemWidgetType {
  "Assignees widget."
  ASSIGNEES
  "Award Emoji widget."
  AWARD_EMOJI
  "Color widget."
  COLOR
  "Current User Todos widget."
  CURRENT_USER_TODOS
  "Description widget."
  DESCRIPTION
  "Health Status widget."
  HEALTH_STATUS
  "Hierarchy widget."
  HIERARCHY
  "Iteration widget."
  ITERATION
  "Labels widget."
  LABELS
  "Linked Items widget."
  LINKED_ITEMS
  "Milestone widget."
  MILESTONE
  "Notes widget."
  NOTES
  "Notifications widget."
  NOTIFICATIONS
  "Progress widget."
  PROGRESS
  "Requirement Legacy widget."
  REQUIREMENT_LEGACY
  "Rolledup Dates widget."
  ROLLEDUP_DATES
  "Start And Due Date widget."
  START_AND_DUE_DATE
  "Status widget."
  STATUS
  "Test Reports widget."
  TEST_REPORTS
  "Weight widget."
  WEIGHT
}

"""

A `AbuseReportID` is a global ID. It is encoded as a string.

An example `AbuseReportID` is: `"gid://gitlab/AbuseReport/1"`.
"""
scalar AbuseReportID

"""

A `AchievementsAchievementID` is a global ID. It is encoded as a string.

An example `AchievementsAchievementID` is: `"gid://gitlab/Achievements::Achievement/1"`.
"""
scalar AchievementsAchievementID

"""

A `AchievementsUserAchievementID` is a global ID. It is encoded as a string.

An example `AchievementsUserAchievementID` is: `"gid://gitlab/Achievements::UserAchievement/1"`.
"""
scalar AchievementsUserAchievementID

"""

A `AiModelID` is a global ID. It is encoded as a string.

An example `AiModelID` is: `"gid://gitlab/Ai::Model/1"`.
"""
scalar AiModelID

"""

A `AlertManagementAlertID` is a global ID. It is encoded as a string.

An example `AlertManagementAlertID` is: `"gid://gitlab/AlertManagement::Alert/1"`.
"""
scalar AlertManagementAlertID

"""

A `AlertManagementHttpIntegrationID` is a global ID. It is encoded as a string.

An example `AlertManagementHttpIntegrationID` is: `"gid://gitlab/AlertManagement::HttpIntegration/1"`.
"""
scalar AlertManagementHttpIntegrationID

"""

A `AnalyticsCycleAnalyticsValueStreamID` is a global ID. It is encoded as a string.

An example `AnalyticsCycleAnalyticsValueStreamID` is: `"gid://gitlab/Analytics::CycleAnalytics::ValueStream/1"`.
"""
scalar AnalyticsCycleAnalyticsValueStreamID

"""

A `AnalyticsDevopsAdoptionEnabledNamespaceID` is a global ID. It is encoded as a string.

An example `AnalyticsDevopsAdoptionEnabledNamespaceID` is: `"gid://gitlab/Analytics::DevopsAdoption::EnabledNamespace/1"`.
"""
scalar AnalyticsDevopsAdoptionEnabledNamespaceID

"""

A `AppSecFuzzingCoverageCorpusID` is a global ID. It is encoded as a string.

An example `AppSecFuzzingCoverageCorpusID` is: `"gid://gitlab/AppSec::Fuzzing::Coverage::Corpus/1"`.
"""
scalar AppSecFuzzingCoverageCorpusID

"""

A `AuditEventsAmazonS3ConfigurationID` is a global ID. It is encoded as a string.

An example `AuditEventsAmazonS3ConfigurationID` is: `"gid://gitlab/AuditEvents::AmazonS3Configuration/1"`.
"""
scalar AuditEventsAmazonS3ConfigurationID

"""

A `AuditEventsExternalAuditEventDestinationID` is a global ID. It is encoded as a string.

An example `AuditEventsExternalAuditEventDestinationID` is: `"gid://gitlab/AuditEvents::ExternalAuditEventDestination/1"`.
"""
scalar AuditEventsExternalAuditEventDestinationID

"""

A `AuditEventsGoogleCloudLoggingConfigurationID` is a global ID. It is encoded as a string.

An example `AuditEventsGoogleCloudLoggingConfigurationID` is: `"gid://gitlab/AuditEvents::GoogleCloudLoggingConfiguration/1"`.
"""
scalar AuditEventsGoogleCloudLoggingConfigurationID

"""

A `AuditEventsInstanceAmazonS3ConfigurationID` is a global ID. It is encoded as a string.

An example `AuditEventsInstanceAmazonS3ConfigurationID` is: `"gid://gitlab/AuditEvents::Instance::AmazonS3Configuration/1"`.
"""
scalar AuditEventsInstanceAmazonS3ConfigurationID

"""

A `AuditEventsInstanceExternalAuditEventDestinationID` is a global ID. It is encoded as a string.

An example `AuditEventsInstanceExternalAuditEventDestinationID` is: `"gid://gitlab/AuditEvents::InstanceExternalAuditEventDestination/1"`.
"""
scalar AuditEventsInstanceExternalAuditEventDestinationID

"""

A `AuditEventsInstanceGoogleCloudLoggingConfigurationID` is a global ID. It is encoded as a string.

An example `AuditEventsInstanceGoogleCloudLoggingConfigurationID` is: `"gid://gitlab/AuditEvents::Instance::GoogleCloudLoggingConfiguration/1"`.
"""
scalar AuditEventsInstanceGoogleCloudLoggingConfigurationID

"""

A `AuditEventsStreamingHTTPNamespaceFilterID` is a global ID. It is encoded as a string.

An example `AuditEventsStreamingHTTPNamespaceFilterID` is: `"gid://gitlab/AuditEvents::Streaming::HTTP::NamespaceFilter/1"`.
"""
scalar AuditEventsStreamingHTTPNamespaceFilterID

"""

A `AuditEventsStreamingHeaderID` is a global ID. It is encoded as a string.

An example `AuditEventsStreamingHeaderID` is: `"gid://gitlab/AuditEvents::Streaming::Header/1"`.
"""
scalar AuditEventsStreamingHeaderID

"""

A `AuditEventsStreamingInstanceHeaderID` is a global ID. It is encoded as a string.

An example `AuditEventsStreamingInstanceHeaderID` is: `"gid://gitlab/AuditEvents::Streaming::InstanceHeader/1"`.
"""
scalar AuditEventsStreamingInstanceHeaderID

"""

A `AwardableID` is a global ID. It is encoded as a string.

An example `AwardableID` is: `"gid://gitlab/Awardable/1"`.
"""
scalar AwardableID

"Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."
scalar BigInt

"""

A `BoardID` is a global ID. It is encoded as a string.

An example `BoardID` is: `"gid://gitlab/Board/1"`.
"""
scalar BoardID

"""

A `BoardsEpicBoardID` is a global ID. It is encoded as a string.

An example `BoardsEpicBoardID` is: `"gid://gitlab/Boards::EpicBoard/1"`.
"""
scalar BoardsEpicBoardID

"""

A `BoardsEpicListID` is a global ID. It is encoded as a string.

An example `BoardsEpicListID` is: `"gid://gitlab/Boards::EpicList/1"`.
"""
scalar BoardsEpicListID

"""

A `CiBuildID` is a global ID. It is encoded as a string.

An example `CiBuildID` is: `"gid://gitlab/Ci::Build/1"`.
"""
scalar CiBuildID

"""

A `CiCatalogResourceID` is a global ID. It is encoded as a string.

An example `CiCatalogResourceID` is: `"gid://gitlab/Ci::Catalog::Resource/1"`.
"""
scalar CiCatalogResourceID

"""

A `CiCatalogResourcesComponentID` is a global ID. It is encoded as a string.

An example `CiCatalogResourcesComponentID` is: `"gid://gitlab/Ci::Catalog::Resources::Component/1"`.
"""
scalar CiCatalogResourcesComponentID

"""

A `CiCatalogResourcesVersionID` is a global ID. It is encoded as a string.

An example `CiCatalogResourcesVersionID` is: `"gid://gitlab/Ci::Catalog::Resources::Version/1"`.
"""
scalar CiCatalogResourcesVersionID

"""

A `CiJobArtifactID` is a global ID. It is encoded as a string.

An example `CiJobArtifactID` is: `"gid://gitlab/Ci::JobArtifact/1"`.
"""
scalar CiJobArtifactID

"""

A `CiPipelineID` is a global ID. It is encoded as a string.

An example `CiPipelineID` is: `"gid://gitlab/Ci::Pipeline/1"`.
"""
scalar CiPipelineID

"""

A `CiPipelineScheduleID` is a global ID. It is encoded as a string.

An example `CiPipelineScheduleID` is: `"gid://gitlab/Ci::PipelineSchedule/1"`.
"""
scalar CiPipelineScheduleID

"""

A `CiPipelineScheduleVariableID` is a global ID. It is encoded as a string.

An example `CiPipelineScheduleVariableID` is: `"gid://gitlab/Ci::PipelineScheduleVariable/1"`.
"""
scalar CiPipelineScheduleVariableID

"""

A `CiProcessableID` is a global ID. It is encoded as a string.

An example `CiProcessableID` is: `"gid://gitlab/Ci::Processable/1"`.
"""
scalar CiProcessableID

"""

A `CiRunnerID` is a global ID. It is encoded as a string.

An example `CiRunnerID` is: `"gid://gitlab/Ci::Runner/1"`.
"""
scalar CiRunnerID

"""

A `CiRunnerManagerID` is a global ID. It is encoded as a string.

An example `CiRunnerManagerID` is: `"gid://gitlab/Ci::RunnerManager/1"`.
"""
scalar CiRunnerManagerID

"""

A `CiStageID` is a global ID. It is encoded as a string.

An example `CiStageID` is: `"gid://gitlab/Ci::Stage/1"`.
"""
scalar CiStageID

"""

A `CiSubscriptionsProjectID` is a global ID. It is encoded as a string.

An example `CiSubscriptionsProjectID` is: `"gid://gitlab/Ci::Subscriptions::Project/1"`.
"""
scalar CiSubscriptionsProjectID

"""

A `CiTriggerID` is a global ID. It is encoded as a string.

An example `CiTriggerID` is: `"gid://gitlab/Ci::Trigger/1"`.
"""
scalar CiTriggerID

"""

A `ClustersAgentID` is a global ID. It is encoded as a string.

An example `ClustersAgentID` is: `"gid://gitlab/Clusters::Agent/1"`.
"""
scalar ClustersAgentID

"""

A `ClustersAgentTokenID` is a global ID. It is encoded as a string.

An example `ClustersAgentTokenID` is: `"gid://gitlab/Clusters::AgentToken/1"`.
"""
scalar ClustersAgentTokenID

"""

A `ClustersClusterID` is a global ID. It is encoded as a string.

An example `ClustersClusterID` is: `"gid://gitlab/Clusters::Cluster/1"`.
"""
scalar ClustersClusterID

"""

Color represented as a hex code or named color.

For example: "#fefefe".
"""
scalar Color

"""

A `ComplianceManagementFrameworkID` is a global ID. It is encoded as a string.

An example `ComplianceManagementFrameworkID` is: `"gid://gitlab/ComplianceManagement::Framework/1"`.
"""
scalar ComplianceManagementFrameworkID

"""

A `ContainerRegistryProtectionRuleID` is a global ID. It is encoded as a string.

An example `ContainerRegistryProtectionRuleID` is: `"gid://gitlab/ContainerRegistry::Protection::Rule/1"`.
"""
scalar ContainerRegistryProtectionRuleID

"""

A `ContainerRepositoryID` is a global ID. It is encoded as a string.

An example `ContainerRepositoryID` is: `"gid://gitlab/ContainerRepository/1"`.
"""
scalar ContainerRepositoryID

"""

A `CustomEmojiID` is a global ID. It is encoded as a string.

An example `CustomEmojiID` is: `"gid://gitlab/CustomEmoji/1"`.
"""
scalar CustomEmojiID

"""

A `CustomerRelationsContactID` is a global ID. It is encoded as a string.

An example `CustomerRelationsContactID` is: `"gid://gitlab/CustomerRelations::Contact/1"`.
"""
scalar CustomerRelationsContactID

"""

A `CustomerRelationsOrganizationID` is a global ID. It is encoded as a string.

An example `CustomerRelationsOrganizationID` is: `"gid://gitlab/CustomerRelations::Organization/1"`.
"""
scalar CustomerRelationsOrganizationID

"""

A `DastProfileID` is a global ID. It is encoded as a string.

An example `DastProfileID` is: `"gid://gitlab/Dast::Profile/1"`.
"""
scalar DastProfileID

"""

A `DastProfileScheduleID` is a global ID. It is encoded as a string.

An example `DastProfileScheduleID` is: `"gid://gitlab/Dast::ProfileSchedule/1"`.
"""
scalar DastProfileScheduleID

"""

A `DastScannerProfileID` is a global ID. It is encoded as a string.

An example `DastScannerProfileID` is: `"gid://gitlab/DastScannerProfile/1"`.
"""
scalar DastScannerProfileID

"""

A `DastSiteProfileID` is a global ID. It is encoded as a string.

An example `DastSiteProfileID` is: `"gid://gitlab/DastSiteProfile/1"`.
"""
scalar DastSiteProfileID

"""

A `DastSiteTokenID` is a global ID. It is encoded as a string.

An example `DastSiteTokenID` is: `"gid://gitlab/DastSiteToken/1"`.
"""
scalar DastSiteTokenID

"""

A `DastSiteValidationID` is a global ID. It is encoded as a string.

An example `DastSiteValidationID` is: `"gid://gitlab/DastSiteValidation/1"`.
"""
scalar DastSiteValidationID

"Date represented in ISO 8601"
scalar Date

"""

A `DependencyProxyManifestID` is a global ID. It is encoded as a string.

An example `DependencyProxyManifestID` is: `"gid://gitlab/DependencyProxy::Manifest/1"`.
"""
scalar DependencyProxyManifestID

"""

A `DeploymentID` is a global ID. It is encoded as a string.

An example `DeploymentID` is: `"gid://gitlab/Deployment/1"`.
"""
scalar DeploymentID

"""

A `DescriptionVersionID` is a global ID. It is encoded as a string.

An example `DescriptionVersionID` is: `"gid://gitlab/DescriptionVersion/1"`.
"""
scalar DescriptionVersionID

"""

A `DesignManagementDesignAtVersionID` is a global ID. It is encoded as a string.

An example `DesignManagementDesignAtVersionID` is: `"gid://gitlab/DesignManagement::DesignAtVersion/1"`.
"""
scalar DesignManagementDesignAtVersionID

"""

A `DesignManagementDesignID` is a global ID. It is encoded as a string.

An example `DesignManagementDesignID` is: `"gid://gitlab/DesignManagement::Design/1"`.
"""
scalar DesignManagementDesignID

"""

A `DesignManagementVersionID` is a global ID. It is encoded as a string.

An example `DesignManagementVersionID` is: `"gid://gitlab/DesignManagement::Version/1"`.
"""
scalar DesignManagementVersionID

"""

A `DiffNoteID` is a global ID. It is encoded as a string.

An example `DiffNoteID` is: `"gid://gitlab/DiffNote/1"`.
"""
scalar DiffNoteID

"""

A `DiscussionID` is a global ID. It is encoded as a string.

An example `DiscussionID` is: `"gid://gitlab/Discussion/1"`.
"""
scalar DiscussionID

"""

Duration between two instants, represented as a fractional number of seconds.

For example: 12.3334
"""
scalar Duration

"""

A `EmailID` is a global ID. It is encoded as a string.

An example `EmailID` is: `"gid://gitlab/Email/1"`.
"""
scalar EmailID

"""

A `EnvironmentID` is a global ID. It is encoded as a string.

An example `EnvironmentID` is: `"gid://gitlab/Environment/1"`.
"""
scalar EnvironmentID

"""

A `EpicID` is a global ID. It is encoded as a string.

An example `EpicID` is: `"gid://gitlab/Epic/1"`.
"""
scalar EpicID

"""

A `EpicTreeSortingID` is a global ID. It is encoded as a string.

An example `EpicTreeSortingID` is: `"gid://gitlab/EpicTreeSorting/1"`.
"""
scalar EpicTreeSortingID

"""

A `GeoBaseRegistryID` is a global ID. It is encoded as a string.

An example `GeoBaseRegistryID` is: `"gid://gitlab/Geo::BaseRegistry/1"`.
"""
scalar GeoBaseRegistryID

"""

A `GitlabErrorTrackingDetailedErrorID` is a global ID. It is encoded as a string.

An example `GitlabErrorTrackingDetailedErrorID` is: `"gid://gitlab/Gitlab::ErrorTracking::DetailedError/1"`.
"""
scalar GitlabErrorTrackingDetailedErrorID

"""

A `GitlabSubscriptionsAddOnPurchaseID` is a global ID. It is encoded as a string.

An example `GitlabSubscriptionsAddOnPurchaseID` is: `"gid://gitlab/GitlabSubscriptions::AddOnPurchase/1"`.
"""
scalar GitlabSubscriptionsAddOnPurchaseID

"""

A global identifier.

A global identifier represents an object uniquely across the application.
An example of a global identifier is `"gid://gitlab/User/1"`.

`gid://gitlab` stands for the root name.
`User` is the name of the ActiveRecord class of the record.
`1` is the record id as per the id in the db table.

Global identifiers are encoded as strings.
"""
scalar GlobalID

"""

A `GroupID` is a global ID. It is encoded as a string.

An example `GroupID` is: `"gid://gitlab/Group/1"`.
"""
scalar GroupID

"An ISO 8601-encoded date"
scalar ISO8601Date

"""

A `IncidentManagementEscalationPolicyID` is a global ID. It is encoded as a string.

An example `IncidentManagementEscalationPolicyID` is: `"gid://gitlab/IncidentManagement::EscalationPolicy/1"`.
"""
scalar IncidentManagementEscalationPolicyID

"""

A `IncidentManagementEscalationRuleID` is a global ID. It is encoded as a string.

An example `IncidentManagementEscalationRuleID` is: `"gid://gitlab/IncidentManagement::EscalationRule/1"`.
"""
scalar IncidentManagementEscalationRuleID

"""

A `IncidentManagementIssuableResourceLinkID` is a global ID. It is encoded as a string.

An example `IncidentManagementIssuableResourceLinkID` is: `"gid://gitlab/IncidentManagement::IssuableResourceLink/1"`.
"""
scalar IncidentManagementIssuableResourceLinkID

"""

A `IncidentManagementOncallParticipantID` is a global ID. It is encoded as a string.

An example `IncidentManagementOncallParticipantID` is: `"gid://gitlab/IncidentManagement::OncallParticipant/1"`.
"""
scalar IncidentManagementOncallParticipantID

"""

A `IncidentManagementOncallRotationID` is a global ID. It is encoded as a string.

An example `IncidentManagementOncallRotationID` is: `"gid://gitlab/IncidentManagement::OncallRotation/1"`.
"""
scalar IncidentManagementOncallRotationID

"""

A `IncidentManagementTimelineEventID` is a global ID. It is encoded as a string.

An example `IncidentManagementTimelineEventID` is: `"gid://gitlab/IncidentManagement::TimelineEvent/1"`.
"""
scalar IncidentManagementTimelineEventID

"""

A `IncidentManagementTimelineEventTagID` is a global ID. It is encoded as a string.

An example `IncidentManagementTimelineEventTagID` is: `"gid://gitlab/IncidentManagement::TimelineEventTag/1"`.
"""
scalar IncidentManagementTimelineEventTagID

"""

A `IntegrationsPrometheusID` is a global ID. It is encoded as a string.

An example `IntegrationsPrometheusID` is: `"gid://gitlab/Integrations::Prometheus/1"`.
The older format `"gid://gitlab/PrometheusService/1"` was deprecated in 14.1.
"""
scalar IntegrationsPrometheusID

"""

A `IssuableID` is a global ID. It is encoded as a string.

An example `IssuableID` is: `"gid://gitlab/Issuable/1"`.
"""
scalar IssuableID

"""

A `IssueID` is a global ID. It is encoded as a string.

An example `IssueID` is: `"gid://gitlab/Issue/1"`.
"""
scalar IssueID

"""

A `IssueParentID` is a global ID. It is encoded as a string.

An example `IssueParentID` is: `"gid://gitlab/IssueParent/1"`.
"""
scalar IssueParentID

"""

A `IterationID` is a global ID. It is encoded as a string.

An example `IterationID` is: `"gid://gitlab/Iteration/1"`.
The older format `"gid://gitlab/EEIteration/1"` was deprecated in 13.3.
"""
scalar IterationID

"""

A `IterationsCadenceID` is a global ID. It is encoded as a string.

An example `IterationsCadenceID` is: `"gid://gitlab/Iterations::Cadence/1"`.
"""
scalar IterationsCadenceID

"Represents untyped JSON"
scalar JSON

"""

A `CommitStatusID` is a global ID. It is encoded as a string.

An example `CommitStatusID` is: `"gid://gitlab/CommitStatus/1"`.
"""
scalar JobID

"JSON object as raw string"
scalar JsonString

"""

A `LabelID` is a global ID. It is encoded as a string.

An example `LabelID` is: `"gid://gitlab/Label/1"`.
"""
scalar LabelID

"""

A `ListID` is a global ID. It is encoded as a string.

An example `ListID` is: `"gid://gitlab/List/1"`.
"""
scalar ListID

"""

A `MemberRoleID` is a global ID. It is encoded as a string.

An example `MemberRoleID` is: `"gid://gitlab/MemberRole/1"`.
"""
scalar MemberRoleID

"""

A `MergeRequestID` is a global ID. It is encoded as a string.

An example `MergeRequestID` is: `"gid://gitlab/MergeRequest/1"`.
"""
scalar MergeRequestID

"""

A `MilestoneID` is a global ID. It is encoded as a string.

An example `MilestoneID` is: `"gid://gitlab/Milestone/1"`.
"""
scalar MilestoneID

"""

A `MlCandidateID` is a global ID. It is encoded as a string.

An example `MlCandidateID` is: `"gid://gitlab/Ml::Candidate/1"`.
"""
scalar MlCandidateID

"""

A `MlModelID` is a global ID. It is encoded as a string.

An example `MlModelID` is: `"gid://gitlab/Ml::Model/1"`.
"""
scalar MlModelID

"""

A `MlModelVersionID` is a global ID. It is encoded as a string.

An example `MlModelVersionID` is: `"gid://gitlab/Ml::ModelVersion/1"`.
"""
scalar MlModelVersionID

"""

A `NamespaceID` is a global ID. It is encoded as a string.

An example `NamespaceID` is: `"gid://gitlab/Namespace/1"`.
"""
scalar NamespaceID

"""

A `NamespacesNamespaceBanID` is a global ID. It is encoded as a string.

An example `NamespacesNamespaceBanID` is: `"gid://gitlab/Namespaces::NamespaceBan/1"`.
"""
scalar NamespacesNamespaceBanID

"""

A `NoteID` is a global ID. It is encoded as a string.

An example `NoteID` is: `"gid://gitlab/Note/1"`.
"""
scalar NoteID

"""

A `NoteableID` is a global ID. It is encoded as a string.

An example `NoteableID` is: `"gid://gitlab/Noteable/1"`.
"""
scalar NoteableID

"""

A `OrganizationsOrganizationID` is a global ID. It is encoded as a string.

An example `OrganizationsOrganizationID` is: `"gid://gitlab/Organizations::Organization/1"`.
"""
scalar OrganizationsOrganizationID

"""

A `PackagesConanFileMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesConanFileMetadatumID` is: `"gid://gitlab/Packages::Conan::FileMetadatum/1"`.
"""
scalar PackagesConanFileMetadatumID

"""

A `PackagesConanMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesConanMetadatumID` is: `"gid://gitlab/Packages::Conan::Metadatum/1"`.
"""
scalar PackagesConanMetadatumID

"""

A `PackagesDependencyID` is a global ID. It is encoded as a string.

An example `PackagesDependencyID` is: `"gid://gitlab/Packages::Dependency/1"`.
"""
scalar PackagesDependencyID

"""

A `PackagesDependencyLinkID` is a global ID. It is encoded as a string.

An example `PackagesDependencyLinkID` is: `"gid://gitlab/Packages::DependencyLink/1"`.
"""
scalar PackagesDependencyLinkID

"""

A `PackagesMavenMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesMavenMetadatumID` is: `"gid://gitlab/Packages::Maven::Metadatum/1"`.
"""
scalar PackagesMavenMetadatumID

"""

A `PackagesNugetDependencyLinkMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesNugetDependencyLinkMetadatumID` is: `"gid://gitlab/Packages::Nuget::DependencyLinkMetadatum/1"`.
"""
scalar PackagesNugetDependencyLinkMetadatumID

"""

A `PackagesNugetMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesNugetMetadatumID` is: `"gid://gitlab/Packages::Nuget::Metadatum/1"`.
"""
scalar PackagesNugetMetadatumID

"""

A `PackagesPackageFileID` is a global ID. It is encoded as a string.

An example `PackagesPackageFileID` is: `"gid://gitlab/Packages::PackageFile/1"`.
"""
scalar PackagesPackageFileID

"""

A `PackagesPackageID` is a global ID. It is encoded as a string.

An example `PackagesPackageID` is: `"gid://gitlab/Packages::Package/1"`.
"""
scalar PackagesPackageID

"""

A `PackagesProtectionRuleID` is a global ID. It is encoded as a string.

An example `PackagesProtectionRuleID` is: `"gid://gitlab/Packages::Protection::Rule/1"`.
"""
scalar PackagesProtectionRuleID

"""

A `PackagesPypiMetadatumID` is a global ID. It is encoded as a string.

An example `PackagesPypiMetadatumID` is: `"gid://gitlab/Packages::Pypi::Metadatum/1"`.
"""
scalar PackagesPypiMetadatumID

"""

A `PathLockID` is a global ID. It is encoded as a string.

An example `PathLockID` is: `"gid://gitlab/PathLock/1"`.
"""
scalar PathLockID

"String or integer."
scalar PayloadAlertFieldPathSegment

"""

A `ProjectID` is a global ID. It is encoded as a string.

An example `ProjectID` is: `"gid://gitlab/Project/1"`.
"""
scalar ProjectID

"""

A `ProjectImportStateID` is a global ID. It is encoded as a string.

An example `ProjectImportStateID` is: `"gid://gitlab/ProjectImportState/1"`.
"""
scalar ProjectImportStateID

"""

A `ProtectedBranchID` is a global ID. It is encoded as a string.

An example `ProtectedBranchID` is: `"gid://gitlab/ProtectedBranch/1"`.
"""
scalar ProtectedBranchID

"""

A `ReleaseID` is a global ID. It is encoded as a string.

An example `ReleaseID` is: `"gid://gitlab/Release/1"`.
"""
scalar ReleaseID

"""

A `ReleasesLinkID` is a global ID. It is encoded as a string.

An example `ReleasesLinkID` is: `"gid://gitlab/Releases::Link/1"`.
"""
scalar ReleasesLinkID

"""

A `RemoteDevelopmentWorkspaceID` is a global ID. It is encoded as a string.

An example `RemoteDevelopmentWorkspaceID` is: `"gid://gitlab/RemoteDevelopment::Workspace/1"`.
"""
scalar RemoteDevelopmentWorkspaceID

"""

A `SecurityTrainingProviderID` is a global ID. It is encoded as a string.

An example `SecurityTrainingProviderID` is: `"gid://gitlab/Security::TrainingProvider/1"`.
"""
scalar SecurityTrainingProviderID

"""

A `SnippetID` is a global ID. It is encoded as a string.

An example `SnippetID` is: `"gid://gitlab/Snippet/1"`.
"""
scalar SnippetID

"""

A `SystemNoteMetadataID` is a global ID. It is encoded as a string.

An example `SystemNoteMetadataID` is: `"gid://gitlab/SystemNoteMetadata/1"`.
"""
scalar SystemNoteMetadataID

"""

A `TerraformStateID` is a global ID. It is encoded as a string.

An example `TerraformStateID` is: `"gid://gitlab/Terraform::State/1"`.
"""
scalar TerraformStateID

"""

Time represented in ISO 8601.

For example: "2021-03-09T14:58:50+00:00".

See `https://www.iso.org/iso-8601-date-and-time-format.html`.
"""
scalar Time

"""

A `TimelogID` is a global ID. It is encoded as a string.

An example `TimelogID` is: `"gid://gitlab/Timelog/1"`.
"""
scalar TimelogID

"""

A `TodoID` is a global ID. It is encoded as a string.

An example `TodoID` is: `"gid://gitlab/Todo/1"`.
"""
scalar TodoID

"""

A `TodoableID` is a global ID. It is encoded as a string.

An example `TodoableID` is: `"gid://gitlab/Todoable/1"`.
"""
scalar TodoableID

"A regexp containing patterns sourced from user input"
scalar UntrustedRegexp

scalar Upload

"""

A `UploadID` is a global ID. It is encoded as a string.

An example `UploadID` is: `"gid://gitlab/Upload/1"`.
"""
scalar UploadID

"""

A `UserID` is a global ID. It is encoded as a string.

An example `UserID` is: `"gid://gitlab/User/1"`.
"""
scalar UserID

"""

A `UsersSavedReplyID` is a global ID. It is encoded as a string.

An example `UsersSavedReplyID` is: `"gid://gitlab/Users::SavedReply/1"`.
"""
scalar UsersSavedReplyID

"""

A `VulnerabilitiesExternalIssueLinkID` is a global ID. It is encoded as a string.

An example `VulnerabilitiesExternalIssueLinkID` is: `"gid://gitlab/Vulnerabilities::ExternalIssueLink/1"`.
"""
scalar VulnerabilitiesExternalIssueLinkID

"""

A `VulnerabilitiesScannerID` is a global ID. It is encoded as a string.

An example `VulnerabilitiesScannerID` is: `"gid://gitlab/Vulnerabilities::Scanner/1"`.
"""
scalar VulnerabilitiesScannerID

"""

A `VulnerabilityID` is a global ID. It is encoded as a string.

An example `VulnerabilityID` is: `"gid://gitlab/Vulnerability/1"`.
"""
scalar VulnerabilityID

"""

A `WorkItemID` is a global ID. It is encoded as a string.

An example `WorkItemID` is: `"gid://gitlab/WorkItem/1"`.

While we transition from Issues into Work Items this type will temporarily support
`IssueID` like: `"gid://gitlab/Issue/1"`. This behavior will be removed without notice in the future.
"""
scalar WorkItemID

"""

A `WorkItemsRelatedWorkItemLinkID` is a global ID. It is encoded as a string.

An example `WorkItemsRelatedWorkItemLinkID` is: `"gid://gitlab/WorkItems::RelatedWorkItemLink/1"`.
"""
scalar WorkItemsRelatedWorkItemLinkID

"""

A `WorkItemsTypeID` is a global ID. It is encoded as a string.

An example `WorkItemsTypeID` is: `"gid://gitlab/WorkItems::Type/1"`.
"""
scalar WorkItemsTypeID

"Autogenerated input type of AbuseReportLabelCreate"
input AbuseReportLabelCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  """

  The color of the label given in 6-digit hex notation with leading '#' sign
  (for example, `#FFAABB`) or one of the CSS color names.
  """
  color: String = "#6699cc"
  "Title of the label."
  title: String!
}

"Autogenerated input type of AchievementsAward"
input AchievementsAwardInput {
  "Global ID of the achievement being awarded."
  achievementId: AchievementsAchievementID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the user being awarded the achievement."
  userId: UserID!
}

"Autogenerated input type of AchievementsCreate"
input AchievementsCreateInput {
  "Avatar for the achievement."
  avatar: Upload
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of or notes for the achievement."
  description: String
  "Name for the achievement."
  name: String!
  "Namespace for the achievement."
  namespaceId: NamespaceID!
}

"Autogenerated input type of AchievementsDelete"
input AchievementsDeleteInput {
  "Global ID of the achievement being deleted."
  achievementId: AchievementsAchievementID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}

"Autogenerated input type of AchievementsRevoke"
input AchievementsRevokeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the user achievement being revoked."
  userAchievementId: AchievementsUserAchievementID!
}

"Autogenerated input type of AchievementsUpdate"
input AchievementsUpdateInput {
  "Global ID of the achievement being updated."
  achievementId: AchievementsAchievementID!
  "Avatar for the achievement."
  avatar: Upload
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of or notes for the achievement."
  description: String
  "Name for the achievement."
  name: String
}

"Autogenerated input type of AddProjectToSecurityDashboard"
input AddProjectToSecurityDashboardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the project to be added to Instance Security Dashboard."
  id: ProjectID!
}

"Autogenerated input type of AdminSidekiqQueuesDeleteJobs"
input AdminSidekiqQueuesDeleteJobsInput {
  "Delete jobs matching ai_resource in the context metadata."
  aiResource: String
  "Delete jobs matching artifact_size in the context metadata."
  artifactSize: String
  "Delete jobs matching artifact_used_cdn in the context metadata."
  artifactUsedCdn: String
  "Delete jobs matching artifacts_dependencies_count in the context metadata."
  artifactsDependenciesCount: String
  "Delete jobs matching artifacts_dependencies_size in the context metadata."
  artifactsDependenciesSize: String
  "Delete jobs matching bulk_import_entity_id in the context metadata."
  bulkImportEntityId: String
  "Delete jobs matching caller_id in the context metadata."
  callerId: String
  "Delete jobs matching client_id in the context metadata."
  clientId: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Delete jobs matching feature_category in the context metadata."
  featureCategory: String
  "Delete jobs matching job_id in the context metadata."
  jobId: String
  "Delete jobs matching merge_action_status in the context metadata."
  mergeActionStatus: String
  "Delete jobs matching pipeline_id in the context metadata."
  pipelineId: String
  "Delete jobs matching project in the context metadata."
  project: String
  "Name of the queue to delete jobs from."
  queueName: String!
  "Delete jobs matching related_class in the context metadata."
  relatedClass: String
  "Delete jobs matching remote_ip in the context metadata."
  remoteIp: String
  "Delete jobs matching root_caller_id in the context metadata."
  rootCallerId: String
  "Delete jobs matching root_namespace in the context metadata."
  rootNamespace: String
  "Delete jobs matching subscription_plan in the context metadata."
  subscriptionPlan: String
  "Delete jobs matching user in the context metadata."
  user: String
  "Delete jobs matching user_id in the context metadata."
  userId: String
  "Delete jobs with the given worker class."
  workerClass: String
}

"Autogenerated input type of AiAction"
input AiActionInput {
  "Input for analyze_ci_job_failure AI action."
  analyzeCiJobFailure: AnalyzeCiJobFailureInput
  "Input for chat AI action."
  chat: AiChatInput
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Client generated ID that can be subscribed to, to receive a response for the mutation."
  clientSubscriptionId: String
  "Input for explain_code AI action."
  explainCode: AiExplainCodeInput
  "Input for explain_vulnerability AI action."
  explainVulnerability: AiExplainVulnerabilityInput
  "Input for fill_in_merge_request_template AI action."
  fillInMergeRequestTemplate: AiFillInMergeRequestTemplateInput
  "Input for generate_commit_message AI action."
  generateCommitMessage: AiGenerateCommitMessageInput
  "Input for generate_description AI action."
  generateDescription: AiGenerateDescriptionInput
  "Input for generate_test_file AI action."
  generateTestFile: GenerateTestFileInput
  "Input for resolve_vulnerability AI action."
  resolveVulnerability: AiResolveVulnerabilityInput
  "Input for summarize_comments AI action."
  summarizeComments: AiSummarizeCommentsInput
  "Input for summarize_review AI action."
  summarizeReview: AiSummarizeReviewInput
}

input AiChatInput {
  "Content of the message."
  content: String!
  "Global ID of the namespace the user is acting on."
  namespaceId: NamespaceID
  "Global ID of the resource to mutate."
  resourceId: AiModelID
}

input AiCurrentFileInput {
  "Content above cursor."
  contentAboveCursor: String
  "Content below cursor."
  contentBelowCursor: String
  "File name."
  fileName: String!
  "Selected text."
  selectedText: String!
}

input AiExplainCodeInput {
  "Code messages that is passed to be explained by AI."
  messages: [AiExplainCodeMessageInput!]!
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

input AiExplainCodeMessageInput {
  "Content of the message."
  content: String!
  "Role of the message (system, user, assistant)."
  role: String!
}

input AiExplainVulnerabilityInput {
  "Include vulnerablility source code in the AI prompt."
  includeSourceCode: Boolean
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

input AiFillInMergeRequestTemplateInput {
  "Template content to fill in."
  content: String!
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
  "Source branch of the changes."
  sourceBranch: String!
  "ID of the project where the changes are from."
  sourceProjectId: ID
  "Target branch of where the changes will be merged into."
  targetBranch: String!
  "Title of the merge request to be created."
  title: String!
}

input AiGenerateCommitMessageInput {
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

input AiGenerateDescriptionInput {
  "Content of the message."
  content: String!
  "Name of the description template to use to generate message off of."
  descriptionTemplateName: String
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

input AiResolveVulnerabilityInput {
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

input AiSummarizeCommentsInput {
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

input AiSummarizeReviewInput {
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

"Field that are available while modifying the custom mapping attributes for an HTTP integration"
input AlertManagementPayloadAlertFieldInput {
  "GitLab alert field name."
  fieldName: AlertManagementPayloadAlertFieldName!
  "Human-readable label of the payload path."
  label: String
  "Path to value inside payload JSON."
  path: [PayloadAlertFieldPathSegment!]!
  "Type of the parsed value."
  type: AlertManagementPayloadAlertFieldType!
}

"Autogenerated input type of AlertSetAssignees"
input AlertSetAssigneesInput {
  "Usernames to assign to the alert. Replaces existing assignees by default."
  assigneeUsernames: [String!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the alert to mutate."
  iid: String!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode
  "Project the alert to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of AlertTodoCreate"
input AlertTodoCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the alert to mutate."
  iid: String!
  "Project the alert to mutate is in."
  projectPath: ID!
}

input AnalyzeCiJobFailureInput {
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

"Autogenerated input type of ApproveDeployment"
input ApproveDeploymentInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment to go with the approval."
  comment: String
  "ID of the deployment."
  id: DeploymentID!
  "Name of the User/Group/Role to use for the approval, when the user belongs to multiple approval rules."
  representedAs: String
  "Status of the approval (either `APPROVED` or `REJECTED`)."
  status: DeploymentsApprovalStatus!
}

"Autogenerated input type of ArtifactDestroy"
input ArtifactDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the artifact to delete."
  id: CiJobArtifactID!
}

"Autogenerated input type of AuditEventsAmazonS3ConfigurationCreate"
input AuditEventsAmazonS3ConfigurationCreateInput {
  "Access key ID of the Amazon S3 account."
  accessKeyXid: String!
  "AWS region where the bucket is created."
  awsRegion: String!
  "Name of the bucket where the audit events would be logged."
  bucketName: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group path."
  groupPath: ID!
  "Destination name."
  name: String
  "Secret access key of the Amazon S3 account."
  secretAccessKey: String!
}

"Autogenerated input type of AuditEventsAmazonS3ConfigurationDelete"
input AuditEventsAmazonS3ConfigurationDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Amazon S3 configuration to destroy."
  id: AuditEventsAmazonS3ConfigurationID!
}

"Autogenerated input type of AuditEventsAmazonS3ConfigurationUpdate"
input AuditEventsAmazonS3ConfigurationUpdateInput {
  "Access key ID of the Amazon S3 account."
  accessKeyXid: String
  "AWS region where the bucket is created."
  awsRegion: String
  "Name of the bucket where the audit events would be logged."
  bucketName: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Amazon S3 configuration to update."
  id: AuditEventsAmazonS3ConfigurationID!
  "Destination name."
  name: String
  "Secret access key of the Amazon S3 account."
  secretAccessKey: String
}

"Autogenerated input type of AuditEventsInstanceAmazonS3ConfigurationCreate"
input AuditEventsInstanceAmazonS3ConfigurationCreateInput {
  "Access key ID of the Amazon S3 account."
  accessKeyXid: String!
  "AWS region where the bucket is created."
  awsRegion: String!
  "Name of the bucket where the audit events would be logged."
  bucketName: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination name."
  name: String
  "Secret access key of the Amazon S3 account."
  secretAccessKey: String!
}

"Autogenerated input type of AuditEventsInstanceAmazonS3ConfigurationDelete"
input AuditEventsInstanceAmazonS3ConfigurationDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the instance-level Amazon S3 configuration to delete."
  id: AuditEventsInstanceAmazonS3ConfigurationID!
}

"Autogenerated input type of AuditEventsInstanceAmazonS3ConfigurationUpdate"
input AuditEventsInstanceAmazonS3ConfigurationUpdateInput {
  "Access key ID of the Amazon S3 account."
  accessKeyXid: String
  "AWS region where the bucket is created."
  awsRegion: String
  "Name of the bucket where the audit events would be logged."
  bucketName: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the instance-level Amazon S3 configuration to update."
  id: AuditEventsInstanceAmazonS3ConfigurationID!
  "Destination name."
  name: String
  "Secret access key of the Amazon S3 account."
  secretAccessKey: String
}

"Autogenerated input type of AuditEventsStreamingDestinationEventsAdd"
input AuditEventsStreamingDestinationEventsAddInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination id."
  destinationId: AuditEventsExternalAuditEventDestinationID!
  "List of event type filters to add for streaming."
  eventTypeFilters: [String!]!
}

"Autogenerated input type of AuditEventsStreamingDestinationEventsRemove"
input AuditEventsStreamingDestinationEventsRemoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination id."
  destinationId: AuditEventsExternalAuditEventDestinationID!
  "List of event type filters to remove from streaming."
  eventTypeFilters: [String!]!
}

"Autogenerated input type of AuditEventsStreamingDestinationInstanceEventsAdd"
input AuditEventsStreamingDestinationInstanceEventsAddInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination id."
  destinationId: AuditEventsInstanceExternalAuditEventDestinationID!
  "List of event type filters to add for streaming."
  eventTypeFilters: [String!]!
}

"Autogenerated input type of AuditEventsStreamingDestinationInstanceEventsRemove"
input AuditEventsStreamingDestinationInstanceEventsRemoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination id."
  destinationId: AuditEventsInstanceExternalAuditEventDestinationID!
  "List of event type filters to remove from streaming."
  eventTypeFilters: [String!]!
}

"Autogenerated input type of AuditEventsStreamingHTTPNamespaceFiltersAdd"
input AuditEventsStreamingHTTPNamespaceFiltersAddInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination ID."
  destinationId: AuditEventsExternalAuditEventDestinationID!
  "Full path of the group."
  groupPath: ID
  "Full path of the project."
  projectPath: ID
}

"Autogenerated input type of AuditEventsStreamingHTTPNamespaceFiltersDelete"
input AuditEventsStreamingHTTPNamespaceFiltersDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Namespace filter ID."
  namespaceFilterId: AuditEventsStreamingHTTPNamespaceFilterID!
}

"Autogenerated input type of AuditEventsStreamingHeadersCreate"
input AuditEventsStreamingHeadersCreateInput {
  "Boolean option determining whether header is active or not."
  active: Boolean = true
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination to associate header with."
  destinationId: AuditEventsExternalAuditEventDestinationID!
  "Header key."
  key: String!
  "Header value."
  value: String!
}

"Autogenerated input type of AuditEventsStreamingHeadersDestroy"
input AuditEventsStreamingHeadersDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Header to delete."
  headerId: AuditEventsStreamingHeaderID!
}

"Autogenerated input type of AuditEventsStreamingHeadersUpdate"
input AuditEventsStreamingHeadersUpdateInput {
  "Boolean option determining whether header is active or not."
  active: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Header to update."
  headerId: AuditEventsStreamingHeaderID!
  "Header key."
  key: String
  "Header value."
  value: String
}

"Autogenerated input type of AuditEventsStreamingInstanceHeadersCreate"
input AuditEventsStreamingInstanceHeadersCreateInput {
  "Boolean option determining whether header is active or not."
  active: Boolean = true
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Instance level external destination to associate header with."
  destinationId: AuditEventsInstanceExternalAuditEventDestinationID!
  "Header key."
  key: String!
  "Header value."
  value: String!
}

"Autogenerated input type of AuditEventsStreamingInstanceHeadersDestroy"
input AuditEventsStreamingInstanceHeadersDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Header to delete."
  headerId: AuditEventsStreamingInstanceHeaderID!
}

"Autogenerated input type of AuditEventsStreamingInstanceHeadersUpdate"
input AuditEventsStreamingInstanceHeadersUpdateInput {
  "Boolean option determining whether header is active or not."
  active: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Header to update."
  headerId: AuditEventsStreamingInstanceHeaderID!
  "Header key."
  key: String
  "Header value."
  value: String
}

"Autogenerated input type of AwardEmojiAdd"
input AwardEmojiAddInput {
  "Global ID of the awardable resource."
  awardableId: AwardableID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Emoji name."
  name: String!
}

"Autogenerated input type of AwardEmojiRemove"
input AwardEmojiRemoveInput {
  "Global ID of the awardable resource."
  awardableId: AwardableID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Emoji name."
  name: String!
}

"Autogenerated input type of AwardEmojiToggle"
input AwardEmojiToggleInput {
  "Global ID of the awardable resource."
  awardableId: AwardableID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Emoji name."
  name: String!
}

"Autogenerated input type of BoardEpicCreate"
input BoardEpicCreateInput {
  "Global ID of the board that the epic is in."
  boardId: BoardsEpicBoardID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group the epic to create is in."
  groupPath: ID!
  "Global ID of the epic board list in which epic will be created."
  listId: BoardsEpicListID!
  "Title of the epic."
  title: String!
}

input BoardIssueInput {
  "Filter by assignee username."
  assigneeUsername: [String]
  "Filter by assignee wildcard. Incompatible with assigneeUsername and assigneeUsernames."
  assigneeWildcardId: AssigneeWildcardId
  "Filter by author username."
  authorUsername: String
  "Filter by confidentiality."
  confidential: Boolean
  "Filter by epic ID. Incompatible with epicWildcardId."
  epicId: EpicID
  "Filter by epic ID wildcard. Incompatible with epicId."
  epicWildcardId: EpicWildcardId
  "Health status of the issue, \"none\" and \"any\" values are supported."
  healthStatusFilter: HealthStatusFilter
  "List of IIDs of issues. For example `[\"1\", \"2\"]`."
  iids: [String!]
  "Filter by a list of iteration cadence IDs."
  iterationCadenceId: [IterationsCadenceID!]
  "Filter by a list of iteration IDs. Incompatible with iterationWildcardId."
  iterationId: [IterationID!]
  "Filter by iteration title."
  iterationTitle: String
  "Filter by iteration ID wildcard."
  iterationWildcardId: IterationWildcardId
  "Filter by label name."
  labelName: [String]
  "Filter by milestone title."
  milestoneTitle: String
  "Filter by milestone ID wildcard."
  milestoneWildcardId: MilestoneWildcardId
  "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
  myReactionEmoji: String
  "List of negated arguments."
  not: NegatedBoardIssueInput
  "List of arguments with inclusive OR."
  or: UnionedIssueFilterInput
  "Filter by release tag."
  releaseTag: String
  "Search query for issue title or description."
  search: String
  "Filter by the given issue types."
  types: [IssueType!]
  "Filter by weight."
  weight: String
  "Filter by weight ID wildcard. Incompatible with weight."
  weightWildcardId: WeightWildcardId
}

"Autogenerated input type of BoardListCreate"
input BoardListCreateInput {
  "Global ID of an existing user."
  assigneeId: UserID
  "Create the backlog list."
  backlog: Boolean
  "Global ID of the issue board to mutate."
  boardId: BoardID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of an existing iteration."
  iterationId: IterationID
  "Global ID of an existing label."
  labelId: LabelID
  "Global ID of an existing milestone."
  milestoneId: MilestoneID
}

"Autogenerated input type of BoardListUpdateLimitMetrics"
input BoardListUpdateLimitMetricsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "New limit metric type for the list."
  limitMetric: ListLimitMetric
  "Global ID of the list."
  listId: ListID!
  "New maximum issue count limit."
  maxIssueCount: Int
  "New maximum issue weight limit."
  maxIssueWeight: Int
}

"Autogenerated input type of BranchRuleCreate"
input BranchRuleCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Branch name, with wildcards, for the branch rules."
  name: String!
  "Full path to the project that the branch is associated with."
  projectPath: ID!
}

"Autogenerated input type of BranchRuleUpdate"
input BranchRuleUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the protected branch."
  id: ProtectedBranchID!
  "Branch name, with wildcards, for the branch rules."
  name: String!
  "Full path to the project that the branch is associated with."
  projectPath: ID!
}

"Autogenerated input type of BuildForecast"
input BuildForecastInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the context for the forecast to pick an appropriate model."
  contextId: GlobalID!
  "Number of data points to forecast."
  horizon: Int!
  "Type of the forecast."
  type: String!
}

"Autogenerated input type of BulkDestroyJobArtifacts"
input BulkDestroyJobArtifactsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the job artifacts to destroy."
  ids: [CiJobArtifactID!]!
  "Global Project ID of the job artifacts to destroy. Incompatible with projectPath."
  projectId: ProjectID!
}

"Autogenerated input type of BulkEnableDevopsAdoptionNamespaces"
input BulkEnableDevopsAdoptionNamespacesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Display namespace ID."
  displayNamespaceId: NamespaceID
  "List of Namespace IDs."
  namespaceIds: [NamespaceID!]!
}

"Autogenerated input type of BulkRunnerDelete"
input BulkRunnerDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IDs of the runners to delete."
  ids: [CiRunnerID!]
}

"Autogenerated input type of CatalogResourcesCreate"
input CatalogResourcesCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project path belonging to the catalog resource."
  projectPath: ID!
}

"Autogenerated input type of CatalogResourcesDestroy"
input CatalogResourcesDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project path belonging to the catalog resource."
  projectPath: ID!
}

"Autogenerated input type of CiJobTokenScopeAddProject"
input CiJobTokenScopeAddProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project that the CI job token scope belongs to."
  projectPath: ID!
  "Project to be added to the CI job token scope."
  targetProjectPath: ID!
}

"Autogenerated input type of CiJobTokenScopeRemoveProject"
input CiJobTokenScopeRemoveProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Direction of access, which defaults to outbound."
  direction: CiJobTokenScopeDirection
  "Project that the CI job token scope belongs to."
  projectPath: ID!
  "Project to be removed from the CI job token scope."
  targetProjectPath: ID!
}

"Attributes for defining a CI/CD variable."
input CiVariableInput {
  "Name of the variable."
  key: String!
  "Value of the variable."
  value: String!
}

"Autogenerated input type of ClusterAgentDelete"
input ClusterAgentDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the cluster agent that will be deleted."
  id: ClustersAgentID!
}

"Autogenerated input type of ClusterAgentTokenCreate"
input ClusterAgentTokenCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the cluster agent that will be associated with the new token."
  clusterAgentId: ClustersAgentID!
  "Description of the token."
  description: String
  "Name of the token."
  name: String!
}

"Autogenerated input type of ClusterAgentTokenRevoke"
input ClusterAgentTokenRevokeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the agent token that will be revoked."
  id: ClustersAgentTokenID!
}

input CommitAction {
  "Action to perform: create, delete, move, update, or chmod."
  action: CommitActionMode!
  "Content of the file."
  content: String
  "Encoding of the file. Default is text."
  encoding: CommitEncoding
  "Enables/disables the execute flag on the file."
  executeFilemode: Boolean
  "Full path to the file."
  filePath: String!
  "Last known file commit ID."
  lastCommitId: String
  "Original full path to the file being moved."
  previousPath: String
}

"Autogenerated input type of CommitCreate"
input CommitCreateInput {
  "Array of action hashes to commit as a batch."
  actions: [CommitAction!]!
  "Name of the branch to commit into, it can be a new branch."
  branch: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Raw commit message."
  message: String!
  "Project full path the branch is associated with."
  projectPath: ID!
  "If on a new branch, name of the original branch."
  startBranch: String
}

input ComplianceFrameworkFilters {
  "ID of the compliance framework."
  id: ComplianceManagementFrameworkID
  "Negated compliance framework filter input."
  not: NegatedComplianceFrameworkFilters
  "Checks presence of compliance framework of the project, \"none\" and \"any\" values are supported."
  presenceFilter: ComplianceFrameworkPresenceFilter
}

input ComplianceFrameworkInput {
  "New color representation of the compliance framework in hex format. e.g. #FCA121."
  color: String
  "Set this compliance framework as the default framework for the group."
  default: Boolean
  "New description for the compliance framework."
  description: String
  "New name for the compliance framework."
  name: String
  "Full path of the compliance pipeline configuration stored in a project repository, such as `.gitlab/.compliance-gitlab-ci.yml@compliance/hipaa` **(ULTIMATE ALL)**."
  pipelineConfigurationFullPath: String
}

input ComplianceStandardsAdherenceInput {
  "Name of the check for the compliance standard."
  checkName: ComplianceStandardsAdherenceCheckName
  "Filter compliance standards adherence by project."
  projectIds: [ProjectID!]
  "Name of the compliance standard."
  standard: ComplianceStandardsAdherenceStandard
}

input ComplianceViolationInput {
  "Merge requests merged after this date (inclusive)."
  mergedAfter: Date
  "Merge requests merged before this date (inclusive)."
  mergedBefore: Date
  "Filter compliance violations by project."
  projectIds: [ProjectID!]
  "Filter compliance violations by target branch."
  targetBranch: String
}

"Autogenerated input type of ConfigureContainerScanning"
input ConfigureContainerScanningInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}

"Autogenerated input type of ConfigureDependencyScanning"
input ConfigureDependencyScanningInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}

"Autogenerated input type of ConfigureSastIac"
input ConfigureSastIacInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}

"Autogenerated input type of ConfigureSast"
input ConfigureSastInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "SAST CI configuration for the project."
  configuration: SastCiConfigurationInput!
  "Full path of the project."
  projectPath: ID!
}

"Autogenerated input type of ConfigureSecretDetection"
input ConfigureSecretDetectionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}

"Autogenerated input type of CorpusCreate"
input CorpusCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the corpus belongs to."
  fullPath: ID!
  "ID of the corpus package."
  packageId: PackagesPackageID!
}

"Autogenerated input type of CreateAlertIssue"
input CreateAlertIssueInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the alert to mutate."
  iid: String!
  "Project the alert to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of CreateAnnotation"
input CreateAnnotationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the cluster to add an annotation to."
  clusterId: ClustersClusterID
  "Path to a file defining the dashboard on which the annotation should be added."
  dashboardPath: String!
  "Description of the annotation."
  description: String!
  "Timestamp indicating ending moment to which the annotation relates."
  endingAt: Time
  "Global ID of the environment to add an annotation to."
  environmentId: EnvironmentID
  "Timestamp indicating starting moment to which the annotation relates."
  startingAt: Time!
}

"Autogenerated input type of CreateBoard"
input CreateBoardInput {
  "ID of user to be assigned to the board."
  assigneeId: UserID
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "ID of iteration cadence to be assigned to the board."
  iterationCadenceId: IterationsCadenceID
  "ID of iteration to be assigned to the board."
  iterationId: IterationID
  "IDs of labels to be added to the board."
  labelIds: [LabelID!]
  "Labels of the issue."
  labels: [String!]
  "ID of milestone to be assigned to the board."
  milestoneId: MilestoneID
  "Board name."
  name: String
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Weight value to be assigned to the board."
  weight: Int
}

"Autogenerated input type of CreateBranch"
input CreateBranchInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Name of the branch."
  name: String!
  "Project full path the branch is associated with."
  projectPath: ID!
  "Branch name or commit SHA to create branch from."
  ref: String!
}

"Autogenerated input type of CreateClusterAgent"
input CreateClusterAgentInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Name of the cluster agent."
  name: String!
  "Full path of the associated project for the cluster agent."
  projectPath: ID!
}

"Autogenerated input type of CreateComplianceFramework"
input CreateComplianceFrameworkInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the namespace to add the compliance framework to."
  namespacePath: ID!
  "Parameters to update the compliance framework with."
  params: ComplianceFrameworkInput!
}

"Autogenerated input type of CreateContainerRegistryProtectionRule"
input CreateContainerRegistryProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Max GitLab access level to prevent from deleting container images in the container registry. For example `DEVELOPER`, `MAINTAINER`, `OWNER`."
  deleteProtectedUpToAccessLevel: ContainerRegistryProtectionRuleAccessLevel!
  "Full path of the project where a protection rule is located."
  projectPath: ID!
  "Max GitLab access level to prevent from pushing container images to the container registry. For example `DEVELOPER`, `MAINTAINER`, `OWNER`."
  pushProtectedUpToAccessLevel: ContainerRegistryProtectionRuleAccessLevel!
  "Container repository path pattern protected by the protection rule. For example `my-project/my-container-*`. Wildcard character `*` allowed."
  repositoryPathPattern: String!
}

"Autogenerated input type of CreateCustomEmoji"
input CreateCustomEmojiInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Namespace full path the emoji is associated with."
  groupPath: ID!
  "Name of the emoji."
  name: String!
  "Location of the emoji file."
  url: String!
}

"Autogenerated input type of CreateDiffNote"
input CreateDiffNoteInput {
  "Content of the note."
  body: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Internal flag for a note. Default is false."
  internal: Boolean
  "Global ID of the resource to add a note to."
  noteableId: NoteableID!
  "Position of this note on a diff."
  position: DiffPositionInput!
}

"Autogenerated input type of CreateEpic"
input CreateEpicInput {
  "IDs of labels to be added to the epic."
  addLabelIds: [ID!]
  "Array of labels to be added to the epic."
  addLabels: [String!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Color of the epic. Available only when feature flag `epic_color_highlight` is enabled. This flag is disabled by default, because the feature is experimental and is subject to change without notice."
  color: Color
  "Indicates if the epic is confidential."
  confidential: Boolean
  "Description of the epic."
  description: String
  "End date of the epic."
  dueDateFixed: String
  "Indicates end date should be sourced from due_date_fixed field not the issue milestones."
  dueDateIsFixed: Boolean
  "Group the epic to mutate is in."
  groupPath: ID!
  "IDs of labels to be removed from the epic."
  removeLabelIds: [ID!]
  "Start date of the epic."
  startDateFixed: String
  "Indicates start date should be sourced from start_date_fixed field not the issue milestones."
  startDateIsFixed: Boolean
  "Title of the epic."
  title: String
}

"Autogenerated input type of CreateImageDiffNote"
input CreateImageDiffNoteInput {
  "Content of the note."
  body: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Internal flag for a note. Default is false."
  internal: Boolean
  "Global ID of the resource to add a note to."
  noteableId: NoteableID!
  "Position of this note on a diff."
  position: DiffImagePositionInput!
}

"Autogenerated input type of CreateIssue"
input CreateIssueInput {
  "Array of user IDs to assign to the issue."
  assigneeIds: [UserID!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates the issue is confidential."
  confidential: Boolean
  "Timestamp when the issue was created. Available only for admins and project owners."
  createdAt: Time
  "Description of the issue."
  description: String
  "ID of a discussion to resolve. Also pass `merge_request_to_resolve_discussions_of`."
  discussionToResolve: String
  "Due date of the issue."
  dueDate: ISO8601Date
  "ID of an epic to associate the issue with."
  epicId: EpicID
  "Desired health status."
  healthStatus: HealthStatus
  "IID (internal ID) of a project issue. Only admins and project owners can modify."
  iid: Int
  "Global iteration cadence ID. Required when `iterationWildcardId` is provided."
  iterationCadenceId: IterationsCadenceID
  "Global iteration ID. Mutually exlusive argument with `iterationWildcardId`."
  iterationId: IterationID
  "Iteration wildcard ID. Supported values are: `CURRENT`. Mutually exclusive argument with `iterationId`. iterationCadenceId also required when this argument is provided."
  iterationWildcardId: IssueCreationIterationWildcardId
  "IDs of labels to be added to the issue."
  labelIds: [LabelID!]
  "Labels of the issue."
  labels: [String!]
  "Indicates discussion is locked on the issue."
  locked: Boolean
  "IID of a merge request for which to resolve discussions."
  mergeRequestToResolveDiscussionsOf: MergeRequestID
  "ID of the milestone to assign to the issue. On update milestone will be removed if set to null."
  milestoneId: MilestoneID
  "Global ID of issue that should be placed after the current issue."
  moveAfterId: IssueID
  "Global ID of issue that should be placed before the current issue."
  moveBeforeId: IssueID
  "Project full path the issue is associated with."
  projectPath: ID!
  "Title of the issue."
  title: String!
  "Type of the issue."
  type: IssueType
  "Weight of the issue."
  weight: Int
}

"Autogenerated input type of CreateIteration"
input CreateIterationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the iteration."
  description: String
  "End date of the iteration."
  dueDate: String
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Global ID of the iteration cadence to be assigned to the new iteration."
  iterationsCadenceId: IterationsCadenceID
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Start date of the iteration."
  startDate: String
  "Title of the iteration."
  title: String
}

"Autogenerated input type of CreateNote"
input CreateNoteInput {
  "Content of the note."
  body: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the discussion the note is in reply to."
  discussionId: DiscussionID
  "Internal flag for a note. Default is false."
  internal: Boolean
  "SHA of the head commit which is used to ensure that the merge request has not been updated since the request was sent."
  mergeRequestDiffHeadSha: String
  "Global ID of the resource to add a note to."
  noteableId: NoteableID!
}

"Autogenerated input type of CreatePackagesProtectionRule"
input CreatePackagesProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Package name protected by the protection rule. For example `@my-scope/my-package-*`. Wildcard character `*` allowed."
  packageNamePattern: String!
  "Package type protected by the protection rule. For example `NPM`."
  packageType: PackagesProtectionRulePackageType!
  "Full path of the project where a protection rule is located."
  projectPath: ID!
  "Max GitLab access level unable to push a package. For example `DEVELOPER`, `MAINTAINER`, `OWNER`."
  pushProtectedUpToAccessLevel: PackagesProtectionRuleAccessLevel!
}

"Autogenerated input type of CreateRequirement"
input CreateRequirementInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the requirement."
  description: String
  "Full project path the requirement is associated with."
  projectPath: ID!
  "Title of the requirement."
  title: String
}

"Autogenerated input type of CreateSnippet"
input CreateSnippetInput {
  "Actions to perform over the snippet repository and blobs."
  blobActions: [SnippetBlobActionInputType!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the snippet."
  description: String
  "Full path of the project the snippet is associated with."
  projectPath: ID
  "Title of the snippet."
  title: String!
  "Paths to files uploaded in the snippet description."
  uploadedFiles: [String!]
  "Visibility level of the snippet."
  visibilityLevel: VisibilityLevelsEnum!
}

"Autogenerated input type of CreateTestCase"
input CreateTestCaseInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Sets the test case confidentiality."
  confidential: Boolean
  "Test case description."
  description: String
  "IDs of labels to be added to the test case."
  labelIds: [ID!]
  "Project full path to create the test case in."
  projectPath: ID!
  "Test case title."
  title: String!
}

"Autogenerated input type of CustomerRelationsContactCreate"
input CustomerRelationsContactCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of or notes for the contact."
  description: String
  "Email address of the contact."
  email: String
  "First name of the contact."
  firstName: String!
  "Group for the contact."
  groupId: GroupID!
  "Last name of the contact."
  lastName: String!
  "Organization for the contact."
  organizationId: CustomerRelationsOrganizationID
  "Phone number of the contact."
  phone: String
}

"Autogenerated input type of CustomerRelationsContactUpdate"
input CustomerRelationsContactUpdateInput {
  "State of the contact."
  active: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of or notes for the contact."
  description: String
  "Email address of the contact."
  email: String
  "First name of the contact."
  firstName: String
  "Global ID of the contact."
  id: CustomerRelationsContactID!
  "Last name of the contact."
  lastName: String
  "Organization of the contact."
  organizationId: CustomerRelationsOrganizationID
  "Phone number of the contact."
  phone: String
}

"Autogenerated input type of CustomerRelationsOrganizationCreate"
input CustomerRelationsOrganizationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Standard billing rate for the organization."
  defaultRate: Float
  "Description of or notes for the organization."
  description: String
  "Group for the organization."
  groupId: GroupID!
  "Name of the organization."
  name: String!
}

"Autogenerated input type of CustomerRelationsOrganizationUpdate"
input CustomerRelationsOrganizationUpdateInput {
  "State of the organization."
  active: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Standard billing rate for the organization."
  defaultRate: Float
  "Description of or notes for the organization."
  description: String
  "Global ID of the organization."
  id: CustomerRelationsOrganizationID!
  "Name of the organization."
  name: String
}

"Autogenerated input type of DastOnDemandScanCreate"
input DastOnDemandScanCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the scanner profile to be used for the scan."
  dastScannerProfileId: DastScannerProfileID
  "ID of the site profile to be used for the scan."
  dastSiteProfileId: DastSiteProfileID!
  "Project the site profile belongs to."
  fullPath: ID!
}

"Represents DAST Profile Cadence."
input DastProfileCadenceInput {
  "Duration of the DAST Profile Cadence."
  duration: Int
  "Unit for the duration of DAST Profile Cadence."
  unit: DastProfileCadenceUnit
}

"Autogenerated input type of DastProfileCreate"
input DastProfileCreateInput {
  "Associated branch."
  branchName: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Represents a DAST Profile Schedule."
  dastProfileSchedule: DastProfileScheduleInput
  "ID of the scanner profile to be associated."
  dastScannerProfileId: DastScannerProfileID!
  "ID of the site profile to be associated."
  dastSiteProfileId: DastSiteProfileID!
  "Description of the profile. Defaults to an empty string."
  description: String = ""
  "Project the profile belongs to."
  fullPath: ID!
  "Name of the profile."
  name: String!
  "Run scan using profile after creation. Defaults to false."
  runAfterCreate: Boolean = false
  "Indicates the runner tags associated with the profile."
  tagList: [String!]
}

"Autogenerated input type of DastProfileDelete"
input DastProfileDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the profile to be deleted."
  id: DastProfileID!
}

"Autogenerated input type of DastProfileRun"
input DastProfileRunInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the profile to be used for the scan."
  id: DastProfileID!
}

"Input type for DAST Profile Schedules"
input DastProfileScheduleInput {
  "Status of a Dast Profile Schedule."
  active: Boolean
  "Cadence of a Dast Profile Schedule."
  cadence: DastProfileCadenceInput
  "Start time of a Dast Profile Schedule."
  startsAt: Time
  "Time Zone for the Start time of a Dast Profile Schedule."
  timezone: String
}

"Autogenerated input type of DastProfileUpdate"
input DastProfileUpdateInput {
  "Associated branch."
  branchName: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Represents a DAST profile schedule."
  dastProfileSchedule: DastProfileScheduleInput
  "ID of the scanner profile to be associated."
  dastScannerProfileId: DastScannerProfileID
  "ID of the site profile to be associated."
  dastSiteProfileId: DastSiteProfileID
  "Description of the profile. Defaults to an empty string."
  description: String = ""
  "ID of the profile to be deleted."
  id: DastProfileID!
  "Name of the profile."
  name: String
  "Run scan using profile after update. Defaults to false."
  runAfterUpdate: Boolean = false
  "Indicates the runner tags associated with the profile."
  tagList: [String!]
}

"Autogenerated input type of DastScannerProfileCreate"
input DastScannerProfileCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the scanner profile belongs to."
  fullPath: ID!
  "Name of the scanner profile."
  profileName: String!
  "Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan."
  scanType: DastScanTypeEnum = PASSIVE
  "Indicates if debug messages should be included in DAST console output. True to include the debug messages."
  showDebugMessages: Boolean = false
  "Maximum number of minutes allowed for the spider to traverse the site."
  spiderTimeout: Int
  "Maximum number of seconds allowed for the site under test to respond to a request."
  targetTimeout: Int
  "Indicates if the AJAX spider should be used to crawl the target site. True to run the AJAX spider in addition to the traditional spider, and false to run only the traditional spider."
  useAjaxSpider: Boolean = false
}

"Autogenerated input type of DastScannerProfileDelete"
input DastScannerProfileDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the scanner profile to be deleted."
  id: DastScannerProfileID!
}

"Autogenerated input type of DastScannerProfileUpdate"
input DastScannerProfileUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the scanner profile to be updated."
  id: DastScannerProfileID!
  "Name of the scanner profile."
  profileName: String!
  "Indicates the type of DAST scan that will run. Either a Passive Scan or an Active Scan."
  scanType: DastScanTypeEnum
  "Indicates if debug messages should be included in DAST console output. True to include the debug messages."
  showDebugMessages: Boolean
  "Maximum number of minutes allowed for the spider to traverse the site."
  spiderTimeout: Int!
  "Maximum number of seconds allowed for the site under test to respond to a request."
  targetTimeout: Int!
  "Indicates if the AJAX spider should be used to crawl the target site. True to run the AJAX spider in addition to the traditional spider, and false to run only the traditional spider."
  useAjaxSpider: Boolean
}

"Input type for DastSiteProfile authentication"
input DastSiteProfileAuthInput {
  "Indicates whether authentication is enabled."
  enabled: Boolean
  "Password to authenticate with on the target."
  password: String
  "Name of password field at the sign-in HTML form."
  passwordField: String
  "Name or ID of sign-in submit button at the sign-in HTML form."
  submitField: String
  "The URL of the page containing the sign-in HTML form on the target website."
  url: String
  "Username to authenticate with on the target."
  username: String
  "Name of username field at the sign-in HTML form."
  usernameField: String
}

"Autogenerated input type of DastSiteProfileCreate"
input DastSiteProfileCreateInput {
  "Parameters for authentication."
  auth: DastSiteProfileAuthInput
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "URLs to skip during an authenticated scan. Defaults to `[]`."
  excludedUrls: [String!] = []
  "Project the site profile belongs to."
  fullPath: ID!
  "Name of the site profile."
  profileName: String!
  "Comma-separated list of request header names and values to be added to every request made by DAST."
  requestHeaders: String
  "File Path or URL used as input for the scan method."
  scanFilePath: String
  "Scan method by the scanner."
  scanMethod: DastScanMethodType
  "Type of target to be scanned."
  targetType: DastTargetTypeEnum
  "URL of the target to be scanned."
  targetUrl: String
}

"Autogenerated input type of DastSiteProfileDelete"
input DastSiteProfileDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the site profile to be deleted."
  id: DastSiteProfileID!
}

"Autogenerated input type of DastSiteProfileUpdate"
input DastSiteProfileUpdateInput {
  "Parameters for authentication."
  auth: DastSiteProfileAuthInput
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "URLs to skip during an authenticated scan."
  excludedUrls: [String!]
  "ID of the site profile to be updated."
  id: DastSiteProfileID!
  "Name of the site profile."
  profileName: String!
  "Comma-separated list of request header names and values to be added to every request made by DAST."
  requestHeaders: String
  "File Path or URL used as input for the scan method."
  scanFilePath: String
  "Scan method by the scanner."
  scanMethod: DastScanMethodType
  "Type of target to be scanned."
  targetType: DastTargetTypeEnum
  "URL of the target to be scanned."
  targetUrl: String
}

"Autogenerated input type of DastSiteTokenCreate"
input DastSiteTokenCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the site token belongs to."
  fullPath: ID!
  "URL of the target to be validated."
  targetUrl: String
}

"Autogenerated input type of DastSiteValidationCreate"
input DastSiteValidationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the site token."
  dastSiteTokenId: DastSiteTokenID!
  "Project the site profile belongs to."
  fullPath: ID!
  "Validation strategy to be used."
  strategy: DastSiteValidationStrategyEnum
  "Path to be requested during validation."
  validationPath: String!
}

"Autogenerated input type of DastSiteValidationRevoke"
input DastSiteValidationRevokeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project the site validation belongs to."
  fullPath: ID!
  "Normalized URL of the target to be revoked."
  normalizedTargetUrl: String!
}

"Autogenerated input type of DeleteAnnotation"
input DeleteAnnotationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the annotation to delete."
  id: String!
}

"Autogenerated input type of DeleteContainerRegistryProtectionRule"
input DeleteContainerRegistryProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the container registry protection rule to delete."
  id: ContainerRegistryProtectionRuleID!
}

"Autogenerated input type of DeletePackagesProtectionRule"
input DeletePackagesProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the package protection rule to delete."
  id: PackagesProtectionRuleID!
}

"Values for ordering deployments by a specific field"
input DeploymentsOrderByInput {
  "Order by Created time."
  createdAt: SortDirectionEnum
  "Order by Finished time."
  finishedAt: SortDirectionEnum
}

"Autogenerated input type of DesignManagementDelete"
input DesignManagementDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Filenames of the designs to delete."
  filenames: [String!]!
  "IID of the issue to modify designs for."
  iid: ID!
  "Project where the issue is to upload designs for."
  projectPath: ID!
}

"Autogenerated input type of DesignManagementMove"
input DesignManagementMoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the design to move."
  id: DesignManagementDesignID!
  "ID of the immediately following design."
  next: DesignManagementDesignID
  "ID of the immediately preceding design."
  previous: DesignManagementDesignID
}

"Autogenerated input type of DesignManagementUpdate"
input DesignManagementUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the design."
  description: String
  "ID of the design to update."
  id: DesignManagementDesignID!
}

"Autogenerated input type of DesignManagementUpload"
input DesignManagementUploadInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Files to upload."
  files: [Upload!]!
  "IID of the issue to modify designs for."
  iid: ID!
  "Project where the issue is to upload designs for."
  projectPath: ID!
}

"Autogenerated input type of DestroyBoard"
input DestroyBoardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the board to destroy."
  id: BoardID!
}

"Autogenerated input type of DestroyBoardList"
input DestroyBoardListInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the list to destroy. Only label lists are accepted."
  listId: ListID!
}

"Autogenerated input type of DestroyComplianceFramework"
input DestroyComplianceFrameworkInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the compliance framework to destroy."
  id: ComplianceManagementFrameworkID!
}

"Autogenerated input type of DestroyContainerRepository"
input DestroyContainerRepositoryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the container repository."
  id: ContainerRepositoryID!
}

"Autogenerated input type of DestroyContainerRepositoryTags"
input DestroyContainerRepositoryTagsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the container repository."
  id: ContainerRepositoryID!
  "Container repository tag(s) to delete. Total number can't be greater than 20"
  tagNames: [String!]!
}

"Autogenerated input type of DestroyCustomEmoji"
input DestroyCustomEmojiInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the custom emoji to destroy."
  id: CustomEmojiID!
}

"Autogenerated input type of DestroyEpicBoard"
input DestroyEpicBoardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the board to destroy."
  id: BoardsEpicBoardID!
}

"Autogenerated input type of DestroyNote"
input DestroyNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the note to destroy."
  id: NoteID!
}

"Autogenerated input type of DestroyPackageFile"
input DestroyPackageFileInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Package file."
  id: PackagesPackageFileID!
}

"Autogenerated input type of DestroyPackageFiles"
input DestroyPackageFilesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IDs of the Package file."
  ids: [PackagesPackageFileID!]!
  "Project path where the packages cleanup policy is located."
  projectPath: ID!
}

"Autogenerated input type of DestroyPackage"
input DestroyPackageInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Package."
  id: PackagesPackageID!
}

"Autogenerated input type of DestroyPackages"
input DestroyPackagesInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the Packages. Max 20"
  ids: [PackagesPackageID!]!
}

"Autogenerated input type of DestroySnippet"
input DestroySnippetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the snippet to destroy."
  id: SnippetID!
}

input DiffImagePositionInput {
  "Merge base of the branch the comment was made on."
  baseSha: String
  "SHA of the HEAD at the time the comment was made."
  headSha: String!
  "Total height of the image."
  height: Int!
  "The paths of the file that was changed. Both of the properties of this input are optional, but at least one of them is required"
  paths: DiffPathsInput!
  "SHA of the branch being compared against."
  startSha: String!
  "Total width of the image."
  width: Int!
  "X position of the note."
  x: Int!
  "Y position of the note."
  y: Int!
}

input DiffPathsInput {
  "Path of the file on the HEAD SHA."
  newPath: String
  "Path of the file on the start SHA."
  oldPath: String
}

input DiffPositionInput {
  "Merge base of the branch the comment was made on."
  baseSha: String
  "SHA of the HEAD at the time the comment was made."
  headSha: String!
  "Line on HEAD SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field."
  newLine: Int
  "Line on start SHA that was changed. Please see the [REST API Documentation](https://docs.gitlab.com/ee/api/discussions.html#create-a-new-thread-in-the-merge-request-diff) for more information on how to use this field."
  oldLine: Int
  "The paths of the file that was changed. Both of the properties of this input are optional, but at least one of them is required"
  paths: DiffPathsInput!
  "SHA of the branch being compared against."
  startSha: String!
}

"Autogenerated input type of DisableDevopsAdoptionNamespace"
input DisableDevopsAdoptionNamespaceInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "One or many IDs of the enabled namespaces to disable."
  id: [AnalyticsDevopsAdoptionEnabledNamespaceID!]!
}

"Autogenerated input type of DiscussionToggleResolve"
input DiscussionToggleResolveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the discussion."
  id: DiscussionID!
  "Will resolve the discussion when true, and unresolve the discussion when false."
  resolve: Boolean!
}

"Filter parameters for projects to be aggregated for DORA metrics."
input DoraProjectFilterInput {
  "Filter projects by topic."
  topic: [String!]
}

"Autogenerated input type of EchoCreate"
input EchoCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Errors to return to the user."
  errors: [String!]
  "Messages to return to the user."
  messages: [String!]
}

"Autogenerated input type of EnableDevopsAdoptionNamespace"
input EnableDevopsAdoptionNamespaceInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Display namespace ID."
  displayNamespaceId: NamespaceID
  "Namespace ID."
  namespaceId: NamespaceID!
}

"Autogenerated input type of EnvironmentCreate"
input EnvironmentCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Cluster agent of the environment."
  clusterAgentId: ClustersAgentID
  "External URL of the environment."
  externalUrl: String
  "Flux resource path of the environment."
  fluxResourcePath: String
  "Kubernetes namespace of the environment."
  kubernetesNamespace: String
  "Name of the environment."
  name: String!
  "Full path of the project."
  projectPath: ID!
  "Tier of the environment."
  tier: DeploymentTier
}

"Autogenerated input type of EnvironmentDelete"
input EnvironmentDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the environment to Delete."
  id: EnvironmentID!
}

"Autogenerated input type of EnvironmentStop"
input EnvironmentStopInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Force environment to stop without executing on_stop actions."
  force: Boolean
  "Global ID of the environment to stop."
  id: EnvironmentID!
}

"Autogenerated input type of EnvironmentUpdate"
input EnvironmentUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Cluster agent of the environment."
  clusterAgentId: ClustersAgentID
  "External URL of the environment."
  externalUrl: String
  "Flux resource path of the environment."
  fluxResourcePath: String
  "Global ID of the environment to update."
  id: EnvironmentID!
  "Kubernetes namespace of the environment."
  kubernetesNamespace: String
  "Tier of the environment."
  tier: DeploymentTier
}

"Autogenerated input type of EnvironmentsCanaryIngressUpdate"
input EnvironmentsCanaryIngressUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the environment to update."
  id: EnvironmentID!
  "Weight of the Canary Ingress."
  weight: Int!
}

"Autogenerated input type of EpicAddIssue"
input EpicAddIssueInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group the epic to mutate belongs to."
  groupPath: ID!
  "IID of the epic to mutate."
  iid: ID!
  "IID of the issue to be added."
  issueIid: String!
  "Full path of the project the issue belongs to."
  projectPath: ID!
}

"Autogenerated input type of EpicBoardCreate"
input EpicBoardCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Whether or not display epic colors. Ignored unless `epic_color_highlight` flag is enabled."
  displayColors: Boolean
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "IDs of labels to be added to the board."
  labelIds: [LabelID!]
  "Labels of the issue."
  labels: [String!]
  "Board name."
  name: String
}

"Autogenerated input type of EpicBoardListCreate"
input EpicBoardListCreateInput {
  "Create the backlog list."
  backlog: Boolean
  "Global ID of the issue board to mutate."
  boardId: BoardsEpicBoardID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of an existing label."
  labelId: LabelID
}

"Autogenerated input type of EpicBoardListDestroy"
input EpicBoardListDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the epic board list to destroy."
  listId: BoardsEpicListID!
}

"Autogenerated input type of EpicBoardUpdate"
input EpicBoardUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Whether or not display epic colors. Ignored unless `epic_color_highlight` flag is enabled."
  displayColors: Boolean
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "Epic board global ID."
  id: BoardsEpicBoardID!
  "IDs of labels to be added to the board."
  labelIds: [LabelID!]
  "Labels of the issue."
  labels: [String!]
  "Board name."
  name: String
}

input EpicFilters {
  "Filter by author username."
  authorUsername: String
  "Filter by confidentiality."
  confidential: Boolean
  "Filter by label name."
  labelName: [String]
  "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
  myReactionEmoji: String
  "Negated epic arguments."
  not: NegatedEpicBoardIssueInput
  "List of arguments with inclusive OR. Ignored unless `or_issuable_queries` flag is enabled."
  or: UnionedEpicFilterInput
  "Search query for epic title or description."
  search: String
}

"Autogenerated input type of EpicMoveList"
input EpicMoveListInput {
  "Global ID of the board that the epic is in."
  boardId: BoardsEpicBoardID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the epic to mutate."
  epicId: EpicID!
  "ID of the board list that the epic will be moved from. Required if moving between lists."
  fromListId: BoardsEpicListID
  "ID of epic that should be placed after the current epic."
  moveAfterId: EpicID
  "ID of epic that should be placed before the current epic."
  moveBeforeId: EpicID
  "Position of epics within the board list. Positions start at 0. Use -1 to move to the end of the list."
  positionInList: Int
  "ID of the list the epic will be in after mutation."
  toListId: BoardsEpicListID!
}

"Autogenerated input type of EpicSetSubscription"
input EpicSetSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group the epic to mutate belongs to."
  groupPath: ID!
  "IID of the epic to mutate."
  iid: ID!
  "Desired state of the subscription."
  subscribedState: Boolean!
}

"A node of an epic tree."
input EpicTreeNodeFieldsInputType {
  "ID of the epic issue or issue the epic or issue is switched with."
  adjacentReferenceId: EpicTreeSortingID
  "ID of the epic issue or epic that is being moved."
  id: EpicTreeSortingID!
  "ID of the new parent epic."
  newParentId: EpicID
  "Type of switch. Valid values are `after` or `before`."
  relativePosition: MoveType
}

"Autogenerated input type of EpicTreeReorder"
input EpicTreeReorderInput {
  "ID of the base epic of the tree."
  baseEpicId: EpicID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Parameters for updating the tree positions."
  moved: EpicTreeNodeFieldsInputType!
}

"Autogenerated input type of EscalationPolicyCreate"
input EscalationPolicyCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the escalation policy."
  description: String
  "Name of the escalation policy."
  name: String!
  "Project to create the escalation policy for."
  projectPath: ID!
  "Steps of the escalation policy."
  rules: [EscalationRuleInput!]!
}

"Autogenerated input type of EscalationPolicyDestroy"
input EscalationPolicyDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Escalation policy internal ID to remove."
  id: IncidentManagementEscalationPolicyID!
}

"Autogenerated input type of EscalationPolicyUpdate"
input EscalationPolicyUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the escalation policy."
  description: String
  "ID of the on-call schedule to create the on-call rotation in."
  id: IncidentManagementEscalationPolicyID!
  "Name of the escalation policy."
  name: String
  "Steps of the escalation policy."
  rules: [EscalationRuleInput!]
}

"Represents an escalation rule"
input EscalationRuleInput {
  "Time in seconds before the rule is activated."
  elapsedTimeSeconds: Int!
  "On-call schedule to notify."
  oncallScheduleIid: ID
  "Status required to prevent the rule from activating."
  status: EscalationRuleStatus!
  "Username of the user to notify."
  username: String
}

"Autogenerated input type of ExportRequirements"
input ExportRequirementsInput {
  "Filter requirements by author username."
  authorUsername: [String!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full project path the requirements are associated with."
  projectPath: ID!
  "Search query for requirement title."
  search: String
  "List of selected requirements fields to be exported."
  selectedFields: [String!]
  "List requirements by sort order."
  sort: Sort
  "Filter requirements by state."
  state: RequirementState
}

"Autogenerated input type of ExternalAuditEventDestinationCreate"
input ExternalAuditEventDestinationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination URL."
  destinationUrl: String!
  "Group path."
  groupPath: ID!
  "Destination name."
  name: String
  "Verification token."
  verificationToken: String
}

"Autogenerated input type of ExternalAuditEventDestinationDestroy"
input ExternalAuditEventDestinationDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of external audit event destination to destroy."
  id: AuditEventsExternalAuditEventDestinationID!
}

"Autogenerated input type of ExternalAuditEventDestinationUpdate"
input ExternalAuditEventDestinationUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination URL to change."
  destinationUrl: String
  "ID of external audit event destination to update."
  id: AuditEventsExternalAuditEventDestinationID!
  "Destination name."
  name: String
}

input GenerateTestFileInput {
  "File path to generate test files for."
  filePath: String!
  "Global ID of the resource to mutate."
  resourceId: AiModelID!
}

"Autogenerated input type of GeoRegistriesBulkUpdate"
input GeoRegistriesBulkUpdateInput {
  "Action to be executed on Geo registries."
  action: GeoRegistriesBulkAction!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Class of the Geo registries to be updated."
  registryClass: GeoRegistryClass!
}

"Autogenerated input type of GeoRegistriesUpdate"
input GeoRegistriesUpdateInput {
  "Action to be executed on a Geo registry."
  action: GeoRegistryAction!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Class of the Geo registry to be updated."
  registryClass: GeoRegistryClass
  "ID of the Geo registry entry to be updated."
  registryId: GeoBaseRegistryID!
}

"Autogenerated input type of GitlabSubscriptionActivate"
input GitlabSubscriptionActivateInput {
  "Activation code received after purchasing a GitLab subscription."
  activationCode: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
}

"Autogenerated input type of GoogleCloudLoggingConfigurationCreate"
input GoogleCloudLoggingConfigurationCreateInput {
  "Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials."
  clientEmail: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Unique identifier of the Google Cloud project to which the logging configuration belongs."
  googleProjectIdName: String!
  "Group path."
  groupPath: ID!
  "Unique identifier used to distinguish and manage different logs within the same Google Cloud project.(defaults to `audit_events`)."
  logIdName: String = "audit_events"
  "Destination name."
  name: String
  "Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service."
  privateKey: String!
}

"Autogenerated input type of GoogleCloudLoggingConfigurationDestroy"
input GoogleCloudLoggingConfigurationDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Google Cloud logging configuration to destroy."
  id: AuditEventsGoogleCloudLoggingConfigurationID!
}

"Autogenerated input type of GoogleCloudLoggingConfigurationUpdate"
input GoogleCloudLoggingConfigurationUpdateInput {
  "Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials."
  clientEmail: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Unique identifier of the Google Cloud project to which the logging configuration belongs."
  googleProjectIdName: String
  "ID of the google Cloud configuration to update."
  id: AuditEventsGoogleCloudLoggingConfigurationID!
  "Unique identifier used to distinguish and manage different logs within the same Google Cloud project."
  logIdName: String
  "Destination name."
  name: String
  "Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service."
  privateKey: String
}

"Autogenerated input type of GroupMemberBulkUpdate"
input GroupMemberBulkUpdateInput {
  "Access level to update the members to."
  accessLevel: MemberAccessLevel!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Date and time the membership expires."
  expiresAt: Time
  "Global ID of the group."
  groupId: GroupID!
  "Global IDs of the members."
  userIds: [UserID!]!
}

"Autogenerated input type of GroupUpdate"
input GroupUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the group that will be updated."
  fullPath: ID!
  "Shared runners availability for the namespace and its descendants."
  sharedRunnersSetting: SharedRunnersSetting!
}

"Autogenerated input type of HttpIntegrationCreate"
input HttpIntegrationCreateInput {
  "Whether the integration is receiving alerts."
  active: Boolean!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Name of the integration."
  name: String!
  "Custom mapping of GitLab alert attributes to fields from the payload example."
  payloadAttributeMappings: [AlertManagementPayloadAlertFieldInput!]
  "Example of an alert payload."
  payloadExample: JsonString
  "Project to create the integration in."
  projectPath: ID!
}

"Autogenerated input type of HttpIntegrationDestroy"
input HttpIntegrationDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to remove."
  id: AlertManagementHttpIntegrationID!
}

"Autogenerated input type of HttpIntegrationResetToken"
input HttpIntegrationResetTokenInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: AlertManagementHttpIntegrationID!
}

"Autogenerated input type of HttpIntegrationUpdate"
input HttpIntegrationUpdateInput {
  "Whether the integration is receiving alerts."
  active: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: AlertManagementHttpIntegrationID!
  "Name of the integration."
  name: String
  "Custom mapping of GitLab alert attributes to fields from the payload example."
  payloadAttributeMappings: [AlertManagementPayloadAlertFieldInput!]
  "Example of an alert payload."
  payloadExample: JsonString
}

"Autogenerated input type of InstanceExternalAuditEventDestinationCreate"
input InstanceExternalAuditEventDestinationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination URL."
  destinationUrl: String!
  "Destination name."
  name: String
}

"Autogenerated input type of InstanceExternalAuditEventDestinationDestroy"
input InstanceExternalAuditEventDestinationDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the external instance audit event destination to destroy."
  id: AuditEventsInstanceExternalAuditEventDestinationID!
}

"Autogenerated input type of InstanceExternalAuditEventDestinationUpdate"
input InstanceExternalAuditEventDestinationUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Destination URL to change."
  destinationUrl: String
  "ID of the external instance audit event destination to update."
  id: AuditEventsInstanceExternalAuditEventDestinationID!
  "Destination name."
  name: String
}

"Autogenerated input type of InstanceGoogleCloudLoggingConfigurationCreate"
input InstanceGoogleCloudLoggingConfigurationCreateInput {
  "Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials."
  clientEmail: String!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Unique identifier of the Google Cloud project to which the logging configuration belongs."
  googleProjectIdName: String!
  "Unique identifier used to distinguish and manage different logs within the same Google Cloud project.(defaults to `audit_events`)."
  logIdName: String = "audit_events"
  "Destination name."
  name: String
  "Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service."
  privateKey: String!
}

"Autogenerated input type of InstanceGoogleCloudLoggingConfigurationDestroy"
input InstanceGoogleCloudLoggingConfigurationDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the Google Cloud logging configuration to destroy."
  id: AuditEventsInstanceGoogleCloudLoggingConfigurationID!
}

"Autogenerated input type of InstanceGoogleCloudLoggingConfigurationUpdate"
input InstanceGoogleCloudLoggingConfigurationUpdateInput {
  "Email address associated with the service account that will be used to authenticate and interact with the Google Cloud Logging service. This is part of the IAM credentials."
  clientEmail: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Unique identifier of the Google Cloud project to which the logging configuration belongs."
  googleProjectIdName: String
  "ID of the instance google Cloud configuration to update."
  id: AuditEventsInstanceGoogleCloudLoggingConfigurationID!
  "Unique identifier used to distinguish and manage different logs within the same Google Cloud project."
  logIdName: String
  "Destination name."
  name: String
  "Private Key associated with the service account. This key is used to authenticate the service account and authorize it to interact with the Google Cloud Logging service."
  privateKey: String
}

"Autogenerated input type of IssuableResourceLinkCreate"
input IssuableResourceLinkCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Incident id to associate the resource link with."
  id: IssueID!
  "Link of the resource."
  link: String!
  "Link text of the resource."
  linkText: String
  "Link type of the resource."
  linkType: IssuableResourceLinkType
}

"Autogenerated input type of IssuableResourceLinkDestroy"
input IssuableResourceLinkDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Issuable resource link ID to remove."
  id: IncidentManagementIssuableResourceLinkID!
}

"Autogenerated input type of IssueLinkAlerts"
input IssueLinkAlertsInput {
  "Alerts references to be linked to the incident."
  alertReferences: [String!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueMove"
input IssueMoveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
  "Project to move the issue to."
  targetProjectPath: ID!
}

"Autogenerated input type of IssueMoveList"
input IssueMoveListInput {
  "Global ID of the board that the issue is in."
  boardId: BoardID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the parent epic. NULL when removing the association."
  epicId: EpicID
  "ID of the board list that the issue will be moved from."
  fromListId: ID
  "IID of the issue to mutate."
  iid: String!
  "ID of issue that should be placed after the current issue."
  moveAfterId: ID
  "ID of issue that should be placed before the current issue."
  moveBeforeId: ID
  "Position of issue within the board list. Positions start at 0. Use -1 to move to the end of the list."
  positionInList: Int
  "Project the issue to mutate is in."
  projectPath: ID!
  "ID of the board list that the issue will be moved to."
  toListId: ID
}

"Autogenerated input type of IssueSetAssignees"
input IssueSetAssigneesInput {
  "Usernames to assign to the resource. Replaces existing assignees by default."
  assigneeUsernames: [String!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode = REPLACE
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetConfidential"
input IssueSetConfidentialInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Whether or not to set the issue as a confidential."
  confidential: Boolean!
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetCrmContacts"
input IssueSetCrmContactsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Customer relations contact IDs to set. Replaces existing contacts by default."
  contactIds: [CustomerRelationsContactID!]!
  "IID of the issue to mutate."
  iid: String!
  "Changes the operation mode. Defaults to REPLACE."
  operationMode: MutationOperationMode
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetDueDate"
input IssueSetDueDateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Desired due date for the issue. Due date is removed if null."
  dueDate: Time
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetEpic"
input IssueSetEpicInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the epic to be assigned to the issue, epic will be removed if absent or set to null"
  epicId: EpicID
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetEscalationPolicy"
input IssueSetEscalationPolicyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the escalation policy to assign to the issue. Policy will be removed if absent or set to null."
  escalationPolicyId: IncidentManagementEscalationPolicyID
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetEscalationStatus"
input IssueSetEscalationStatusInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
  "Set the escalation status."
  status: IssueEscalationStatus!
}

"Autogenerated input type of IssueSetIteration"
input IssueSetIterationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  """

  Iteration to assign to the issue.
  """
  iterationId: IterationID
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetLocked"
input IssueSetLockedInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Whether or not to lock discussion on the issue."
  locked: Boolean!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssueSetSeverity"
input IssueSetSeverityInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
  "Set the incident severity level."
  severity: IssuableSeverity!
}

"Autogenerated input type of IssueSetSubscription"
input IssueSetSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
  "Desired state of the subscription."
  subscribedState: Boolean!
}

"Autogenerated input type of IssueSetWeight"
input IssueSetWeightInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
  "The desired weight for the issue. If set to null, weight is removed."
  weight: Int
}

"Autogenerated input type of IssueUnlinkAlert"
input IssueUnlinkAlertInput {
  "Global ID of the alert to unlink from the incident."
  alertId: AlertManagementAlertID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of IssuesBulkUpdate"
input IssuesBulkUpdateInput {
  "Global ID array of the labels that will be added to the issues. "
  addLabelIds: [LabelID!]
  "Global ID array of the users that will be assigned to the given issues. Existing assignees will be replaced with the ones on this list."
  assigneeIds: [UserID!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the epic that will be assigned to the issues."
  epicId: EpicID
  "Health status that will be assigned to the issues."
  healthStatus: HealthStatus
  "Global ID array of the issues that will be updated. IDs that the user can't update will be ignored. A max of 100 can be provided."
  ids: [IssueID!]!
  "Global ID of the iteration that will be assigned to the issues."
  iterationId: IterationID
  "Global ID of the milestone that will be assigned to the issues."
  milestoneId: MilestoneID
  "Global ID of the parent to which the bulk update will be scoped. The parent can be a project **(FREE ALL)** or a group **(PREMIUM ALL)**. Example `IssueParentID` are `\"gid://gitlab/Project/1\"` and `\"gid://gitlab/Group/1\"`."
  parentId: IssueParentID!
  "Global ID array of the labels that will be removed from the issues. "
  removeLabelIds: [LabelID!]
  "Close or reopen an issue."
  stateEvent: IssueStateEvent
  "Subscribe to or unsubscribe from issue notifications."
  subscriptionEvent: IssuableSubscriptionEvent
}

"Autogenerated input type of IterationCadenceCreate"
input IterationCadenceCreateInput {
  "Whether the iteration cadence is active."
  active: Boolean!
  "Whether the iteration cadence should automatically generate upcoming iterations."
  automatic: Boolean!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the iteration cadence. Maximum length is 5000 characters."
  description: String
  "Duration in weeks of the iterations within this cadence."
  durationInWeeks: Int
  "Group where the iteration cadence is created."
  groupPath: ID!
  "Upcoming iterations to be created when iteration cadence is set to automatic."
  iterationsInAdvance: Int
  "Whether the iteration cadence should roll over issues to the next iteration or not."
  rollOver: Boolean
  "Timestamp of the automation start date."
  startDate: Time
  "Title of the iteration cadence."
  title: String
}

"Autogenerated input type of IterationCadenceDestroy"
input IterationCadenceDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the iteration cadence."
  id: IterationsCadenceID!
}

"Autogenerated input type of IterationCadenceUpdate"
input IterationCadenceUpdateInput {
  "Whether the iteration cadence is active."
  active: Boolean
  "Whether the iteration cadence should automatically generate upcoming iterations."
  automatic: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the iteration cadence. Maximum length is 5000 characters."
  description: String
  "Duration in weeks of the iterations within this cadence."
  durationInWeeks: Int
  "Global ID of the iteration cadence."
  id: IterationsCadenceID!
  "Upcoming iterations to be created when iteration cadence is set to automatic."
  iterationsInAdvance: Int
  "Whether the iteration cadence should roll over issues to the next iteration or not."
  rollOver: Boolean
  "Timestamp of the automation start date."
  startDate: Time
  "Title of the iteration cadence."
  title: String
}

"Autogenerated input type of IterationDelete"
input IterationDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the iteration."
  id: IterationID!
}

"Autogenerated input type of JiraImportStart"
input JiraImportStartInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project key of the importer Jira project."
  jiraProjectKey: String!
  "Project name of the importer Jira project."
  jiraProjectName: String
  "Project to import the Jira project into."
  projectPath: ID!
  "Mapping of Jira to GitLab users."
  usersMapping: [JiraUsersMappingInputType!]
}

"Autogenerated input type of JiraImportUsers"
input JiraImportUsersInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project to import the Jira users into."
  projectPath: ID!
  "Index of the record the import should started at, default 0 (50 records returned)."
  startAt: Int
}

input JiraUsersMappingInputType {
  "ID of the GitLab user."
  gitlabId: Int
  "Jira account ID of the user."
  jiraAccountId: String!
}

"Autogenerated input type of JobArtifactsDestroy"
input JobArtifactsDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiBuildID!
}

"Autogenerated input type of JobCancel"
input JobCancelInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiBuildID!
}

"Autogenerated input type of JobPlay"
input JobPlayInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiBuildID!
  "Variables to use when playing a manual job."
  variables: [CiVariableInput!] = []
}

"Autogenerated input type of JobRetry"
input JobRetryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiProcessableID!
  "Variables to use when retrying a manual job."
  variables: [CiVariableInput!] = []
}

"Autogenerated input type of JobUnschedule"
input JobUnscheduleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the job to mutate."
  id: CiBuildID!
}

"Autogenerated input type of LabelCreate"
input LabelCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  """

  The color of the label given in 6-digit hex notation with leading '#' sign
  (for example, `#FFAABB`) or one of the CSS color names.
  """
  color: String = "#6699cc"
  "Description of the label."
  description: String
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Title of the label."
  title: String!
}

"Autogenerated input type of MarkAsSpamSnippet"
input MarkAsSpamSnippetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the snippet to update."
  id: SnippetID!
}

"Autogenerated input type of MemberRoleCreate"
input MemberRoleCreateInput {
  "Base access level for the custom role."
  baseAccessLevel: MemberAccessLevel!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the member role."
  description: String
  "Group the member role to mutate is in. Required for SaaS."
  groupPath: ID!
  "Name of the member role."
  name: String
  "List of all customizable permissions."
  permissions: [MemberRolePermission!]
}

"Autogenerated input type of MemberRoleDelete"
input MemberRoleDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the member role to delete."
  id: MemberRoleID!
}

"Autogenerated input type of MemberRoleUpdate"
input MemberRoleUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the member role."
  description: String
  "ID of the member role to mutate."
  id: MemberRoleID!
  "Name of the member role."
  name: String
  "List of all customizable permissions."
  permissions: [MemberRolePermission!]
}

"Autogenerated input type of MergeRequestAccept"
input MergeRequestAcceptInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Custom merge commit message."
  commitMessage: String
  "IID of the merge request to mutate."
  iid: String!
  "Project the merge request to mutate is in."
  projectPath: ID!
  "HEAD SHA at the time when the merge was requested."
  sha: String!
  "Should the source branch be removed."
  shouldRemoveSourceBranch: Boolean
  "Squash commits on the source branch before merge."
  squash: Boolean = false
  "Custom squash commit message (if squash is true)."
  squashCommitMessage: String
  "How to merge the merge request."
  strategy: MergeStrategyEnum
}

"Autogenerated input type of MergeRequestCreate"
input MergeRequestCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the merge request (Markdown rendered as HTML for caching)."
  description: String
  "Labels of the merge request."
  labels: [String!]
  "Project full path the merge request is associated with."
  projectPath: ID!
  "Source branch of the merge request."
  sourceBranch: String!
  "Target branch of the merge request."
  targetBranch: String!
  "Title of the merge request."
  title: String!
}

"Autogenerated input type of MergeRequestReviewerRereview"
input MergeRequestReviewerRereviewInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the merge request to mutate."
  iid: String!
  "Project the merge request to mutate is in."
  projectPath: ID!
  """

  User ID for the user that has been requested for a new review.
  """
  userId: UserID!
}

"Autogenerated input type of MergeRequestSetAssignees"
input MergeRequestSetAssigneesInput {
  "Usernames to assign to the resource. Replaces existing assignees by default."
  assigneeUsernames: [String!]!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the merge request to mutate."
  iid: String!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode = REPLACE
  "Project the merge request to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of MergeRequestSetDraft"
input MergeRequestSetDraftInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  """

  Whether or not to set the merge request as a draft.
  """
  draft: Boolean!
  "IID of the merge request to mutate."
  iid: String!
  "Project the merge request to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of MergeRequestSetLabels"
input MergeRequestSetLabelsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the merge request to mutate."
  iid: String!
  """

  Label IDs to set. Replaces existing labels by default.
  """
  labelIds: [LabelID!]!
  """

  Changes the operation mode. Defaults to REPLACE.
  """
  operationMode: MutationOperationMode
  "Project the merge request to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of MergeRequestSetLocked"
input MergeRequestSetLockedInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the merge request to mutate."
  iid: String!
  """

  Whether or not to lock the merge request.
  """
  locked: Boolean!
  "Project the merge request to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of MergeRequestSetMilestone"
input MergeRequestSetMilestoneInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the merge request to mutate."
  iid: String!
  """

  Milestone to assign to the merge request.
  """
  milestoneId: MilestoneID
  "Project the merge request to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of MergeRequestSetReviewers"
input MergeRequestSetReviewersInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the merge request to mutate."
  iid: String!
  "Operation to perform. Defaults to REPLACE."
  operationMode: MutationOperationMode = REPLACE
  "Project the merge request to mutate is in."
  projectPath: ID!
  "Usernames of reviewers to assign. Replaces existing reviewers by default."
  reviewerUsernames: [String!]!
}

"Autogenerated input type of MergeRequestSetSubscription"
input MergeRequestSetSubscriptionInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the merge request to mutate."
  iid: String!
  "Project the merge request to mutate is in."
  projectPath: ID!
  "Desired state of the subscription."
  subscribedState: Boolean!
}

"Autogenerated input type of MergeRequestUpdateApprovalRule"
input MergeRequestUpdateApprovalRuleInput {
  "ID of an approval rule."
  approvalRuleId: Int!
  "Number of required approvals for a given rule."
  approvalsRequired: Int!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IDs of groups as approvers."
  groupIds: [String!] = []
  "IID of the merge request to mutate."
  iid: String!
  "Name of the approval rule."
  name: String!
  "Project the merge request to mutate is in."
  projectPath: ID!
  "Whether hidden groups should be removed."
  removeHiddenGroups: Boolean = false
  "IDs of users as approvers."
  userIds: [String!] = []
}

"Autogenerated input type of MergeRequestUpdate"
input MergeRequestUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the merge request (Markdown rendered as HTML for caching)."
  description: String
  "IID of the merge request to mutate."
  iid: String!
  "Project the merge request to mutate is in."
  projectPath: ID!
  "Action to perform to change the state."
  state: MergeRequestNewState
  "Target branch of the merge request."
  targetBranch: String
  "Estimated time to complete the merge request. Use `null` or `0` to remove the current estimate."
  timeEstimate: String
  "Title of the merge request."
  title: String
}

input MergeRequestsResolverNegatedParams {
  "Array of label names. All resolved merge requests will not have these labels."
  labels: [String!]
  "Title of the milestone."
  milestoneTitle: String
}

"Autogenerated input type of MlModelCreate"
input MlModelCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the model."
  description: String
  "Name of the model."
  name: String!
  "Project the model to mutate is in."
  projectPath: ID!
}

"A year and month input for querying product analytics usage data."
input MonthSelectionInput {
  "Month of the period to return."
  month: Int!
  "Year of the period to return."
  year: Int!
}

"Autogenerated input type of NamespaceBanDestroy"
input NamespaceBanDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the namespace ban to remove."
  id: NamespacesNamespaceBanID!
}

"Autogenerated input type of NamespaceCiCdSettingsUpdate"
input NamespaceCiCdSettingsUpdateInput {
  "Indicates if stale runners directly belonging to this namespace should be periodically pruned."
  allowStaleRunnerPruning: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the namespace the settings belong to."
  fullPath: ID!
}

"Autogenerated input type of NamespaceIncreaseStorageTemporarily"
input NamespaceIncreaseStorageTemporarilyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the namespace to mutate."
  id: NamespaceID!
}

input NegatedBoardIssueInput {
  "Filter by assignee username."
  assigneeUsername: [String]
  "Filter by author username."
  authorUsername: String
  "Filter by epic ID. Incompatible with epicWildcardId."
  epicId: EpicID
  """

  Health status not applied to the issue.
  Includes issues where health status is not set.
  """
  healthStatusFilter: HealthStatus
  "List of IIDs of issues. For example `[\"1\", \"2\"]`."
  iids: [String!]
  "Filter by a list of iteration IDs. Incompatible with iterationWildcardId."
  iterationId: [IterationID!]
  "Filter by iteration title."
  iterationTitle: String
  "Filter by iteration ID wildcard."
  iterationWildcardId: NegatedIterationWildcardId
  "Filter by label name."
  labelName: [String]
  "Filter by milestone title."
  milestoneTitle: String
  "Filter by milestone ID wildcard."
  milestoneWildcardId: MilestoneWildcardId
  "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
  myReactionEmoji: String
  "Filter by release tag."
  releaseTag: String
  "Filter by the given issue types."
  types: [IssueType!]
  "Filter by weight."
  weight: String
}

input NegatedComplianceFrameworkFilters {
  "ID of the compliance framework."
  id: ComplianceManagementFrameworkID
}

input NegatedEpicBoardIssueInput {
  "Filter by author username."
  authorUsername: String
  "Filter by label name."
  labelName: [String]
  "Filter by reaction emoji applied by the current user. Wildcard values \"NONE\" and \"ANY\" are supported."
  myReactionEmoji: String
}

input NegatedEpicFilterInput {
  "Filter by author username."
  authorUsername: String
  "Filter by label name."
  labelName: [String]
  "Filter by reaction emoji applied by the current user."
  myReactionEmoji: String
}

input NegatedIssueFilterInput {
  "ID of a user not assigned to the issues."
  assigneeId: String
  "Usernames of users not assigned to the issue."
  assigneeUsernames: [String!]
  "Username of a user who didn't author the issue."
  authorUsername: [String!]
  "ID of an epic not associated with the issues."
  epicId: String
  """

  Health status not applied to the issue.
  Includes issues where health status is not set.
  """
  healthStatusFilter: [HealthStatus!]
  "List of IIDs of issues to exclude. For example, `[1, 2]`."
  iids: [String!]
  "List of iteration Global IDs not applied to the issue."
  iterationId: [ID!]
  "Filter by negated iteration ID wildcard."
  iterationWildcardId: IterationWildcardId
  "Labels not applied to this issue."
  labelName: [String!]
  "Milestone not applied to this issue."
  milestoneTitle: [String!]
  "Filter by negated milestone wildcard values."
  milestoneWildcardId: NegatedMilestoneWildcardId
  "Filter by reaction emoji applied by the current user."
  myReactionEmoji: String
  "Release tag not associated with the issue's milestone. Ignored when parent is a group."
  releaseTag: [String!]
  "Filters out issues by the given issue types."
  types: [IssueType!]
  "Weight not applied to the issue."
  weight: String
}

input NegatedValueStreamAnalyticsIssueFilterInput {
  "Usernames of users not assigned to the issue."
  assigneeUsernames: [String!]
  "Username of a user who didn't author the issue."
  authorUsername: String
  "ID of an epic not associated with the issues."
  epicId: ID
  "List of iteration Global IDs not applied to the issue."
  iterationId: ID
  "Labels not applied to this issue."
  labelNames: [String!]
  "Milestone not applied to this issue."
  milestoneTitle: String
  "Filter by reaction emoji applied by the current user."
  myReactionEmoji: String
  "Weight not applied to the issue."
  weight: Int
}

"Active period time range for on-call rotation"
input OncallRotationActivePeriodInputType {
  "End of the rotation active period in 24 hour format. For example, \"18:30\"."
  endTime: String!
  "Start of the rotation active period in 24 hour format. For example, \"18:30\"."
  startTime: String!
}

"Autogenerated input type of OncallRotationCreate"
input OncallRotationCreateInput {
  "Active period of time that the on-call rotation should take place."
  activePeriod: OncallRotationActivePeriodInputType
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "End date and time of the on-call rotation, in the timezone of the on-call schedule."
  endsAt: OncallRotationDateInputType
  "Name of the on-call rotation."
  name: String!
  "Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies."
  participants: [OncallUserInputType!]!
  "Project to create the on-call schedule in."
  projectPath: ID!
  "Rotation length of the on-call rotation."
  rotationLength: OncallRotationLengthInputType!
  "IID of the on-call schedule to create the on-call rotation in."
  scheduleIid: String!
  "Start date and time of the on-call rotation, in the timezone of the on-call schedule."
  startsAt: OncallRotationDateInputType!
}

"Date input type for on-call rotation"
input OncallRotationDateInputType {
  "Date component of the date in YYYY-MM-DD format."
  date: String!
  "Time component of the date in 24hr HH:MM format."
  time: String!
}

"Autogenerated input type of OncallRotationDestroy"
input OncallRotationDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the on-call rotation to remove."
  id: IncidentManagementOncallRotationID!
  "Project to remove the on-call schedule from."
  projectPath: ID!
  "IID of the on-call schedule to the on-call rotation belongs to."
  scheduleIid: String!
}

"The rotation length of the on-call rotation"
input OncallRotationLengthInputType {
  "Rotation length of the on-call rotation."
  length: Int!
  "Unit of the rotation length of the on-call rotation."
  unit: OncallRotationUnitEnum!
}

"Autogenerated input type of OncallRotationUpdate"
input OncallRotationUpdateInput {
  "Active period of time that the on-call rotation should take place."
  activePeriod: OncallRotationActivePeriodInputType
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "End date and time of the on-call rotation, in the timezone of the on-call schedule."
  endsAt: OncallRotationDateInputType
  "ID of the on-call schedule to create the on-call rotation in."
  id: IncidentManagementOncallRotationID!
  "Name of the on-call rotation."
  name: String
  "Usernames of users participating in the on-call rotation. A maximum limit of 100 participants applies."
  participants: [OncallUserInputType!]
  "Rotation length of the on-call rotation."
  rotationLength: OncallRotationLengthInputType
  "Start date and time of the on-call rotation, in the timezone of the on-call schedule."
  startsAt: OncallRotationDateInputType
}

"Autogenerated input type of OncallScheduleCreate"
input OncallScheduleCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the on-call schedule."
  description: String
  "Name of the on-call schedule."
  name: String!
  "Project to create the on-call schedule in."
  projectPath: ID!
  "Timezone of the on-call schedule."
  timezone: String!
}

"Autogenerated input type of OncallScheduleDestroy"
input OncallScheduleDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "On-call schedule internal ID to remove."
  iid: String!
  "Project to remove the on-call schedule from."
  projectPath: ID!
}

"Autogenerated input type of OncallScheduleUpdate"
input OncallScheduleUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the on-call schedule."
  description: String
  "On-call schedule internal ID to update."
  iid: String!
  "Name of the on-call schedule."
  name: String
  "Project to update the on-call schedule in."
  projectPath: ID!
  "Timezone of the on-call schedule."
  timezone: String
}

"The rotation user and color palette"
input OncallUserInputType {
  "Value of DataVisualizationColorEnum. The color from the palette to assign to the on-call user."
  colorPalette: DataVisualizationColorEnum
  "Color weight to assign to for the on-call user. To view on-call schedules in GitLab, do not provide a value below 500. A value between 500 and 950 ensures sufficient contrast."
  colorWeight: DataVisualizationWeightEnum
  "Username of the user to participate in the on-call rotation. For example, `\"user_one\"`."
  username: String!
}

"Autogenerated input type of OrganizationCreate"
input OrganizationCreateInput {
  "Avatar for the organization."
  avatar: Upload
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the organization."
  description: String
  "Name for the organization."
  name: String!
  "Path for the organization."
  path: String!
}

"Autogenerated input type of OrganizationUpdate"
input OrganizationUpdateInput {
  "Avatar for the organization."
  avatar: Upload
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the organization."
  description: String
  "ID of the organization to mutate."
  id: OrganizationsOrganizationID!
  "Name for the organization."
  name: String
  "Path for the organization."
  path: String
}

"Autogenerated input type of PagesMarkOnboardingComplete"
input PagesMarkOnboardingCompleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  projectPath: ID!
}

"Autogenerated input type of PipelineCancel"
input PipelineCancelInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline to mutate."
  id: CiPipelineID!
}

"Autogenerated input type of PipelineDestroy"
input PipelineDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline to mutate."
  id: CiPipelineID!
}

"Autogenerated input type of PipelineRetry"
input PipelineRetryInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline to mutate."
  id: CiPipelineID!
}

"Autogenerated input type of PipelineScheduleCreate"
input PipelineScheduleCreateInput {
  "Indicates if the pipeline schedule should be active or not."
  active: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Cron expression of the pipeline schedule."
  cron: String!
  """

  Cron time zone supported by ActiveSupport::TimeZone.
  For example: "Pacific Time (US & Canada)" (default: "UTC").
  """
  cronTimezone: String
  "Description of the pipeline schedule."
  description: String!
  "Full path of the project the pipeline schedule is associated with."
  projectPath: ID!
  "Ref of the pipeline schedule."
  ref: String!
  "Variables for the pipeline schedule."
  variables: [PipelineScheduleVariableInput!]
}

"Autogenerated input type of PipelineScheduleDelete"
input PipelineScheduleDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
}

"Autogenerated input type of PipelineSchedulePlay"
input PipelineSchedulePlayInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
}

"Autogenerated input type of PipelineScheduleTakeOwnership"
input PipelineScheduleTakeOwnershipInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
}

"Autogenerated input type of PipelineScheduleUpdate"
input PipelineScheduleUpdateInput {
  "Indicates if the pipeline schedule should be active or not."
  active: Boolean
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Cron expression of the pipeline schedule."
  cron: String
  """

  Cron time zone supported by ActiveSupport::TimeZone.
  For example: "Pacific Time (US & Canada)" (default: "UTC").
  """
  cronTimezone: String
  "Description of the pipeline schedule."
  description: String
  "ID of the pipeline schedule to mutate."
  id: CiPipelineScheduleID!
  "Ref of the pipeline schedule."
  ref: String
  "Variables for the pipeline schedule."
  variables: [PipelineScheduleVariableInput!]
}

"Attributes for the pipeline schedule variable."
input PipelineScheduleVariableInput {
  "Boolean option to destroy the variable."
  destroy: Boolean
  "ID of the variable to mutate."
  id: CiPipelineScheduleVariableID
  "Name of the variable."
  key: String!
  "Value of the variable."
  value: String!
  "Type of the variable."
  variableType: CiVariableType!
}

"Autogenerated input type of PipelineTriggerCreate"
input PipelineTriggerCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the pipeline trigger token."
  description: String!
  "Full path of the project that the pipeline trigger token to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of PipelineTriggerDelete"
input PipelineTriggerDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the pipeline trigger token to mutate."
  id: CiTriggerID!
}

"Autogenerated input type of PipelineTriggerUpdate"
input PipelineTriggerUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the pipeline trigger token."
  description: String!
  "ID of the pipeline trigger token to mutate."
  id: CiTriggerID!
}

"Autogenerated input type of ProjectCiCdSettingsUpdate"
input ProjectCiCdSettingsUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full Path of the project the settings belong to."
  fullPath: ID!
  "Indicates CI/CD job tokens generated in other projects have restricted access to this project."
  inboundJobTokenScopeEnabled: Boolean
  "Indicates if the latest artifact should be kept for the project."
  keepLatestArtifact: Boolean
  "Indicates if merged results pipelines are enabled for the project."
  mergePipelinesEnabled: Boolean
  "Indicates if merge trains are enabled for the project."
  mergeTrainsEnabled: Boolean
  "Indicates whether an option is allowed to merge without refreshing the merge train. Ignored unless the `merge_trains_skip_train` feature flag is also enabled."
  mergeTrainsSkipTrainAllowed: Boolean
}

"Autogenerated input type of ProjectInitializeProductAnalytics"
input ProjectInitializeProductAnalyticsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project to initialize."
  projectPath: ID!
}

"Autogenerated input type of ProjectMemberBulkUpdate"
input ProjectMemberBulkUpdateInput {
  "Access level to update the members to."
  accessLevel: MemberAccessLevel!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Date and time the membership expires."
  expiresAt: Time
  "Global ID of the project."
  projectId: ProjectID!
  "Global IDs of the members."
  userIds: [UserID!]!
}

"Autogenerated input type of ProjectSetComplianceFramework"
input ProjectSetComplianceFrameworkInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the compliance framework to assign to the project. Set to `null` to unset."
  complianceFrameworkId: ComplianceManagementFrameworkID
  "ID of the project to change the compliance framework of."
  projectId: ProjectID!
}

"Autogenerated input type of ProjectSetContinuousVulnerabilityScanning"
input ProjectSetContinuousVulnerabilityScanningInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Desired status for Continuous Vulnerability Scanning feature."
  enable: Boolean!
  "Full path of the project."
  projectPath: ID!
}

"Autogenerated input type of ProjectSetLocked"
input ProjectSetLockedInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path to the file."
  filePath: String!
  "Whether or not to lock the file path."
  lock: Boolean!
  "Full path of the project to mutate."
  projectPath: ID!
}

"Autogenerated input type of ProjectSubscriptionCreate"
input ProjectSubscriptionCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the downstream project of the Project Subscription."
  projectPath: String!
  "Full path of the upstream project of the Project Subscription."
  upstreamPath: String!
}

"Autogenerated input type of ProjectSubscriptionDelete"
input ProjectSubscriptionDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the subscription to delete."
  subscriptionId: CiSubscriptionsProjectID!
}

"Autogenerated input type of ProjectSyncFork"
input ProjectSyncForkInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project to initialize."
  projectPath: ID!
  "Ref of the fork to fetch into."
  targetBranch: String!
}

"Autogenerated input type of PrometheusIntegrationCreate"
input PrometheusIntegrationCreateInput {
  "Whether the integration is receiving alerts."
  active: Boolean!
  "Endpoint at which Prometheus can be queried."
  apiUrl: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Project to create the integration in."
  projectPath: ID!
}

"Autogenerated input type of PrometheusIntegrationResetToken"
input PrometheusIntegrationResetTokenInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: IntegrationsPrometheusID!
}

"Autogenerated input type of PrometheusIntegrationUpdate"
input PrometheusIntegrationUpdateInput {
  "Whether the integration is receiving alerts."
  active: Boolean
  "Endpoint at which Prometheus can be queried."
  apiUrl: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the integration to mutate."
  id: IntegrationsPrometheusID!
}

"Autogenerated input type of PromoteToEpic"
input PromoteToEpicInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Group the promoted epic will belong to."
  groupPath: ID
  "IID of the issue to mutate."
  iid: String!
  "Project the issue to mutate is in."
  projectPath: ID!
}

"Autogenerated input type of ReleaseAssetLinkCreate"
input ReleaseAssetLinkCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Relative path for a direct asset link."
  directAssetPath: String
  "Type of the asset link."
  linkType: ReleaseAssetLinkType = OTHER
  "Name of the asset link."
  name: String!
  "Full path of the project the asset link is associated with."
  projectPath: ID!
  "Name of the associated release's tag."
  tagName: String!
  "URL of the asset link."
  url: String!
}

"Autogenerated input type of ReleaseAssetLinkDelete"
input ReleaseAssetLinkDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the release asset link to delete."
  id: ReleasesLinkID!
}

"Fields that are available when modifying a release asset link"
input ReleaseAssetLinkInput {
  "Relative path for a direct asset link."
  directAssetPath: String
  "Type of the asset link."
  linkType: ReleaseAssetLinkType = OTHER
  "Name of the asset link."
  name: String!
  "URL of the asset link."
  url: String!
}

"Autogenerated input type of ReleaseAssetLinkUpdate"
input ReleaseAssetLinkUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Relative path for a direct asset link."
  directAssetPath: String
  "ID of the release asset link to update."
  id: ReleasesLinkID!
  "Type of the asset link."
  linkType: ReleaseAssetLinkType
  "Name of the asset link."
  name: String
  "URL of the asset link."
  url: String
}

"Fields that are available when modifying release assets"
input ReleaseAssetsInput {
  "List of asset links to associate to the release."
  links: [ReleaseAssetLinkInput!]
}

"Autogenerated input type of ReleaseCreate"
input ReleaseCreateInput {
  "Assets associated to the release."
  assets: ReleaseAssetsInput
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description (also known as \"release notes\") of the release."
  description: String
  "Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones."
  milestones: [String!]
  "Name of the release."
  name: String
  "Full path of the project the release is associated with."
  projectPath: ID!
  "Commit SHA or branch name to use if creating a new tag."
  ref: String
  "Date and time for the release. Defaults to the current time. Expected in ISO 8601 format (`2019-03-15T08:00:00Z`). Only provide this field if creating an upcoming or historical release."
  releasedAt: Time
  "Message to use if creating a new annotated tag."
  tagMessage: String
  "Name of the tag to associate with the release."
  tagName: String!
}

"Autogenerated input type of ReleaseDelete"
input ReleaseDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project the release is associated with."
  projectPath: ID!
  "Name of the tag associated with the release to delete."
  tagName: String!
}

"Autogenerated input type of ReleaseUpdate"
input ReleaseUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description (release notes) of the release."
  description: String
  "Title of each milestone the release is associated with. GitLab Premium customers can specify group milestones."
  milestones: [String!]
  "Name of the release."
  name: String
  "Full path of the project the release is associated with."
  projectPath: ID!
  "Release date."
  releasedAt: Time
  "Name of the tag associated with the release."
  tagName: String!
}

"Autogenerated input type of RemoveProjectFromSecurityDashboard"
input RemoveProjectFromSecurityDashboardInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the project to remove from the Instance Security Dashboard."
  id: ProjectID!
}

"Autogenerated input type of RepositionImageDiffNote"
input RepositionImageDiffNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the DiffNote to update."
  id: DiffNoteID!
  "Position of this note on a diff."
  position: UpdateDiffImagePositionInput!
}

input RequirementLegacyFilterInput {
  "List of legacy requirement IIDs of work items. or example `[\"1\", \"2\"]`."
  legacyIids: [String!]!
}

"Autogenerated input type of RunnerCreate"
input RunnerCreateInput {
  "Access level of the runner."
  accessLevel: CiRunnerAccessLevel
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the runner."
  description: String
  "Global ID of the group that the runner is created in (valid only for group runner)."
  groupId: GroupID
  "Indicates the runner is locked."
  locked: Boolean
  "Runner's maintenance notes."
  maintenanceNote: String
  "Maximum timeout (in seconds) for jobs processed by the runner."
  maximumTimeout: Int
  "Indicates the runner is not allowed to receive jobs."
  paused: Boolean
  "Global ID of the project that the runner is created in (valid only for project runner)."
  projectId: ProjectID
  "Indicates the runner is able to run untagged jobs."
  runUntagged: Boolean
  "Type of the runner to create."
  runnerType: CiRunnerType!
  "Tags associated with the runner."
  tagList: [String!]
}

"Autogenerated input type of RunnerDelete"
input RunnerDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the runner to delete."
  id: CiRunnerID!
}

"Autogenerated input type of RunnerUpdate"
input RunnerUpdateInput {
  "Access level of the runner."
  accessLevel: CiRunnerAccessLevel
  "Projects associated with the runner. Available only for project runners."
  associatedProjects: [ProjectID!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the runner."
  description: String
  "ID of the runner to update."
  id: CiRunnerID!
  "Indicates the runner is locked."
  locked: Boolean
  "Runner's maintenance notes."
  maintenanceNote: String
  "Maximum timeout (in seconds) for jobs processed by the runner."
  maximumTimeout: Int
  "Indicates the runner is not allowed to receive jobs."
  paused: Boolean
  "Private projects' \"compute cost factor\" associated with the runner (GitLab.com only)."
  privateProjectsMinutesCostFactor: Float
  "Public projects' \"compute cost factor\" associated with the runner (GitLab.com only)."
  publicProjectsMinutesCostFactor: Float
  "Indicates the runner is able to run untagged jobs."
  runUntagged: Boolean
  "Tags associated with the runner."
  tagList: [String!]
}

"Autogenerated input type of RunnersExportUsage"
input RunnersExportUsageInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "UTC start date of the period to report on. Defaults to the start of last full month."
  fromDate: ISO8601Date
  "Maximum number of projects to return. All other runner usage will be attributed to an `<Other projects>` entry. Defaults to 1000 projects."
  maxProjectCount: Int = 1000
  """

  UTC end date of the period to report on. " \
  "Defaults to the end of the month specified by `fromDate`.
  """
  toDate: ISO8601Date
  "Scope of the runners to include in the report."
  type: CiRunnerType
}

"Autogenerated input type of RunnersRegistrationTokenReset"
input RunnersRegistrationTokenResetInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the project or group to reset the token for. Omit if resetting instance runner token."
  id: ID
  "Scope of the object to reset the token for."
  type: CiRunnerType!
}

"Represents the analyzers entity in SAST CI configuration"
input SastCiConfigurationAnalyzersEntityInput {
  "State of the analyzer."
  enabled: Boolean!
  "Name of analyzer."
  name: String!
  "List of variables for the analyzer."
  variables: [SastCiConfigurationEntityInput!]
}

"Represents an entity in SAST CI configuration"
input SastCiConfigurationEntityInput {
  "Default value that is used if value is empty."
  defaultValue: String!
  "CI keyword of entity."
  field: String!
  "Current value of the entity."
  value: String!
}

"Represents a CI configuration of SAST"
input SastCiConfigurationInput {
  "List of analyzers and related variables for the SAST configuration."
  analyzers: [SastCiConfigurationAnalyzersEntityInput!]
  "List of global entities related to SAST configuration."
  global: [SastCiConfigurationEntityInput!]
  "List of pipeline entities related to SAST configuration."
  pipeline: [SastCiConfigurationEntityInput!]
}

"Autogenerated input type of SavedReplyCreate"
input SavedReplyCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Content of the saved reply."
  content: String!
  "Name of the saved reply."
  name: String!
}

"Autogenerated input type of SavedReplyDestroy"
input SavedReplyDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the saved reply."
  id: UsersSavedReplyID!
}

"Autogenerated input type of SavedReplyUpdate"
input SavedReplyUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Content of the saved reply."
  content: String!
  "Global ID of the saved reply."
  id: UsersSavedReplyID!
  "Name of the saved reply."
  name: String!
}

"Autogenerated input type of ScanExecutionPolicyCommit"
input ScanExecutionPolicyCommitInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project."
  fullPath: String
  "Name of the policy. If the name is null, the `name` field from `policy_yaml` is used."
  name: String!
  "Changes the operation mode."
  operationMode: MutationOperationMode!
  "YAML snippet of the policy."
  policyYaml: String!
}

"Autogenerated input type of SecurityFindingCreateIssue"
input SecurityFindingCreateIssueInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the project to attach the issue to."
  project: ProjectID!
  "UUID of the security finding to be used to create an issue."
  uuid: String!
}

"Autogenerated input type of SecurityFindingCreateMergeRequest"
input SecurityFindingCreateMergeRequestInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "UUID of the security finding to be used to create a merge request."
  uuid: String!
}

"Autogenerated input type of SecurityFindingDismiss"
input SecurityFindingDismissInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment why finding should be dismissed."
  comment: String
  "Reason why finding should be dismissed."
  dismissalReason: VulnerabilityDismissalReason
  "UUID of the finding to be dismissed."
  uuid: String!
}

"Autogenerated input type of SecurityFindingRevertToDetected"
input SecurityFindingRevertToDetectedInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment that explains why finding was reverted to detected status."
  comment: String
  "UUID of the finding to be dismissed."
  uuid: String!
}

"Autogenerated input type of SecurityPolicyProjectAssign"
input SecurityPolicyProjectAssignInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project or group."
  fullPath: String
  "ID of the security policy project."
  securityPolicyProjectId: ProjectID!
}

"Autogenerated input type of SecurityPolicyProjectCreate"
input SecurityPolicyProjectCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project or group."
  fullPath: String
}

"Autogenerated input type of SecurityPolicyProjectUnassign"
input SecurityPolicyProjectUnassignInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project or group."
  fullPath: String
}

"Autogenerated input type of SecurityTrainingUpdate"
input SecurityTrainingUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Sets the training provider as enabled for the project."
  isEnabled: Boolean!
  "Sets the training provider as primary for the project."
  isPrimary: Boolean
  "Full path of the project."
  projectPath: ID!
  "ID of the provider."
  providerId: SecurityTrainingProviderID!
}

"Represents an action to perform over a snippet file"
input SnippetBlobActionInputType {
  "Type of input action."
  action: SnippetBlobActionEnum!
  "Snippet file content."
  content: String
  "Path of the snippet file."
  filePath: String!
  "Previous path of the snippet file."
  previousPath: String
}

"Autogenerated input type of StarProject"
input StarProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Full path of the project to star or unstar."
  projectId: ProjectID!
  "Indicates whether to star or unstar the project."
  starred: Boolean!
}

input StatusFilterInput {
  "Status of the work item."
  status: RequirementStatusFilter!
}

input StatusInput {
  "Status to assign to the work item."
  status: TestReportState!
}

"Autogenerated input type of TerraformStateDelete"
input TerraformStateDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Terraform state."
  id: TerraformStateID!
}

"Autogenerated input type of TerraformStateLock"
input TerraformStateLockInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Terraform state."
  id: TerraformStateID!
}

"Autogenerated input type of TerraformStateUnlock"
input TerraformStateUnlockInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the Terraform state."
  id: TerraformStateID!
}

"A time-frame defined as a closed inclusive range of two dates"
input Timeframe {
  "End of the range."
  end: Date!
  "Start of the range."
  start: Date!
}

"Autogenerated input type of TimelineEventCreate"
input TimelineEventCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Incident ID of the timeline event."
  incidentId: IssueID!
  "Text note of the timeline event."
  note: String!
  "Timestamp of when the event occurred."
  occurredAt: Time!
  "Tags for the incident timeline event."
  timelineEventTagNames: [String!]
}

"Autogenerated input type of TimelineEventDestroy"
input TimelineEventDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Timeline event ID to remove."
  id: IncidentManagementTimelineEventID!
}

"Autogenerated input type of TimelineEventPromoteFromNote"
input TimelineEventPromoteFromNoteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Note ID from which the timeline event promoted."
  noteId: NoteID!
}

"Autogenerated input type of TimelineEventTagCreate"
input TimelineEventTagCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Name of the tag."
  name: String!
  "Project to create the timeline event tag in."
  projectPath: ID!
}

"Autogenerated input type of TimelineEventUpdate"
input TimelineEventUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the timeline event to update."
  id: IncidentManagementTimelineEventID!
  "Text note of the timeline event."
  note: String
  "Timestamp when the event occurred."
  occurredAt: Time
  "Tags for the incident timeline event."
  timelineEventTagNames: [String!]
}

"Autogenerated input type of TimelogCreate"
input TimelogCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the issuable (Issue, WorkItem or MergeRequest)."
  issuableId: IssuableID!
  "When the time was spent."
  spentAt: Time!
  "Summary of time spent."
  summary: String!
  "Amount of time spent."
  timeSpent: String!
}

"Autogenerated input type of TimelogDelete"
input TimelogDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the timelog."
  id: TimelogID!
}

"Autogenerated input type of TodoCreate"
input TodoCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported."
  targetId: TodoableID!
}

"Autogenerated input type of TodoMarkDone"
input TodoMarkDoneInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item to mark as done."
  id: TodoID!
}

"Autogenerated input type of TodoRestore"
input TodoRestoreInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item to restore."
  id: TodoID!
}

"Autogenerated input type of TodoRestoreMany"
input TodoRestoreManyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the to-do items to restore (a maximum of 50 is supported at once)."
  ids: [TodoID!]!
}

"Autogenerated input type of TodosMarkAllDone"
input TodosMarkAllDoneInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the to-do item's parent. Issues, merge requests, designs, and epics are supported. If argument is omitted, all pending to-do items of the current user are marked as done."
  targetId: TodoableID
}

input UnionedEpicFilterInput {
  "Filters epics that are authored by one of the given users."
  authorUsernames: [String!]
  "Filters epics that have at least one of the given labels."
  labelNames: [String!]
}

input UnionedIssueFilterInput {
  "Filters issues that are assigned to at least one of the given users."
  assigneeUsernames: [String!]
  "Filters issues that are authored by one of the given users."
  authorUsernames: [String!]
  "Filters issues that have at least one of the given labels."
  labelNames: [String!]
}

"Autogenerated input type of UpdateAlertStatus"
input UpdateAlertStatusInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IID of the alert to mutate."
  iid: String!
  "Project the alert to mutate is in."
  projectPath: ID!
  "Status to set the alert."
  status: AlertManagementStatus!
}

"Autogenerated input type of UpdateBoardEpicUserPreferences"
input UpdateBoardEpicUserPreferencesInput {
  "Board global ID."
  boardId: BoardID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Whether the epic should be collapsed in the board."
  collapsed: Boolean!
  "ID of an epic to set preferences for."
  epicId: EpicID!
}

"Autogenerated input type of UpdateBoard"
input UpdateBoardInput {
  "ID of user to be assigned to the board."
  assigneeId: UserID
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Whether or not backlog list is hidden."
  hideBacklogList: Boolean
  "Whether or not closed list is hidden."
  hideClosedList: Boolean
  "Board global ID."
  id: BoardID!
  "ID of iteration cadence to be assigned to the board."
  iterationCadenceId: IterationsCadenceID
  "ID of iteration to be assigned to the board."
  iterationId: IterationID
  "IDs of labels to be added to the board."
  labelIds: [LabelID!]
  "Labels of the issue."
  labels: [String!]
  "ID of milestone to be assigned to the board."
  milestoneId: MilestoneID
  "Board name."
  name: String
  "Weight value to be assigned to the board."
  weight: Int
}

"Autogenerated input type of UpdateBoardList"
input UpdateBoardListInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates if the list is collapsed for the user."
  collapsed: Boolean
  "Global ID of the list."
  listId: ListID!
  "Position of list within the board."
  position: Int
}

"Autogenerated input type of UpdateComplianceFramework"
input UpdateComplianceFrameworkInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the compliance framework to update."
  id: ComplianceManagementFrameworkID!
  "Parameters to update the compliance framework with."
  params: ComplianceFrameworkInput!
}

"Autogenerated input type of UpdateContainerExpirationPolicy"
input UpdateContainerExpirationPolicyInput {
  "This container expiration policy schedule."
  cadence: ContainerExpirationPolicyCadenceEnum
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates whether this container expiration policy is enabled."
  enabled: Boolean
  "Number of tags to retain."
  keepN: ContainerExpirationPolicyKeepEnum
  "Tags with names matching this regex pattern will expire."
  nameRegex: UntrustedRegexp
  "Tags with names matching this regex pattern will be preserved."
  nameRegexKeep: UntrustedRegexp
  "Tags older that this will expire."
  olderThan: ContainerExpirationPolicyOlderThanEnum
  "Project path where the container expiration policy is located."
  projectPath: ID!
}

"Autogenerated input type of UpdateContainerRegistryProtectionRule"
input UpdateContainerRegistryProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Maximum GitLab access level prevented from deleting a container. For example, `DEVELOPER`, `MAINTAINER`, `OWNER`."
  deleteProtectedUpToAccessLevel: ContainerRegistryProtectionRuleAccessLevel
  "Global ID of the container registry protection rule to be updated."
  id: ContainerRegistryProtectionRuleID!
  "Maximum GitLab access level prevented from pushing a container. For example, `DEVELOPER`, `MAINTAINER`, `OWNER`."
  pushProtectedUpToAccessLevel: ContainerRegistryProtectionRuleAccessLevel
  "Container's repository path pattern of the protection rule. For example, `my-scope/my-project/container-dev-*`. Wildcard character `*` allowed."
  repositoryPathPattern: String
}

"Autogenerated input type of UpdateDependencyProxyImageTtlGroupPolicy"
input UpdateDependencyProxyImageTtlGroupPolicyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates whether the policy is enabled or disabled."
  enabled: Boolean
  "Group path for the group dependency proxy image TTL policy."
  groupPath: ID!
  "Number of days to retain a cached image file."
  ttl: Int
}

"Autogenerated input type of UpdateDependencyProxyPackagesSettings"
input UpdateDependencyProxyPackagesSettingsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates whether the dependency proxy for packages is enabled for the project. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  enabled: Boolean
  "Password for the external Maven packages registry. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  mavenExternalRegistryPassword: String
  "URL for the external Maven packages registry. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  mavenExternalRegistryUrl: String
  "Username for the external Maven packages registry. Introduced in 16.5: This feature is an Experiment. It can be changed or removed at any time."
  mavenExternalRegistryUsername: String
  "Project path for the dependency proxy for packages settings."
  projectPath: ID!
}

"Autogenerated input type of UpdateDependencyProxySettings"
input UpdateDependencyProxySettingsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates whether the policy is enabled or disabled."
  enabled: Boolean
  "Group path for the group dependency proxy."
  groupPath: ID!
}

input UpdateDiffImagePositionInput {
  "Total height of the image."
  height: Int
  "Total width of the image."
  width: Int
  "X position of the note."
  x: Int
  "Y position of the note."
  y: Int
}

"Autogenerated input type of UpdateEpicBoardList"
input UpdateEpicBoardListInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates if the list is collapsed for the user."
  collapsed: Boolean
  "Global ID of the epic list."
  listId: BoardsEpicListID!
  "Position of list within the board."
  position: Int
}

"Autogenerated input type of UpdateEpic"
input UpdateEpicInput {
  "IDs of labels to be added to the epic."
  addLabelIds: [ID!]
  "Array of labels to be added to the epic."
  addLabels: [String!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Color of the epic. Available only when feature flag `epic_color_highlight` is enabled. This flag is disabled by default, because the feature is experimental and is subject to change without notice."
  color: Color
  "Indicates if the epic is confidential."
  confidential: Boolean
  "Description of the epic."
  description: String
  "End date of the epic."
  dueDateFixed: String
  "Indicates end date should be sourced from due_date_fixed field not the issue milestones."
  dueDateIsFixed: Boolean
  "Group the epic to mutate is in."
  groupPath: ID!
  "IID of the epic to mutate."
  iid: ID!
  "IDs of labels to be removed from the epic."
  removeLabelIds: [ID!]
  "Array of labels to be removed from the epic."
  removeLabels: [String!]
  "Start date of the epic."
  startDateFixed: String
  "Indicates start date should be sourced from start_date_fixed field not the issue milestones."
  startDateIsFixed: Boolean
  "State event for the epic."
  stateEvent: EpicStateEvent
  "Title of the epic."
  title: String
}

"Autogenerated input type of UpdateImageDiffNote"
input UpdateImageDiffNoteInput {
  "Content of the note."
  body: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the note to update."
  id: NoteID!
  "Position of this note on a diff."
  position: UpdateDiffImagePositionInput
}

"Autogenerated input type of UpdateIssue"
input UpdateIssueInput {
  "IDs of labels to be added to the issue."
  addLabelIds: [ID!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Indicates the issue is confidential."
  confidential: Boolean
  "Description of the issue."
  description: String
  "Due date of the issue."
  dueDate: ISO8601Date
  "ID of the parent epic. NULL when removing the association."
  epicId: EpicID
  "Desired health status."
  healthStatus: HealthStatus
  "IID of the issue to mutate."
  iid: String!
  "IDs of labels to be set. Replaces existing issue labels."
  labelIds: [ID!]
  "Indicates discussion is locked on the issue."
  locked: Boolean
  "ID of the milestone to assign to the issue. On update milestone will be removed if set to null."
  milestoneId: ID
  "Project the issue to mutate is in."
  projectPath: ID!
  "IDs of labels to be removed from the issue."
  removeLabelIds: [ID!]
  "Close or reopen an issue."
  stateEvent: IssueStateEvent
  "Estimated time to complete the issue. Use `null` or `0` to remove the current estimate."
  timeEstimate: String
  "Title of the issue."
  title: String
  "Type of the issue."
  type: IssueType
  "Weight of the issue."
  weight: Int
}

"Autogenerated input type of UpdateIteration"
input UpdateIterationInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the iteration."
  description: String
  "End date of the iteration."
  dueDate: String
  "Group of the iteration."
  groupPath: ID!
  "Global ID of the iteration."
  id: ID!
  "Start date of the iteration."
  startDate: String
  "Title of the iteration."
  title: String
}

"Autogenerated input type of UpdateNamespacePackageSettings"
input UpdateNamespacePackageSettingsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "When generic_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  genericDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate generic packages are allowed for this namespace."
  genericDuplicatesAllowed: Boolean
  "Indicates whether Maven package forwarding is locked for all descendent namespaces."
  lockMavenPackageRequestsForwarding: Boolean
  "Indicates whether npm package forwarding is locked for all descendent namespaces."
  lockNpmPackageRequestsForwarding: Boolean
  "Indicates whether PyPI package forwarding is locked for all descendent namespaces."
  lockPypiPackageRequestsForwarding: Boolean
  "When maven_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  mavenDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate Maven packages are allowed for this namespace."
  mavenDuplicatesAllowed: Boolean
  "Indicates whether Maven package forwarding is allowed for this namespace."
  mavenPackageRequestsForwarding: Boolean
  "Namespace path where the namespace package setting is located."
  namespacePath: ID!
  "Indicates whether npm package forwarding is allowed for this namespace."
  npmPackageRequestsForwarding: Boolean
  "When nuget_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect. "
  nugetDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate NuGet packages are allowed for this namespace."
  nugetDuplicatesAllowed: Boolean
  "Indicates wheather the NuGet symbol server is enabled for this namespace."
  nugetSymbolServerEnabled: Boolean
  "Indicates whether PyPI package forwarding is allowed for this namespace."
  pypiPackageRequestsForwarding: Boolean
  "When terraform_module_duplicates_allowed is false, you can publish duplicate packages with names that match this regex. Otherwise, this setting has no effect."
  terraformModuleDuplicateExceptionRegex: UntrustedRegexp
  "Indicates whether duplicate Terraform packages are allowed for this namespace."
  terraformModuleDuplicatesAllowed: Boolean
}

"Autogenerated input type of UpdateNote"
input UpdateNoteInput {
  "Content of the note."
  body: String
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the note to update."
  id: NoteID!
}

"Autogenerated input type of UpdatePackagesCleanupPolicy"
input UpdatePackagesCleanupPolicyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Number of duplicated package files to retain."
  keepNDuplicatedPackageFiles: PackagesCleanupKeepDuplicatedPackageFilesEnum
  "Project path where the packages cleanup policy is located."
  projectPath: ID!
}

"Autogenerated input type of UpdatePackagesProtectionRule"
input UpdatePackagesProtectionRuleInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the package protection rule to be updated."
  id: PackagesProtectionRuleID!
  "Package name protected by the protection rule. For example, `@my-scope/my-package-*`. Wildcard character `*` allowed."
  packageNamePattern: String
  "Package type protected by the protection rule. For example, `NPM`."
  packageType: PackagesProtectionRulePackageType
  "Maximum GitLab access level unable to push a package. For example, `DEVELOPER`, `MAINTAINER`, `OWNER`."
  pushProtectedUpToAccessLevel: PackagesProtectionRuleAccessLevel
}

"Autogenerated input type of UpdateRequirement"
input UpdateRequirementInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the requirement."
  description: String
  "Creates a test report for the requirement with the given state."
  lastTestReportState: TestReportState
  "Full project path the requirement is associated with."
  projectPath: ID!
  "State of the requirement."
  state: RequirementState
  "Title of the requirement."
  title: String
  "IID of the requirement work item to update."
  workItemIid: String
}

"Autogenerated input type of UpdateSnippet"
input UpdateSnippetInput {
  "Actions to perform over the snippet repository and blobs."
  blobActions: [SnippetBlobActionInputType!]
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the snippet."
  description: String
  "Global ID of the snippet to update."
  id: SnippetID!
  "Title of the snippet."
  title: String
  "Visibility level of the snippet."
  visibilityLevel: VisibilityLevelsEnum
}

"Autogenerated input type of UploadDelete"
input UploadDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Upload filename."
  filename: String!
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Secret part of upload path."
  secret: String!
}

"Autogenerated input type of UserAchievementPrioritiesUpdate"
input UserAchievementPrioritiesUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global IDs of the user achievements being prioritized, ordered from highest to lowest priority."
  userAchievementIds: [AchievementsUserAchievementID!]!
}

"Autogenerated input type of UserAchievementsDelete"
input UserAchievementsDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the user achievement being deleted."
  userAchievementId: AchievementsUserAchievementID!
}

"Autogenerated input type of UserAddOnAssignmentCreate"
input UserAddOnAssignmentCreateInput {
  "Global ID of AddOnPurchase to be assigned to."
  addOnPurchaseId: GitlabSubscriptionsAddOnPurchaseID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of user to be assigned."
  userId: UserID!
}

"Autogenerated input type of UserAddOnAssignmentRemove"
input UserAddOnAssignmentRemoveInput {
  "Global ID of AddOnPurchase assignment belongs to."
  addOnPurchaseId: GitlabSubscriptionsAddOnPurchaseID!
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of user whose assignment will be removed."
  userId: UserID!
}

"Autogenerated input type of UserCalloutCreate"
input UserCalloutCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Feature name you want to dismiss the callout for."
  featureName: String!
}

"Autogenerated input type of UserPreferencesUpdate"
input UserPreferencesUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Sort order for issue lists."
  issuesSort: IssueSort
  "Whether Web IDE Extension Marketplace is enabled for the user."
  useWebIdeExtensionMarketplace: Boolean
  "Determines whether the pipeline list shows ID or IID."
  visibilityPipelineIdType: VisibilityPipelineIdType
}

"Autogenerated input type of UserSetNamespaceCommitEmail"
input UserSetNamespaceCommitEmailInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the email to set."
  emailId: EmailID
  "ID of the namespace to set the namespace commit email for."
  namespaceId: NamespaceID!
}

"Autogenerated input type of ValueStreamCreate"
input ValueStreamCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Value stream name."
  name: String!
  "Full path of the namespace(project or group) the value stream is created in."
  namespacePath: ID!
  "Value stream configuration."
  setting: ValueStreamSettingInput
  "Value stream custom stages."
  stages: [ValueStreamStageInput!]
}

"Autogenerated input type of ValueStreamDestroy"
input ValueStreamDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the value stream to destroy."
  id: AnalyticsCycleAnalyticsValueStreamID!
}

"Attributes for value stream setting."
input ValueStreamSettingInput {
  "Projects' global IDs used to filter value stream data."
  projectIdsFilter: [ProjectID!]
}

"Attributes for value stream stage."
input ValueStreamStageInput {
  "Whether the stage is customized. If false, it assigns a built-in default stage by name."
  custom: Boolean = true
  "End event identifier."
  endEventIdentifier: ValueStreamStageEvent
  "Label ID associated with the end event identifier."
  endEventLabelId: LabelID
  "Whether the stage is hidden."
  hidden: Boolean
  "Name of the stage."
  name: String!
  "Start event identifier."
  startEventIdentifier: ValueStreamStageEvent
  "Label ID associated with the start event identifier."
  startEventLabelId: LabelID
}

"Autogenerated input type of ValueStreamUpdate"
input ValueStreamUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the value stream to update."
  id: AnalyticsCycleAnalyticsValueStreamID!
  "Value stream name."
  name: String
  "Value stream configuration."
  setting: ValueStreamSettingInput
  "Value stream custom stages."
  stages: [ValueStreamStageInput!]
}

"Autogenerated input type of VulnerabilitiesDismiss"
input VulnerabilitiesDismissInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment why vulnerability was dismissed (maximum 50,000 characters)."
  comment: String
  "Reason why vulnerability should be dismissed."
  dismissalReason: VulnerabilityDismissalReason
  "IDs of the vulnerabilities to be dismissed (maximum 100 entries)."
  vulnerabilityIds: [VulnerabilityID!]!
}

"Autogenerated input type of VulnerabilitiesRemoveAllFromProject"
input VulnerabilitiesRemoveAllFromProjectInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "IDs of project for which all Vulnerabilities should be removed. The deletion will happen in the background so the changes will not be visible immediately."
  projectIds: [ProjectID!]!
}

"Autogenerated input type of VulnerabilityConfirm"
input VulnerabilityConfirmInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment why vulnerability was confirmed (maximum 50,000 characters)."
  comment: String
  "ID of the vulnerability to be confirmed."
  id: VulnerabilityID!
}

"Autogenerated input type of VulnerabilityCreate"
input VulnerabilityCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Timestamp of when the vulnerability state changed to confirmed (defaults to creation time if status is `confirmed`)."
  confirmedAt: Time
  "Long text section that describes the vulnerability in more detail."
  description: String!
  "Timestamp of when the vulnerability was first detected (defaults to creation time)."
  detectedAt: Time
  "Timestamp of when the vulnerability state changed to dismissed (defaults to creation time if status is `dismissed`)."
  dismissedAt: Time
  "Array of CVE or CWE identifiers for the vulnerability."
  identifiers: [VulnerabilityIdentifierInput!]!
  "Name of the vulnerability."
  name: String!
  "ID of the project to attach the vulnerability to."
  project: ProjectID!
  "Timestamp of when the vulnerability state changed to resolved (defaults to creation time if status is `resolved`)."
  resolvedAt: Time
  "Information about the scanner used to discover the vulnerability."
  scanner: VulnerabilityScannerInput!
  "Severity of the vulnerability (defaults to `unknown`)."
  severity: VulnerabilitySeverity = UNKNOWN
  "Instructions for how to fix the vulnerability."
  solution: String
  "State of the vulnerability (defaults to `detected`)."
  state: VulnerabilityState = DETECTED
}

"Autogenerated input type of VulnerabilityDismiss"
input VulnerabilityDismissInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment why vulnerability was dismissed (maximum 50,000 characters)."
  comment: String
  "Reason why vulnerability should be dismissed."
  dismissalReason: VulnerabilityDismissalReason
  "ID of the vulnerability to be dismissed."
  id: VulnerabilityID!
}

"Autogenerated input type of VulnerabilityExternalIssueLinkCreate"
input VulnerabilityExternalIssueLinkCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "External tracker type of the external issue link."
  externalTracker: VulnerabilityExternalIssueLinkExternalTracker!
  "ID of the vulnerability."
  id: VulnerabilityID!
  "Type of the external issue link."
  linkType: VulnerabilityExternalIssueLinkType!
}

"Autogenerated input type of VulnerabilityExternalIssueLinkDestroy"
input VulnerabilityExternalIssueLinkDestroyInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the vulnerability external issue link."
  id: VulnerabilitiesExternalIssueLinkID!
}

input VulnerabilityIdentifierInput {
  "External ID of the vulnerability identifier."
  externalId: String
  "External type of the vulnerability identifier."
  externalType: String
  "Name of the vulnerability identifier."
  name: String!
  "URL of the vulnerability identifier."
  url: String!
}

"Autogenerated input type of VulnerabilityIssueLinkCreate"
input VulnerabilityIssueLinkCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "ID of the issue to link to."
  issueId: IssueID!
  "IDs of vulnerabilities to link to the given issue.  Up to 100 can be provided."
  vulnerabilityIds: [VulnerabilityID!]!
}

"Autogenerated input type of VulnerabilityResolve"
input VulnerabilityResolveInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment why vulnerability was resolved (maximum 50,000 characters)."
  comment: String
  "ID of the vulnerability to be resolved."
  id: VulnerabilityID!
}

"Autogenerated input type of VulnerabilityRevertToDetected"
input VulnerabilityRevertToDetectedInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Comment why vulnerability was reverted to detected (maximum 50,000 characters)."
  comment: String
  "ID of the vulnerability to be reverted to detected."
  id: VulnerabilityID!
}

input VulnerabilityScannerInput {
  "Unique ID that identifies the scanner."
  id: String!
  "Human readable value that identifies the analyzer, not required to be unique."
  name: String!
  "Link to more information about the analyzer."
  url: String!
  "Information about vendor/maintainer of the scanner."
  vendor: VulnerabilityScannerVendorInput
  "Version of the scanner."
  version: String!
}

input VulnerabilityScannerVendorInput {
  "Name of the vendor/maintainer."
  name: String!
}

"Autogenerated input type of WorkItemAddLinkedItems"
input WorkItemAddLinkedItemsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Type of link. Defaults to `RELATED`."
  linkType: WorkItemRelatedLinkType
  "Global IDs of the items to link. Maximum number of IDs you can provide: 10."
  workItemsIds: [WorkItemID!]!
}

"Autogenerated input type of WorkItemConvert"
input WorkItemConvertInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Global ID of the new work item type."
  workItemTypeId: WorkItemsTypeID!
}

input WorkItemConvertTaskInput {
  "Last line in the Markdown source that defines the list item task."
  lineNumberEnd: Int!
  "First line in the Markdown source that defines the list item task."
  lineNumberStart: Int!
  "Current lock version of the work item containing the task in the description."
  lockVersion: Int!
  "Full string of the task to be replaced. New title for the created work item."
  title: String!
  "Global ID of the work item type used to create the new work item."
  workItemTypeId: WorkItemsTypeID!
}

"Autogenerated input type of WorkItemCreateFromTask"
input WorkItemCreateFromTaskInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Arguments necessary to convert a task into a work item."
  workItemData: WorkItemConvertTaskInput!
}

"Autogenerated input type of WorkItemCreate"
input WorkItemCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Sets the work item confidentiality."
  confidential: Boolean
  "Description of the work item."
  description: String
  "Input for hierarchy widget."
  hierarchyWidget: WorkItemWidgetHierarchyCreateInput
  "Iteration widget of the work item."
  iterationWidget: WorkItemWidgetIterationInput
  "Input for milestone widget."
  milestoneWidget: WorkItemWidgetMilestoneInput
  "Full path of the namespace(project or group) the work item is created in."
  namespacePath: ID
  "Title of the work item."
  title: String!
  "Global ID of a work item type."
  workItemTypeId: WorkItemsTypeID!
}

"Autogenerated input type of WorkItemDelete"
input WorkItemDeleteInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
}

"Autogenerated input type of WorkItemExport"
input WorkItemExportInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "List of IIDs of work items. For example, `[\"1\", \"2\"]`."
  iids: [String!]
  """

  Specify the fields to perform the search in.
  Defaults to `[TITLE, DESCRIPTION]`. Requires the `search` argument.'
  """
  in: [IssuableSearchableField!]
  "Full project path."
  projectPath: ID!
  "Search query for title or description."
  search: String
  "List of selected fields to be exported. Omit to export all available fields."
  selectedFields: [AvailableExportFields!]
  "Current state of the work item."
  state: IssuableState
  "Filter work items by the given work item types."
  types: [IssueType!]
}

"Autogenerated input type of WorkItemRemoveLinkedItems"
input WorkItemRemoveLinkedItemsInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Global IDs of the items to unlink. Maximum number of IDs you can provide: 10."
  workItemsIds: [WorkItemID!]!
}

"Autogenerated input type of WorkItemSubscribe"
input WorkItemSubscribeInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Desired state of the subscription."
  subscribed: Boolean!
}

"Autogenerated input type of WorkItemUpdate"
input WorkItemUpdateInput {
  "Input for assignees widget."
  assigneesWidget: WorkItemWidgetAssigneesInput
  "Input for emoji reactions widget."
  awardEmojiWidget: WorkItemWidgetAwardEmojiUpdateInput
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Input for color widget."
  colorWidget: WorkItemWidgetColorInput
  "Sets the work item confidentiality."
  confidential: Boolean
  "Input for to-dos widget."
  currentUserTodosWidget: WorkItemWidgetCurrentUserTodosInput
  "Input for description widget."
  descriptionWidget: WorkItemWidgetDescriptionInput
  "Input for health status widget."
  healthStatusWidget: WorkItemWidgetHealthStatusInput
  "Input for hierarchy widget."
  hierarchyWidget: WorkItemWidgetHierarchyUpdateInput
  "Global ID of the work item."
  id: WorkItemID!
  "Input for iteration widget."
  iterationWidget: WorkItemWidgetIterationInput
  "Input for labels widget."
  labelsWidget: WorkItemWidgetLabelsUpdateInput
  "Input for milestone widget."
  milestoneWidget: WorkItemWidgetMilestoneInput
  "Input for notes widget."
  notesWidget: WorkItemWidgetNotesInput
  "Input for notifications widget."
  notificationsWidget: WorkItemWidgetNotificationsUpdateInput
  "Input for progress widget."
  progressWidget: WorkItemWidgetProgressInput
  "Input for start and due date widget."
  startAndDueDateWidget: WorkItemWidgetStartAndDueDateUpdateInput
  "Close or reopen a work item."
  stateEvent: WorkItemStateEvent
  "Input for status widget."
  statusWidget: StatusInput
  "Title of the work item."
  title: String
  "Input for weight widget."
  weightWidget: WorkItemWidgetWeightInput
}

"Autogenerated input type of WorkItemUpdateTask"
input WorkItemUpdateTaskInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Global ID of the work item."
  id: WorkItemID!
  "Arguments necessary to update a task."
  taskData: WorkItemUpdatedTaskInput!
}

input WorkItemUpdatedTaskInput {
  "Input for assignees widget."
  assigneesWidget: WorkItemWidgetAssigneesInput
  "Input for emoji reactions widget."
  awardEmojiWidget: WorkItemWidgetAwardEmojiUpdateInput
  "Sets the work item confidentiality."
  confidential: Boolean
  "Input for to-dos widget."
  currentUserTodosWidget: WorkItemWidgetCurrentUserTodosInput
  "Input for description widget."
  descriptionWidget: WorkItemWidgetDescriptionInput
  "Input for hierarchy widget."
  hierarchyWidget: WorkItemWidgetHierarchyUpdateInput
  "Global ID of the work item."
  id: WorkItemID!
  "Input for labels widget."
  labelsWidget: WorkItemWidgetLabelsUpdateInput
  "Input for milestone widget."
  milestoneWidget: WorkItemWidgetMilestoneInput
  "Input for notes widget."
  notesWidget: WorkItemWidgetNotesInput
  "Input for notifications widget."
  notificationsWidget: WorkItemWidgetNotificationsUpdateInput
  "Input for start and due date widget."
  startAndDueDateWidget: WorkItemWidgetStartAndDueDateUpdateInput
  "Close or reopen a work item."
  stateEvent: WorkItemStateEvent
  "Title of the work item."
  title: String
}

input WorkItemWidgetAssigneesInput {
  "Global IDs of assignees."
  assigneeIds: [UserID!]!
}

input WorkItemWidgetAwardEmojiUpdateInput {
  "Action for the update."
  action: WorkItemAwardEmojiUpdateAction!
  "Emoji name."
  name: String!
}

input WorkItemWidgetColorInput {
  "Color of the work item."
  color: Color!
}

input WorkItemWidgetCurrentUserTodosInput {
  "Action for the update."
  action: WorkItemTodoUpdateAction!
  "Global ID of the to-do. If not present, all to-dos of the work item will be updated."
  todoId: TodoID
}

input WorkItemWidgetDescriptionInput {
  "Description of the work item."
  description: String!
}

input WorkItemWidgetHealthStatusInput {
  "Health status to be assigned to the work item."
  healthStatus: HealthStatus
}

input WorkItemWidgetHierarchyCreateInput {
  "Global ID of the parent work item."
  parentId: WorkItemID
}

input WorkItemWidgetHierarchyUpdateInput {
  "ID of the work item to be switched with."
  adjacentWorkItemId: WorkItemID
  "Global IDs of children work items."
  childrenIds: [WorkItemID!]
  "Global ID of the parent work item. Use `null` to remove the association."
  parentId: WorkItemID
  "Type of switch. Valid values are `BEFORE` or `AFTER`."
  relativePosition: RelativePositionType
}

input WorkItemWidgetIterationInput {
  "Iteration to assign to the work item."
  iterationId: IterationID
}

input WorkItemWidgetLabelsUpdateInput {
  "Global IDs of labels to be added to the work item."
  addLabelIds: [LabelID!]
  "Global IDs of labels to be removed from the work item."
  removeLabelIds: [LabelID!]
}

input WorkItemWidgetMilestoneInput {
  "Milestone to assign to the work item."
  milestoneId: MilestoneID
}

input WorkItemWidgetNotesInput {
  "Discussion lock attribute for notes widget of the work item."
  discussionLocked: Boolean!
}

input WorkItemWidgetNotificationsUpdateInput {
  "Desired state of the subscription."
  subscribed: Boolean!
}

input WorkItemWidgetProgressInput {
  "Current progress value of the work item."
  currentValue: Int!
  "End value of the work item."
  endValue: Int
  "Start value of the work item."
  startValue: Int
}

input WorkItemWidgetStartAndDueDateUpdateInput {
  "Due date for the work item."
  dueDate: Date
  "Start date for the work item."
  startDate: Date
}

input WorkItemWidgetWeightInput {
  "Weight of the work item."
  weight: Int
}

"Autogenerated input type of WorkspaceCreate"
input WorkspaceCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "GlobalID of the cluster agent the created workspace will be associated with."
  clusterAgentId: ClustersAgentID!
  "Desired state of the created workspace."
  desiredState: String!
  "Project repo git path containing the devfile used to configure the workspace."
  devfilePath: String!
  "Project repo git ref containing the devfile used to configure the workspace."
  devfileRef: String!
  "Editor to inject into the created workspace. Must match a configured template."
  editor: String!
  "Maximum hours the workspace can exist before it is automatically terminated."
  maxHoursBeforeTermination: Int!
  "ID of the project that will provide the Devfile for the created workspace."
  projectId: ProjectID!
}

"Autogenerated input type of WorkspaceUpdate"
input WorkspaceUpdateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Desired state of the created workspace."
  desiredState: String!
  "Global ID of the workspace."
  id: RemoteDevelopmentWorkspaceID!
}

"Autogenerated input type of iterationCreate"
input iterationCreateInput {
  "A unique identifier for the client performing the mutation."
  clientMutationId: String
  "Description of the iteration."
  description: String
  "End date of the iteration."
  dueDate: String
  "Full path of the group with which the resource is associated."
  groupPath: ID
  "Global ID of the iteration cadence to be assigned to the new iteration."
  iterationsCadenceId: IterationsCadenceID
  "Full path of the project with which the resource is associated."
  projectPath: ID
  "Start date of the iteration."
  startDate: String
  "Title of the iteration."
  title: String
}
