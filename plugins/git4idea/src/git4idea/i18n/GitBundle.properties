action.text.show.all.submitted=Show all files changed by this commit
add.action.name=Add
add.adding=Adding files...
addrefspec.button=Add
addrefspec.get.references.tooltip=Get remote tag and branch references (depending on checkbox state).
addrefspec.get.references=&Get References
addrefspec.getting.references.title=Getting remote references for {0}
addrefspec.include.branches.tooltip=The next update references wil retrieve remote branches.
addrefspec.include.branches=Include &branches
addrefspec.include.tags.tooltip=The next update references wil retrieve remote tags.
addrefspec.include.tags=Include &tags
addrefspec.node.branches=Branches
addrefspec.node.tags=Tags
addrefspec.reference.chooser.tooltip=Select remote branch and tag references
addrefspec.title=Add Reference(s)
annotate.action.name=Annotate
annotation.tool.tip=commit {0}\nAuthor: {1}\nDate: {2}\n\n{3}
changes.retrieving=Retrieving changes for revision {0}
checking.out=Checkout {0}
checkout.action.name=Checkout
checkout.branch.label=&Checkout
checkout.branch.name.exists=Branch with the same name exists. Use override option to force branch creation.
checkout.branch=Checkout
checkout.create.ref.log.tooltip=If checked the reference log is created for the branch. It allows time based searches. (the option \"-l\")
checkout.create.ref.log=Create ref &log
checkout.include.tags.tooltip=If checked, the combobox will include tags names as well as branches.
checkout.include.tags=&Include tags
checkout.invalid.new.branch.name=Invalid new branch name
checkout.new.branch.tooltip=Enter name of new branch here. Leave blank if you do not want to create a new branch.
checkout.new.branch=As &new branch
checkout.override.branch=&Override
checkout.override.tooltip=If checked a branch will be created even if a branch with the same name already exists. The previous branch will be deleted.
checkout.ref.tooltip=Select branch, tag, or enter commit reference
checkout.retrieving.branches.and.tags=Retrieving branches and tags
checkout.track.branch=&Track branch
checkout.track.tooltip=If checked, the newly created branch will track original branch during pull.
checkout.validate.tooltip=Use this button to validate reference expression if entered manually.
checkout.validate=&Validate
checkout.validation.failed=Source revision validation failed
command.cancelled=The command was cancelled.
commit.action.name=Comm&it
commit.author.tooltip=<html>Specify a commit author here if it is different from committer. The author should be in the format: Author Name &lt;author@ema.il&gt;</html>
commit.author=&Author:
commit.amend.tooltip=<html>Merge this commit with the previous one</html>
commit.amend=Amend commit
commit.partial.merge.message=Partial commit during a {0} is not allowed.\n\
  The following files are not included in commit.\n\
  Perform commit with all files included?
commit.partial.merge.title=Partial Merge Commit
commit.push.changes.tooltip=When this option is enabled, changes are pushed to the server after commit.
commit.push.changes=&Push Changes
common.current.branch.tooltip=The currently checked out branch.
common.current.branch=Current Branch:
common.do.not.show.tooltip=If this option is selected, the choice will be remembered, and the dialog will not be shown again.
common.do.not.show=&Do not show this dialog again
common.git.root.tooltip=Select Git VCS root
common.git.root=Git &Root:
common.no.active.branch=<no active branch>
common.refreshing=Refreshing files
computing.annotation=Computing annotation for {0}
crlf.convert.convert=Convert Selected
crlf.convert.label=<html>&The following text files have line separator that do not match the project line separator.<br/>Select files you wish to convert to project default line separators before commit.</html>
crlf.convert.leave=Leave Unchanged
crlf.convert.none.tooltip=If this option is selected, the file are not attempted to be converted before commit.
crlf.convert.none=Do &not convert files
crlf.convert.title=Invalid Line Separators
current.branch.action.name=CurrentBranch
current.branch.change.tracked=Change Tracked Branch
current.branch.message=Checked out branch: {0}
current.branch.title=Configure Tracked Branch
current.branch.tracked.branch.none=<none>
current.branch.tracked.branch.tooltip=Select the branch to track
current.branch.tracked.branch=&Branch:
current.branch.tracked.remote.none=<none>
current.branch.tracked.remote.this=<this repository>
current.branch.tracked.repository.tooltip=Select repository to track
current.branch.tracked.repository=Re&pository:
current.branch.tracked.title=Tracked Branch
debug.git.exec=DEBUG: work-dir: [{0}] exec: [{1}]
delete.action.name=Delete
diff.find.error=Finding revision for diff: {0}
error.dialog.title=Error
error.list.title={0} Error:
error.occurred.during=Error occurred during ''{0}''
errors.message.item=\n   {0}
errors.message=The Git operation ended with multiple errors:{0}
fetch.action.name=Fetch
fetch.button=Fetch
fetch.force.references.update.tooltip=Forces update of branch references for which update is not forced in reference mapping.
fetch.force.references.update=Force references &update
fetch.remote.label=Re&mote:
fetch.remote.tooltip=Remote name or url for fetch
fetch.tags.label=Fetch &tags:
fetch.tags.policy.all=All
fetch.tags.policy.for.fetched.commits=For fetched commits
fetch.tags.policy.none=None
fetch.tags.tooltip=<html>Select fetched commits policy<ul><li><i>For fetched commits</i> means tags associated with commits on fetched branches are fetched.</li><li><i>All</i> means that all tags and reference commits are fetched</li><li><i>None</i> means that no tags are fetched.</li></ul></html>
fetch.title=Git Fetch
fetching.tags.title=Updating tags from {0}
fetching.title=Fetching from {0}
find.git.description=Select path to Git executable
find.git.error.title=Error Running Git
find.git.success.title=Git executed successfully
find.git.title=Git Configuration
find.git.unsupported.message=<html><tt>{0}</tt><br>This version is unsupported, and some plugin functionality could fail to work.<br>The minimal supported version is <em>{1}</em>.</html>
fix.roots.button=Accept
fix.roots.list.tooltip=The suggested list of Git VCS roots, new roots are marked as bold, removed roots are marked as overstriked.
fix.roots.message=The following Git VCS roots will be used instead of the current Git VCS roots.
fix.roots.title=Fix Git VCS Roots
fix.roots.valid.message=The invalid Git roots have been fixed already.
fix.roots.valid.title=All Git Roots Are Valid
getting.history=Getting history for {0}
git.default.commit.message=\n# Brief commit description here\n\n# Full commit description here (comment lines starting with '#' will not be included)\n\n
git.error.exit=The Git process exited with the code {0}
git.running=Running: {0}

git.vcs.config.convert.crlf=&Line Separators Conversion:
git.vcs.config.convert.do.not.convert=Do not convert
git.vcs.config.convert.project=Convert to project line separators
git.vcs.config.convert.ask=Ask before conversion
git.vcs.config.convert.tooltip=<html>Specify what to do if line separators in a file and in the project code style are different:\
  <ul>\
  <li><b>Do not convert</b> - do nothing, commit as is.</li>\
  <li><b>Convert to project line separators</b> - before commit convert line separators to match project code style settings.</li>\
  <li><b>Ask before conversion</b> - show dialog and ask what to do.</li>\
  </ul>\
  Note that this setting has nothing common with Git autocrlf and other Git settings.\
  </html>
git.vcs.config.path.label=Path to &Git executable:
git.vcs.config.ssh.mode.idea=Built-in
git.vcs.config.ssh.mode.native=Native
git.vcs.config.ssh.mode.tooltip=<html>Specify the version of SSH to be used with Git.\
  <ul><li><b>Native</b> means that the native SSH will be used.</li>\
  <li><b>Built-in</b> means that the implementation provided by {0} will be used.</li></ul>\
  The native implementation might cause hangups on some platforms. \
  In native case, you also might need to configure <em>ssh-askpass</em> for your platform to receive GUI prompts for passwords.</html>
git.vcs.config.ssh.mode=&SSH executable:
git.vcs.config.test.label=Test 
git.vcs.config.test=&Test

index.file.error=Updating file in the index failed
init.add.root.message=Do you want to add this directory as a VCS root?
init.add.root.title=Git Init
init.destination.directory.description=Select directory where the new Git repository will be created.
init.destination.directory.title=Select directory for git init
init.warning.already.under.git=<html>The selected directory <tt>{0}</tt> is already under Git.<br/>Are you sure that you want to create a new VCS root?</html>
init.warning.title=Git Init
initializing.title=Initializing repository...
merge.action.name=Merge
merge.add.log.information.tooltip=Add log information to the commit message (\"--log\" option)
merge.add.log.information=Add &log information
merge.branch.button=Merge
merge.branch.message=Select branch to merge into this one ({0})
merge.branch.title=Merge Branches
merge.branches.tooltip=<html>The chooser for branches. Select one or more branches to merge (already merged branches are not shown)</html>.
merge.branches=&Branches to merge:
merge.commit.message.tooltip=The commit message to use in case if merge results in commit (\"-m\" option)
merge.commit.message=Commit &Message
merge.default.strategy=<default>
merge.is.not.needed=Merge is not needed for the file {0}
merge.load.files=Loading files for merge
merge.no.commit.tooltip=Force no commit for merge (the \"--no-commit\" option)
merge.no.commit=No &commit
merge.no.fast.forward.tooltip=Disable fast forward (\"--no-ff\" option)
merge.no.fast.forward=No &fast forward
merge.retrieving.branches=Retrieving unmerged branches
merge.squash.commit=S&quash commit
merge.squash.tooltip=Squash all changes into the single commit (\"--squash\" option)
merge.strategy.tooltip=The merge strategy to use (\"-s\" option)
merge.strategy=&Strategy:
merge.tool.action.name=MergeTool
merge.tool.column.status.deleted=Deleted
merge.tool.column.status.modified=Modified
merge.tool.column.theirs.status=Theirs
merge.tool.column.yours.status=Yours
merging.branch=Merging branch {0}
merging.title=Merging changes to {0}
paths.affected.title=Paths affected in commit {0}
pull.action.name=Pull
pull.button=Pull
pull.force.reference.update=Force reference &update
pull.get.branches.tooltip=Get branch names from remote repository. Otherwise a locally cached information is used.
pull.get.branches=&Get Branches
pull.getting.remote.branches=Getting remote branches
pull.remote.tooltip=Registered remote name or URL.
pull.remote=Re&mote:
pull.retrieving.remotes=Retrieving remotes
pull.title=Pull Changes
pull.url.message=Enter remote repository URL to pull/merge (empty for default):
pull.url.title=Pull URL
pulling.title=Pulling changes from {0}
push.action.name=Push
push.active.action.name=Push Active Branches
push.active.autostash.tooltip=Auto-stash changes before rebase
push.active.autostash=&Auto-stash
push.active.rebase.and.push=Rebase and Push
push.active.commit.node.merge=(merge commit)
push.active.commits=&Commits:
push.active.error.behind=Some local branches are behind remote branches
push.active.error.merges.unchecked=Roots with merge commits cannot be selectively pushed
push.active.error.no.branch=Some roots are not on the branch
push.active.error.reorder.merges=It is not possible to reorder commits if merges present
push.active.error.reorder.needed=The nodes should be reordered using rebase operation.
push.active.fetch.failed.title=Fetch Failed
push.active.fetch.failed=The fetch operation failed for some branches
push.active.fetch.tooltip=Fetch state of tracked branches from remote repository
push.active.fetch=&Fetch
push.active.fetching=Fetching changes for active branches
push.active.pushing=Pushing branches...
push.active.rebase.tooltip=Rebase branches in order to make push possible (might reorder commits)
push.active.rebase=&Rebase
push.active.rebasing=Rebasing ...
push.active.save.before.rebase=Clean working tree before rebase:
push.active.status.behind=Unable to push. The current branch is behind tracked branch by {0,choice, 1#1 commit|2#{0,number} commits}.
push.active.status.no.branch=The head is not on the branch.
push.active.status.no.commits.behind=Nothing to push. The current branch is behind tracked branch by {0,choice, 1#1 commit|2#{0,number} commits}.
push.active.status.no.commits=Nothing to push.
push.active.status.no.tracked=No tracked branch is configured.
push.active.status.push={0,choice, 1#1 commit|2#{0,number} commits} will be pushed.
push.active.status.status=Status: 
push.active.title=Push Active Branches
push.active.view=&View
push.branches.tooltip=Select branches to push
push.branches=&Branches:
push.button=Push
push.force.update.tooltip=If selected remote ref is updated even if they are is not an ancestor of the local ref.
push.force.update=&Force update
push.policy.all=All
push.policy.default=Default
push.policy.mirror=Mirror
push.policy.selected=Selected branches
push.policy.tooltip=<html>Select push policy:<ul><li><em>Default</em> - the push is done according to the configuration of the remote.</li><li><em>Selected branches</em> - selected branches are pushed.</li><li><em>All</em> - all references under refs/heads are pushed.</li><li><em>Mirror</em> - all references under refs/ are pushed including tags and remotes.</li></ul></html>
push.policy=&Push:
push.remote.tooltip=Specify remote repository URL or remote name where to push changes.
push.remote=Re&mote:
push.show.tags.tooltip=If selected, the tags are shown in branch chooser as well.
push.show.tags=Show ta&gs
push.tags.tooltip=All tag references are pushed in addition to references specified in references section.
push.tags=Push &tags
push.title=Push Changes
push.use.thin.pack.tooltip=If this option is selected, the push will spend extra CPU cycles to minimize amount of data transferred (use it for slow connections)
push.use.thin.pack=&Use thin pack
pushing.all.changes=Pushing all committed changes, refs & tags to remote repositories
gc.action.name=Run Garbage Collector
rebase.abort.action.name=Abort Rebasing
rebase.action.error=Git Rebase Error
rebase.action.message=Multiple Git roots have unfinished rebase process, please select root to perform action on.
rebase.action.name=Rebase
rebase.action.no.root=There is no rebase operation in progress in the project
rebase.branch.tooltip=Select branch to rebase (if branch is different from the current branch, it will be checked out first)
rebase.branch=&Branch:
rebase.button=Rebase
rebase.continue.action.name=Continue Rebasing
rebase.editor.action.column=Action
rebase.editor.button=Start Rebasing
rebase.editor.comment.column=Comment
rebase.editor.commit.column=Commit
rebase.editor.invalid.entryset=No commits found to rebase
rebase.editor.invalid.squash=The first non-skip commit could not be marked as squashed since squash merges commit with the previous commit.
rebase.editor.message=Reorder and edit &rebased commits
rebase.editor.move.down.tooltip=Move commit down (commit will be applied later)
rebase.editor.move.down=Move &Down
rebase.editor.move.up.tooltip=Move commit up in the list (commit will be applied earlier)
rebase.editor.move.up=Move &Up
rebase.editor.title=Rebasing Commits
rebase.editor.view.tooltip=View commit contents
rebase.editor.view=&View
rebase.from.tooltip=Specify actual base for the branch. Leave blank to onto.
rebase.from=&From:
rebase.in.progress=Interactive rebase has been already started for this Git root.
rebase.interactive.tooltip=If selected, the interactive rebase will be preformed.
rebase.interactive=&Interactive
rebase.invalid.from=\"From\" reference expression is invalid.
rebase.invalid.onto=\"Onto\" reference expression is invalid.
rebase.merge.strategy.tooltip=Select merge strategy to use
rebase.merge.strategy=Merge &Strategy:
rebase.no.merge.tooltip=If selected, no merge strategies will be applied during the rebase.
rebase.no.merge=&Do not use merge strategies
rebase.onto.tooltip=The reference that will become a new base for selected branch.
rebase.onto.validate=&Validate
rebase.onto=&Onto:
rebase.preserve.merges.tooltip=Preserve merges during rebase instead of squashing them.
rebase.preserve.merges=&Preserve Merges
rebase.result.amend.title=Rebase Suspended
rebase.result.amend=Stopped for amending commit while rebasing ({0}/{1}).\nAmend commit and continue the rebase process.
rebase.result.cancelled.title=Rebase Cancelled
rebase.result.cancelled=The rebase process was cancelled.
rebase.result.conflict.title=Rebase Suspended
rebase.result.conflict=Stopped rebasing because of conflict ({0}/{1}).\nResolve conflicts and continue the rebase process.
rebase.result.error.title=Rebase Error
rebase.result.error=Stopped rebasing because of error while rebasing ({0}/{1}).\nCheck vcs console for details.
rebase.show.remote.branches.tooltip=If selected, remote branches are shown in drop down as well.
rebase.show.remote.branches=Show Re&mote Branches
rebase.show.tags.tooltip=Show tags in \"from\" and \"onto\" comboboxes.
rebase.skip.action.name=Skip Commit in Rebasing
rebase.title=Rebase branch
rebase.unstructured.editor.button=Resume Rebasing
rebase.unstructured.editor.git.root=Git Root:
rebase.unstructured.editor.message=Git rebase operation requested additional &information through the editor:
rebase.unstructured.editor.title=Additional Rebase Input
rebase.unstructured.editor.tooltip=Edit this text according to instructions provided inline
rebase.valdate.onto.tooltip=Validate "onto" reference.
rebase.validate.from.tooltip=Validate \"from\" reference
rebase.validate.from=Va&lidate
rebasing.title=Rebasing...
refspec.add.all.branches.tooltip=Add refspec that maps all remote branches by glob spec.
refspec.add.all.branches=Add A&ll Branches
refspec.add.all.tags.tooltip=Adds mapping entry for all tags
refspec.add.all.tags=Add All Ta&gs
refspec.add.ref.tooltip=Add branch or tag by name
refspec.add.ref=&Add...
refspec.branch.prefix.tooltip=Specify default branch prefix for the mapping.
refspec.branch.prefix=Remote &Name:
refspec.column.force=Force
refspec.column.local=Local
refspec.column.remote=Remote
refspec.default.tooltip=Restore default reference mapping
refspec.default=&Default
refspec.remove.tooltip=Delete refspec entry
refspec.remove=Remo&ve
refspec.title=Reference mapping
refspec.validation.remote.invalid=The invalid local name for remote
refspec.validation.remote.is.blank=The local name for remote is blank
regase.show.tags=Show &tags
remove.removing=Removing files...
repository.action.missing.roots.misconfigured=None of configured Git roots are under Git. The configured directory or some of its ancestors must have ".git" directory in it.
repository.action.missing.roots.title=No Git roots
repository.action.missing.roots.unconfigured.message=No Git roots are configured for the project.
reset.action.name=Reset Head ...
reset.button=Reset
reset.commit.invalid=The specified commit expression did not pass validation.
reset.commit.label=To &Commit:
reset.commit.tooltip=The commit that will become the current HEAD\n as result of reset operation.
reset.title=Reset Head
reset.type.hard=Hard
reset.type.mixed=Mixed
reset.type.soft=Soft
reset.type.tooltip=<html>The reset type (see also <code>git reset</code> man page):<ul><li><b>Mixed</b> resets index but not working tree</li><li><b>Soft</b> leaves index and working tree, just moves head pointer</li><li><b>Hard</b> resets index and working tree.<em>Changes in the working tree will be lost</em></li></ul></html>
reset.type=Reset &Type:
reset.validate.tooltip=Validate the commit pointer and check the content of referenced commit.
reset.validate=&Validate
resetting.title=Resetting HEAD...
revert.action.name=&Revert
revert.reverting.mulitple=Reverting {0} files
revert.reverting=Reverting files...
revision.graph=RevisionGraph
root.tracker.message.title=Invalid Git Roots
root.tracker.message=<p>Some configured Git VCS roots are not under Git or have Git repositories in subdirectories without a configured VCS root. <a href="">Configure.</a></p>
select.branch.to.checkout=Select branch to checkout
show.all.paths.affected.action.name=Show All Affected Paths
ssh.ask.passphrase.title=SSH Key Passphrase
ssh.askPassphrase.message=Please enter passphrase for the private key {0} (the user name is {1})
ssh.changed.host.key=<html>The server host key for the host {0}:{1} has changed to {2} (type {3}).\nDo you want to accept the changed key?</html>
ssh.confirm.key.titile=Confirm SSH Server Key
ssh.error.title=Authentication error
ssh.keyboard.interactive.title=SSH Keyboard Interactive: {0}
ssh.keyboard.interactive.username=Username:
ssh.new.host.key=<html>Connecting to a new host {0}:{1} that has the key {2} (type {3}).\nDo you want to add this host to known hosts database?</html>
ssh.password.message=Please enter password for user {0}
ssh.password.title=SSH Password Login
stash.action.name=Stash
stash.button=Create Stash
stash.keep.index.tooltip=If this checkbox is selected, indexed changes are kept in the index.
stash.keep.index=Keep &index
stash.message.tooltip=Enter stash message here.
stash.message=&Message:
stash.title=Stash
stashing.title=Stashing changes...
tag.action.name=Tag
tag.button=Create Tag
tag.commit.label=&Commit:
tag.commit.tooltip=Enter name of commit or object to tag or leave blank to use HEAD.
tag.error.creating.message.file.message=Unable to create message file: {0}
tag.error.creating.message.file.title=Error creating message file
tag.error.invalid.commit=The commit or object name is invalid.
tag.error.tag.exists=The tag with the same name exists.
tag.force.tooltip=Force creation of the text even if tag with such name already exists.
tag.force=&Force
tag.getting.existing.tags=Getting existing tags...
tag.message.label=&Message:
tag.message.tooltip=If the message is not empty, an annotated tag is created.
tag.message=Specify tag name:
tag.name.label=Tag &Name:
tag.name.tooltip=Enter the new tag name here.
tag.nonvcs.error.message=ERROR: Files not tagged, not all are under VCS root!
tag.nonvcs.error.title=Tag Result
tag.title=Tag
tag.validate.tooltip=Click this button to the validate commit to be tagged.
tag.validate=&Validate
tagging.title=Tagging files...
task.queue.title=Git Operations
unindexed.files.changlelist.name=Unindexed Files
unstash.action.name=UnStash
unstash.branch.label\:=As new &branch:
unstash.branch.tooltip=If non-empty name is entered, the stash is checked out as a new branch.
unstash.button.apply=Apply Stash
unstash.button.branch=Branch
unstash.button.pop=Pop Stash
unstash.clear.tooltip=Delete all stashes in the repository.
unstash.clear=&Clear
unstash.clearing.stashes=Clearing stashes...
unstash.drop.tooltip=Delete selected stash
unstash.drop=&Drop
unstash.dropping.stash=Dropping stash {0}...
unstash.error.branch.exists=The specified branch already exists
unstash.error.invalid.branch.name=Invalid branch name
unstash.pop.stash.tooltip=If selected the stash is dropped after it is applied.
unstash.pop.stash=&Pop stash
unstash.reinstate.index.tooltip=Attempt to reinstate index as well as working tree changes.
unstash.reinstate.index=Reinstate &index
unstash.stashes.item=<html><b><tt>{0}</tt></b>:<i>{1}</i>: {2}</html>
unstash.stashes.tooltip=Select a stash to operate for.
unstash.stashes=&Stashes:
unstash.title=UnStash Changes
unstash.unstashing=Unstashing...
unstash.view.tooltip=View selected stash
unstash.view=&View
unstashing.title=UnStashing changes...
update.locally.modified.files.tooltip=Locally modified files.
update.locally.modified.files=&Files:
update.locally.modified.git.root=Git Root:
update.locally.modified.message=<html><p>The following files under this root are locally modified. <br/>\
  Possible reasons: uncommitted changes; a problem with crlf conversion; {0} configuration file auto-save.</p>\
  <p><ul>\
    <li>Press <b>Revert Files</b> to discard these local changes and continue the update process.</li>\
    <li>Press <b>Cancel</b> to cancel the update process. <br/> Use Auto-Stash option to stash local changes before update and restore them after it.</li>\
  </ul></p> \
  </html>
update.locally.modified.rescan.tooltip=<html>Rescan the repository to check for locally modified files again.<br/>Use this button if you have resolved the problem manually.</html>
update.locally.modified.rescan=Re&scan
update.locally.modified.revert=Revert Files
update.locally.modified.title=Locally modified files are detected
update.options.display.name=Git Update Settings
update.options.no.commit=No &Commit
update.options.save.before.update=Clean working tree before update
update.options.save.keep.tooltip=Leave changes on working tree
update.options.save.keep=Do &Not Clean
update.options.save.shelve.tooltip=Use {0}''s Shelve to save changes (the files will be restored after update)
update.options.save.shelve=Using She&lve
update.options.save.stash.tooltip=Use Git Stash to save changes (the files will be restored after update)
update.options.save.stash=Using S&tash
update.options.type.default.tooltip=Use branch default update strategy for all updated Git VCS roots
update.options.type.default=Branch &Default
update.options.type.merge.tooltip=Use merge update strategy for all Git VCS roots
update.options.type.merge=&Merge
update.options.type.rebase.tooltip=Use rebase update strategy for all Git VCS roots
update.options.type.rebase=&Rebase
update.options.type=Update Type
update.rebase.no.change.cancel=Cancel Update
update.rebase.no.change.retry=Retry Continue
update.rebase.no.change.skip=Skip Commit
update.rebase.no.change.title=No Changes Staged
update.rebase.no.change=<html>No changes detected <tt>{0}</tt>. <ul><li>Skip Commit - skips current commit in the rebase process</li><li>Retry Continue - do it after you add changes to commit manually</li><li>Or cancel cancels update process for this root.</li></ul></html>
update.rebase.unmerged.title=Unresolved Rebase Conflicts
update.rebase.unmerged=<html>Root: <tt>{0}</tt><br/>There still remain files to be merged. Do you want to merge them?<ul><li>Yes - Merge.</li><li>No - Cancel update for this root.</li></ul></html>
update.restoring.change.lists=Restoring change lists...
update.root.rebasing.item=<li>{0}</li>
update.root.rebasing.message=<html>The following roots have unfinished rebase process. Update is not possible.<ul>{0}</u></html>
update.root.rebasing.title=Unfinished Rebase Process
update.root.rebasing=The root {0} has unfinished rebase process.
update.shelving.changes=Shelving changes...
update.unshelving.changes=Unshelving Changes...
util.remote.renderer.default=<html><b>{0}</b>(<i>{1}</i>)</html>
util.remote.renderer.none=<html><i>None</i></html>
util.remote.renderer.normal=<html><b>{0}</b>(<i>{1}</i>)</html>
util.remote.renderer.self=<html><i>Current repository</i></html>
vcs.unable.to.run.git=Unable to run git: {0} ({1})
vfs.listener.add.single.prompt=Do you want to add the following file to Git?\n{0}\n\nIf you say No, you can still add it later manually.
vfs.listener.add.single.title=Add File to Git
vfs.listener.add.title=Add Files to Git
vfs.listener.checking.ignored=Checking for ignored files
vfs.listener.delete.single.prompt=Do you want to delete the following file from Git?\n{0}\n\nIf you say No, you can still delete it later manually.
vfs.listener.delete.single.title=Delete File from Git
vfs.listener.delete.title=Delete Files from Git

general.error = Git error
executable.error.title = Git executable problem
executable.error.description = Git couldn't be started. Probably the path to Git executable is not valid. <a href="">Fix it.</a>

git.commit.message.empty=Please specify commit message
git.commit.message.empty.title=Commit Message Is Empty

git.executable.notification.title=Can't start Git
git.executable.notification.description=Probably the path to Git executable is not valid.
git.executable.dialog.title=Git executable
git.executable.dialog.description=Specify the full path to Git executable
git.executable.dialog.error=It doesn't appear to be a valid Git executable
git.executable.filechooser.title=Git executable
git.executable.filechooser.description=Specify the full path to Git executable

git.push.active.close=Close

git.unstash.clear.confirmation.message=Remove all stashes? This cannot be undone.
git.unstash.clear.confirmation.title=Remove all stashes?
git.unstash.drop.confirmation.message=<html>Do you want to remove {0}?<br/>"{1}"</html>
git.unstash.drop.confirmation.title=Remove stash {0}?

branch.delete.not_fully_merged.description=The branch <code><b>{0}</b></code> is not fully merged to the branch <code><b>{1}</b></code>.<br/>Below is the list of unmerged commits.
branch.delete.not_fully_merged.description.not_on_branch=You are currently not on the branch (<code>{1}</code>). <br>\
  The branch <code><b>{0}</b></code> is not fully merged to <code>{2}</code>.<br/>Below is the list of unmerged commits.
branch.delete.merged_to.many=The branch <code><b>{0}</b></code> is however fully merged to the following branches: <code>{1}</code>.
branch.delete.merged_to.one=The branch <code><b>{0}</b></code> is however fully merged to the branch <code>{1}</code>.
branch.delete.warning=You may still delete the branch <code><b>{0}</b></code>, but beware that it cannot be undone.

vcs.popup.git.github.section=GitHub

vcs.history.action.gitlog=Select in Git Log