remove.middleman.tooltip.warning=Deletion will break type hierarchy
remove.middleman.column.header=Delete
remove.middleman.methods.to.inline.title=&Methods to Inline
remove.middleman.deleted.hierarchy.conflict={0} will be deleted. Hierarchy will be broken
delegating.field=Delegating field
replace.temp.with.query.title=Replace Temp with Query
cannot.replace.temp.with.query.in.interface=Cannot replace temp with query in interface
error.wrong.caret.position.local.name=Caret should be positioned at the name of the local variable to be refactored
remove.middleman=Remove Middleman
the.caret.should.be.positioned.at.the.name.of.the.field.to.be.refactored=The caret should be positioned at the name of the field to be refactored.
field.selected.is.not.used.as.a.delegate=The selected field is not used as a delegate.
wrap.return.value=Wrap Return Value
method.selected.returns.void=The selected method returns 'void'.
constructor.returns.can.not.be.wrapped=Constructor returns cannot be wrapped.
wrap.return.value.title=Wrap Return Value
method.to.wrap.returns.from.label=Method to wrap returns from:
method.whose.return.are.to.wrapped=Method, whose return is to be wrapped
references.to.be.modified.usage.view=References to be modified {0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files}
remove.middleman.field.header=Remove middleman field:
references.to.expose.usage.view=References to expose {0, choice, 0#(Not found)|1#{0} reference|2#{0} references}{1, choice, 0#|1# in {1} file|2# in {1} files}
remove.middleman.title=Remove Middleman
wrapped.return.command.name=Wrapped return as {0} for {1}()
exposed.delegation.command.name=Exposed delegation to {0}
dialog.message.invalid.inner.class.name=''{0}'' is an invalid inner class name
dialog.message.inner.class.with.name.already.exist=Inner class with name ''{0}'' already exists
dialog.message.invalid.qualified.wrapper.class.name=''{0}'' is an invalid qualified wrapper class name
dialog.message.invalid.wrapper.class.name=''{0}'' is an invalid wrapper class name
dialog.message.wrapper.field.not.found=Wrapper field not found
dialog.message.invalid.wrapper.class.package.name=''{0}'' is an invalid wrapper class package name
could.not.find.selected.wrapping.class=Cannot find the selected wrapping class
there.already.exists.a.class.with.the.selected.name=The class with the selected name already exists


action.RemoveMiddleman.text=Remove _Middleman...
action.RemoveMiddleman.description=Inline delegate to the selected field methods
action.ReplaceTempWithQuery.text=Replace Temp with _Query...
action.ReplaceTempWithQuery.description=Convert the selected variable into a method
action.WrapReturnValue.text=Wra_p Method Return Value...
action.WrapReturnValue.description=Wrap return value of the specified method with object
action.Generify.text=Convert Raw Types to Generics...
action.Generify.description=Convert your code to use generic types

generify.title=Convert Raw Types to Generics
type.cook.command=Generify
type.cook.drop.obsolete.casts=&Drop obsolete casts
type.cook.elements.header=Scope(s) to generify
type.cook.generify.objects=Generify &Objects
type.cook.leave.object.parameterized.types.raw=&Leave Object-parameterized types raw
type.cook.perform.exhaustive.search=Perform &exhaustive search
type.cook.preserve.raw.arrays=Preserve raw &arrays
type.cook.produce.wildcard.types=Produce &wildcard types
type.cook.ratio.generified={0,choice,-1#not calculated|0#{0,number} of {1}}
type.cook.report=Items generified: {0}, casts removed: {1}
declaration.s.to.be.generified=Declaration(s) to be generified {0}
