// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
{
  generate = [
    psi = 'no'
    exact-types = 'elements'
    java = '8'
  ]

  parserClass = 'org.jetbrains.plugins.groovy.lang.parser.GroovyGeneratedParser'
  parserUtilClass = 'org.jetbrains.plugins.groovy.lang.parser.GroovyParserUtils'
  parserImports = [
    'static com.intellij.lang.parser.GeneratedParserUtilBase.*'
    'static org.jetbrains.plugins.groovy.lang.parser.GroovyGeneratedParserUtils.adapt_builder_'
  ]

  elementTypeHolderClass = 'org.jetbrains.plugins.groovy.lang.psi.GroovyElementTypes'
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.lexer.GroovyElementType'
  tokenTypeClass = 'org.jetbrains.plugins.groovy.lang.lexer.GroovyElementType'

  tokens = [
    SH_COMMENT = 'shell comment'
    SL_COMMENT = 'line comment'
    ML_COMMENT = 'block comment'

    IDENTIFIER = 'identifier'
    NL = 'new line'

    T_RBRACE = '}'
    T_LPAREN = '('
    T_RPAREN = ')'
    T_LBRACK = '['
    T_RBRACK = ']'
    T_LBRACE = '{'
    T_ELLIPSIS = '...'
    T_ARROW = '->'
    T_DOLLAR = '$'
    T_AT = '@'
    T_SEMI = ';'
    T_COLON = ':'
    T_COMMA = ','
    T_INC = '++'
    T_DEC = '--'
    T_EQ = '=='
    T_ID = '==='
    T_NEQ = '!='
    T_NID = '!=='
    T_LAND = '&&'
    T_LOR = '||'
    T_NOT = '!'
    T_NOT_IN = '!in'
    T_NOT_INSTANCEOF = '!instanceof'
    T_BNOT = '~'
    T_COMPARE = '<=>'
    T_REGEX_FIND = '=~'
    T_REGEX_MATCH = '==~'
    T_LT = '<'
    T_GT = '>'
    T_LE = '<='
    T_GE = '>='
    T_RANGE = '..'
    T_RANGE_RIGHT_OPEN = '..<'
    T_RANGE_LEFT_OPEN = '<..'
    T_RANGE_BOTH_OPEN = '<..<'
    T_DOT = '.'
    T_SAFE_DOT = '?.'
    T_SPREAD_DOT = '*.'
    T_METHOD_CLOSURE = '.&'
    T_METHOD_REFERENCE = '::'
    T_Q = '?'
    T_ELVIS = '?:'

    T_POW = '**'
    T_STAR = '*'
    T_DIV = '/'
    T_REM = '%'
    T_PLUS = '+'
    T_MINUS = '-'
    T_BAND = '&'
    T_XOR = '^'
    T_BOR = '|'

    T_ASSIGN = '='
    T_ELVIS_ASSIGN = '?='
    T_POW_ASSIGN = '**='
    T_STAR_ASSIGN = '*='
    T_DIV_ASSIGN = '/='
    T_REM_ASSIGN = '%='
    T_PLUS_ASSIGN = '+='
    T_MINUS_ASSIGN = '-='
    T_LSH_ASSIGN = '<<='
    T_RSH_ASSIGN = '>>='
    T_RSHU_ASSIGN = '>>>='
    T_BAND_ASSIGN = '&='
    T_XOR_ASSIGN = '^='
    T_BOR_ASSIGN = '|='

    KW_BOOLEAN = 'boolean'
    KW_BYTE = 'byte'
    KW_CHAR = 'char'
    KW_DOUBLE = 'double'
    KW_FLOAT = 'float'
    KW_INT = 'int'
    KW_LONG = 'long'
    KW_SHORT = 'short'
    KW_VOID = 'void'

    KW_ABSTRACT = 'abstract'
    KW_AS = 'as'
    KW_ASSERT = 'assert'
    KW_BREAK = 'break'
    KW_CASE = 'case'
    KW_CATCH = 'catch'
    KW_CLASS = 'class'
    KW_CONTINUE = 'continue'
    KW_DEF = 'def'
    KW_VAR = 'var'
    KW_DEFAULT = 'default'
    KW_DO = 'do'
    KW_ELSE = 'else'
    KW_ENUM = 'enum'
    KW_EXTENDS = 'extends'
    KW_FALSE = 'false'
    KW_FINAL = 'final'
    KW_FINALLY = 'finally'
    KW_FOR = 'for'
    KW_IF = 'if'
    KW_IMPLEMENTS = 'implements'
    KW_IMPORT = 'import'
    KW_IN = 'in'
    KW_INTERFACE = 'interface'
    KW_INSTANCEOF = 'instanceof'
    KW_NATIVE = 'native'
    KW_NULL = 'null'
    KW_NEW = 'new'
    KW_NON_SEALED = 'non-sealed'
    KW_PACKAGE = 'package'
    KW_PERMITS = 'permits'
    KW_PRIVATE = 'private'
    KW_PROTECTED = 'protected'
    KW_PUBLIC = 'public'
    KW_RETURN = 'return'
    KW_RECORD = 'record'
    KW_SEALED = 'sealed'
    KW_STATIC = 'static'
    KW_STRICTFP = 'strictfp'
    KW_SUPER = 'super'
    KW_SWITCH = 'switch'
    KW_SYNCHRONIZED = 'synchronized'
    KW_THIS = 'this'
    KW_THROW = 'throw'
    KW_THROWS = 'throws'
    KW_TRAIT = 'trait'
    KW_TRANSIENT = 'transient'
    KW_TRUE = 'true'
    KW_TRY = 'try'
    KW_VOLATILE = 'volatile'
    KW_WHILE = 'while'
    KW_YIELD = 'yield'

    NUM_INT = 'Integer'
    NUM_LONG = 'Long'
    NUM_BIG_INT = 'BigInteger'
    NUM_BIG_DECIMAL = 'BigDecimal'
    NUM_FLOAT = 'Float'
    NUM_DOUBLE = 'Double'

    STRING_SQ = 'single quoted string'
    STRING_TSQ = 'triple single quoted string'
    STRING_DQ = 'double quoted string'
    STRING_TDQ = 'triple double quoted string'

    GSTRING_BEGIN = 'Gstring begin'
    GSTRING_CONTENT = 'Gstring content'
    GSTRING_END = 'Gstring end'

    SLASHY_BEGIN = 'regex begin'
    SLASHY_CONTENT = 'regex content'
    SLASHY_END = 'regex end'

    DOLLAR_SLASHY_BEGIN = '$/ regex begin'
    DOLLAR_SLASHY_CONTENT = '$/ regex content'
    DOLLAR_SLASHY_END = '$/ regex end'

    T_WRONG = 'wrong token'
  ]

  extends(".*_expression") = expression
  extends(".*_type_element") = type_element
  elementType('.*_modifier_list') = modifier_list
  elementType('.*_class_type_element') = class_type_element
  consumeTokenMethod('.*_expression') = 'consumeTokenFast'
  consumeTokenMethod('.*_expression_tail') = 'consumeTokenFast'
  consumeTokenMethod('.*_shift.*_sign') = 'consumeTokenFast'
  consumeTokenMethod('fast.*') = 'consumeTokenFast'
  consumeTokenMethod('.*_type_definition') = 'consumeTokenFast'
  name(".*type_element") = 'type'
  name('.*type_definition') = ''
}

root ::= mb_nl package_definition? mb_separators top_levels

// region Header constructs
package_definition ::= modifier_list mb_nl ('package') package_name
{
  pin = 3
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrPackageDefinitionElementType'
  consumeTokenMethod = 'consumeTokenFast'
}
private package_name ::= qualified_name { name = 'package name' }

import ::= modifier_list mb_nl ('import') 'static'? qualified_name import_star? import_alias?
{
  pin = 3
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrImportStatementElementType'
  consumeTokenMethod = 'consumeTokenFast'
}
private import_star ::= '.' '*'
import_alias ::= 'as' mb_nl IDENTIFIER
{
  pin = 1
}
// endregion


// region Modifiers
modifier_list ::= non_empty_modifier_list | empty_modifier_list
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrModifierListElementType'
}
empty_modifier_list ::=
non_empty_modifier_list ::= <<a_b_a (modifier | annotation) mb_nl>>
annotation_modifier_list ::= non_empty_annotation_list?
private non_empty_annotation_list ::= <<a_b_a annotation mb_nl>>
private modifier ::= 'abstract'
                   | 'default'
                   | 'final'
                   | 'native'
                   | 'private'
                   | 'protected'
                   | 'public'
                   | 'static'
                   | 'strictfp'
                   | 'synchronized' !'('
                   | 'transient'
                   | 'volatile'
                   | 'sealed'
                   | 'non-sealed'
                   | def_modifier
                   | var_modifier
{
  consumeTokenMethod = 'consumeTokenFast'
}
/*
 * 'def' is a part of a reference if followed by a dot
 */
private def_modifier ::= 'def' !'.' { consumeTokenMethod = 'consumeTokenFast' }

/*
 * 'var' could be modifier or identifier
 */
private var_modifier ::= 'var' &(weak_keyword | IDENTIFIER | modifier | type_element | tuple_var_declaration_tuple)  { consumeTokenMethod = 'consumeTokenFast' }
// endregion

private weak_keyword_identifiers ::= 'var' | 'yield' | 'permits' | 'record' { consumeTokenMethod = 'consumeTokenFast' }

private weak_keyword ::= weak_keyword_identifiers | clear_variants_and_fail

// region Annotations
annotation ::= '@' annotation_reference after_annotation_reference
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrAnnotationElementType'
  consumeTokenMethod = 'consumeTokenFast'
  extraRoot = true
}
private annotation_reference ::= simple_reference { name = 'annotation reference' }
private after_annotation_reference ::= mb_nl annotation_argument_list | empty_annotation_argument_list
annotation_argument_list ::= <<paren_list annotation_member_value_pair>>
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrAnnotationArgumentListElementType'
}
empty_annotation_argument_list ::= { elementType = annotation_argument_list }
annotation_member_value_pair ::= annotation_key '=' annotation_value | annotation_value
{
  name = 'annotation attribute'
  pin('.*') = 2
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrNameValuePairElementType'
  extraRoot = true
}
private annotation_key ::= weak_keyword | IDENTIFIER | 'as' | 'def' | 'in'
private annotation_value ::= annotation | annotation_array_value | expression
{
  name = 'annotation attribute initializer'
}
annotation_array_value ::= '[' annotation_array_item* (mb_nl ']') { pin = 1 }
private annotation_array_item ::= mb_nl <<separated_item annotation_array_item_end annotation_value annotation_array_item_start>>
private annotation_array_item_end ::= mb_nl (',' | &']' | end_of_file)
private annotation_array_item_start ::= '@' | expression_start
// endregion


// region Type definitions
private type_definition ::= (non_empty_modifier_list mb_nl | empty_modifier_list) type_definition_tail
private type_definition_tail ::= class_type_definition
                               | interface_type_definition
                               | trait_type_definition
                               | enum_type_definition
                               | annotation_type_definition
                               | record_type_definition
private class_definition_header ::= <<classIdentifier>> type_parameter_list? nl_extends nl_implements nl_permits
private interface_definition_header ::= <<classIdentifier>> type_parameter_list? nl_extends nl_non_empty_implements? nl_permits
private trait_definition_header ::= IDENTIFIER type_parameter_list? nl_extends nl_implements nl_permits
private enum_definition_header ::= <<classIdentifier>> nl_non_empty_extends? nl_implements
private annotation_definition_header ::= IDENTIFIER
private record_definition_header ::= <<classIdentifier>> type_parameter_list? method_parameter_list nl_implements

left class_type_definition ::= 'class' class_definition_header mb_nl class_body <<popClassIdentifier>>
{
  pin = class_definition_header
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrClassDefinitionElementType'
}
left interface_type_definition ::= 'interface' interface_definition_header mb_nl class_body <<popClassIdentifier>>
{
  pin = interface_definition_header
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrInterfaceDefinitionElementType'
}
left trait_type_definition ::= 'trait' trait_definition_header mb_nl class_body
{
  pin = trait_definition_header
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrTraitElementType'
}
left enum_type_definition ::= 'enum' enum_definition_header mb_nl enum_body <<popClassIdentifier>>
{
  pin = enum_definition_header
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrEnumDefinitionElementType'
}
left annotation_type_definition ::= '@' ('interface') annotation_definition_header mb_nl annotation_body
{
  pin = annotation_definition_header
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrAnnotationDefinitionElementType'
}
left record_type_definition ::= 'record' record_definition_header mb_nl record_body
{
  pin = record_definition_header
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrRecordDefinitionElementType'
}

class_body ::= '{' <<disableCompactConstructors class_body_inner>> '}'
{
  pin = 1
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrTypeDefinitionBodyElementType'
}
class_body_inner ::= mb_separators class_members { elementType = '' name = '' }
enum_body ::= '{' mb_nl <<disableCompactConstructors enum_members>> '}'
{
  pin = 1
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrEnumDefinitionBodyElementType'
}
annotation_body ::= '{' mb_nl <<disableCompactConstructors annotation_members>> '}'
{
  pin = 1
  elementType = class_body
}
record_body ::= '{' <<enableCompactConstructors class_body_inner>> '}'
{
  pin = 1
  elementType = class_body
}
// endregion


// region Members
private meta class_level_item ::= <<separated_item class_level_end <<item>> class_level_start>>

private class_members ::= class_member* clear_error
private class_member ::= <<class_level_item class_level>>
private class_level ::= class_initializer
                      | type_definition
                      | tuple_var_declaration <<error "tuple.cant.be.placed.in.class">>
                      | parse_class_declaration
private class_level_start ::= IDENTIFIER | modifier | '{' | '@' | 'class' | 'interface' | 'trait' | 'enum' | primitive_type
private class_level_end ::= separators | <<eof>> | &'}'

private enum_members ::= [enum_constants_separated] class_members
private enum_constants_separated ::= enum_constants class_level_end { pin = 1 }

private annotation_members ::= annotation_level_item*
private annotation_level_item ::= <<class_level_item annotation_level>>
private annotation_level ::= type_definition | parse_annotation_declaration
// endregion


// region Declarations
private meta declaration ::= <<choice
                                 <<d_modifiers <<after_modifiers>>>>
                                 <<d_no_modifiers <<after_no_modifiers>>>>
                             >>
private meta d_modifiers ::= non_empty_modifier_list mark_left <<mb_nl_group <<after_modifiers>>>> { pin = 1 }
private meta d_no_modifiers ::= empty_modifier_list mark_left <<after_no_modifiers>>

private declaration_start_modifiers ::= non_empty_modifier_list mb_type_parameter_list mb_declaration_type_element { pin = 1 }
private mb_type_parameter_list ::= [mb_nl type_parameter_list]
private mb_declaration_type_element ::= [mb_nl declaration_type_element]
private declaration_type_element ::= definitely_type_element | clear_variants_and_fail
private definitely_type_element ::= <<definitelyTypeElement type_element declaration_lookahead>>

private declaration_lookahead ::= method_lookahead | (<<isCompactConstructorAllowed>> compact_constructor_lookahead) | variable_lookahead
private variable_lookahead ::= &(weak_keyword | IDENTIFIER)
private method_lookahead ::= &(method_identifier '(')
private compact_constructor_lookahead ::= &(<<constructorIdentifier>>)
// endregion


// region Class level declarations
private parse_class_declaration ::= <<parseTailLeftFlat class_declaration_start class_declaration_tail>>
                                  | <<parseTailLeftFlat naked_method_declaration_start methods_tail>>
private class_declaration_start ::= declaration_start_modifiers | class_declaration_start_no_modifiers

private class_declaration_start_no_modifiers ::= empty_modifier_list class_declaration_start_after_no_modifiers
private class_declaration_start_after_no_modifiers ::= class_declaration_start_after_no_modifiers1
                                                     | class_declaration_start_after_no_modifiers2
private class_declaration_start_after_no_modifiers1 ::= capital_type_element !('(' | '{')
private class_declaration_start_after_no_modifiers2 ::= declaration_type_element
private naked_method_declaration_start ::= empty_modifier_list (method_lookahead | compact_constructor_lookahead)

private class_declaration_tail ::= <<mb_nl_group (methods_tail | field_declaration)>>
private methods_tail ::= constructor
                       | method
                       | <<isCompactConstructorAllowed>> compact_constructor

private parse_annotation_declaration ::= <<parseTailLeftFlat class_declaration_start annotation_tails>>
                                       | <<parseTailLeftFlat naked_method_declaration_start annotation_method>>
private annotation_tails ::= <<mb_nl_group (annotation_method | field_declaration)>>
// endregion


// region Class initializers
class_initializer ::= class_initializer_modifier_list mb_nl lazy_block
class_initializer_modifier_list ::= 'static' | !nl { consumeTokenMethod = 'consumeTokenFast' }
// endregion


// region Fields
field_declaration ::= field (',' mb_nl field)* { elementType = variable_declaration }
field ::= var { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrFieldElementType' }
// endregion


// region Enum constants
// A
// A,
// A, B
// A, B,
enum_constants ::= enum_constant ((mb_nl ',') mb_nl enum_constant)* [mb_nl ',']
{
  pin = 1
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrEnumConstantListElementType'
}
enum_constant ::= annotation_modifier_list mb_nl IDENTIFIER call_argument_list? enum_constant_initializer?
{
  pin = 3
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrEnumConstantElementType'
}
enum_constant_initializer ::= class_body
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrEnumConstantInitializerElementType'
}
// endregion


// region Methods
method ::= method_identifier method_parameter_list nl_throws [mb_nl lazy_block]
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrMethodElementType'
  pin = 2
}
constructor ::= constructor_identifier method_parameter_list nl_throws [mb_nl lazy_constructor_block]
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrConstructorElementType'
  pin = 2
}
compact_constructor ::= constructor_identifier empty_parameter_list empty_throws_clause [mb_nl lazy_constructor_block]
{
  elementType = constructor
  pin = 2
}
annotation_method ::= method_identifier method_parameter_list [mb_nl annotation_method_default] nl_throws
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrAnnotationMethodElementType'
  pin = 2
}
private annotation_method_default ::= 'default' annotation_value { pin = 1 }

private method_identifier ::= weak_keyword | IDENTIFIER | string_literal_tokens { consumeTokenMethod = 'consumeTokenFast' }
private constructor_identifier ::= <<constructorIdentifier>>
// endregion


// region Parameters
fake parameter_list ::= { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrParameterListElementType' }

method_parameter_list ::= <<paren_list parse_parameter>> { elementType = parameter_list }
private parse_parameter ::= <<parseTailLeftFlat parameter_start parameter>>
private parameter_start ::= parameter_start_modifiers | parameter_start_no_modifiers
private parameter_start_modifiers ::= non_empty_modifier_list mb_nl parameter_start_after_modifiers { pin = 1 }
private parameter_start_after_modifiers ::= parameter_type_element_silent? ellipsis?
private parameter_start_no_modifiers ::= empty_modifier_list parameter_start_after_no_modifiers
private parameter_start_after_no_modifiers ::= parameter_type_element_silent ellipsis? | ellipsis | variable_lookahead
private parameter_type_element_silent ::= parameter_type_element | clear_variants_and_fail
private parameter_type_element ::= primitive_type_element array_type_elements
                                 | qualified_class_type_element array_type_elements
                                 | unqualified_class_type_element &(weak_keyword | IDENTIFIER | ellipsis)
                                 | unqualified_class_type_element array_type_element array_type_elements
private ellipsis ::= '...' { consumeTokenMethod = 'consumeTokenFast' }
parameter ::= var { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrParameterElementType' }
// endregion


// region Reference lists
fake extends_clause ::=     { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrExtendsClauseElementType' }
fake implements_clause ::=  { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrImplementsClauseElementType' }
fake permits_clause ::=     { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrPermitsClauseElementType' }
fake throws_clause ::=      { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrThrowsClauseElementType' }

private nl_extends ::= nl_non_empty_extends | empty_extends_clause
private nl_implements ::= nl_non_empty_implements | empty_implements_clause
private nl_permits ::= nl_non_empty_permits | empty_permits_clause
private nl_throws ::= [nl &('throws' | '{')] (non_empty_throws_clause | empty_throws_clause)

empty_extends_clause ::= empty { elementType = extends_clause }
empty_implements_clause ::= empty { elementType = implements_clause }
empty_permits_clause ::= empty { elementType = permits_clause }
empty_throws_clause ::= empty { elementType = throws_clause }

private nl_non_empty_extends ::= mb_nl non_empty_extends_clause { consumeTokenMethod = 'consumeTokenFast' }
private nl_non_empty_implements ::= mb_nl non_empty_implements_clause { consumeTokenMethod = 'consumeTokenFast' }
private nl_non_empty_permits ::= mb_nl non_empty_permits_clause { consumeTokenMethod = 'consumeTokenFast' }

non_empty_extends_clause ::= 'extends' <<comma_list_p extends_list_item>>
{
  pin = 1
  elementType = extends_clause
  consumeTokenMethod = 'consumeTokenFast'
}
non_empty_implements_clause ::= 'implements' <<comma_list_p implements_list_item>>
{
  pin = 1
  elementType = implements_clause
  consumeTokenMethod = 'consumeTokenFast'
}
non_empty_permits_clause ::= 'permits' <<comma_list_p permits_list_item>>
{
  pin = 1
  elementType = permits_clause
  consumeTokenMethod = 'consumeTokenFast'
}
non_empty_throws_clause ::= 'throws' <<comma_list_p throws_list_item>>
{
  pin = 1
  elementType = throws_clause
  consumeTokenMethod = 'consumeTokenFast'
}

private extends_list_item ::= mb_nl type_code_reference | extends_list_item_recovered
private extends_list_item_recovered ::= empty fail { pin = 1 recoverWhile = extends_recovery }
private extends_recovery ::= !(',' | 'implements' | '{')
private implements_list_item ::= mb_nl type_code_reference | implement_list_item_recovered
private implement_list_item_recovered ::= empty fail { pin = 1 recoverWhile = implements_recovery }
private implements_recovery ::= !(',' | '{')
private permits_list_item ::= mb_nl type_code_reference | permits_list_recovered
private permits_list_recovered ::= empty fail { pin = 1 recoverWhile = permits_recovery }
private permits_recovery ::= !(',' | '{')
private throws_list_item ::= mb_nl type_code_reference
// endregion


// region Generics
type_parameter_list ::= '<' mb_nl type_parameters <<mb_nl_group '>'>>
{
  pin = 1
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrTypeParameterListElementType'
  consumeTokenMethod = 'consumeTokenFast'
}
private type_parameters ::= type_parameter type_parameters_tail*
private type_parameters_tail ::= ',' mb_nl type_parameter { pin = 1 }

type_parameter ::= IDENTIFIER (type_parameter_bounds_list | empty_type_parameter_bounds_list)
{
  name = 'type parameter'
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrTypeParameterElementType'
}
type_parameter_bounds_list ::= 'extends' mb_nl type_parameter_bounds
{
  pin = 1
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrTypeParameterBoundsElementType'
}
empty_type_parameter_bounds_list ::= { elementType = type_parameter_bounds_list }
private type_parameter_bounds ::= type_code_reference type_parameter_bounds_tail*
private type_parameter_bounds_tail ::= '&' mb_nl type_code_reference { pin = 1 }

type_argument_list ::= diamond_type_argument_list | non_empty_type_argument_list
private diamond_type_argument_list ::=  <<isDiamondAllowed>> fast_l_angle '>'
private non_empty_type_argument_list ::= '<' <<comma_list_p type_argument_list_item>> type_argument_list_end
{
  pin = 1
  consumeTokenMethod = 'consumeTokenFast'
}
private type_argument_list_item ::= mb_nl <<annotated type_argument>>
private type_argument_list_end ::= <<mb_nl_group '>'>>
private type_argument ::= any_type_element | wildcard_type_element
{
  name = 'type argument'
}
soft_type_argument_list ::= '<' soft_type_argument_list_item soft_type_argument_list_tail* type_argument_list_end
{
  consumeTokenMethod = 'consumeTokenFast'
  elementType = type_argument_list
}
private soft_type_argument_list_item ::= type_argument_list_item | clear_variants_and_fail
private soft_type_argument_list_tail ::= fast_comma mb_nl soft_type_argument_list_item
// endregion


// region Blocks
lazy_constructor_block ::= <<parseBlockLazy constructor_block 'CONSTRUCTOR_BLOCK'>> { elementType = '' }
constructor_block ::= '{' mb_separators [constructor_call_expression block_level_end] block_levels '}'
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrConstructorBlockElementType'
  pin = 1
  extraRoot = true
}
lazy_block ::= <<parseBlockLazy open_block 'OPEN_BLOCK'>> { elementType = '' }
open_block ::= open_block_impl
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrBlockElementType'
  extraRoot = true
}
open_block_switch_aware ::= <<insideSwitchExpression open_block_impl>>
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrBlockElementType'
  elementTypeFactory = 'org.jetbrains.plugins.groovy.lang.parser.parsing.util.ParserUtils.getSwitchAwareBlockElementType'
  extraRoot = true
}
private open_block_impl ::= '{' mb_separators block_levels '}' { pin = 1 }
// endregion


// region Block level constructs
private separator ::= ';' | NL | <<extendedSeparator>>
private separators ::= separator+
private mb_separators ::= separator*

private top_levels ::= top_level_item* clear_error
private top_level_item ::= <<addVariant "statement">> <<separated_item top_level_end top_level top_level_start>>
private top_level ::= import | statement
private top_level_start ::= 'import' | block_level_start
private top_level_end ::= separators | <<eof>>

// FIXME parse extended statement inside statement rule, i.e. expect separators after extended statement
private extended_statement_item ::= <<extendedStatement>> mb_separators

block_levels ::= block_level_item* clear_error { elementType = '' name = '' }
private block_level_item ::= extended_statement_item
                           | <<addVariant "statement">> <<separated_item block_level_end statement block_level_start>>
private block_level_start ::= statement_start | class_level_start
private block_level_end ::= top_level_end | &'}'

private case_level_item ::= extended_statement_item
                          | <<addVariant "statement">> <<separated_item case_level_end statement case_level_start>>
private case_level_start ::= statement_start | class_level_start | 'case' | 'default'
private case_level_end ::= block_level_end | &('case' | 'default')
{
  consumeTokenMethod = 'consumeTokenFast'
}
// endregion


// region Block level declarations
fake variable_declaration ::= { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrVariableDeclarationElementType' }

private parse_block_declaration ::= <<parseTailLeftFlat block_declaration_start block_declaration_tail>>
private block_declaration_start ::= declaration_start_modifiers | block_declaration_start_no_modifiers
private block_declaration_start_no_modifiers ::= empty_modifier_list block_declaration_type_element
private block_declaration_type_element ::= (capital_type_element | clear_variants_and_fail) declaration_lookahead
private block_declaration_tail ::= <<mb_nl_group (method | variable_declaration_tail)>>
private local_variable_declaration ::= <<parseTailLeftFlat block_declaration_start variable_declaration_tail>>

variable_declaration_tail ::= variable (',' mb_nl variable)*
{
  elementType = variable_declaration
  pin('variable_declaration_tail_1_0') = 1
}
variable ::= var { elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrVariableElementType' }

tuple_var_declaration ::= non_empty_modifier_list tuple_var_declaration_tuple mb_nl tuple_initializer
{
  elementType = variable_declaration
  pin = tuple_var_declaration_tuple
}
private tuple_var_declaration_tuple ::= '(' tuple_var_declaration_item (mb_nl ',' tuple_var_declaration_item)* mb_nl ')'
{
  consumeTokenMethod = 'consumeTokenFast'
  pin = 2
  pin('tuple_var_declaration_tuple_2_0') = 2
}

private tuple_var_declaration_item ::= mb_nl (type_element tuple_variable | tuple_variable)
tuple_variable ::= weak_keyword | IDENTIFIER
{
  elementType = variable
}
private tuple_initializer ::= '=' mb_nl expression_or_application
{
  pin = 1
}
// endregion


// region Statements
private statement_start ::= expression_start
                          | '@'
                          | statement_keywords
                          | modifier
                          | primitive_type
private statement_keywords ::= 'assert'
                             | 'break'
                             | 'continue'
                             | 'for'
                             | 'if'
                             | 'return'
                             | 'switch'
                             | 'throw'
                             | 'try'
                             | 'while'
{
  consumeTokenMethod = 'consumeTokenFast'
}
statement ::= if_statement
            | switch_statement
            | try_statement
            | while_statement
            | do_while_statement
            | for_statement
            | synchronized_statement
            | return_statement
            | break_statement
            | yield_statement
            | continue_statement
            | assert_statement
            | throw_statement
            | labeled_statement
            | type_definition | <<withProtectedLastVariantPos tuple_var_declaration>> | parse_block_declaration
            | expression_statement
            | block_statement
{
  elementType = ''
}

private branch ::= <<extendedStatement>> | statement

block_statement ::= !<<isParameterizedClosure>> lazy_block
{
  extraRoot = true
}

private expression_statement ::= expression_or_application_except_zero_params_closure

if_statement ::= 'if' after_if_keyword { pin = 1 }
private after_if_keyword ::= if_header mb_nl branch [mb_separators else_branch] { pin = 1 }
private if_header ::= '(' mb_nl expression_or_application mb_nl ')' { pin = 1 }
private else_branch ::= 'else' mb_nl branch { pin = 1 }

switch_statement ::= 'switch' '(' expression ')' (mb_nl switch_body)
{
  pin = 1
}
private switch_body ::= '{' mb_nl general_switch_section* '}' { pin = 1 }

try_statement ::= 'try' try_resource_list? mb_nl lazy_block (mb_nl catch_clause)* [mb_nl finally_clause] { pin = 1 }

try_resource_list ::= '(' try_resource_list_item+ ')' { pin = 1 }
private try_resource_list_item ::= mb_nl local_variable_declaration try_resource_list_separator { pin = 2 }
private try_resource_list_separator ::= &')' | separators

catch_clause ::= 'catch' '(' parse_catch_parameter ')' (mb_nl lazy_block) { pin = 1 }
private parse_catch_parameter ::= <<parseTailLeftFlat catch_parameter_start catch_parameter>>
private catch_parameter_start ::= modifier_list catch_parameter_type_element?
private catch_parameter_type_element ::= type_element_followed_by_identifier
                                       | type_element disjunction_type_element
catch_parameter ::= weak_keyword | IDENTIFIER { elementType = parameter }
finally_clause ::= 'finally' (mb_nl lazy_block)
{
  pin = 1
}

while_statement ::= 'while' after_while { pin = 1 }
private after_while ::= while_header mb_nl while_body { pin = 1 }
private while_header ::= '(' mb_nl expression mb_nl ')' { pin = 1 }
private while_body ::= followed_by_semi | branch

do_while_statement ::= 'do' mb_nl branch mb_nl 'while' '(' expression (mb_nl ')') { pin = 1 }

private type_element_followed_by_identifier ::= type_element variable_lookahead
private mb_type_element ::= type_element_followed_by_identifier?

for_statement ::= 'for' (for_header mb_nl for_body) { pin('.*') = 1 }
private for_header ::= '(' mb_nl for_clause mb_nl ')' { pin = 1 }
private for_clause ::= for_in_clause | traditional_for_clause

for_in_clause ::= for_in_parameter (':' | 'in') expression { consumeTokenMethod = 'consumeTokenFast' }
for_in_parameter ::= modifier_list mb_type_element (weak_keyword | IDENTIFIER) | clear_variants_and_fail { elementType = parameter }

traditional_for_clause ::= empty for_clause_initialization? mb_nl ';' mb_nl expression? mb_nl ';' mb_nl for_clause_update? { pin = 1 }
private for_clause_initialization ::= for_variable_declaration | expression | clear_variants_and_fail
private for_clause_update ::= expression_list

private for_variable_declaration ::= <<declaration fvd_after_modifiers fvd_after_no_modifiers>>
private fvd_after_modifiers ::= fvd_tuple_tail | fvd_modifiers_type | fvd_tail
left fvd_tuple_tail ::= tuple_var_declaration_tuple tuple_initializer { pin = 1 elementType = variable_declaration }
private fvd_modifiers_type ::= <<definitelyTypeElement type_element variable_lookahead>> fvd_tail { pin = 1 }
private fvd_after_no_modifiers ::= (capital_type_element variable_lookahead) fvd_tail { pin = 1 }
private fvd_tail ::= variable_declaration_tail <<wrapLeft>>

expression_list ::= expression mb_nl (',' mb_nl expression)*

// FIXME get rid of this weird logic
private for_body ::= &<<extendedStatement>> | followed_by_semi | statement { name = 'loop body' }

synchronized_statement ::= 'synchronized' '(' expression mb_nl ')' (mb_nl lazy_block)
{
  pin = 2
}

labeled_statement ::= IDENTIFIER after_label
private after_label ::= ':' mb_nl statement
{
  pin = 1
  consumeTokenMethod = 'consumeTokenFast'
}

return_statement ::= 'return' expression?

break_statement ::= 'break' IDENTIFIER?
continue_statement ::= 'continue' IDENTIFIER?
yield_statement ::= <<insideSwitchExpression>> 'yield' expression { pin = 2 }

throw_statement ::= 'throw' expression
{
  pin = 1
}

assert_statement ::= 'assert' expression assert_message?
{
  pin = 1
}
private assert_message ::= assert_message_separator (mb_nl expression)
{
  pin = 1
}
private assert_message_separator ::= ':' | ','
// endregion


// region Expressions
private expression_start ::= weak_keyword
                           | IDENTIFIER
                           | '!' | '(' | '+' | '++' | '-' | '--' | '[' | '~'
                           | 'this' | 'super'
                           | DOLLAR_SLASHY_BEGIN
                           | GSTRING_BEGIN
                           | SLASHY_BEGIN
                           | 'new'
                           | primitive_type
                           | simple_literal_tokens
{
  consumeTokenMethod = 'consumeTokenFast'
}
expression ::= priority15
             | conditionals               // 14
             | lor_expression             // 13
             | land_expression            // 12
             | bor_expression             // 11
             | xor_expression             // 10
             | band_expression            //  9
             | priority8
             | priority7
             | shift_or_range             //  6
             | additive_expression        //  5
             | multiplicative_expression  //  4
             | power_expression           //  2
             | prefix_unary_expression    //  3
             | priority1_4
             | priority1_5
             | qualified_expressions
             | priority1_2
             | priority1_1
             | priority0

fake reference_expression ::=
fake unary_expression ::=
private priority0 ::= unqualified_reference_expression
                    | built_in_type_expression
                    | literal
                    | gstring
                    | regex
                    | parenthesized_expression
unqualified_reference_expression ::= (weak_keyword | IDENTIFIER) soft_type_argument_list?
                                   | 'this'
                                   | 'super'
                                   | code_reference_identifiers_soft &(reference_dot | '.&')
                                   | (string_literal_tokens | regex_literal) &string_literal_as_reference
{
  elementType = reference_expression
}
// TODO use literal as reference element
private string_literal_as_reference ::= '('                                           // explicit method call
                                      | !<<isArguments>> !<<isApplicationArguments>> application_argument_start   // followed by application arguments
                                      | <<closureArgumentSeparator '{'>>              // closure arguments
{
  consumeTokenMethod = 'consumeTokenFast'
}
private application_argument_start ::= weak_keyword
                                     | IDENTIFIER
                                     | simple_literal_tokens
                                     | GSTRING_BEGIN
                                     | primitive_type
                                     | '~' | '!'
                                     | 'this' | 'super'
{
  consumeTokenMethod = 'consumeTokenFast'
}

built_in_type_expression ::= primitive_type

literal ::= simple_literal_tokens | regex_literal { extends = expression }
private simple_literal_tokens ::= NUM_INT
                                | NUM_LONG
                                | NUM_BIG_INT
                                | NUM_BIG_DECIMAL
                                | NUM_FLOAT
                                | NUM_DOUBLE
                                | string_literal_tokens
                                | 'true'
                                | 'false'
                                | 'null'
{
  consumeTokenMethod = 'consumeTokenFast'
}

private regex_literal ::= slashy_literal | dollar_slashy_literal { consumeTokenMethod = 'consumeTokenFast' }
slashy_literal ::= SLASHY_BEGIN fast_slashy_content !'$' SLASHY_END { pin = 3 }
dollar_slashy_literal ::= DOLLAR_SLASHY_BEGIN fast_dollar_slashy_content? !'$' DOLLAR_SLASHY_END { pin = 3 }

gstring ::= <<compound_string GSTRING_BEGIN fast_string_content GSTRING_END>> { extends = expression }
regex ::= slashy_string | dollar_slashy_string { extends = expression }
private slashy_string ::= <<compound_string SLASHY_BEGIN fast_slashy_content SLASHY_END>>
private dollar_slashy_string ::= <<compound_string DOLLAR_SLASHY_BEGIN fast_dollar_slashy_content DOLLAR_SLASHY_END>>

private fast_slashy_content ::= SLASHY_CONTENT
private fast_dollar_slashy_content ::= DOLLAR_SLASHY_CONTENT
private fast_string_content ::= GSTRING_CONTENT

private meta compound_string ::= <<begin>> (<<string_content <<content>>>> | string_injection)* <<end>> { pin = 1 }
meta string_content ::= <<content>>
string_injection ::= '$' string_injection_body
{
  pin = 1
  consumeTokenMethod = 'consumeTokenFast'
}
private string_injection_body ::= qualified_reference_expression | unqualified_reference_expression | lazy_closure | clear_variants <<unexpected "identifier.or.block.expected">>

parenthesized_expression ::= p_parenthesized_expression_inner
private p_parenthesized_expression_inner ::= '(' mb_nl <<insideParentheses expression>> mb_nl ')' { pin = 1 }

private priority1_1 ::= new_anonymous_expression | new_expression

new_anonymous_expression ::= 'new' type_argument_list? anonymous_type_definition { elementType = new_expression }
anonymous_type_definition ::= <<annotated code_reference>> call_argument_list mb_nl_inside_parentheses class_body
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.psi.stubs.elements.GrAnonymousElementType'
}

new_expression ::= 'new' type_argument_list? new_expression_creator { pin = 1 }
private new_expression_creator ::= <<annotated new_expression_type>> (l_paren_variant | new_expression_tail) { pin = 1 }
private new_expression_type ::= primitive_type_element | <<allowDiamond code_reference>>
private l_paren_variant ::= &'(' fail // adds a variant, to achieve "'(' expected" generated message
private new_expression_tail ::= array_initializer_tail | array_declaration | (mb_nl call_argument_list)

private array_initializer_tail ::= array_initializer_declaration mb_nl array_initializer
array_initializer_declaration ::= array_dimensions+ { elementType = array_declaration }
private array_dimensions ::= non_empty_annotation_list? '['(']') { consumeTokenMethod = 'consumeTokenFast' }
array_initializer ::= '{' mb_nl '}' | array_initializer_pin
private array_initializer_pin ::=  '{' <<a_b_a array_initializer_item array_initializer_separator>> array_initializer_separator? mb_nl '}' { pin = 1 }
private array_initializer_item ::= mb_nl expression
private array_initializer_separator ::= mb_nl ','

array_declaration ::= mandatory_expression optional_expression* { consumeTokenMethod = 'consumeTokenFast' }
private mandatory_expression ::= non_empty_annotation_list? '[' expression ']' { pin = 2 consumeTokenMethod = 'consumeTokenFast' }
private optional_expression ::= non_empty_annotation_list? '[' expression? ']' { pin = 2 consumeTokenMethod = 'consumeTokenFast' }

private priority1_2 ::= method_call_expression | lazy_closure | lambda_expression | single_parameter_lambda_expression | list_or_map
constructor_call_expression ::= &('this' | 'super') unqualified_reference_expression call_tail
method_call_expression ::= expression <<callTail call_tail_with_nl_before_closure call_tail>>
private call_tail ::= call_argument_list lazy_closure* | empty_argument_list lazy_closure+
private call_tail_with_nl_before_closure ::= call_argument_list (mb_nl lazy_closure)* | empty_argument_list (mb_nl lazy_closure)+

//region Lambda expression
lambda_expression ::= !<<isClosureParameter>> lambda_expression_base | clear_variants_and_fail
{
  extraRoot = true
}
private lambda_expression_base ::= lambda_expression_head mb_nl lambda_body { pin = 1 }
private lambda_expression_head ::= lambda_parameter_list mb_nl '->' { consumeTokenMethod = 'consumeTokenFast' }
lambda_parameter_list ::= empty_parens | '(' <<comma_list (mb_nl parse_parameter)>> ')' { elementType = parameter_list }
private lambda_body ::=  (!<<isParameterizedClosure>> lazy_block_lambda_body) | expression_lambda_body

expression_lambda_body ::= expression_or_application

single_parameter_lambda_expression::= !<<isClosureParameter>> <<isLambdaExpressionAllowed>> single_parameter_lambda_expression_base | clear_variants_and_fail { elementType = lambda_expression }
private single_parameter_lambda_expression_base ::= single_parameter_lambda_expression_head mb_nl single_parameter_lambda_body { pin = 1 }
private single_parameter_lambda_expression_head ::= single_parameter_lambda_parameter_list mb_nl '->' { consumeTokenMethod = 'consumeTokenFast' }

single_parameter_lambda_parameter_list ::= !<<isApplicationArguments>> single_parameter_lambda_parameter { elementType = parameter_list }
single_parameter_lambda_parameter ::= modifier_list (weak_keyword | IDENTIFIER) {
  elementType = parameter
}
private single_parameter_lambda_body ::= expression_single_parameter_lambda_body | lazy_block_lambda_body
expression_single_parameter_lambda_body ::= expression_or_application_except_zero_params_closure
{
  elementType = expression_lambda_body
}

lazy_block_lambda_body ::= <<parseBlockLazy block_lambda_body 'BLOCK_LAMBDA_BODY'>> {
  elementType = block_lambda_body
}

block_lambda_body ::= block_lambda_body_impl {
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrBlockLambdaBodyElementType'
  consumeTokenMethod = 'consumeTokenFast'
  extraRoot = true
}
block_lambda_body_switch_aware ::= <<insideSwitchExpression block_lambda_body_impl>> {
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrBlockLambdaBodyElementType'
  elementTypeFactory = 'org.jetbrains.plugins.groovy.lang.parser.parsing.util.ParserUtils.getSwitchAwareLambdaBlockElementType'
  extraRoot = true
}
private block_lambda_body_impl ::= '{' mb_nl block_levels '}'
// endregion

lazy_closure ::= <<parseBlockLazy closure 'CLOSURE'>>
{
  extends = expression
  elementType = closure
}
closure ::= closure_impl
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrClosureElementType'
  extraRoot = true
}
closure_switch_aware ::= <<insideSwitchExpression closure_impl>>
{
  elementTypeClass = 'org.jetbrains.plugins.groovy.lang.parser.GrClosureElementType'
  elementTypeFactory = 'org.jetbrains.plugins.groovy.lang.parser.parsing.util.ParserUtils.getSwitchAwareClosureBlockElementType'
  extraRoot = true
}
private closure_impl ::= '{' mb_nl closure_header mb_separators block_levels '}' { pin = 1   consumeTokenMethod = 'consumeTokenFast'
 }
private closure_header ::= closure_header_with_arrow | empty_parameter_list
private closure_header_with_arrow ::= empty_parameter_list mb_nl closure_arrow | closure_parameter_list mb_nl closure_arrow
private closure_arrow ::= '->'
closure_parameter_list ::= <<comma_list (mb_nl closure_parameter)>> { elementType = parameter_list }
private closure_parameter ::= <<closureParameter parse_parameter>>
empty_parameter_list ::= { elementType = parameter_list }

list_or_map ::= empty_list | empty_map | non_empty_list_or_map
{
  extends = expression
}

private empty_map ::= '[' mb_nl fast_colon mb_nl ']' { consumeTokenMethod='consumeTokenFast' }
private empty_list ::= '[' mb_nl ']' { consumeTokenMethod='consumeTokenFast' }
private non_empty_list_or_map ::= '[' bracket_argument_list_item bracket_argument_list_inner (mb_nl ']')
{
  pin = 2
}

private qualified_expressions ::= method_reference_expression | attribute_expression | qualified_reference_expression | property_expression
method_reference_expression ::= expression (mb_nl method_reference_dot) (mb_nl qualified_reference_expression_identifiers)
qualified_reference_expression ::= expression (mb_nl reference_dot) after_dot { elementType = reference_expression }
attribute_expression ::= expression (mb_nl attribute_dot) after_dot
property_expression ::= expression (mb_nl property_dot) <<mb_nl_group (type_argument_list? property_expression_identifiers)>>

private method_reference_dot ::= '.&' | '::' { consumeTokenMethod = 'consumeTokenFast' }
private reference_dot ::= '.' | '?.' | '*.' { consumeTokenMethod = 'fast' }
private attribute_dot ::= reference_dot mb_nl ('@') { consumeTokenMethod = 'fast' }
private property_dot ::= attribute_dot | method_reference_dot | reference_dot

private after_dot ::= <<mb_nl_group (type_argument_list? qualified_reference_expression_identifiers)>>
private qualified_reference_expression_identifiers ::= weak_keyword | IDENTIFIER
                                                     | string_literal_tokens
                                                     | regex_literal
                                                     | modifier
                                                     | keyword
                                                     | primitive_type
{
  name = 'property selector'
}
private property_expression_identifiers ::= parenthesized_expression | lazy_block | gstring | regex
{
  name = 'property selector'
}

private priority1_4 ::= not_expression | cast_expression
not_expression ::= ('~' | '!') mb_nl <<disableNlBeforeClosure>> expression { elementType = unary_expression }
cast_expression ::= &cast_expression_start '(' <<annotated type_element>> ')' cast_operand
private cast_expression_start ::= '(' non_empty_annotation_list? (IDENTIFIER | primitive_type) { consumeTokenMethod = 'consumeTokenFast' }
private cast_operand ::= !empty_parens <<castOperandCheck>> priority1_4

private priority1_5 ::= index_expression | safe_index_expression | postfix_unary_expression
index_expression ::= expression index_expression_argument_list
safe_index_expression ::= expression fast_question index_expression_argument_list not_colon { elementType = index_expression }
index_expression_argument_list ::= !empty_map '[' bracket_argument_list_inner (mb_nl ']')
{
  pin = 2
  elementType = argument_list
  consumeTokenMethod = 'consumeTokenFast'
}

postfix_unary_expression ::= expression ('++' | '--')
{
  elementType = unary_expression
}

power_expression ::= expression '**' mb_nl <<disableNlBeforeClosure>> expression

prefix_unary_expression ::= ('++' | '--' | '-' | '+') mb_nl <<disableNlBeforeClosure>> expression
{
  elementType = unary_expression
}

multiplicative_expression ::= expression mb_nl ('*' | '/' | '%') mb_nl <<disableNlBeforeClosure>> expression

additive_expression ::= expression mb_nl_inside_parentheses ('+' | '-') mb_nl <<disableNlBeforeClosure>> expression

private shift_or_range ::= shift_expression | range_expression
shift_expression ::= expression mb_nl shift_sign mb_nl <<disableNlBeforeClosure>> expression
private shift_sign ::= left_shift_sign | right_shift_unsigned_sign | right_shift_sign { consumeTokenMethod = 'consumeTokenFast' }
left_shift_sign ::= '<' '<'
right_shift_sign ::= '>' '>'
right_shift_unsigned_sign ::= '>' '>' '>'
range_expression ::= expression mb_nl ('<..' | '<..<' | '..' | '..<') mb_nl <<disableNlBeforeClosure>> expression

private priority7 ::= relational_expression | in_expression | instanceof_expression | as_expression
relational_expression ::= expression mb_nl relational_operator mb_nl <<disableNlBeforeClosure>> expression
private relational_operator ::= '<' !'<' | '<=' | '>' !'>' | '>=' { consumeTokenMethod = 'consumeTokenFast' }
in_expression ::= expression mb_nl ('in' | '!in') mb_nl <<disableNlBeforeClosure>> expression
instanceof_expression ::= expression mb_nl instanceof_expression_tail
private instanceof_expression_tail ::= ('instanceof' | '!instanceof') mb_nl (type_element | expect_type) { pin = 1 }
as_expression ::= expression mb_nl ('as') mb_nl type_element

private priority8 ::= equality_expression | compare_expression | regex_find_expression | regex_match_expression
equality_expression ::= expression mb_nl <<equalityOperator>> mb_nl <<disableNlBeforeClosure>> expression
compare_expression ::= expression mb_nl ('<=>') mb_nl <<disableNlBeforeClosure>> expression
{
  elementType = relational_expression
}
regex_find_expression ::= expression mb_nl ('=~') mb_nl <<disableNlBeforeClosure>> expression
regex_match_expression ::= expression mb_nl ('==~') mb_nl <<disableNlBeforeClosure>> expression

band_expression ::= expression mb_nl ('&') mb_nl <<disableNlBeforeClosure>> expression
xor_expression ::= expression mb_nl ('^') mb_nl <<disableNlBeforeClosure>> expression
bor_expression ::= expression mb_nl ('|') mb_nl <<disableNlBeforeClosure>> expression
land_expression ::= expression mb_nl ('&&') mb_nl <<disableNlBeforeClosure>> expression
lor_expression ::= expression mb_nl ('||') mb_nl <<disableNlBeforeClosure>> expression

private conditionals ::= ternary_expression | elvis_expression | switch_expression
ternary_expression ::= expression mb_nl (ternary_tail_pin | ternary_tail)
private ternary_tail_pin ::= '?' mb_nl !'[' expression mb_nl ':' mb_nl conditionals { pin = 3 consumeTokenMethod = 'consumeTokenFast' }
private ternary_tail ::= '?' mb_nl expression mb_nl ':' mb_nl conditionals { pin = 5 consumeTokenMethod = 'consumeTokenFast' }
elvis_expression ::= expression mb_nl ('?:' mb_nl) <<disableNlBeforeClosure>> expression
{
  rightAssociative = true
}

// region Switch expression
switch_expression ::= 'switch' '(' mb_nl expression mb_nl ')' mb_nl ('{' mb_nl <<insideSwitchExpression general_switch_section>>* '}') { pin = 1 }
private general_switch_section ::= !'}' (case_section | default_section) { pin = 1 recoverWhile = case_section_recovery }
private case_section_recovery ::= !('}' | 'case' | 'default')

case_section ::= 'case' <<forbidLambdaExpressions switch_expression_list>> switch_expr_remainder { pin = 1 }
switch_expression_list ::= expression (',' mb_nl expression)* { elementType = expression_list }
default_section ::= 'default' switch_expr_remainder { elementType = case_section pin = 1 }
private switch_expr_remainder ::= case_arrow_remainder | case_colon_remainder
// we need to enable yield here because groovy does not have such entity as switch statement with arrows, so technically yield is allowed there
private case_arrow_remainder ::= '->' mb_nl <<insideSwitchExpression case_level_item>> mb_separators { pin = 1 }
private case_colon_remainder ::= ':' mb_nl case_level_item* { pin = 1 }
// endregion


private priority15 ::= assignment_expression | tuple_assignment_expression
assignment_expression ::= expression mb_nl assignment_expression_rvalue { rightAssociative = true }
private assignment_expression_rvalue ::= (<<assignmentOperator>> mb_nl) expression_or_application { pin = 1 }

tuple_assignment_expression ::= single_tuple_assignment | multi_tuple_assignment
private single_tuple_assignment ::= single_tuple mb_nl tuple_initializer // don't pin because "(foo)" may be a parenthesized expression
private multi_tuple_assignment ::= tuple  mb_nl !'->' tuple_initializer { // pin only if it's not a part of "(foo, bar) -> baz"
  pin = 3
}
single_tuple ::= '(' mb_nl unqualified_reference_expression mb_nl ')' { elementType = tuple }
tuple ::= '(' mb_nl unqualified_reference_expression (mb_nl ',' mb_nl unqualified_reference_expression)+ mb_nl ')'
{
  consumeTokenMethod = 'consumeTokenFast'
}
// endregion


// region Applications
expression_or_application ::= <<notApplicationArguments expression_or_application_inner>> { elementType = '' name = '' }
private expression_or_application_inner ::= <<enableNlBeforeClosure expression>> application*
private application ::= <<parseApplication application_ref application_expression application_call application_index>>
{
  extends = expression
}
left application_ref ::= weak_keyword | IDENTIFIER | simple_literal_tokens
{
  elementType = reference_expression
  consumeTokenMethod = 'consumeTokenFast'
}
left application_expression ::= application_argument_list | clear_variants_and_fail
left application_call ::= call_argument_list (mb_nl lazy_closure)* | empty_argument_list (mb_nl lazy_closure)+ { elementType = method_call_expression }
left application_index ::= mb_question index_expression_argument_list

private expression_or_application_except_zero_params_closure ::= <<isParameterizedClosure>> expression_or_application
                                                                | !double_block_statement expression_or_application !<<isAfterClosure>>

private double_block_statement::= block_statement nls block_statement
// endregion


// region Arguments
fake argument_list ::=

empty_argument_list ::= { elementType = argument_list }

call_argument_list ::= !<<isParameterizedLambda>> (empty_parens | non_empty_argument_list)
{
  elementType = argument_list
}

private non_empty_argument_list::= '(' <<insideParentheses <<notApplicationArguments paren_argument_list_inner>>>> (mb_nl ')') {
  pin = 1
  consumeTokenMethod = 'consumeTokenFast'
}

private paren_argument_list_inner ::= paren_argument_list_item* clear_error
private bracket_argument_list_inner ::= bracket_argument_list_item*

private paren_argument_list_item ::= <<argument_list_item ')'>>
private bracket_argument_list_item ::= <<argument_list_item ']'>>

private meta argument_list_item ::= <<argument_list_item_head <<brace>>>> <<argument_list_item_end <<brace>>>> { pin = 1 }
private meta argument_list_item_head ::= <<argument_list_item_head0 <<brace>> <<argument_list_item_recovery <<brace>>>>>>
private meta argument_list_item_head0 ::= mb_nl !(end_of_file | <<brace>> | '}') parse_argument { pin = 2 recoverWhile = '<<recovery>>' }
private meta argument_list_item_end ::= <<mb_nl_group (',' | &<<brace>>)>>
private meta argument_list_item_recovery ::= !(nl | ',' | <<brace>> | '}' | qualified_reference_expression_identifiers | expression_start | argument_label)

application_argument_list ::= <<applicationArguments application_arguments>>
private application_arguments ::= argument (',' mb_nl argument)*

private parse_argument ::= <<parseArgument argument>>
private argument ::= spread_list_argument | named_argument | expression (map_argument_label map_argument)?

left map_argument_label ::= &':'
{
 elementType = argument_label
 consumeTokenMethod = 'consumeTokenFast'
}
left map_argument ::= ':' expression
{
 pin = 1
 consumeTokenMethod = 'consumeTokenFast'
 elementType = named_argument
}
spread_list_argument ::= !<<isApplicationArguments>> '*' expression { consumeTokenMethod = 'consumeTokenFast' }
named_argument ::= argument_label named_argument_tail
private named_argument_tail ::= ':' (mb_nl expression)
{
  pin = 1
  consumeTokenMethod = 'consumeTokenFast'
}
argument_label ::= weak_keyword | IDENTIFIER | string_literal_tokens | primitive_type | modifier | keyword | '*' { consumeTokenMethod = 'fast' }
// endregion


// region Type elements
type_element ::= (primitive_type_element | class_type_element) array_type_elements
{
  extraRoot = true
}

primitive_type_element ::= primitive_type <<setTypeWasPrimitive>>
external primitive_type ::= parsePrimitiveType

// Type element with last part capitalized or primitive type.
// Example 1: com.foo.bar.Baz       will match
// Example 2: com.foo.bar.Baz<Baz>  will match
// Example 3: com.foo.bar.baz       will not match
// Example 4: com.foo.bar.baz<Baz>  will not match
capital_type_element ::= (primitive_type_element | capital_class_type_element) array_type_elements { elementType = type_element }

class_type_element ::= code_reference
qualified_class_type_element ::= qualified_code_reference
unqualified_class_type_element ::= short_code_reference
private capital_class_type_element ::= <<capitalizedTypeElement class_type_element <<refWasCapitalized>>>>

private array_type_elements ::= array_type_element*
left array_type_element ::= non_empty_annotation_list? '[' mb_nl ']' { consumeTokenMethod = 'consumeTokenFast' }

wildcard_type_element ::= '?' wildcard_bound?
private wildcard_bound ::= ('extends' | 'super') <<annotated any_type_element>> { pin = 1 }
left disjunction_type_element ::= disjunction_type_element_part+
private disjunction_type_element_part ::= '|' (type_element | expect_type) { pin = 1 consumeTokenMethod = 'consumeTokenFast' }

private expect_type ::= <<replaceVariants "type">> fail
private any_type_element ::= <<anyTypeElement type_element>>
// endregion


// region Code references
code_reference ::= code_reference_base
{
  extraRoot = true
}
private code_reference_base ::= short_code_reference code_reference_tail*
qualified_code_reference ::= short_code_reference code_reference_tail code_reference_tail* { elementType = code_reference}
short_code_reference ::= code_reference_part { elementType = code_reference }
left code_reference_tail ::= code_reference_dot <<mb_nl_group code_reference_part>> <<setRefWasQualified>>
{
  pin = 1
  elementType = code_reference
  consumeTokenMethod = 'consumeTokenFast'
}
simple_reference ::= short_simple_reference simple_reference_tail* { elementType = code_reference }
short_simple_reference ::= code_reference_identifier { elementType = code_reference }
left simple_reference_tail ::= code_reference_dot <<mb_nl_group code_reference_identifier>> { elementType = code_reference } // don't pin on dot

private code_reference_dot ::= '.' !'*'
private code_reference_part ::= code_reference_identifier [type_argument_list <<setRefHadTypeArguments>>]
private code_reference_identifier ::= <<codeReferenceIdentifier code_reference_identifiers>>
private code_reference_identifiers ::= IDENTIFIER | weak_keyword_identifiers | code_reference_identifiers_soft (<<isQualifiedName>> | &'.')
private code_reference_identifiers_soft ::= 'def' | 'as' | 'in' | 'trait' | 'var' { consumeTokenMethod = 'consumeTokenFast' }

// for the sake of showing 'type expected' message
type_code_reference ::= <<annotated code_reference_base>> { elementType = '' name = 'type' }

private qualified_name ::= <<qualifiedName code_reference>>

//noinspection BnfUnusedRule
doc_reference ::= short_code_reference doc_reference_tail* { elementType = code_reference }
left doc_reference_tail ::= '.' code_reference_part { elementType = code_reference }
// endregion


// region Variables
private var ::= (weak_keyword | IDENTIFIER) mb_initializer
private mb_initializer ::= [mb_nl ('=') mb_nl expression_or_application]
{
  pin('.*') = 2
  consumeTokenMethod = 'consumeTokenFast'
}
// endregion


// region Other
private mb_nl_inside_parentheses ::= [<<insideParentheses>> mb_nl]
private mb_nl ::= nl*
private nls ::= nl+
private nl ::= NL { consumeTokenMethod = 'consumeTokenFast' }
// FIXME this rule allows error reporting in position before the new line
private meta mb_nl_group ::= <<something>> | <<withProtectedLastVariantPos (nls <<something>>)>>
private empty ::= ()
private empty_parens ::= '(' mb_nl (')') { consumeTokenMethod = 'consumeTokenFast' }

private mb_question ::= '?'? { consumeTokenMethod = 'consumeTokenFast' }

private not_colon ::= !fast_colon

private fast_question ::= '?'
private fast_colon ::= ':'
private fast_comma ::= ','
private fast_l_angle ::= '<'

private followed_by_semi ::= &';' { consumeTokenMethod = 'fast' }

private string_literal_tokens ::= STRING_SQ | STRING_TSQ | STRING_DQ | STRING_TDQ { consumeTokenMethod = 'consumeTokenFast' }
// endregion


// region Lists
private meta comma_list_p ::= <<a_b_a_p <<item>> fast_comma>>
private meta a_b_a_p ::= <<a>> (<<b>> <<a>>)* { pin('.*') = 1 }
private meta comma_list ::= <<a_b_a <<item>> fast_comma>>
private meta a_b_a ::= <<a>> (<<b>> <<a>>)* { pin = 1 }

private meta paren_list ::= empty_parens | '(' <<paren_list_inner <<item>>>> (mb_nl ')') { pin('paren_list_1') = 1 }
private meta paren_list_inner ::= <<paren_list_item <<item>>>> <<paren_list_tail <<item>>>>*
private meta paren_list_item ::= mb_nl empty <<item>> { pin = 2 recoverWhile = paren_list_item_recovery }
private meta paren_list_tail ::= mb_nl ',' <<paren_list_item <<item>>>> { pin = 2 }
private paren_list_item_recovery ::= !(',' | ')' | '}' | nl)
// endregion

//annotation nodes will be added to the root node of <<item>>
private meta annotated ::= (non_empty_annotation_list <<forceWrapLeft <<item>>>>) | <<item>>

// region Recovery

// item junk item -> parse item, recover junk until end or item, report missing end
// item junk end  -> parse item, recover junk until end or item, parse end
// junk item      -> recover junk until end or item, report missing end
// junk end       -> recover junk until end or item, parse separator

// fun item(end, element, start) = head(end, element, recovery(end, start)) | end
private meta separated_item ::= <<separated_item_head <<item_end>> <<element>> <<separated_recovery <<element_start>> <<item_end>>>>>> <<item_end>> { pin = 1 }
// fun head(end, element, recovery) = !end element { recoverWhile = recovery }
private meta separated_item_head ::= !<<item_end>> <<element>> { pin = 1 recoverWhile = '<<separated_recovery>>' }
// fun recovery(end, start) = !(end | start)
private meta separated_recovery ::= !(<<item_end>> | <<element_start>>)
// endregion


// region Generated parser util
private external keyword ::= parseKeyword
private clear_variants_and_fail ::= clear_variants fail
private external clear_variants ::= clearVariants
private external clear_error ::= clearError
private external fail ::= noMatch
private external end_of_file ::= eof
private external mark_left ::= markLeft
// endregion