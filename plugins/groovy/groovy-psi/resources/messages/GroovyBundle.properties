language.groovy=Groovy
filetype.groovy.description=Groovy
filetype.dgm.description=Groovy extension module descriptor file
filetype.dgm.display.name=DGM
filetype.logback.description=Groovy Logback DSL configuration
filetype.logback.display.name=Groovy Logback DSL
filetype.gdsl.description=IntelliJ Groovy DSL configuration
filetype.gdsl.display.name=Groovy DSL
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=Action generates propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=Action generates propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() and hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=Action generates equals and hashCode now
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter and Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=Generates getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=Generates setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=Generates getter
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=Constructor
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=Generates constructor
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=Generate toString() method
action.ExcludeFromStubGeneration.text=Exclude from Stub Generation
action.ExcludeFromStubGeneration.description=Don't generate Java stubs for this Groovy file on compilation
action.DumpGroovyControlFlowAction.text=Dump Groovy Control Flow
action.ConvertToCompileStatic.text=Convert to @CompileStatic
action.ConvertToCompileStatic.description=Convert Groovy files to @CompileStatic
action.ConvertGroovyToJava.text=Convert to Java
action.ConvertGroovyToJava.description=Convert Groovy files to Java
action.Groovy.NewScript.text=Groovy Script
action.Groovy.NewScript.description=Create new Groovy script
action.Groovy.NewClass.text=Groovy Class
action.Groovy.NewClass.description=Create new Groovy class
action.Groovy.CheckResources.Rebuild.text=_Rebuild Resources
action.Groovy.CheckResources.Rebuild.description=Run the compiler for all Groovy files in resource roots to check for compilation issues
action.Groovy.CheckResources.Make.text=_Build Resources
action.Groovy.CheckResources.Make.description=Run the incremental compiler for Groovy files in resource roots to check for compilation issues
group.Groovy.CheckResources.text=Gr_oovy Resources
group.Groovy.CheckResources.description=Run the compiler for Groovy files in resource roots to check for compilation issues
file.template.group.title.groovy=Groovy
groovy.term.class=class
groovy.term.record=record
groovy.term.interface=interface
groovy.term.trait=trait
groovy.term.enum=enum
groovy.term.annotation=annotation
groovy.term.type.parameter=type parameter
groovy.term.method=method
groovy.term.field=field
groovy.term.property=property
groovy.term.parameter=parameter
groovy.term.variable=local variable
groovy.term.binding=script binding variable
groovy.term.label=label
groovy.term.closure=closure
groovy.term.expression=expression
new.class.action.text=Groovy Class
new.class.action.description=Creates a new Groovy Class
new.class.dialog.title=New Groovy Class
new.class.list.item.class=Class
new.class.list.item.interface=Interface
new.class.list.item.trait=Trait
new.class.list.item.enum=Enum
new.class.list.item.annotation=Annotation
new.class.list.item.record=Record
invalid.qualified.name=This is not a valid Groovy qualified name
new.script.action.text=Groovy Script
new.script.action.description=Creates a new Groovy Script
new.script.dialog.title=Enter Name for New Groovy Script
new.script.list.item.script=Groovy script
new.script.list.item.script.dsl=GroovyDSL script
new.gant.script.dialog.title=New Gant Script
new.gant.script.dialog.message=Enter a name for a new Gant Script
debug.option=Enable &debug stack trace
groovy.debug.disable.specific.methods=Do not step &into specific Groovy classes
groovy.debug.caption=Groovy
########################################################################################################################
# Parser error messages
########################################################################################################################
identifier.expected=Identifier expected
identifier.or.block.expected=Identifier or code block expected
string.end.expected=String end expected
try.without.catch.finally='try' without 'catch' or 'finally'
expression.expected=Expression expected
duplicate.modifier=Duplicate modifier ''{0}''
########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=Cannot resolve symbol ''{0}''
cannot.access=Access to ''{0}'' exceeds its access rights
cannot.reference.non.static=Cannot reference non-static symbol ''{0}'' from static context
cannot.return.from.constructor=Cannot return an object from constructor
cannot.return.from.void.method=Cannot return an object from a method that returns 'void'
cannot.return.type=Cannot return ''{0}'' from method returning ''{1}''
cannot.apply.method.or.closure=''{0}'' cannot be applied to ''{1}''
cannot.apply.method1=''{0}'' in ''{1}'' cannot be applied to ''{2}''
cannot.apply.constructor=Constructor ''{0}'' in ''{1}'' cannot be applied to ''{2}''
cannot.apply.default.constructor=Cannot apply default constructor for class ''{0}''
cannot.instantiate.abstract.class=Cannot instantiate abstract class ''{0}''
cannot.instantiate.interface=Cannot instantiate interface ''{0}''
missing.required.named.parameter=Missing required named parameter ''{0}''
loss.of.precision=Possible loss of precision from ''{0}'' to ''{1}''
cannot.assign=Cannot assign ''{0}'' to ''{1}''
cannot.cast=Cannot cast ''{0}'' to ''{1}''
multiple.assignments.without.list.expr=Multiple assignments without list expressions on the right hand side are unsupported in static type checking mode
spread.operator.is.not.available=The spread operator cannot be used as argument with static type checking
replace.with.list.literal=Replace with list literal
replace.with.get.at=Replace with index access
incorrect.number.of.values=Incorrect number of values. Expected:{0} Was:{1}
invalid.lvalue=Invalid value to assign to
duplicate.class=Class ''{0}'' already exists in ''{1}''
duplicate.inner.class=Duplicate class: ''{0}''
script.generated.with.same.name=There is a synthetic class ''{0}'' generated for script code
variable.already.defined=Variable ''{0}'' already defined
field.already.defined=Field ''{0}'' already defined
create.class.family.name=Create Class
create.class.text=Create class ''{0}''
create.interface.text=Create interface ''{0}''
create.annotation.text=Create annotation ''{0}''
create.record.text=Create record ''{0}''
constructors.are.not.allowed.in.anonymous.class=Constructors are not allowed in anonymous class
no.such.property=Property ''{0}'' does not exist
change.modifier=Make ''{0}'' {1}
change.modifier.not=Make ''{0}'' not {1}
change.modifier.family.name=Change modifiers
parameter.cast.fix=Cast {0,number,ordinal} parameter to {1}
action.convert.lambda.to.closure=Convert lambda to closure
add.parenthesis.to.lambda.parameter.list=Add parentheses to parameter list
# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=default visible
# suppress inspection "UnusedProperty"
protected.visibility.presentation=protected
# suppress inspection "UnusedProperty"
private.visibility.presentation=private
# suppress inspection "UnusedProperty"
public.visibility.presentation=public
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=abstract
# suppress inspection "UnusedProperty"
static.visibility.presentation=static
# suppress inspection "UnusedProperty"
final.visibility.presentation=final
# suppress inspection "UnusedProperty"
sealed.visibility.presentation=sealed
# suppress inspection "UnusedProperty"
non.sealed.visibility.presentation=non-sealed
# suppress inspection "UnusedProperty"
native.visibility.presentation=native
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=synchronized
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suppress inspection "UnusedProperty"
transient.visibility.presentation=transient
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=volatile
# suppress inspection "UnusedProperty"
def.visibility.presentation=def
intention.family.name.convert.conditional.expression.to.elvis=Convert conditional expression to Elvis
intention.family.name.replace.with.keyed.access=Replace with keyed access
intention.family.name.fix.range.class=Fix range class
intention.family.name.make.return.implicit=Make return implicit
intention.family.name.simplify=Simplify
intention.family.name.remove.unnecessary.continue=Remove unnecessary continue
intention.family.name.remove.unnecessary.return=Remove unnecessary return
intention.family.name.add.parameter.cast=Add parameter cast
intention.family.name.replace.for.each.operator=Replace 'for-each' operator
intention.family.name.add.cast=Add cast
intention.family.name.change.variable.type=Change variable type
intention.family.name.replace.with.conditional.call=Replace with conditional call
intention.family.name.collapse.conditional.expressions=Collapse conditional expression
intention.family.name.remove.double.negation=Remove double negation
intention.family.name.activate.dsl.descriptor=Activate DSL Descriptor
intention.family.name.collapse.if.statement=Collapse 'if' statement
intention.family.name.replace.with.short.circuit.expression=Replace with short-circuit expression
intention.family.name.replace.something.with=Replace ''{0}'' with ''{1}''
intention.family.name.add.attributes.to.annotation=Add attributes to annotation
intention.family.name.fix.quotation=Fix quotation
intention.family.name.add.class.to.clause=Add class to clause
intention.family.name.add.missing.case.branches=Add missing case branches
intention.family.name.replace.modifiers=Replace modifiers
illegal.combination.of.modifiers=Illegal combination of modifiers
illegal.combination.of.modifiers.abstract.and.final=Illegal combination of modifiers 'abstract' and 'final'
modifier.volatile.not.allowed.here=Modifier 'volatile' not allowed here
modifier.transient.not.allowed.here=Modifier 'transient' not allowed here
modifier.0.not.allowed=Modifier ''{0}'' not allowed here
interface.cannot.have.modifier.final=Interface cannot have modifier 'final'
script.method.cannot.have.modifier.abstract=Script method cannot have modifier 'abstract'
script.cannot.have.modifier.native=Script cannot have modifier 'native'
interface.must.have.no.static.method=Interface must have no static method
only.abstract.class.can.have.abstract.method=Only abstract class can have abstract method
anonymous.class.cannot.have.abstract.method=Anonymous class cannot have abstract method
illegal.combination.of.modifiers.volatile.and.final=Illegal combination of modifiers 'volatile' and 'final'
variable.cannot.be=Variable cannot have modifier ''{0}''
remove.modifier=Remove ''{0}''
not.abstract.method.should.have.body=Not abstract method should have body
cannot.create.class.error.text=Cannot Create Class ''{0}'': {1}
cannot.create.class.error.title=Cannot Create Class
no.class.in.file.template=No Class Found in File Template
Inner.methods.are.not.supported=Inner methods are not supported
final.class.cannot.be.extended=Final class cannot be extended
# Groovy 1.7 checks
unsupported.inner.class.0=Inner classes are not supported in Groovy {0}
unsupported.anonymous.class.0=Anonymous classes are not supported in Groovy {0}
# Groovy 1.8 checks
unsupported.diamonds.0=Diamonds are not supported in Groovy {0}
unsupported.command.syntax.0=Command expression syntax is not supported in Groovy {0}
unsupported.dollar.slashy.string.0=Dollar slashy strings are not supported in Groovy {0}
unsupported.multiline.slashy.string.0=Multi-line slashy strings are not supported in Groovy {0}
#Groovy 2.3 checks
unsupported.traits.0=Traits are not supported in Groovy {0}
#Groovy 2.5 checks
duplicating.named.parameter=Duplicate named parameter ''{0}'' occurs in parameters: {1}
field.should.be.immutable=Field ''{0}'' should have immutable type or be declared so with @ImmutableOptions
immutable.options.property.not.exist=Property ''{0}'' does not exist
explicit.includes.and.excludes=Only one of 'includes' and 'excludes' should be supplied
require.closure.as.attribute.value=Expected closure as attribute value
initializers.are.forbidden.with.defaults=Default values are forbidden with 'defaults' disabled in @TupleConstructor
super.is.not.allowed.in.pre.with.call.super=Call to super is not allowed in 'pre' with 'callSuper' enabled
#Groovy 3.0 checks
illegal.default.modifier=Modifier 'default' makes sense only in interface's methods
illegal.default.modifier.fix=Remove 'default' modifier
default.modifier.in.old.versions=Modifier 'default' is available in Groovy 3.0 or later
unsupported.do.while.statement='do while' is not supported in current version
unsupported.tuple.declaration.in.for=Tuple declaration in 'for' initialization is not supported in current version
unsupported.multiple.variables.in.for=Multiple variables in 'for' initialization are not supported in current version
unsupported.expression.list.in.for.update=Multiple expressions in 'for' update are not supported in current version
unsupported.resource.list='try' with resources is not supported in current version
unsupported.array.initializers=Array initializers are not supported in current version
operator.is.not.supported.in=Operator ''{0}'' is not supported in current version
unsupported.negated.in=Negated 'in' is not supported in current version
unsupported.negated.instanceof=Negated 'instanceof' is not supported in current version
unsupported.elvis.assignment=Elvis assignment is not supported in current version
unsupported.safe.index.access=Safe index access is not supported in current version
unsupported.lambda=Lambdas are not supported in current version
unsupported.type.annotations=Type annotations are not supported in current version
unsupported.tuple.application.initializer=Application initializer is not supported in current version
illegal.single.argument.lambda=Single argument form of lambda is available only as right part of assignment expression or as argument inside method call
#Groovy 4.0 checks
inspection.message.modifier.sealed.available.with.groovy.or.later=Modifier 'sealed' is available in Groovy 4.0 or later
illegal.sealed.modifier.fix=Remove 'sealed' modifier
inspection.message.modifier.nonsealed.available.with.groovy.or.later=Modifier 'non-sealed' is available in Groovy 4.0 or later
illegal.nonsealed.modifier.fix=Remove 'non-sealed' modifier
inspection.message.permits.available.with.groovy.4.or.later='permits' is available in Groovy 4.0 or later
inspection.display.name.unnecessary.sealed.modifier=Unnecessary 'sealed' modifier
inspection.display.name.unnecessary.non.sealed.modifier=Unnecessary 'non-sealed' modifier
inspection.display.name.switch.exhaustiveness.check=Exhaustiveness check for switch expressions
inspection.display.name.pojo.without.compile.static=@POJO without @CompileStatic
inspection.separator.disable.in.file.types=Enable in file types:
inspection.message.only.one.final.sealed.non.sealed.should.be.applied.to.class=Only one of 'final', 'sealed', 'non-sealed', @Sealed, or @NonSealed should be applied to class
inspection.message.modifier.sealed.cannot.be.applied.to.enum.class=Modifier 'sealed' cannot be applied to enum class
inspection.message.modifier.non.sealed.cannot.be.applied.to.enum.class=Modifier 'non-sealed' cannot be applied to enum class
inspection.message.annotation.sealed.cannot.be.applied.to.enum.class=Annotation '@Sealed' cannot be applied to enum class
inspection.message.annotation.non.sealed.cannot.be.applied.to.enum.class=Annotation '@NonSealed' cannot be applied to enum class
inspection.message.invalid.permits.clause.must.be.sealed=Invalid ''permits'' clause: ''{0}'' must be ''sealed''
inspection.message.invalid.permits.clause.must.directly.extend=Invalid ''permits'' clause: ''{0}'' must directly extend ''{1}''
inspection.message.not.allowed.in.sealed.hierarchy=''{0}'' is not allowed in the sealed hierarchy
inspection.message.interface.has.no.explicit.or.implicit.implementors=Interface ''{0}'' has no explicit or implicit permitted implementers
inspection.message.class.has.no.explicit.or.implicit.subclasses=Class ''{0}'' has no explicit or implicit permitted subclasses
inspection.message.interface.cannot.be.non.sealed.without.sealed.parent=Interface ''{0}'' cannot be non-sealed without sealed parent
inspection.message.class.cannot.be.non.sealed.without.sealed.parent=Class ''{0}'' cannot be non-sealed without sealed parent
inspection.message.switch.expressions.are.available.with.groovy.4.or.later=Switch expressions are available in Groovy 4.0 or later
inspection.message.arrows.in.case.expressions.are.available.with.groovy.4.or.later=Arrows in case expressions are available in Groovy 4.0 or later
inspection.message.multiple.expressions.in.case.section.are.available.with.groovy.4.or.later=Multiple expressions in case labels are available in Groovy 4.0 or later
inspection.message.keyword.yield.available.with.groovy.4.or.later=Keyword 'yield' is available in Groovy 4.0 or later
inspection.message.mixing.arrows.colons.not.allowed=Mixing arrows and colons is not allowed
inspection.message.case.or.default.branches.are.expected='case' or 'default' branches are expected
inspection.message.yield.or.throw.expected.in.case.section='yield' or 'throw' is expected in the case section
inspection.message.switch.expressions.do.not.support.return=Switch expressions do not support 'return'
inspection.message.switch.expression.does.not.cover.all.possible.outcomes=Switch expression does not cover all possible outcomes
inspection.message.left.open.ranges.are.available.in.groovy.4.or.later=Left-open ranges are available in Groovy 4.0 or later
inspection.message.both.open.ranges.are.available.in.groovy.4.or.later=Both-open ranges are available in Groovy 4.0 or later
inspection.message.records.are.available.in.groovy.4.or.later=Records are available in Groovy 4.0.0-beta-2 or later
inspection.message.compact.constructor.should.have.explicit.visibility.modifier=Compact constructor must have explicit visibility modifier
inspection.message.fraction.literals.without.leading.zero.are.available.in.groovy.or.later=Fraction literals without leading zero are available in Groovy 4.0 or later
inspection.message.0.not.allowed.for.record=''{0}'' is not allowed for record
inspection.message.pojo.has.effect.only.with.compilestatic=@POJO has effect only with @CompileStatic
inspection.message.record.parameter.should.be.immutable=Record parameter ''{0}'' should have immutable type or be declared so with @ImmutableOptions
inspection.message.static.interface.methods.must.be.qualified.in.groovy.4='static' interface methods must be qualified starting from Groovy 4
checkbox.report.unmatched.null=Report unmatched 'null'

method.is.not.implemented=Method ''{0}'' is not implemented
change.implements.and.extends.classes=Normalize extends and implements lists
fix.package.name=Fix package name
checkbox.delegate.via.overloading.method=Delegate via overloading method
checkbox.ignore.conditional.operators=Ignore conditional operators
checkbox.ignore.obscure.operators=Ignore obscure operators
checkbox.ignore.double.checked.locking.on.volatile.fields=Ignore double-checked locking on volatile fields
checkbox.inspect.anonymous.closures=Inspect anonymous closures
checkbox.only.warn.if.loop.empty=Only warn if loop is empty
add.dynamic.property=Add dynamic property ''{0}''
duplicate.element.in.the.map=Duplicate element ''{0}'' in the map
dynamic.tool.window.id=Dynamic Members
create.field.from.usage.family.name=Create field from usage
create.field.from.usage=Create field ''{0}''
create.method.from.usage.family.name=Create method from usage
create.method.from.usage=Create method ''{0}''
create.variable.from.usage.family.name=Create variable from usage
create.variable.from.usage=Create variable ''{0}''
create.parameter.from.usage.family.name=Create parameter from usage
create.parameter.from.usage=Create parameter ''{0}''
add.dynamic.element=Add dynamic element
add.dynamic.method=Add Dynamic Method
add.dynamic.method.0=Add dynamic method ''{0}''
dynamic.type=Type
dynamic.name=Name
dynamic.properties.table.name=Method Arguments
dynamic.method.return.type=Return &type:
dynamic.method.property.type=Property &type:
are.you.sure.to.delete.dynamic.property=Are you sure to delete ''{0}''?
dynamic.property.deletion=Deletion Dynamic Property
are.you.sure.to.delete.elements=Are you sure to delete ''{0}'' elements?
dynamic.element.deletion=Dynamic Element Deletion
tuple.cant.be.placed.in.class=Multiple assignments are not allowed for fields
is.not.enclosing.class=''{0}'' is not an enclosing class
package.definition.cannot.have.modifiers=Package definition cannot have modifiers
import.statement.cannot.have.modifiers=Import statement cannot have modifiers
undefined.label=Undefined label ''{0}''
continue.outside.loop=The continue statement is only allowed inside loops
break.outside.loop.or.switch=The 'break' statement is only allowed inside loops or colon-style switch statements
label.already.used=Label ''{0}'' is already in use
break.outside.loop=The break statement with named labels is only allowed inside loops
Constructor=Constructor
Getter=Getter
Setter=Setter
not.allowed.modifier.in.for.in=Modifier ''{0}'' is not allowed here
property.name.expected=Property name expected
wildcards.are.not.allowed.in.extends.list=A super type may not specify a wildcard type
method.does.not.override.super=Method does not override method from its super class
method.duplicate=Method with signature {0} is already defined in the class ''{1}''
ambiguous.code.block=Ambiguous code block
call.without.parentheses.are.supported.since.groovy.3=Calls without parentheses in argument list are supported since Groovy 3.0
newlines.here.are.available.since.groovy.3=Newline characters in argument list are available since Groovy 3.0
cyclic.inheritance.involving.0=Cyclic inheritance involving ''{0}''
there.is.no.default.constructor.available.in.class.0=There is no default constructor available in class ''{0}''
groovy.library.is.not.configured.for.module=Groovy SDK is not configured for module ''{0}''
configure.groovy.library=Configure Groovy SDK\u2026
create.instance.of.built-in.type=Instantiation of built-in type
incorrect.variable.name=Incorrect variable name
no.interface.expected.here=No interface expected here
no.class.expected.here=No class expected here
invoke.completion.second.time.to.show.skipped.methods=Invoke completion second time to show skipped methods
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy files are mapped to ''{0}''.\nYou can map them to Groovy in Settings | File types
class.is.not.annotation=''{0}'' is not an annotation
method.call.is.ambiguous=Method call is ambiguous
operator.call.is.ambiguous=Operator call is ambiguous
duplicated.named.parameter=Duplicated named parameter ''{0}'' found
no.super.classes.found=No super classes found
no.super.method.found=No super methods found
cannot.assign.string.to.enum.0=Cannot assign string to enum ''{0}''
cannot.find.enum.constant.0.in.enum.1=Cannot find enum constant ''{0}'' in enum ''{1}''
recursive.constructor.invocation=Recursive constructor invocation
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=The usage of a map entry expression to initialize an Enum is currently not supported
class.definition.is.not.expected.here=Class definition is not expected here
move.class.0.from.method=Move ''{0}'' to correct place
move.class.from.method.family.name=Move to correct place quick-fix
cannot.infer.argument.types=Cannot infer argument types
Equals=Equals
default.initializers.are.not.allowed.in.abstract.method=Default initializers are not allowed in abstract methods
groovy.does.not.support.constructor.type.arguments=Groovy does not support constructor type arguments
illegal.escape.character.in.string.literal=Illegal escape character in string literal
method.with.type.parameters.should.have.return.type=Method with type parameters should have return type
primitive.type.parameters.are.not.allowed=Primitive type parameters are not allowed in type parameter list
primitive.bound.types.are.not.allowed=Primitive bound types are not allowed
ellipsis.type.is.not.allowed.here=Ellipsis type is not allowed here
method.0.is.too.complex.too.analyze=Method ''{0}'' is too complex to analyze.\nTypes of local variables are not inferred.
closure.is.too.complex.to.analyze=Closure is complex to analyze.\nTypes of local variables are not inferred.
0.is.deprecated=''{0}'' is deprecated
wrong.number.of.type.arguments=Wrong number of type arguments\: {0}; required\: {1}
type.argument.0.is.not.in.its.bound.should.extend.1=Type parameter ''{0}'' is not in its bound; should extend ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=Catch statement parameter type should be a subclass of Throwable
exception.0.has.already.been.caught=Exception ''{0}'' has already been caught
unnecessary.type=Unnecessary exception ''{0}''. ''{1}'' is already declared
create.enum=Create enum ''{0}''
create.trait=Create trait ''{0}''
annotation.field.can.only.be.used.within.a.script.body=Annotation @Field can only be used within a script body
annotation.field.can.only.be.used.within.a.script=Annotation @Field can only be used within a script
return.type.is.incompatible=The return type of {0} in {1} is incompatible with {2} in {3}
anonymous.class.derived.from.0=anonymous class derived from {0}
throws.clause.is.not.allowed.in.at.interface='throws' clause is not allowed in @interface members
at.interface.0.does.not.contain.attribute=@interface ''{0}'' does not contain attribute ''{1}''
duplicate.attribute=Duplicate attribute
missed.attributes=Missed attributes\: {0}
unexpected.attribute.type.0=Unexpected attribute type\: ''{0}''
annotation.field.should.have.type.declaration=Field in annotation should have type declaration
interface.members.are.not.allowed.to.be=Interface members are not allowed to be {0}
abstract.methods.must.not.have.body=Abstract methods must not have body
method.has.incorrect.modifier.volatile=Method has incorrect modifier 'volatile'
native.methods.cannot.have.body=Native methods cannot have body
top.level.class.may.not.have.private.modifier=Top level class may not have 'private' modifier
top.level.class.may.not.have.protected.modifier=Top level class may not have 'protected' modifier
property.missing=propertyMissing
attribute.name.expected=Attribute name expected
java.style.for.each.statement.requires.a.type.declaration=Java-style for-each statement requires a type declaration
super.cannot.be.used.in.static.context='super' cannot be used in static context
qualified.0.is.allowed.only.in.nested.or.inner.classes=Qualified {0} is allowed only in nested/inner classes
groovy.file.0=Groovy file ''{0}''
type.argument.list.is.not.allowed.here=Type argument list is not allowed here
initializers.are.not.allowed.in.interface=Initializers are not allowed in interface
initializer.cannot.have.annotations=Initializers cannot have annotations
initializer.cannot.be.0=Initializer cannot be {0}
constructors.are.not.allowed.in.interface=Constructors are not allowed in interface
type.parameters.are.unexpected=Type parameters are unexpected
constructors.cannot.have.return.type=Return type element is not allowed in constructor
constructor.cannot.have.static.modifier=Constructor may not be static
annotation.types.may.not.have.extends.clause=Annotation types may not have 'extends' clause
annotation.types.may.not.have.implements.clause=Annotation types may not have 'implements' clause
no.implements.clause.allowed.for.interface=Interfaces may not have 'implements' clause
enums.may.not.have.extends.clause=Enums may not have 'extends' clause
method.0.cannot.override.method.1.in.2.overridden.method.is.final=Method ''{0}'' cannot override method ''{1}'' in ''{2}''; overridden method is final
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=Method ''{0}'' cannot have weaker access privileges (''{1}'') than ''{2}'' in ''{3}'' (''{4}'')
tuple.declaration.should.end.with.def.modifier=Tuple declaration should end with 'def' modifier
injection.should.not.contain.line.feeds=GString injection must not contain line feeds
collection.literal.contains.named.argument.and.expression.items=Collection literal contains named and expression arguments at the same time
annotation.collector.cannot.have.attributes=Annotation type annotated with @AnnotationCollector cannot have attributes
annotation.type.cannot.be.inner=Annotation type cannot be inner
named.arguments.are.not.allowed.inside.index.operations=Named arguments are not allowed inside index operations
expected.0.to.be.inline.constant=Expected ''{0}'' to be an inline constant
cannot.assign.a.value.to.final.field.0=Cannot assign a value to final field ''{0}''
cannot.assign.a.value.to.final.parameter.0=Cannot assign a value to final parameter ''{0}''
variable.0.might.not.have.been.initialized=Variable ''{0}'' might not have been initialized
doc.end.expected='*/' expected
mixing.private.and.public.protected.methods.of.the.same.name=Mixing private and public/protected methods of the same name
explicit.constructors.are.not.allowed.in.immutable.class=Explicit constructors are not allowed for @Immutable class
repetitive.method.name.0=Repetitive method name ''{0}''
declared.type.0.have.to.extend.script=Declared type ''{0}'' does not extend ''groovy.lang.Script'' class
declared.type.0.extends.1.which.is.circular.inheritance=Declared type ''{0}'' extends ''{1}'', which is a circular inheritance
base.script.annotation.is.allowed.only.inside.scripts=Annotation @BaseScript can only be used within a script
delegate.annotation.is.only.for.methods.without.arguments=Annotation @Delegate couldn't be applied to method with arguments
builder.annotation.not.support.super.for.simple.strategy=Annotation attribute 'includeSuperProperties' not supported by groovy.transform.builder.SimpleStrategy
0.expressions.on.trait.fields.properties.are.not.supported.in.traits={0} expressions on trait fields/properties are not supported in traits
only.traits.expected.here=Only traits are expected here
anonymous.classes.cannot.be.created.from.traits=Anonymous classes from traits are available since Groovy 2.5.2
trait.method.cannot.be.protected=Trait methods are not allowed to be protected
non.static.classes.not.allowed=Non-static inner classes are not allowed in traits
selfType.class.does.not.inherit=@SelfType: Class ''{0}'' does not inherit ''{1}''
illegal.type.void=Illegal type: 'void'
illegal.method.name=Method name contains illegal character(s): {0}
indexed.property.is.applicable.to.properties.only=@IndexedProperty is applicable to properties only
listener.list.field.must.have.a.generic.collection.type=@ListenerList field must have a generic Collection type
listener.list.field.with.generic.wildcards.not.supported=@ListenerList field with generic wildcards not supported
synchronized.not.allowed.on.abstract.method=@Synchronized not allowed on abstract method
lock.field.0.must.be.static=Lock field ''{0}'' must be static
lock.field.0.must.not.be.static=Lock field ''{0}'' must not be static
lock.field.0.not.found=Lock field ''{0}'' not found
select.module.action.text=Select Module\u2026
select.module.action.description=Select module to use classpath of
select.module.popup.title=Use Classpath of Module
### Inspection groups ###
inspection.annotations=Annotations
inspection.assignments=Assignment issues
inspection.bugs=Probable bugs
inspection.confusing=Potentially confusing code constructs
inspection.control.flow=Control flow issues
inspection.data.flow=Data flow
inspection.error.handling=Error handling
inspection.gpath=GPath
inspection.naming=Naming conventions
inspection.method.metrics=Method metrics
inspection.redundancy=Declaration redundancy
inspection.threading=Threading issues
inspection.validity=Validity issues
inspection.style=Style
inspection.other=Other
### Inspections ###
inspection.display.name.result.of.assignment.used=Result of assignment used
inspection.display.name.assignment.can.be.operator.assignment=Assignment can be replaced with operator assignment
inspection.display.name.delegates.to=@DelegatesTo
inspection.display.name.unresolved.access=Unresolved reference expression
inspection.display.name.untyped.access=Untyped reference expression
inspection.display.name.list.set.can.be.keyed.access=Call to List.set can be keyed access
inspection.display.name.list.get.can.be.keyed.access=Call to List.get can be keyed access
inspection.display.name.map.put.can.be.keyed.access=Call to Map.put can be keyed access
inspection.display.name.map.get.can.be.keyed.access=Call to Map.get can be keyed access
inspection.display.name.parameter.naming.convention=Method parameter naming convention
inspection.display.name.constant.naming.convention=Constant naming convention
inspection.display.name.instance.variable.naming.convention=Instance variable naming convention
inspection.display.name.instance.method.naming.convention=Instance method naming convention
inspection.display.name.static.variable.naming.convention=Static variable naming convention
inspection.display.name.static.method.naming.convention=Static method naming convention
inspection.display.name.local.variable.naming.convention=Local variable naming convention
inspection.display.name.class.naming.convention=Class naming convention
inspection.display.name.groovydoc.check=Unresolved GroovyDoc reference
inspection.display.name.constructor.named.arguments=Named arguments of constructor call
inspection.display.name.result.of.object.allocation.ignored=Result of object allocation ignored
inspection.display.name.divide.by.zero=Division by zero
inspection.display.name.infinite.recursion=Infinite recursion
inspection.display.name.infinite.loop.statement=Infinite loop statement
inspection.display.name.non.short.circuit.boolean=Non short-circuit boolean
inspection.display.name.duplicate.switch.branch=Duplicate switch case
inspection.display.name.gstring.key=GString map key
inspection.display.name.octal.integer=Octal integer
inspection.display.name.overly.complex.boolean.expression=Overly complex boolean expression
inspection.display.name.clashing.trait.methods=Clashing trait methods
inspection.display.name.overly.complex.arithmetic.expression=Overly complex arithmetic expression
inspection.display.name.double.negation=Double negation
inspection.display.name.pointless.arithmetic=Pointless arithmetic expression
inspection.display.name.empty.statement.body=Statement with empty body
inspection.display.name.reassigned.in.closure.local.var=Local variable is reassigned in closure or anonymous class
inspection.display.name.result.of.increment.or.decrement.used=Result of increment or decrement used
inspection.display.name.negated.if=Negated if condition expression
inspection.display.name.in.argument.check=Incompatible 'in' argument types
inspection.display.name.negated.conditional=Negated conditional expression
inspection.display.name.nested.conditional=Nested conditional expression
inspection.display.name.conditional=Ternary expression
inspection.display.name.nested.switch=Nested switch statement
inspection.display.name.multiple.return.points.per.method=Method with multiple return points
inspection.display.name.method.with.more.than.three.negations=Method with more than three negations
inspection.display.name.overly.nested.method=Overly nested method
inspection.display.name.overly.long.method=Overly long method
inspection.display.name.overly.complex.method=Overly complex method
inspection.display.name.method.parameter.count=Method with too many parameters
inspection.display.name.while.loop.spins.on.field=While loop spins on field
inspection.display.name.unsynchronized.method.overrides.synchronized.method=Unsynchronized method overrides synchronized method
inspection.display.name.synchronization.on.variable.initialized.with.literal=Synchronization on variable initialized with literal
inspection.display.name.synchronization.on.non.final.field=Synchronization on non-final field
inspection.display.name.wait.while.not.synchronized='wait()' while not synced
inspection.display.name.wait.call.not.in.loop='wait()' not in loop
inspection.display.name.notify.while.not.synchronized='notify()' or 'notifyAll()' while not synced
inspection.display.name.system.run.finalizers.on.exit=Call to System.runFinalizersOnExit()
inspection.display.name.thread.stop.suspend.resume=Call to Thread.stop(), Thread.suspend(), or Thread.resume()
inspection.display.name.nested.synchronized.statement=Nested 'synchronized' statement
inspection.display.name.synchronized.method=Synchronized method
inspection.display.name.synchronization.on.this=Synchronization on 'this'
inspection.display.name.empty.sync.block=Empty 'synchronized' block
inspection.display.name.busy.wait=Busy wait
inspection.display.name.public.field.accessed.in.synchronized.context=Non-private field accessed in synchronized context
inspection.display.name.unconditional.wait=Unconditional 'wait' call
inspection.display.name.double.checked.locking=Double-checked locking
inspection.display.name.access.to.static.field.locked.on.instance=Access to static field locked on instance data
inspection.display.name.change.to.method=Operator invocation can be replaced with method call
inspection.display.name.change.to.operator=Method call can be replaced with operator invocation
inspection.display.name.unnecessary.alias=Unnecessary import alias
inspection.display.name.unnecessary.semicolon=Unnecessary semicolon
inspection.display.name.unnecessary.public.modifier=Unnecessary 'public'
inspection.display.name.unnecessary.def.modifier=Unnecessary 'def'
inspection.display.name.unnecessary.final.modifier=Unnecessary 'final'
inspection.display.name.java.style.properties.invocation=Java-style property access
inspection.display.name.trivial.if=Redundant 'if' statement
inspection.display.name.constant.if.statement=Constant if statement
inspection.display.name.constant.conditional=Constant conditional expression
inspection.display.name.trivial.conditional=Redundant conditional expression
inspection.display.name.return.from.closure.can.be.implicit='return' statement can be implicit
inspection.display.name.switch.statement.with.no.default=Switch statement with no default case
inspection.display.name.final.variable.access=Final variable access
inspection.display.name.unnecessary.return=Unnecessary 'return' statement
inspection.display.name.unnecessary.continue=Unnecessary 'continue' statement
inspection.display.name.fallthrough=Fallthrough in 'switch' statement
inspection.display.name.if.statement.with.too.many.branches=If statement with too many branches
inspection.display.name.if.statement.with.identical.branches=If statement with identical branches
inspection.display.name.conditional.can.be.conditional.call=Ternary expression can be replaced with safe call
inspection.display.name.conditional.can.be.elvis=Ternary expression can be replaced with elvis expression
inspection.display.name.conditional.with.identical.branches=Ternary expression with identical branches
inspection.display.name.loop.statement.that.doesnt.loop=Loop statement that doesn't loop
inspection.display.name.unreachable.statement=Unreachable statement
inspection.display.name.continue='continue' statement
inspection.display.name.break='break' statement
inspection.display.name.unused.catch.parameter=Unused 'catch' parameter
inspection.display.name.empty.try.block=Empty 'try' block
inspection.display.name.annotation.references.unknown.identifier=@TupleConstructor and @MapConstructor
inspection.display.name.unresolved.labels.in.named.variant=@NamedVariant/@NamedParam/@NamedDelegate unresolved label
inspection.display.name.empty.finally.block=Empty 'finally' block
inspection.display.name.empty.catch.block=Empty 'catch' block
inspection.display.name.throw.from.finally.block='throw' inside 'finally' block
inspection.display.name.return.from.finally.block='return' inside 'finally' block
inspection.display.name.method.may.be.static=Method can be made 'static'
inspection.display.name.continue.or.break.from.finally.block='continue' or 'break' from 'finally' block
inspection.display.name.unchecked.assignment.of.member.of.raw.type=Unchecked assignment from members of raw type
inspection.display.name.silly.assignment=Silly assignment
inspection.display.name.nested.assignment=Nested assignment
inspection.display.name.assignment.to.method.parameter=Assignment to method parameter
inspection.display.name.assignment.to.for.loop.parameter=Assignment to 'for' loop parameter
inspection.display.name.assignability.check=Incompatible type assignments
inspection.display.name.type.customizer=Type customizer inspection
inspection.display.name.unused.declaration=Unused declaration
inspection.display.name.second.unsafe.call=Second unsafe call
inspection.display.name.unused.assignment=Unused assignment
inspection.display.name.unused.inc.dec=Unused incrementing or decrementing
inspection.display.name.unassigned.access=Variable not assigned
inspection.display.name.no.return=Missing return statement
inspection.display.name.clashing.getters=Clashing getters
inspection.display.name.package.mismatch=Package mismatch
inspection.display.name.deprecated.api.usage=Deprecated API usage
inspection.display.name.unnecessary.qualified.reference=Unnecessary qualified reference
inspection.display.name.pointless.boolean=Pointless boolean expression
inspection.display.name.access.to.inaccessible.element=Inaccessible element
inspection.display.name.incorrect.range.argument=Incorrect range arguments
inspection.display.name.new.instance.of.singleton=New instance of class annotated with @groovy.lang.Singleton
inspection.display.name.check.labeled.statement=Labeled statement inspection
inspection.display.name.variable.can.be.final=Variable can be final
inspection.display.name.equals.between.inconvertible.types='equals()' between objects of inconvertible types
inspection.display.name.singleton.constructor=@Singleton constructors
inspection.display.name.implicit.null.argument=Implicit null argument
inspection.display.name.string.style.violation=String style violation
inspection.display.name.non.extending.permitted.subclasses=Non-extending permitted subclasses
inspection.message.access.to.static.field.locked.on.instance.data=Access to static field <code>#ref</code> locked on instance data #loc
inspection.message.assignment.replaceable.with.operator.assignment=<code>#ref</code> could be simplified to ''{0}'' #loc
inspection.message.assignment.to.for.loop.parameter=Assignment to for-loop parameter '#ref' #loc
inspection.message.assignment.to.method.parameter=Assignment to method parameter '#ref' #loc
inspection.message.ref.statement=#ref statement #loc
inspection.message.call.to.thread.ref.in.a.loop=Call to <code>Thread.#ref()</code> in a loop, probably busy-waiting #loc
inspection.message.conditional.expression.can.be.call=Conditional expression can be call #loc
inspection.message.conditional.expression.can.be.elvis=Conditional expression can be elvis #loc
inspection.message.conditional.expression=Conditional expression #loc
inspection.message.conditional.expression.with.identical.branches=Conditional expression with identical branches #loc
inspection.message.ref.can.be.simplified='#ref' can be simplified #loc
inspection.message.ref.statement.can.be.simplified=#ref statement can be simplified #loc
inspection.message.constant.name.ref.too.short=Constant name '#ref' is too short
inspection.message.constant.name.ref.too.long=Constant name '#ref' is too long
inspection.message.constant.name.ref.doesnt.match.regex=Constant name ''#ref'' doesn''t match regex ''{0}'' #loc
inspection.message.ref.inside.finally.block='#ref' inside 'finally' block #loc
inspection.message.divide.by.zero=Division by zero #loc
inspection.message.double.checked.locking=Double-checked locking #loc
inspection.message.double.negation.ref=Double negation #ref #loc
inspection.message.duplicate.switch.case.ref=Duplicate switch case '#ref' #loc
inspection.message.empty.ref.block=Empty '#ref' block #loc
inspection.message.ref.statement.has.empty.branch='#ref' statement has an empty branch
inspection.message.ref.statement.has.empty.body='#ref' statement has an empty body
inspection.message.cannot.resolve.method.call=Cannot resolve method 'call'
inspection.message.fallthrough.in.switch.statement=Fallthrough in 'switch' statement #loc
inspection.message.gstring.used.as.maps.key=GString is used as map''s key #loc
inspection.message.ref.statement.cannot.complete.without.throwing.exception=<code>#ref</code> statement cannot complete without throwing an exception #loc
inspection.message.code.ref.code.recurses.infinitely.can.only.complete.by.throwing.exception=<code>#ref</code> recurses infinitely, and can only complete by throwing an exception #loc
inspection.message.instance.method.name.ref.too.short=Instance method name '#ref' is too short
inspection.message.instance.method.name.ref.too.long=Instance method name '#ref' is too long
inspection.message.instance.method.name.ref.doesnt.match.regex=Instance method name ''#ref'' doesn''t match regex ''{0}'' #loc
inspection.message.instance.variable.name.ref.too.short=Instance variable name '#ref' is too short
inspection.message.instance.variable.name.ref.too.long=Instance variable name '#ref' is too long
inspection.message.couldnt.find.property.field.with.this.name=Couldn''t find property or field with this name #loc
inspection.message.instance.variable.name.ref.doesn.t.match.regex=Instance variable name ''#ref'' doesn''t match regex ''{0}'' #loc
inspection.message.call.to.ref.can.be.keyed.access=Call to '#ref' can be keyed access #loc
inspection.message.ref.statement.with.identical.branches='#ref' statement with identical branches #loc
inspection.message.ref.statement.with.too.many.branches=''#ref'' statement with too many branches ({0}) #loc
inspection.message.local.variable.name.ref.too.short=Local variable name '#ref' is too short
inspection.message.local.variable.name.ref.too.long=Local variable name '#ref' is too long
inspection.message.local.variable.name.ref.doesnt.match.regex=Local variable name ''#ref'' doesn''t match regex ''{0}'' #loc
inspection.message.code.ref.code.statement.doesnt.loop=<code>#ref</code> statement doesn''t loop #loc
inspection.message.method.ref.contains.too.many.parameters.0.1=Method ''#ref'' contains too many parameters ({0}>{1})
inspection.message.method.ref.has.too.many.negations=Method ''#ref'' has too many negations ({0} > 3)
inspection.message.ref.has.0.return.points=<code>#ref</code> has {0} return points #loc
inspection.message.negated.conditional.expression=Negated conditional expression #loc
inspection.message.negated.if.condition.expression=Negated if condition expression #loc
inspection.message.nested.assignment.expression=Nested assignment expression #loc
inspection.message.nested.conditional.expression=Nested conditional expression #loc
inspection.message.nested.ref.statement=Nested '#ref' statement #loc
inspection.message.non.short.circuit.boolean.expression=Non-short-circuit boolean expression #loc
inspection.message.call.to.ref.outside.synchronized.context=Call to '#ref' outside of synchronized context #loc
inspection.message.octal.integer.ref=Octal integer #ref #loc
inspection.message.overly.complex.arithmetic.expression=Overly complex arithmetic expression #loc
inspection.message.overly.complex.boolean.expression=Overly complex boolean expression #loc
inspection.message.method.ref.overly.complex.cyclomatic.complexity=Method ''#ref'' is overly complex (cyclomatic complexity = {0}>{1})
inspection.message.method.ref.too.long.statement.count=Method ''#ref'' is too long (statement count = {0}>{1})
inspection.message.method.ref.overly.nested.nesting.depth=Method ''#ref'' is overly nested (nesting depth = {0}>{1})
inspection.message.method.parameter.name.ref.too.short=Method parameter name '#ref' is too short
inspection.message.method.parameter.name.ref.too.long=Method parameter name '#ref' is too long
inspection.message.method.parameter.name.ref.doesnt.match.regex=Method parameter name ''#ref'' doesn''t match regex ''{0}'' #loc
inspection.message.non.private.field.accessed.in.synchronized.context=Non-private field '#ref' accessed in synchronized context  #loc
inspection.message.nested.assignment=Usage of assignment expression result #loc
inspection.message.result.increment.or.decrement.expression.used=Usage of increment or decrement results #loc
inspection.message.result.of.new.ref.is.ignored=Result of ''new #ref{0}'' is ignored #loc
inspection.message.ref.statement.at.end.closure.can.be.made.implicit=Explicit return at the end of closure #loc
inspection.message.silly.assignment=Silly assignment #loc
inspection.message.static.method.name.ref.too.short=Static method name ''#ref'' is too short
inspection.message.static.method.name.ref.too.long=Static method name ''#ref'' is too long
inspection.message.static.method.name.ref.doesnt.match.regex=Static method name ''#ref'' doesn''t match regex ''{0}'' #loc
inspection.message.static.variable.name.ref.too.short=Static variable name '#ref' is too short
inspection.message.label.name.ref.not.supported.by.0=Label name ''#ref'' is not supported by {0}
inspection.message.static.variable.name.ref.too.long=Static variable name '#ref' is too long
inspection.message.static.variable.name.ref.doesnt.match.regex=Static variable name ''#ref'' doesn''t match regex ''{0}'' #loc
inspection.message.property.0.is.final=Property ''{0}'' is final #loc
inspection.message.ref.statement.with.no.default.branch=#ref statement with no 'default' branch#loc
inspection.message.synchronization.on.non.final.field.ref=Synchronization on non-final field ''#ref'' #loc
inspection.message.synchronization.on.ref=Synchronization on '#ref' #loc
inspection.message.synchronization.on.variable.ref.which.was.initialized.with.literal=Synchronization on '#ref', which was initialized with a literal #loc
inspection.message.synchronized.method.ref=Synchronized method '#ref' #loc
inspection.message.call.to.system.ref=Call to 'System.#ref' #loc
inspection.message.call.to.thread.ref=Call to 'Thread.#ref' #loc
inspection.message.trivial.conditional.expression=Trivial conditional expression #loc
inspection.message.property.0.is.ignored.by.map.constructor=Property ''{0}'' is ignored by @MapConstructor #loc
inspection.message.unconditional.call.to.ref=Unconditional call to <code>#ref()</code> #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.loop=#ref is unnecessary as the last statement in a loop #loc
inspection.message.ref.is.unnecessary.as.last.statement.in.method.with.no.return.value=#ref is unnecessary as the last statement in a method with no return value #loc
inspection.message.unreachable.statement=Unreachable statement #loc
inspection.message.unsynchronized.method.ref.overrides.synchronized.method=Unsynchronized method '#ref' overrides a synchronized method #loc
inspection.message.cannot.determine.type.ref=Cannot determine type of '#ref'
inspection.message.call.to.ref.outside.of.loop=Call to '#ref' outside of loop #loc
inspection.message.call.to.ref.outside.of.synchronized.context=Call to '#ref' outside of the synchronized context #loc
inspection.message.ref.loop.spins.on.field=<code>#ref</code> loop spins on field #loc
inspection.message.package.name.mismatch=Package name mismatch
inspection.message.dsl.descriptor.file.has.been.changed.and.isnt.currently.executed=DSL descriptor file has been changed and isn''t currently executed
inspection.message.dsl.descriptor.file.has.been.disabled.due.to.processing.error=DSL descriptor file has been disabled due to a processing error
inspection.message.traits.0.contain.clashing.methods.with.signature.1=Traits {0} contain clashing methods with signature {1}
inspection.message.unused.catch.parameter.ref=Unused catch parameter '#ref' #loc
inspection.message.package.name.mismatch.actual.0.expected.1=Package name mismatch. Actual: ''{0}'', expected: ''{1}''
inspection.message.property.not.indexable.type.must.be.array.or.list.but.found.0=Property is not indexable. Type must be an array or a list but found {0}
inspection.message.type.argument.0.can.not.be.1=Type of argument ''{0}'' can not be ''{1}''
inspection.message.method.called.with.implicit.null.argument=Method is called with implicit null argument
inspection.message.plain.string.should.be.double.quoted=Plain string should be double-quoted
inspection.message.plain.string.should.be.single.quoted=Plain string should be single-quoted
inspection.message.plain.string.should.be.slashy.quoted=Plain string should be slashy-quoted
inspection.message.plain.string.should.be.dollar.slashy.quoted=Plain string should be dollar-slashy-quoted
inspection.message.plain.string.should.be.quoted.with.triple.quotes=Plain string should be quoted with '''
inspection.message.plain.string.should.be.quoted.with.triple.double.quotes=Plain string should be quoted with """
inspection.message.multiline.string.should.be.quoted.with.triple.quotes=Multiline string should be quoted with '''
inspection.message.multiline.string.should.be.quoted.with.triple.double.quotes=Multiline string should be quoted with """
inspection.message.multiline.string.should.be.slashy.quoted=Multiline string should be slashy-quoted
inspection.message.multiline.string.should.be.dollar.slashy.quoted=Multiline string should be dollar-slashy-quoted
inspection.message.string.escaping.could.be.minimized=Escaping could be minimized
inspection.message.interpolated.string.should.be.double.quoted=Interpolated string should be double-quoted
inspection.message.interpolated.string.should.be.dollar.slashy.quoted=Interpolated string should be dollar-slashy-quoted
inspection.message.interpolated.string.should.be.slashy.quoted=Interpolated string should be slashy-quoted
inspection.message.interpolated.string.should.be.quoted.with.triple.double.quotes=Interpolated string should be quoted with """
text.class.0.is.unused=Class {0} is unused
text.constructor.0.is.unused=Constructor {0} is unused
text.method.0.is.unused=Method {0} is unused
text.property.0.is.unused=Property {0} is unused
text.parameter.0.is.unused=Parameter {0} is unused
### Intention groups ###
intention.category.groovy=Groovy
intention.category.conversions=Groovy/Expression conversions
intention.category.closures=Groovy/Closures
intention.category.comments=Groovy/Comments
intention.category.groovy.style=Groovy/Groovy-style
intention.category.control.flow=Groovy/Control flow
intention.category.groovy.declaration=Groovy/Declaration
intention.category.groovy.other=Groovy/Other
configurable.GroovyCompilerConfigurable.display.name=Groovy Compiler
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=Alternatively, you can specify Groovy-Eclipse compiler at <a href=\\"#\\">Java Compiler page</a>
settings.compiler.select.path.to.groovy.compiler.configscript=Select path to Groovy compiler configscript
settings.compiler.path.to.configscript=Path to &configscript:
settings.compiler.invoke.dynamic.support=Invoke &dynamic support
settings.compiler.exclude.from.stub.generation=Exclude from stub generation:
settings.code.style.label.indent.style=Label indent style:
settings.code.style.label.indent.size=label indent size
settings.code.style.indent.statements.after.label=Indent statements after label
settings.code.style.absolute=Absolute
settings.code.style.indent.labels=Indent labels
settings.inlay.parameter.types=Parameter types
settings.inlay.inferred.parameter.types=Inferred parameter types
settings.inlay.type.parameter.list=Type parameter list
settings.inlay.show.type.hints.for=Show type hints for:
# suppress inspection "UnusedProperty"
inlay.groovy.implicit.null.argument.hint.description=Calls that pass no arguments to methods that take one argument, which means that an implicit null will be passed as the argument.
inlay.groovy.parameters.hints.inferred.parameter.types=Inferred parameter types in methods.
inlay.groovy.parameters.hints.type.parameter.list=Methods with one or more inferred type parameters. Requires the <b>Inferred parameter types<b/> hint.
intention.name.replace.with.in=Replace ':' with 'in'
intention.name.activate.back=Activate back
intention.name.cast.to.0=Cast to {0}
intention.name.replace.eq.with.0.eq=Replace ''='' with ''{0}=''
intention.name.cast.operand.to.0=Cast operand to {0}
intention.name.add.required.attributes.to.map.constructor=Add required attributes to '@MapConstructor'
intention.name.convert.to.single.quoted.string=Convert to single-quoted string
intention.name.change.quotes.to.triple.single.quotes=Change quotes to '''
intention.name.convert.to.double.quoted.string=Convert to double-quoted string
intention.name.change.quotes.to.triple.double.quotes=Change quotes to """
intention.name.convert.to.slashy.string=Convert to slashy string
intention.name.convert.to.dollar.slashy.string=Convert to dollar-slashy string
intention.name.add.to.clause=Add ''{0}'' to {1} clause of ''{2}''
intention.name.replace=Replace ''{0}'' with ''{1}''
intention.name.insert.default.branch=Insert 'default' branch
intention.name.insert.case.0=Insert ''case {0}''
intention.name.insert.case.0.case.1=Insert ''case {0}'', ''case {1}''
intention.name.insert.missing.branches=Insert missing branches
intention.name.remove.wrong.modifiers.for.record=Remove wrong modifiers for record
intention.name.make.compact.constructor.public=Make compact constructor 'public'
intention.name.replace.with.qualified.expression=Replace with qualified name
# suppress inspection "UnusedProperty"
intention.name.create.abstract.method.in.class=Create abstract method ''{0}'' in ''{1}''
# suppress inspection "UnusedProperty"
intention.name.create.method.in.class=Create method ''{0}'' in ''{1}''
# suppress inspection "UnusedProperty"
intention.name.create.constant.field.in.class=Create constant field ''{0}'' in ''{1}''
# suppress inspection "UnusedProperty"
intention.name.create.field.in.class=Create field ''{0}'' in ''{1}''
intention.name.create.enum.constant.0=Create enum constant ''{0}''
intention.family.name.create.field=Create field
intention.family.name.replace.keywords=Replace elements
add.compilestatic=Add @CompileStatic
leave.only.modifier.or.annotation.0=Leave only ''{0}''
add.modifier.sealed=Add modifier 'sealed'
action.remove.dynamic.member.text=Remove
action.remove.dynamic.member.description=Remove dynamic member
action.collapse.all.text=Collapse All
action.collapse.all.description=Collapse all
action.expand.all.text=Expand All
action.expand.all.description=Expand all
dynamic.members.column.name.element=Dynamic Element
dynamic.members.column.name.type=Type
command.name.add.dynamic.member=Add Dynamic Member
popup.content.navigation.to.overriding.classes.unavailable=Navigation to overriding classes is not possible during index update
overriding.methods.of.0=Overriding Methods of ''{0}''
expression.type.no.expression=No expression found
expression.type.unknown=<unknown>
add.class.to.extends.family.name=Implement
intention.family.name.rename=Rename
generated.stub.message=This stub is generated for Groovy class to make Groovy-Java cross-compilation possible
generated.stub.navigate.link.label=Go to the Groovy class
generated.stub.exclude.link.label=Exclude from stub generation
module.with.groovy=Simple module with attached Groovy library
action.build.restart.text=Build and Restart
action.build.module.restart.description=Build module ''{0}'' and restart
gdsl.investigate.link.label=Click here to investigate
gdsl.error.notification.title=DSL script execution error
dialog.message.gant.not.configured=Gant is not configured
investigate.gdsl.error.intention.name=View details
investigate.gdsl.error.family.name=Investigate DSL descriptor processing error
grab.intention.name=Grab the artifacts
grab.family.name=Grab
grab.progress.title=Processing @Grab annotations
grab.result.title={0} Grape dependency {0, choice, 0#jars|1#jar|2#jars} added
grab.jar.count=<b>{0}</b>: {1} {1, choice, 0#jars|1#jar|2#jars}
grab.error.ivy.missing.title=Ivy is Missing
grab.error.ivy.missing.message=Sorry, but IDEA cannot @Grab the dependencies without Apache Ivy. \
  Please add Apache Ivy to your module dependencies and re-run the action.
grab.error.0.title=Can''t run @Grab: {0}
this.super.completion.advertisement=Pressing {0} twice without a class qualifier would show all accessible static methods
optimize.imports.progress.title=Optimizing Imports in Groovy files\u2026
groovy.library.label=Groovy library:
replace.all.occurrences.and.remove.variable.0=Replace all occurrences and remove variable ''{0}''
introduce.variable.declare.final.label=Declare &final
introduce.variable.replace.all.occurrences=Replace &all occurrences
introduce.variable.replace.all.0.occurrences=Replace &all occurrences ({0} occurrences)
introduce.parameter.delegate.via.overload=De&legate via overloading method
introduce.parameter.replace.fields.border.title=Replace Fields Used in Expression with Their Getters
introduce.parameter.do.not.replace.option.label=Do n&ot replace
introduce.parameter.replace.inaccessible.fields.option.label=Replace fields &inaccessible in usage context
introduce.parameter.replace.all.fields.option.label=&Replace all fields
introduce.variable.type.label=&Type:
introduce.variable.name.label=&Name:
introduce.parameter.explicit.return.statement.option.label=Use e&xplicit return statement
introduce.parameter.delegating.unavailable.tooltip=Delegating is not allowed in closure context
introduce.variable.change.type.advertisement=Press {0} to change type
framework.0.home.label={0} home:
select.framework.0.home.title=Select {0} Home
framework.0.sdk.chooser.title={0} SDK
framework.0.sdk.chooser.description=Choose a directory containing {0} distribution
framework.0.sdk.chooser.error.message=Looks like {0} distribution in specified path is broken. Cannot determine version.
framework.0.sdk.chooser.error.title=Failed to Create Library
framework.0.library={0} library
framework.0.library.version.1={0} library of version {1}
framework.gant=Gant
script.runner.display.name=Groovy
script.runner.description=Groovy class or script
script.runner.chooser.title=Script Path
script.runner.chooser.description=Specify path to script
script.runner.module.not.specified.message=Module is not specified
script.runner.no.groovy.for.module=Groovy is not configured for module ''{0}''
script.runner.cant.find.script=Cannot find script ''{0}''
script.runner.unknown.script.type=Unknown script type ''{0}''
script.runner.file.is.not.groovy.file=Script file is not Groovy file
script.runner.class.does.not.exist=Class does not exist
script.runner.class.cannot.be.executed=Class cannot be executed
dialog.title.refactoring.unavailable.in.current.scope=Refactoring Unavailable in Current Scope
parameter.list.owner.chooser.title=Introduce Parameter to
extract.closure.command.name=Extract Closure
introduce.constant.title=Introduce Constant
undefined.library.version=undefined
method.parameters.count.max.parameters.option=Maximum number of parameters:
method.returns.max.returns.option=Return point limit:
overly.complex.method.complexity.limit.option=Method complexity limit:
overly.long.method.statements.limit.option=Maximum statements per method:
overly.nested.method.nesting.limit.option=Maximum nesting depth:
add.method.family=Add method
change.base.method.label=Change base method
change.usages.label=Change usages
convert.parameter.to.map.entry.title=Convert Parameter to Map Entry
live.template.context.declaration=Declaration
live.template.context.expression=Expression
live.template.context.statement=Statement
postfix.template.provider.name=Groovy
find.usages.method.0.of.class.1={0} of {1}
change.signature.type.column=Type
change.signature.default.initializer.column=Default Initializer
static.import.method.fix=Static import method\u2026
static.import.method.0.fix=Static import method ''{0}''
groovy.consoles.type=Groovy Consoles
getter.kind.gdk.method.0=GDK method {0}
getter.kind.method.0=Method {0}
getter.kind.getter.0=Getter {0}
parameter.hint.number.of.arguments={0, choice, 0#|1#{0} argument|2#{0} arguments}
surround.with.for=for
surround.with.if=if
surround.with.if.else=if / else
surround.with.if.expr=if (expr)
surround.with.if.else.expr=if (expr) / else
surround.with.parentheses=(expr)
surround.with.closure={ -> ... }.call()
surround.with.try=try
surround.with.try.catch=try / catch
surround.with.try.finally=try / finally
surround.with.try.catch.finally=try / catch / finally
surround.with.while=while
surround.with.while.expr=while (expr)
surround.with.cast=((Type) expr)
surround.with.with=with () {...}
surround.with.with.expr=with (expr)
surround.with.shouldFail=shouldFail () {...}
code.style.group.list.map.literals=List and map literals
code.style.option.align.when.multiple=Align when multiple
code.style.option.wrap.after.dot=Wrap after dot
code.style.option.align.multiline.named.arguments=Align multiline named arguments
code.style.option.use.flying.geese.braces=Use flying geese braces
code.style.option.import.annotations=Import annotations
code.style.option.simple.lambdas.closures.in.one.line=Simple lambdas/closures in one line
code.style.option.relational.operators=Relational operators (<, >, <=, >=, <=>)
code.style.option.unary.operators=Unary operators (!, -, +, ++, --, *)
code.style.option.in.named.argument.before.colon=In named argument before ':'
code.style.option.in.named.argument.after.colon=In named argument after ':'
code.style.option.list.maps.literals=List and maps literals
code.style.option.closure.left.brace.in.method.calls=Closure left brace in method calls
code.style.option.gstring.injection.braces=GString injection braces
code.style.option.tuple.assignment.expression=Tuple assignment expression
code.style.option.regexp.expression=Regexp expression (==~, =~)
code.style.option.before.assert.separator=Before 'assert' separator
code.style.option.after.assert.separator=After 'assert' separator
code.style.option.before.record.parameter.list=Before record parameter list
code.style.groovydoc.tab.name=GroovyDoc
code.style.groovydoc.enable=Enable GroovyDoc formatting
# @Singleton
singleton.constructor.found=@Singleton class should not have constructors
singleton.constructor.remove=Remove constructor
singleton.constructor.makeNonStrict=Make @Singleton non-strict
########################################################################################################################
# Unused imports
########################################################################################################################
unused.import=Unused import
optimize.imports=Optimize imports
optimize.all.imports=Optimize unused import statements
########################################################################################################################
# Create class fix
########################################################################################################################
dialog.create.class.package.chooser.title=Choose destination package
create.directory.command=Create Directory
destination.package=Destination package:
second.unsafe.call=Second unsafe call
call.can.throw.npe=Calling chain can throw NullPointerException
unused.default.parameter.message=Default parameter is not used
unused.default.parameter.fix=Remove initializer
unused.assignment.tooltip=Assignment is not used
unused.variable=Variable is not used
variable.can.be.final.tooltip=Variable ''{0}'' can be final
parameter.can.be.final.tooltip=Parameter ''{0}'' can be final
equals.between.inconvertible.types.tooltip=<code>{0}</code> between objects of inconvertible types ''{1}'' and ''{2}''
replace.with.operator.message=''{0}'' can be replaced with operator
replace.with.operator.fix=Replace ''{0}'' with operator
replace.with.operator.double.negation.option=Use double negation (i.e. !!)
replace.with.operator.compareTo.equality.option=Replace 'compareTo' equality to equals (i.e. ==)
replace.with.operator.parentheses=Do not suggest replace with operator if it entails additional parentheses
replace.with.method.message=Can be replaced with ''{0}'' method call
replace.with.method.fix=Replace with ''{0}'' method
unassigned.access.tooltip=Variable ''{0}'' might not be assigned
no.return.message=Not all execution paths return a value
unresolved.type.status=Type ''{0}'' is not resolved
no.type.specified=No type specified
dynamic.element=Dynamic Element
pointless.boolean.problem.descriptor=Redundant boolean operations #loc
pointless.arithmetic.error.message=Redundant arithmetic operations #loc
pointless.boolean.quickfix=Simplify
Cannot.perform.undo.operation=Cannot perform undo operation
Undo.disable=Undo Disabled
type.doesnt.contain.method=Type ''{0}'' cannot be iterated in range because it does not have method ''{1}''
type.doesnt.implement.comparable=Type ''{0}'' does not implement Comparable
add.method=Add method ''{0}()'' to class ''{1}''
implement.class=Implement {0}
fix.class=Fix class {0}
rtype.cannot.contain.ltype=''{1}'' cannot contain ''{0}''
new.instance.of.singleton=New instance of class annotated with @groovy.lang.Singleton
replace.new.expression.with.instance.access=Replace with instance access
getter.0.clashes.with.getter.1=Clash occurred: ''{0}'' with ''{1}''
unused.0=Unused ''{0}''
remove.0=Remove ''{0}''
replace.postfix.0.with.prefix.0=Replace postfix ''{0}'' with prefix ''{0}''
replace.0.with.1=Replace ''{0}'' with binary ''{1}''
local.var.0.is.reassigned=Local variable ''{0}'' is reassigned
anonymous.class=anonymous class
closure=closure
other.scope=Other scope
method.may.be.static=Method may be static
method.may.be.static.option.ignore.trait.methods=Ignore trait methods
method.may.be.static.only.private.or.final.option=Only check final or private methods
method.may.be.static.ignore.empty.method.option=Ignore empty methods
ignore.boolean.expressions=Ignore unassigned variables in boolean checks
highlight.if.groovy.object.methods.overridden=Highlight references from class overriding invokeMethod(), getProperty(), or setProperty()
highlight.if.missing.methods.declared=Highlight references from class declaring missingMethod() or missingProperty()
gr.package.inspection.check.scripts=Check scripts
java.style.property.access=Java-style accessor invocation
type.customizer.is.not.marked.as.a.resource.file=Type customizer script is not marked as compiler resources
add.to.resources=Add to resources
add.type.customizer.to.resources=Add type customizer script to resources
target.0.does.not.exist=Target ''{0}'' does not exist
target.annotation.is.unused=@Target is unused
change.lvalue.type=Change variable ''{0}'' type to ''{1}''
replace.qualified.name.with.import=Replace qualified name with import
comments.count.as.content=Comments count as content
ignore.when.catch.parameter.is.named.ignore.or.ignored=Ignore when catch parameter is named ignore or ignored
no.applicable.signature.found=No applicable signature found
expected.type.0=Expected ''{0}'', found ''{1}''
declare.explicit.implementations.of.trait=Declare explicit implementations of trait
unnecessary.modifier.description=Modifier ''{0}'' is not necessary
unnecessary.modifier.remove=Remove unnecessary ''{0}''
unnecessary.def.explicitly.typed.only=Only report in explicitly typed declarations
unnecessary.alias.fix=Remove unnecessary alias
unnecessary.alias.description=Alias is unnecessary
unnecessary.semicolon.description=Semicolon is unnecessary
unnecessary.semicolon.fix=Remove semicolon
dynamic.dialog.class.label=&Class:
dynamic.dialog.type.label=&Type:
dynamic.dialog.static.checkbox=&Static
find.method.ro.method.usages=Searching for Usages of Enclosing Method in Project Files
find.method.ro.closure.usages=Searching for Usages of Enclosing Closure in Project Files
conversion.method.not.allowed.in.non.groovy.files=Refactoring is not allowed for methods which have occurrences in non-Groovy files:
conversion.closure.not.allowed.in.non.groovy.files=Refactoring is not allowed for closures which have occurrences in non-Groovy files:
wrong.method.first.parameter.type=Method ''{0}'' is used with named arguments, but its first parameter ''{1}'' does not conform to Map type.
wrong.closure.first.parameter.type=Closure ''{0}'' is used with named arguments, but its first parameter ''{1}'' does not conform to Map type.
map.parameter.dialog.create.new.checkbox=&Create new parameter for named arguments
map.parameter.dialog.explicit.type.checkbox=Specify type explicitly
convert.cannot.itself=Refactoring is not available for map parameter itself
map.param.name=Map parameter &name:
convert.param.to.map.entry=Convert Parameter to Map Entry
closure.used.as.variable=Closure is passed as argument. Refactoring can break semantic.
do.you.want.to.change.method.return.type=Do you want to change return type of ''{0}'' method
do.you.want.to.change.variable.type=Do you want to change type of ''{0}''
closure.is.accessed.outside.of.groovy=Field <b>{0}</b> is accessed outside of Groovy
write.access.to.closure.variable=Write access to field <b>{0}</b>
field.is.used.in.argument.label=Field <b>{0}</b> is used in argument label
method.with.signature.already.exists=Method with signature {0} already exists
field.already.exists=Field <b>{0}</b> already exists
method.is.used.outside.of.groovy=Method is used outside of Groovy
do.you.want.to.change.type.of.parameter.in.method=Do you want to change type of parameter ''{0}'' in method ''{1}''
file.exists=File ''{0}'' already exists in directory ''{1}''
move.to.correct.dir.family.name=Move File to Correct Package
move.to.correct.dir=Move to package ''{0}''
add.return.type=Add return type
add.return.type.to.method.declaration=Add return type to method declaration
infer.method.parameters.types=Add explicit types to parameters
infer.method.parameters.types.for.method.declaration=Add explicit types for all parameters in method declaration
replace.with.wrapper=Replace with ''{0}''
replace.primitive.type.with.wrapper=Replace primitive type with wrapper
remove.parameter.0=Remove parameter ''{0}''
remove.unused.parameter=Remove unused parameter
remove.exception=Remove exception
remove.catch.block=Remove catch block
try.catch.fix=Try-catch fix
cannot.create.class=Cannot create class
rename.file.to.0=Rename file to ''{0}''
java.style.properties.invocation.intention.family.name=Change Java-style accessor invocation to Groovy-style property reference
java.style.properties.invocation.intention.name=Change to Groovy-style property reference
generate.equals.and.hashcode.already.defined.warning.anonymous=equals() and hashCode() already defined
generate.equals.and.hashcode.already.defined.warning=equals() and hashCode() already defined
generate.equals.and.hashcode.already.defined.title=equals() and hashCode() Already Defined
generate.equals.compare.nested.arrays.comment= // Compare nested arrays - values of {0} here
generate.equals.compare.arrays.comment= // Probably incorrect - comparing Object[] arrays with Arrays.equals
generate.property.missing.already.defined.warning=propertyMissing() already defined
generate.property.missing.already.defined.title=propertyMissing() Already Defined
generate.method.missing.already.defined.warning=methodMissing() already defined
generate.method.missing.already.defined.title=methodMissing() Already Defined
action.Gant.NewScript.text=Gant Script
action.Gant.NewScript.description=Create new Gant script
action.Groovy.Console.text=Groovy Console
action.Groovy.Console.description=Launch Groovy console
module.name.0.and.groovy.version.1={0} ({1})
groovy.version.0=Groovy {0}
groovy.version.bundled.0=Bundled Groovy {0}
configurable.greclipse.border.title=Groovy-Eclipse options
configurable.greclipse.path.label=Path to groovy-eclipse-batch jar:
configurable.greclipse.path.chooser.description=Select path to groovy-eclipse-batch-*.jar with version matching your Groovy distribution
configurable.greclipse.command.line.params.label=Additional command line parameters:
configurable.greclipse.debug.checkbox=Generate debug info
configurable.hotswap.checkbox=Enable hot-swap agent for Groovy code
configurable.hotswap.checkbox.description=May cause serialization issues in the debugged application
run.configuration.script.path.label=Script path:
run.configuration.module.chooser.label=&Module:
run.configuration.module.classpath.checkbox=Add module &classpath to the runner
pull.up.wont.be.accessible.from={0} won''t be accessible from {1}
pull.up.wont.be.accessible.from.the.subclass={0} uses {1} which won''t be accessible from the subclass.
pull.up.abstract.wont.be.accessible.from=Can''t make {0} abstract as it won''t be accessible from the subclass.
settings.inlay.implicit.null.argument=Implicit null argument
settings.inlay.show.hints.for.implicit.null.argument=Show hint for implicit null argument
header.extract.closure=Extract closure
string.sort.default=Default
string.sort.strings.with.escaping=Strings with escaping
string.sort.strings.with.interpolation=Strings with interpolation
string.sort.multiline.string=Multiline string
separator.preferable.string.kind=Preferable Kind
separator.domain.of.inspection.usage=Domain of Usage
checkbox.inspect.gradle.files=Inspect Gradle files
string.option.do.not.handle.specifically=Do not handle specifically
string.option.double.quoted.string=Double-quoted string
string.option.single.quoted.string=Single-quoted string
string.option.slashy.string=Slashy string
string.option.triple.quoted.string=Triple-quoted string
string.option.triple.double.quoted.string=Triple-double-quoted string
string.option.dollar.slashy.string=Dollar-slashy string
label.groovy.sdk=Groovy SDK:
local.variable.types=Local variable types
settings.inlay.show.variable.type.hints=Show local variable type hints
# suppress inspection "UnusedProperty"
inlay.groovy.variable.type.hints.description=Local variable types at declarations where they are not specified explicitly.
settings.inlay.put.type.hint.before.identifier=Put type hint before identifier
dialog.title.select.groovy.sdk=Select Groovy SDK
dialog.title.specify.groovy.sdk=Specify Groovy SDK home
dialog.title.no.jdk.specified.error=No Groovy SDK specified
dialog.title.no.jdk.specified.title=No Groovy SDK Specified
dialog.title.no.jdk.specified.prompt=Do you want to create a project with no SDK assigned?
dialog.title.validation.path.should.not.be.empty=Path should not be empty
dialog.title.validation.path.does.not.contain.groovy.sdk=Path does not contain Groovy SDK
dialog.title.validation.invalid.sdk.specified.title=Invalid Groovy SDK Specified
dialog.title.validation.invalid.sdk.specified.error=Invalid Groovy SDK specified
dialog.title.validation.directory.you.specified.does.not.contain.groovy.sdk.do.you.want.to.create.project.with.this.configuration=You specified a directory that does not contain Groovy SDK. Do you want to create a project with this configuration?
new.project.wizard.groovy.retrieving.has.failed=Failed to retrieve Groovy versions
new.project.wizard.groovy.creating.main.file=Creating Groovy Main File\u2026
documentation.cannot.infer.type.label=Cannot infer type
documentation.inferred.type.label=Inferred type
# GDK is an abbreviation for Groovy Development Kit
documentation.gdk.label=GDK
notification.group.groovy.dsl=Groovy DSL errors
notification.group.grape=Groovy @Grab annotation processed
# GINQ
ginq.error.message.expected.in.operator=Expected '\u2026 in \u2026'
ginq.error.message.expected.alias=Expected alias name
ginq.error.message.expected.data.source=Expected data source
ginq.error.message.expected.a.boolean.expression=Expected a boolean expression
ginq.error.message.on.is.expected.after.join='on' is expected after 'join'-like clause
ginq.error.message.on.should.not.be.provided.after.crossjoin='on' is not expected after 'crossjoin'
ginq.error.message.groupby.expected.a.list.of.expressions=Expected a list of expressions
ginq.error.message.orderby.expected.a.list.of.ordering.fields=Expected a list of ordering fields
ginq.error.message.expected.one.or.two.arguments.for.limit=Expected one or two arguments for 'limit'
ginq.error.message.unrecognized.query=Unrecognized query
ginq.error.message.0.must.be.before.1=''{0}'' must be before ''{1}''
ginq.error.message.0.must.be.after.1=''{0}'' must be after ''{1}''
ginq.error.message.from.must.be.in.the.start.of.a.query='from' must be in the start of a query
ginq.error.message.query.should.start.from.from=Query should start with 'from'
ginq.error.message.query.should.end.with.select=Query should end with 'select'
ginq.error.message.boolean.condition.expected=Boolean condition expected
ginq.error.message.container.expected=GINQ, Iterable, Stream, or array expected
ginq.code.style.group.ginq.clauses=GINQ clauses
ginq.code.style.option.wrap.on.clauses=Wrap 'on' clause
ginq.code.style.option.indent.on.clauses=Indent 'on' clause
ginq.code.style.option.wrap.having.clauses=Wrap 'having' clause
ginq.code.style.option.indent.having.clauses=Indent 'having' clause
ginq.code.style.option.space.after.keyword=Put space after keywords
shows.parameter.names.at.function.call.sites=Shows parameter names at function call sites.
######################################################################################################################
# Code style attributes
########################################################################################################################
attribute.descriptor.annotations=Annotations
attribute.descriptor.annotation.attribute.name=Annotation attribute name
attribute.descriptor.annotation.name=Annotation name
attribute.descriptor.braces.and.operators=Braces and Operators
attribute.descriptor.braces=Braces
attribute.descriptor.closure.expression.braces.and.arrow=Closure expression braces and arrow
attribute.descriptor.lambda.expression.braces.and.arrow=Lambda expression braces and arrow
attribute.descriptor.brackets=Brackets
attribute.descriptor.parentheses=Parentheses
attribute.descriptor.operator.sign=Operator sign
attribute.descriptor.comments=Comments
attribute.descriptor.line.comment=Line comment
attribute.descriptor.block.comment=Block comment
attribute.descriptor.groovydoc=Groovydoc
attribute.descriptor.groovydoc.text=Text
attribute.descriptor.groovydoc.tag=Tag
attribute.descriptor.classes.and.interfaces=Classes and Interfaces
attribute.descriptor.class=Class
attribute.descriptor.abstract.class=Abstract class
attribute.descriptor.anonymous.class=Anonymous class
attribute.descriptor.interface=Interface
attribute.descriptor.trait=Trait
attribute.descriptor.enum=Enum
attribute.descriptor.type.parameter=Type parameter
attribute.descriptor.methods=Methods
attribute.descriptor.method.declaration=Method declaration
attribute.descriptor.constructor.declaration=Constructor declaration
attribute.descriptor.instance.method.call=Instance method call
attribute.descriptor.static.method.call=Static method call
attribute.descriptor.constructor.call=Constructor call
attribute.descriptor.fields=Fields
attribute.descriptor.instance.field=Instance field
attribute.descriptor.static.field=Static field
attribute.descriptor.variables.and.parameters=Variables and Parameters
attribute.descriptor.local.variable=Local variable
attribute.descriptor.reassigned.local.variable=Reassigned local variable
attribute.descriptor.parameter=Parameter
attribute.descriptor.reassigned.parameter=Reassigned parameter
attribute.descriptor.references=References
attribute.descriptor.instance.property.reference=Instance property reference
attribute.descriptor.static.property.reference=Static property reference
attribute.descriptor.unresolved.reference=Unresolved reference
attribute.descriptor.strings=Strings
attribute.descriptor.string=String
attribute.descriptor.gstring=GString
attribute.descriptor.valid.string.escape=Valid string escape
attribute.descriptor.invalid.string.escape=Invalid string escape
attribute.descriptor.keyword=Keyword
attribute.descriptor.number=Number
attribute.descriptor.bad.character=Bad character
attribute.descriptor.list.map.to.object.conversion=List/Map to object conversion
attribute.descriptor.map.key.named.argument=Map key/Named argument
attribute.descriptor.label=Label