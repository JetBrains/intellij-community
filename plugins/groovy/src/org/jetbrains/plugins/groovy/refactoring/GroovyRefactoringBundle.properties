#
# Copyright 2000-2007 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

########################################################################################################################
# Introduce variable
########################################################################################################################
introduce.variable.title=Introduce Variable
only.in.groovy.files=This refactoring is available only in Groovy files
selected.block.should.represent.an.expression=Selected block should represent an expression
refactoring.is.not.supported.in.the.current.context=Refactoring is not supported in current context
refactoring.is.not.supported.in.method.parameters=Refactoring is not supported in closure or method parameters
replace.all.occurrences=Replace all occurrences
declare.final=Declare final
press.escape.to.remove.the.highlighting=Press Escape to remove the highlighting
specify.the.type.explicitly=Specify the type explicitly
variable.of.type=Variable of type:
selected.expression.has.void.type=Selected expression has void type
selected.expression.in.command.expression=Selected expression is part of command expression
introduced.variable.conflicts.with.parameter.0=Introduced variable will conflict with parameter {0}
introduced.variable.conflicts.with.variable.0=Introduced variable will conflict with local variable {0}

########################################################################################################################
# Inline variable
########################################################################################################################
inline.variable.title=Inline Variable
variable.is.never.used.0=Variable ''{0}'' is never used
field.is.never.used.0=Field ''{0}'' is never used
wrong.element.to.inline=The caret should be positioned on the name of Groovy method or local variable
cannot.find.a.single.definition.to.inline.local.var=Cannot find a single definition to inline local variable
cannot.find.a.single.definition.to.inline.field=No initializer present for the field
inline.local.command=Inline Variable
local.varaible.is.lvalue=Variable to be inlined has occurrence as lvalue in assignment
inline.local.variable.prompt.0.1=Inline local variable ''{0}''?

########################################################################################################################
# Extract method
########################################################################################################################
extract.method.title=Extract Method
selected.block.should.represent.a.statement.set=Selected block should represent a set of statements or an expression
multiple.output.values=There are multiple output values for the selected code fragment
selected.block.contains.invocation.of.another.class.constructor=Selected block contains invocation of another class constructor
specify.type.label=Specify return &type explicitly
name.label=&Name:
signature.preview.border.title=Signature Preview
parameters.border.title=Parameters
visibility.border.title=Visibility
method.border.title=Method
visibility.private=Private
visibility.public=Public
visibility.protected=Protected
row.move.up=Move Up
row.move.down=Move Down
method.is.already.defined.in.class=Method {0} is already defined in the class {1}.
method.is.already.defined.in.script=Method {0} is already defined in the script {1}.

########################################################################################################################
# Inline method
########################################################################################################################
inline.refactoring.title=Inline
inline.method.title=Inline Method
inline.method.border.title=Inline
inline.method.label=Method {0}
all.invocations.and.remove.the.method=Inline &all invocations and remove the method
all.invocations.in.project=Inline &all invocations in project
this.invocation.only.and.keep.the.method=Inline &this invocation only and keep the method
refactoring.cannot.be.applied.to.abstract.methods=Refactoring cannot be applied to abstract methods
refactoring.cannot.be.applied.no.sources.attached=Refactoring cannot be applied: no sources attached
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=Refactoring is not supported when return statement interrupts the execution flow
refactoring.is.not.supported.for.recursive.methods=Refactoring is not supported for recursive methods
refactoring.cannot.be.applied.to.constructors=Refactoring cannot be applied to constructors
refactoring.is.not.supported.in.parameter.initializers=Refactoring is not supported in parameter initializers
inline.method.prompt.0=Inline method ''{0}'' invocation?
refactoring.is.available.only.for.method.calls=Refactoring is available only for method calls
method.is.not.accessible.form.context.0=Method {0} used in inlined method is not accessible from call site
field.is.not.accessible.form.context.0=Field {0} used in inlined method is not accessible from call site
super.reference.is.used=Super call used in inlined method will not be valid after inline.

########################################################################################################################
# Inline method
########################################################################################################################
variable.conflicts.with.parameter.0=Chosen name conflicts with parameter {0}
variable.conflicts.with.variable.0=Chosen name  will conflict with local variable {0}
variable.conflicts.with.field.0=Chosen name  will conflict with field {0}

########################################################################################################################
# Introduce Parameter
########################################################################################################################
introduce.parameter.title=Introduce Parameter
groovy.does.not.support.inner.classes.but.it.is.used.in.parameter.initializer=Groovy does not support inner classes but it is used in parameter initializer.
groovy.does.not.support.anonymous.classes.but.it.is.used.in.parameter.initializer=Groovy does not support anonymous classes but it is used in parameter initializer.
error.wrong.caret.position.method.name=The caret should be positioned at the name of the method to be refactored.

########################################################################################################################
# Change signature
########################################################################################################################
changeSignature.refactoring.name=Change Signature
column.name.type=Type
column.name.name=Name
column.name.default.initializer=Initializer
column.name.default.value=Default value
method.duplicate=Method with signature {0} is already defined in {1}
replace.setter.for.property=The default setter for property ''{0}'' will be overwritten
replace.getter.for.property=The default getter for property ''{0}'' will be overwritten
name.is.wrong=Name ''{0}'' is incorrect
incorrect.data=Incorrect data
return.type.is.wrong=Return type is wrong
type.for.parameter.is.incorrect=Type for parameter ''{0}'' is incorrect
specify.default.value=Specify default value or initializer for parameter ''{0}''
changing.signature.of.0=Changing signature of {0}
refactored.method.will.cover.closure.property=Refactored method will override closure property ''{0}'' in {1}
changeSignature.not.throwable.type=Wrong type: ''{0}'' for exception, should extend java.lang.Throwable
changeSignature.wrong.type.for.exception=Wrong type: ''{0}'' for exception
changeSignature.no.type.for.exception=Specify a type for exception
no.occurrences.found=No occurrences found
expression.is.not.constant=Selected expression is not a constant
class.does.not.exists=Class {0} does not exists
class.does.not.exist.in.the.module=Class does not exists in the module. Do you want to create it?
closure.uses.external.variables=Closure uses external not constant variables
expression.invokes.not.static.methods=Expression invokes not static methods
class.language.is.not.groovy=Language of target class is not Groovy
implicit.getter.will.by.overriden.by.method=Implicit getter of property {0} will be overriden by method {1}
implicit.setter.will.by.overriden.by.method=Implicit setter of property {0} will be overriden by method {1}
usage.of.field.will.be.overriden.by.method=Usage of field will be overriden by method {0}
usage.will.be.overriden.by.method=Usage {0} will be overriden by method {1}
target.class.is.not.specified=Target class is not specified
is.not.class.name=''{0}'' is not class name
target.class.must.not.be.script=Target class must not be a script
rename.is.not.applicable.to.implicit.elements=Implicit elements cannot be renamed
rename.member=Rename {0}
rename.property=Rename property ''{0}''
cannot.introduce.field.in.script=There is no class in the scope
cannot.introduce.field.in.interface=Cannot introduce field in interface
expression.contains.errors=Expression contains errors
field.0.is.already.defined=Field {0} is already defined
access.to.created.field.0.will.be.overriden.by.method.1=Access to field {0} will be overriden by {1}
final.field.cant.be.initialized.in.cur.method=Final field cannot be initialized in current method
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=Selected variable is used for write
field.cannot.be.initialized.in.field.declaration=Field cannot be initialized in declaration
field.cannot.be.initialized.in.constructor(s)=Field cannot be initialized in constructor(s)
selected.variable.is.used.for.write=Selected variable is used for write
there.is.no.method.or.closure=There is no containing method or closure
remove.parameter.0.no.longer.used=Remove parameter ''{0}'' no longer used
convert.to.java.refactoring.name=Convert to Java
convert.to.java.can.work.only.with.groovy=Convert to Java refactoring works only with Groovy files
files.to.be.converted=Files to be converted
converting.files.to.java=Converting files to Java
convert.to.static.refactoring.name=Convert to @CompileStatic
convert.to.static.can.work.only.with.groovy=Convert to @CompileStatic refactoring works only with Groovy files
converting.files.to.static=Converting files to @CompileStatic
intention.converting.to.static=Apply convert to @CompileStatic
intention.converting.to.static.family=Convert to @CompileStatic
rename.groovy.property=Rename &Groovy property
change.usages.of.var=Change usages of variable ''{0}''?
reference.to.accessor.0.is.used=Reference to accessor <bold>{0}<bold> cannot be inlined.
variable.is.accessed.for.writing=Variable ''{0}'' is accessed for writing
introduce.closure.parameter.elements.header=Adding parameter to a closure
extract.closure.title=Extract closure
cannot.process.usage.in.language.{0}=Cannot process usage in {0}
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=You cannot pass ''{0}'' as parameter because you remove parameter ''{1}'' associated with it from the method. You should deselect "Remove parameter ''{0}'' no longer used" or deselect parameter ''{1}'' in the parameter table.
rename.groovy.implicit.closure.parameter=Rename implicit closure parameter
rename.implicit.closure.parameter.to=Rename implicit closure parameter to\:
implicit.closure.parameter=Implicit closure parameter
selected.expression.should.not.be.lvalue=Selected expression should not be left hand side of assignment
column.name.use.any.var=Use any var
rename.groovy.method=Rename Groovy method
cannot.inline.0.=Cannot inline {0}
ref.0.will.not.be.resolved.outside.of.current.context=Reference ''{0}'' will not be resolved outside of current context
cannot.rename.property.0=Cannot rename property <bold>''{0}''</bold> which overrides method <bold>''{1}''</bold>
cannot.inline.reference.0=Cannot inline reference ''{0}''
cannot.rename.script.class.to.0=Cannot rename script class ''{0}'' to ''{1}''
