#
#  Copyright 2000-2007 JetBrains s.r.o.
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

########################################################################################################################
# Groovy script template
########################################################################################################################
file.template.group.title.groovy=Groovy

newclass.dlg.title=New Groovy Class
newclass.menu.action.text=Groovy Class
newclass.menu.action.description=Creates new Groovy Class
newscript.dlg.prompt=Enter name for new Groovy Script
newscript.menu.action.text=Groovy Script
newscript.menu.action.description=Creates new Groovy Script
##########################################################################################################################
# GDK & compilation
########################################################################################################################

cannot.compile.groovy.files.no.facet=Cannot find Groovy home for module ''{0}''.\nYou should either:\n\
- invoke 'Add Framework support' action for this module,\n\
or:\n\
- add Groovy jars to module classpath manually.
cannot.compile.groovy.files.no.sdk=Cannot Compile Groovy Files.\nPlease Set up SDK for module ''{0}''.
cannot.compile.groovy.files.no.sdk.mult=Cannot Compile Groovy Files.\nPlease Set up SDK for modules ''{0}''.
cannot.compile=Cannot Compile
debug.option=Enable &debug stacktrace
groovy.debug.disable.specific.methods=Do not step &into specific Groovy classes
groovy.debug.caption=Groovy

########################################################################################################################
# Parser error messages
########################################################################################################################

separator.expected=';' or new line expected
separator.or.rcurly.expected=';', '}' or new line expected
import.keyword.expected='import' expected
import.identifier.expected=package or class name expected
identifier.expected=Identifier expected
import.not.allowed=Imports are not allowed inside blocks
identifier.or.block.expected=Identifier or code block expected
string.end.expected=String end expected
regex.end.expected=Regex ending expected
lbrack.expected='[' expected
rbrack.expected=']' expected
lparen.expected='(' expected
lcurly.expected='{' expected
comma.expected=',' expected
rcurly.expected='}' expected
rparen.expected=')' expected
comma.or.rparen.expected=',' or ')' expected
semi.expected=';' expected
gt.expected='>' expected
else.without.if='else' without 'if'
catch.without.try='catch' without 'try'
finally.without.try='finally' without 'try'
case.without.switch='case' outside 'switch' block
default.without.switch='default' outside 'switch' block
catch.or.finally.expected='catch' or 'finally' expected
colon.expected=':' expected
wrong.statement=Wrong statement
variable.definitions.expected=Variable definition expected
method.definitions.expected=Method definition expected
type.specification.expected=Type specification expected
type.definition.expected=Type definition expected
expression.expected=Expression expected
annotation.initializer.expected=Annotation initializer expected
annotation.member.value.initializer.expected=Annotation member value initializer expected
case.block.expected=Case block expected
case.expected='case' or 'default' expected
block.expression.expected=Block expression expected
wrong.string=Wrong string literal
path.selector.expected=Property selector expected
duplicate.modifier=Duplicate modifier ''{0}''
param.expected=Parameter expected
for.clause.expected=clause expected
at.expected='@' expected
if.expected='if' expected
compound.statemenet.expected=Initializer block expected
indentifier.or.string.or.left.parenth.literal.expected=Identifier, string literal or '(' expected

empty.parameter.list.expected=empty parameter list expected
string.name.unexpected=string name unexpected
method.definition.without.modifier=Method definition must be precede by modifier, type or 'def' keyword
interface.body.expected=interface body expected
interface.must.has.no.static.compound.statemenet=static compound statement unexpected in interface
interface.must.has.no.compound.statemenet=compound statement unexpected in interface

########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=Cannot resolve symbol ''{0}''
ambiguous.constructor.call=Ambiguous constructor call
cannot.access=Access to ''{0}'' exceeds its access rights
cannot.reference.static=Cannot reference static symbol ''{0}'', class qualifier needed
cannot.reference.non.static=Cannot reference non-static symbol ''{0}'' from static context
cannot.return.from.constructor=Cannot return an object from constructor
cannot.return.from.void.method=Cannot return an object from a method that returns 'void'
cannot.apply.method.or.closure=''{0}'' cannot be applied to ''{1}''
cannot.apply.method1=''{0}'' in ''{1}'' cannot be applied to ''{2}''
cannot.apply.constructor=Constructor ''{0}'' in ''{1}'' cannot be applied to ''{2}''
cannot.apply.default.constructor=Cannot apply default constructor for class ''{0}''
cannot.instantiate.abstract.class=Cannot instantiate abstract class ''{0}''
cannot.instantiate.interface=Cannot instantiate interface ''{0}''
cannot.assign=Cannot assign ''{0}'' to ''{1}''
invalid.lvalue=Invalid value to assign to
duplicate.class=Class ''{0}'' already exists in ''{1}''
duplicate.inner.class=Duplicate class: ''{0}''
script.generated.with.same.name=There is a synthetic class ''{0}'' generated for script code
variable.already.defined=Variable ''{0}'' already defined
field.already.defined=Field ''{0}'' already defined
import.what=Import ''{0}''
import.class=Import Class
create.class.family.name=Create Class
create.class.text=Create Class {0}
create.interface.text=Create Interface {0}
create.annotation.text=Create Annotation {0}
static.declaration.in.inner.class=Inner classes cannot have static declarations
constructors.are.not.allowed.in.anonymous.class=Constructors are not allowed in anonymous class
no.such.property=Property ''{0}'' does not exist
change.modifier=Make ''{0}'' {1}
change.modifier.not=Make ''{0}'' not {1}
change.modifier.family.name=Change modifiers
# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=default visible
# suppress inspection "UnusedProperty"
protected.visibility.presentation=protected
# suppress inspection "UnusedProperty"
private.visibility.presentation=private
# suppress inspection "UnusedProperty"
public.visibility.presentation=public
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=abstract
# suppress inspection "UnusedProperty"
static.visibility.presentation=static
# suppress inspection "UnusedProperty"
final.visibility.presentation=final
# suppress inspection "UnusedProperty"
native.visibility.presentation=native
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=synchronized
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suppress inspection "UnusedProperty"
transient.visibility.presentation=transient
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=volatile
# suppress inspection "UnusedProperty"
def.visibility.presentation=def



# {0} - colspan, {1} - method name, {2} - class name, {3} - formal myParameters row, {4} - arguments row
########################################################################################################################
# Compiler
########################################################################################################################
class.already.exists=Class ''{0}'' already exists

annotation.definition.qualified.name.expected=Annotation definition qualified name expected
type.expected=Type expected
type.parameter.expected=Type parameter expected
type.argument.expected=Type argument expected

illegal.combination.of.modifiers=Illegal combination of modifiers
illegal.combination.of.modifiers.abstract.and.final=Illegal combination of modifiers 'abstract' and 'final'
modifier.volatile.not.allowed.here=Modifier 'volatile' not allowed here
modifier.transient.not.allowed.here=Modifier 'transient' not allowed here
intarface.cannot.have.modifier.final=Interface cannot have modifier 'final'
script.method.cannot.have.modifier.abstract=Script method cannot have modifier 'abstract'
script.cannot.have.modifier.native=Script cannot have modifier 'native'
interface.must.have.no.static.method=Interface must have no static method
only.abstract.class.can.have.abstract.method=Only abstract class can have abstract method
anonymous.class.cannot.have.abstract.method=Anonymous class cannot have abstract method
illegal.combination.of.modifiers.volatile.and.final=Illegal combination of modifiers 'volatile' and 'final'
variable.cannot.be.native=Variable cannot have modifier 'native'
variable.cannot.be.abstract=Variable cannot have modifier 'abstract'
not.abstract.method.should.have.body=Not abstract method should have body
cannot.create.class.error.text=Cannot Create Class ''{0}'': {1}
cannot.create.class.error.title=Cannot Create Class
no.class.in.file.template=No Class Found in File Template
error.external=External error
Inner.methods.are.not.supported=Inner methods are not supported
final.class.cannot.be.extended=Final class cannot be extended

#Override and implement
method.is.not.implemented=Method ''{0}'' is not implemented
change.implements.and.extends.classes=Normalize extends and implements lists

class.is.not.expected.here=Class is not expected here
fix.package.name=Fix package name

#dynamic properties
add.dynamic.property=Add Dynamic Property ''{0}''
duplicate.element.in.the.map=Duplicate element in the map
dynamic.toolwindow.search.elements=Search dynamic element
dynamic.toolwindow.property.filter=Property Filter
dynamic.tool.window.id=Dynamic Properties

create.from.usage.family.name=Create From Usage
create.field.from.usage=Create Field ''{0}''
create.method.from.usage=Create Method ''{0}''
create.variable.from.usage=Create Variable ''{0}''
add.dynamic.element=Add dynamic element
add.dynamic.method=Add Dynamic Method
dynamic.type=Type
dynamic.name=Name
dynamic.properties.table.name=Method arguments
dynamic.method.return.type=Return &type:
dynamic.method.property.type=Property &type:
are.you.sure.to.delete.dynamic.property=Are you sure to delete ''{0}''?
dynamic.property.deletion=Deletion Dynamic Property
are.you.sure.to.delete.elements=Are you sure to delete ''{0}'' elements?
dynamic.element.deletion=Dynamic Element Deletion
dynamic.window=Dynamic window
dynamic.properties.table.no.arguments=Arguments list is empty.
assignment.expected='=' expected
tuple.cant.be.placed.in.class=Multiple assignments are not allowed for fields
singleton.class.should.have.private.constructor=Class with '@Singleton' annotation should have private constructor
qualified.new.of.static.class=Qualified new of static class
unknown.class=unknown class ''{0}''
is.not.enclosing.class=''{0}'' is not an enclosing class
package.definition.cannot.have.modifiers=Package definition cannot have modifiers
import.statement.cannot.have.modifiers=Import statement cannot have modifiers
inner.classes.are.not.supported=Inner classes are not supported in Groovy {0}
anonymous.classes.are.not.supported=Anonymous classes are not supported in Groovy {0}
undefined.label=Undefined label ''{0}''
continue.outside.loop=The continue statement is only allowed inside loops
break.outside.loop.or.switch=The break statement is only allowed inside loops or switches
label.already.used=Label ''{0}'' is already in use
break.outside.loop=The break statement with named labels is only allowed inside loops

Constructor=Constructor
Getter=Getter
Setter=Setter
groovy.like.library.found=Groovy Library Found
groovy.like.library.found.text=Do you want to set up Groovy for module ''{0}'' \n\
with found library ''{1}'' (Groovy version {2})?
compile.groovy.files=&Compile Groovy files
in.expected='in' expected
not.allowed.modifier.in.forin=Modifier ''{0}'' is not allowed here
property.name.expected=Property name expected
add.method.body=Add method body
wildcards.are.not.allowed.in.extends.list=A super type may not specify a wildcard type
method.doesnot.override.super=Method does not override method from its super class
method.duplicate=Method with signature {0} is already defined in the class ''{1}''
ambiguous.code.block=Ambiguous code block
cyclic.inheritance.involving.0=Cyclic inheritance involving ''{0}''
there.is.no.default.constructor.available.in.class.0=There is no default constructor available in class ''{0}''
groovy.library.is.not.configured.for.module=Groovy SDK is not configured for module ''{0}''
configure.groovy.library=Configure Groovy SDK...
create.instance.of.built-in.type=Instantiation of built-in type
incorrect.variable.name=Incorrect variable name
is.not.supported.in.version=Command Expression syntax is not supported in Groovy {0}
no.interface.expected.here=No interface expected here
no.class.expected.here=No class expected here
move.to.extends.list=Move reference to extends list
move.to.implements.list=Move reference to implements list
script.file.is.not.groovy.file=Script file is not Groovy file
class.does.not.exist=Class does not exist
class.can't\ be\ executed=Class cannot be executed
invoke.completion.second.time.to.show.skipped.methods=Invoke completion second time to show skipped methods
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy files are mapped to ''{0}''.\nYou can map them to Groovy in Settings | File types
class.is.not.annotation=''{0}'' is not an annotation
method.call.is.ambiguous=Method call is ambiguous
duplicated.named.parameter=Duplicated named parameter ''{0}'' found
no.super.classes.found=No super classes found
no.super.method.found=No super methods found
wrong.package.name=Package name ''{0}'' does not corresponding to the file path ''{1}''
cannot.assign.string.to.enum.0=Cannot assign string to enum ''{0}''
cannot.find.enum.constant.0.in.enum.1=Cannot find enum constant ''{0}'' in enum ''{1}''
recursive.constructor.invocation=Recursive constructor invocation
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=The usage of a map entry expression to initialize an Enum is currently not supported
class.definition.is.not.expected.here=Class definition is not expected here
move.class.0.from.method=Move ''{0}'' to correct place
move.class.from.method.family.name=Move to correct place quick fix
diamonds.are.not.allowed.in.groovy.0=Diamonds are not allowed in Groovy {0}
multiline.slashy.strings.are.not.allowed.in.groovy.0=Multi-line slashy strings are not allowed in Groovy {0}
slashy.strings.with.injections.are.not.allowed.in.groovy.0=Slashy strings with injections are not allowed in Groovy {0}
constructor.call.is.ambiguous=Constructor call is ambiguous
cannot.infer.argument.types=Cannot infer argument types
triple.is.not.expected.here='...' is not expected here
Equals=Equals
default.initializers.are.not.allowed.in.abstract.method=Default initializers are not allowed in abstract methods
groovy.does.not.support.constructor.type.arguments=Groovy does not support constructor type arguments
illegal.escape.character.in.string.literal=Illegal escape character in string literal
dollar.slash.end.expected=Dollar slash ending expected
add.parentheses=Add parentheses
add.parentheses.to.command.method.call=Add parentheses to command method call
dollar.slash.strings.are.not.allowed.in.0=Dollar slashy strings are not allowed in Groovy {0}
method.with.type.parameters.should.have.return.type=Method with type parameters should have return type
primitive.type.parameters.are.not.allowed=Primitive type parameters are not allowed in type parameter list
primitive.bound.types.are.not.allowed=Primitive bound types are not allowed
ellipsis.type.is.not.allowed.here=Ellipsis type is not allowed here
method.0.is.too.complex.too.analyze=Method ''{0}'' is too complex to analyze.\nTypes of local variables are not inferred.
closure.is.too.complex.to.analyze=Closure is complex to analyze.\nTypes of local variables are not inferred.
0.is.deprecated=''{0}'' is deprecated
create.parameter.from.usage=Create Parameter ''{0}''
wrong.number.of.type.arguments=Wrong number of type arguments\: {0}; required\: {1}
type.argument.0.is.not.in.its.bound.should.extend.1=Type parameter ''{0}'' is not in its bound; should extend ''{1}''
catch.statement.parameter.type.should.be.a.subclass.of.throwable=Catch statement parameter type should be a subclass of Throwable
exception.0.has.already.been.caught=Exception ''{0}'' has already been caught
unnecessary.type=Unnecessary exception ''{0}''. ''{1}'' is already declared
create.enum=Create Enum {0}
create.inner.class=Create Inner Class {0}
annotation.field.can.only.be.used.within.a.script.body=Annotation @Field can only be used within a script body
annotation.field.can.only.be.used.within.a.script=Annotation @Field can only be used within a script
public.modifier.is.not.allowed.in.interfaces='public' modifier is not allowed in interfaces
return.type.is.incompatible=The return type of {0} in {1} is incompatible with {2} in {3}
anonymous.class.derived.from.0=anonymous class derived from {0}
throws.clause.is.not.allowed.in.at.interface='throws' clause is not allowed in @interface members
at.interface.0.does.not.contain.attribute=@interface ''{0}'' does not contain attribute ''{1}''
duplicate.attribute=Duplicate attribute
missed.attributes=Missed attributes\: {0}
unexpected.attribute.type.0=Unexpected attribute type\: ''{0}''
annotation.attribute.should.have.return.type.declaration=Annotation attribute should have return type declaration
interface.members.are.not.allowed.to.be=Interface members are not allowed to be {0}
abstract.method.cannot.be.final=Abstract method cannot be final
abstract.methods.must.not.have.body=Abstract methods must not have body
method.has.incorrect.modifier.volatile=Method has incorrect modifier 'volatile'
native.methods.cannot.have.body=Native methods cannot have body
top.level.class.maynot.have.private.modifier=Top level class may not have 'private' modifier
top.level.class.maynot.have.protected.modifier=Top level class may not have 'protected' modifier
property.missing=propertyMissing
attribute.name.expected=Attribute name expected
java.style.for.each.statement.requires.a.type.declaration=Java-style for-each statement requires a type declaration
super.cannot.be.used.in.static.context='super' cannot be used in static context
qualified.0.is.allowed.only.in.nested.or.inner.classes=Qualified {0} is allowed only in nested/inner classes
groovy.file.0=Groovy file ''{0}''
type.argument.list.is.not.allowed.here=Type argument list is not allowed here
initializers.are.not.allowed.in.interface=Initializers are not allowed in interface
initializer.cannot.have.annotations=Initializers cannot have annotations
initializer.cannot.be.0=Initializer cannot be {0}
constructors.are.not.allowed.in.interface=Constructors are not allowed in interface
type.parameters.are.unexpected=Type parameters are unexpected
constructors.cannot.have.return.type=Return type element is not allowed in constructor
constructor.cannot.have.static.modifier=Constructor may not be static
annotation.types.may.not.have.extends.clause=Annotation types may not have 'extends' clause
annotation.types.may.not.have.implements.clause=Annotation types may not have 'implements' clause
no.implements.clause.allowed.for.interface=Interfaces may not have 'implements' clause
enums.may.not.have.extends.clause=Enums may not have 'extends' clause
method.0.cannot.override.method.1.in.2.overridden.method.is.final=Method ''{0}'' cannot override method ''{1}'' in ''{2}''; overridden method is final
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=Method ''{0}'' cannot have weaker access privileges (''{1}'') than ''{2}'' in ''{3}'' (''{4}'')
tuple.declaration.should.end.with.def.modifier=Tuple declaration should end with 'def' modifier
