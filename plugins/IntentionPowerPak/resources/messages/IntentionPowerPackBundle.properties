extract.to.method.reference.intention.name=Extract to method reference
merge.parallel.ifs.intention.name=Merge 'if's
merge.parallel.ifs.intention.family.name=Merge parallel ifs
merge.else.if.intention.name=Merge 'else if'
merge.else.if.intention.family.name=Merge else if
change.to.end.of.line.comment.intention.name=Replace with end-of-line comment
change.to.end.of.line.comment.intention.family.name=Replace with end-of-line comment
replace.for.each.loop.with.indexed.for.loop.intention.name=Replace for-each loop with indexed 'for' loop
replace.for.each.loop.with.iterator.for.loop.intention.name=Replace for-each loop with iterator 'for' loop
replace.for.each.loop.with.indexed.for.loop.intention.family.name=Replace for-each loop with indexed for loop
replace.for.each.loop.with.optimized.indexed.for.loop.intention.name=Replace for-each loop with optimized indexed 'for' loop
replace.for.each.loop.with.optimized.indexed.for.loop.intention.family.name=Replace for-each loop with optimized indexed for loop
replace.for.each.loop.with.iterator.for.loop.intention.family.name=Replace for-each loop with iterator for loop
replace.while.loop.with.do.while.loop.intention.name=Replace 'while' loop with 'do while' loop
replace.while.loop.with.do.while.loop.intention.family.name=Replace while loop with do while loop
replace.do.while.loop.with.while.loop.intention.name=Replace 'do while' loop with 'while' loop
replace.do.while.loop.with.while.loop.intention.family.name=Replace do while loop with while loop
#expand.boolean.intention.name=Convert to 'if else'
expand.boolean.declaration.intention.name=Expand boolean declaration to 'if else'
expand.boolean.return.intention.name=Expand boolean return to 'if else'
expand.boolean.assignment.intention.name=Expand boolean assignment to 'if else'
expand.boolean.intention.family.name=Expand boolean
split.else.if.intention.name=Split 'else if'
split.else.if.intention.family.name=Split else if
convert.to.nested.if.intention.name=Convert to multiple 'if's
convert.to.nested.if.intention.family.name=Expand boolean to multiple ifs
join.concatenated.string.literals.intention.name=Join concatenated string literals
join.concatenated.string.literals.intention.family.name=Join concatenated string literals
replace.switch.with.if.intention.name=Replace 'switch' with 'if'
replace.switch.with.if.intention.family.name=Replace switch with if
create.assert.intention.name=Create JUnit assertion
create.assert.intention.family.name=Create JUnit assertion
merge.if.or.intention.name=Merge sequential 'if' statements
merge.if.or.intention.family.name=Merge sequential 'if' statements
merge.if.and.intention.name=Merge nested 'if' statements
merge.if.and.intention.family.name=Merge nested 'if' statements
replace.concatenation.with.string.buffer.intention.name=Replace '+' with 'StringBuffer.append()'
replace.concatenation.with.string.builder.intention.name=Replace '+' with 'StringBuilder.append()'
replace.concatenation.with.string.buffer.intention.family.name=Replace + with StringBuilder.append()
move.comment.to.separate.line.intention.name=Move comment to separate line
move.comment.to.separate.line.intention.family.name=Move comment to separate line
change.to.c.style.comment.intention.name=Replace with block comment
change.to.c.style.comment.intention.family.name=Replace with block comment
split.declaration.and.initialization.intention.name=Split into declaration and initialization
split.declaration.and.initialization.intention.family.name=Split declaration and initialization
char.to.string.intention.name=Replace character literal with string
char.to.string.intention.family.name=Replace char with string
make.call.chain.into.call.sequence.intention.name=Expand method call chain into call sequence
make.call.chain.into.call.sequence.intention.family.name=Expand call chain into call sequence
merge.call.sequence.to.chain.intention.name=Merge sequential method calls into call chain
merge.call.sequence.to.chain.intention.family.name=Merge sequential method calls into call chain
detail.exceptions.intention.name=Detail exceptions
detail.exceptions.intention.family.name=Detail exceptions
flip.conditional.intention.name=Flip '?:'
flip.conditional.intention.family.name=Flip conditional
replace.shift.with.multiply.intention.family.name=Replace shift with multiply
demorgans.intention.family.name=De Morgan's laws
flip.comparison.intention.family.name=Flip comparison
negate.comparison.intention.family.name=Negate comparison
flip.commutative.method.call.intention.family.name=Flip commutative method call
constant.subexpression.intention.family.name=Compute constant value for subexpression
extract.increment.intention.family.name=Extract increment
inline.increment.intention.family.name=Inline increment/decrement
flip.assert.literal.intention.family.name=Flip assert literal
replace.assert.literal.with.assert.equals.intention.family.name=Replace assertTrue, assertFalse, or assertNull with assertEquals
replace.multiply.with.shift.intention.family.name=Replace multiply with shift
convert.interface.to.class.intention.name=Convert to 'class'
convert.interface.to.class.intention.family.name=Convert interface to class
replace.on.demand.import.intention.name=Replace with single class imports
replace.on.demand.import.intention.family.name=Replace on demand import with single class imports
replace.operator.assignment.with.assignment.intention.family.name=Replace operator assignment with assignment
convert.catch.to.throws.intention.name=Replace 'catch' section with 'throws' declaration
convert.catch.to.throws.intention.family.name=Replace catch section with throws declaration
wrap.vararg.arguments.with.explicit.array.intention.name=Wrap vararg arguments with explicit array creation
wrap.vararg.arguments.with.explicit.array.intention.family.name=Wrap vararg arguments with explicit array creation
extract.while.loop.condition.to.if.statement.intention.name=Extract condition to internal 'if' statement
extract.while.loop.condition.to.if.statement.intention.family.name=Extract while loop condition to internal if statement
replace.concatenation.with.format.string.intention.name=Replace '+' with 'String.format()'
replace.concatenation.with.format.string.intention.name.formatted=Replace '+' with 'formatted()'
replace.concatenation.with.format.string.intention.family.name=Replace string concatenation with String.format()
replace.format.string.with.concatenation.intention.name=Replace 'String.format()' with concatenation
replace.format.string.with.concatenation.intention.family.name=Replace String.format() with concatenation
copy.concatenated.string.to.clipboard.intention.name=Copy string concatenation text to the clipboard
copy.string.literal.to.clipboard.intention.name=Copy string literal text to the clipboard
copy.concatenated.string.to.clipboard.intention.family.name=Copy string concatenation text to the clipboard
flip.expression.intention.family.name=Flip binary expression
flip.setter.call.intention.family.name=Flip setter call
eliminate.parentheses.intention.name=Eliminate parentheses
reverse.for.loop.direction.intention.family.name=Reverse direction of for loop
reverse.for.loop.direction.intention.name=Reverse direction of for loop
replace.operator.assignment.with.postfix.expression.intention.family.name=Replace operator assignment with postfix expression
replace.postfix.expression.with.operator.assignment.intention.family.name=Replace postfix expression with operator assignment
replace.postfix.expression.with.assignment.intention.family.name=Replace postfix expression with assignment
replace.assignment.with.postfix.expression.intention.family.name=Replace assignment with postfix expression
annotate.overridden.methods.intention.family.name=Annotate overriding methods and their parameters
annotate.overridden.methods.intention.method.name=Annotate overriding methods as ''{0}''
annotate.overridden.methods.intention.parameters.name=Annotate same parameter of overriding methods as ''{0}''
replace.arm.with.try.finally.intention.name=Replace 'try-with-resources' with 'try finally'
replace.arm.with.try.finally.intention.family.name=Replace try-with-resources with try-finally
merge.nested.try.statements.intention.name=Merge nested 'try' statements
merge.nested.try.statements.intention.family.name=Merge nested try statements
obscure.thrown.exceptions.intention.family.name=Replace exceptions in throws clause with single more general exception
change.modifier.intention.name=Change access modifier
change.variable.type.to.rhs.type.intention.family.name=Change variable type to type of initializer
unicode.unescape.intention.name=Replace unicode escape with character
unicode.unescape.intention.family.name=Replace unicode escape with unescaped character
replace.octal.escape.with.unicode.escape.intention.name=Replace octal escape with unicode escape
replace.octal.escape.with.unicode.escape.intention.family.name=Replace octal escape with unicode escape
negate.conditional.intention.name=Negate '?:'
negate.conditional.intention.family.name=Negate conditional
objects.require.non.null.intention.name=Use 'java.util.Objects.requireNonNull()' expression
objects.require.non.null.intention.family.name=Use 'java.util.Objects.requireNonNull()' expression
postfix.prefix.intention.family.name=Flip prefix/postfix expression
replace.conditional.with.boolean.expression.intention.family.name=Replace conditional expression with boolean expression
replace.conditional.with.boolean.expression.intention.name=Replace '?:' with boolean expression
replace.with.arrays.as.list.intention.family.name=Replace with 'Arrays.asList()'
replace.with.mutable.collection.intention.family.name=Replace with mutable collection
replace.with.mutable.collection.intention.intention.name=Replace with ''{0}''

#hand made
flip.smth.intention.name=Flip ''{0}''
flip.smth.intention.name1=Flip ''{0}'' (changes semantics)
flip.comparison.intention.name=Flip ''{0}'' to ''{1}''
negate.comparison.intention.name=Negate ''{0}''
negate.comparison.intention.name1=Negate ''{0}'' to ''{1}''
flip.commutative.method.call.intention.name=Flip ''.{0}()''
flip.commutative.method.call.intention.name1=Flip ''.{0}()'' (may change semantics)
constant.expression.intention.name=Compute constant value of ''{0}''
#suppress inspection "UnusedProperty"
press.escape.to.remove.highlighting.message=Press Escape to remove the highlighting
extract.increment.intention.name=Extract ''{0}''
inline.increment.intention.name=Inline ''{0}''
replace.assert.literal.with.assert.equals.intention.name=Replace ''{0}()'' with ''assertEquals({1}, ...)''
replace.assert.literal.with.assert.equals.intention.name2=Replace ''{0}()'' with ''assertEquals()''
replace.assert.literal.with.assert.equals.intention.name1=Replace ''{0}()'' with ''assertEquals(..., {1}, ...)''
flip.setter.call.intention.name=Flip Setter Call
adapter.to.listener.intention.name=Replace extension of ''{0}'' with ''Listener'' implementation
adapter.to.listener.intention.family.name=Replace adapter extension with listener implementation
change.variable.type.to.rhs.type.intention.name=Declare ''{0}'' with type ''{1}''
change.modifier.text=Make ''{0}'' {1}
convert.datapoints.fix.family.name=Convert @DataPoint(s) annotation holder
make.method.default.family.name=Make method default
intention.name.make.default=Make ''{0}()'' default
create.missing.switch.branches.family.name=Create missing switch branches
intention.name.replace.field.or.method=Replace by @{0} {1, choice, 0#field|1#method}
show.example.date.time.output.intention.family.name=Show example date time output
invalid.pattern.hint.text=Invalid pattern

#warnings
0.is.declared.in.1.but.when.public.should.be.declared.in.a.file.named.2={0} is declared in {1} but when public should be declared in a file named {2}
0.will.have.incompatible.access.privileges.with.super.1={0} will have incompatible access privileges with super {1}
0.will.no.longer.be.visible.from.overriding.1={0} will no longer be visible from overriding {1}
0.will.have.incompatible.access.privileges.with.overriding.1={0} will have incompatible access privileges with overriding {1}
0.already.extends.1.and.will.not.compile.after.converting.2.to.a.class={0} implementing {2} already extends {1} and will not compile after converting {2} to a class
0.will.not.compile.after.converting.1.to.a.class={0} will not compile after converting {1} to a class
