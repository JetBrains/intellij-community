// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.plugins.gradle.service.resolve.transformation

import com.intellij.lang.java.beans.PropertyKind
import com.intellij.openapi.util.Key
import com.intellij.psi.*
import com.intellij.psi.impl.light.LightClass
import com.intellij.psi.impl.light.LightMethodBuilder
import com.intellij.psi.impl.light.LightParameter
import com.intellij.psi.scope.PsiScopeProcessor
import com.intellij.psi.util.PropertyUtilBase.*
import com.intellij.util.asSafely
import org.jetbrains.plugins.gradle.service.resolve.GradleCommonClassNames
import org.jetbrains.plugins.gradle.service.resolve.GradleCommonClassNames.GRADLE_API_PROVIDER_PROPERTY
import org.jetbrains.plugins.groovy.lang.psi.util.GroovyCommonClassNames
import org.jetbrains.plugins.groovy.lang.resolve.shouldProcessMethods

/**
 * It is a fact that Gradle decorates classes from the plugins and the API.
 * Since the decoration happens at runtime, there is no way to provide a physical reference to the results of this process.
 * Therefore, we need to mimic Gradle's behavior and perform the decoration ourselves also.
 * @see org.gradle.internal.instantiation.generator.AbstractClassGenerator (better check the javadocs, they are, eh, enlightening)
 */
class GradleDecoratedLightPsiClass(delegate: PsiClass) : LightClass(delegate) {

  /**
   * A setter for each [org.gradle.api.provider.Property] without a setter
   */
  private val syntheticSetters : List<PsiMethod>

  /**
   * For each method accepting [org.gradle.api.Action], a similar method but accepting a closure.
   * It might seem like a redundant generation: Groovy supports SAM-coercions, so the method with Action will be safely chosen.
   * Unfortunately, we have Kotlin, which has its own view on resolution priority. There are classes which have
   * overloads to Action and kotlin.Function1 (isomorphic to Action), and for Groovy these two classes are the same.
   * But Closure has the highest priority for Groovy, so to avoid an error about ambiguity, we have to follow the logic of Gradle.
   */
  private val syntheticClosureActionAdapters : List<PsiMethod>

  private val allSyntheticMethods: List<PsiMethod>
    get() = syntheticSetters + syntheticClosureActionAdapters

  init {
    val allMethods = delegate.allMethods
    val syntheticSetters = mutableListOf<PsiMethod>()
    val syntheticClosureAdapters = mutableListOf<PsiMethod>()
    val methodRegistry = allMethods.groupBy { it.name }
    for (method in allMethods) {
      if (method == null) continue
      val setter = getSetter(method, methodRegistry.keys)
      if (setter != null) {
        syntheticSetters += setter
      }
      val actionOverrider = getActionOverrider(method, methodRegistry)
      if (actionOverrider != null) {
        syntheticClosureAdapters += actionOverrider
      }
    }
    this.syntheticSetters = syntheticSetters
    this.syntheticClosureActionAdapters = syntheticClosureAdapters
  }

  override fun getMethods(): Array<PsiMethod> {
    return super.getMethods() + allSyntheticMethods
  }

  override fun processDeclarations(processor: PsiScopeProcessor, state: ResolveState, lastParent: PsiElement?, place: PsiElement): Boolean {
    return super.processDeclarations(processor, state, lastParent, place) && run {
      if (!processor.shouldProcessMethods()) {
        return@run true
      }
      for (innerSetter in allSyntheticMethods) {
        if (!processor.execute(innerSetter, state)) {
          return@run false
        }
      }
      true
    }
  }
}

private fun getSetter(method: PsiMethod, names: Set<String>): PsiMethod? {
  if (!isSimplePropertyGetter(method)) {
    return null
  }
  val simpleName = getPropertyName(method) ?: return null
  val setterName = getAccessorName(simpleName, PropertyKind.SETTER)
  if (names.contains(setterName)) {
    return null
  }
  val returnType = method.returnType ?: return null
  val returnClassType = returnType.asSafely<PsiClassType>()
  if (returnClassType?.resolve()?.qualifiedName != GRADLE_API_PROVIDER_PROPERTY) return null
  return with(LightMethodBuilder(method.manager, setterName)) {
    navigationElement = method
    containingClass = method.containingClass
    originInfo = "Generated by decoration of Gradle property getter"
    setMethodReturnType(PsiTypes.voidType())
    val innerParameter = returnClassType.parameters.singleOrNull() ?: return null
    addParameter("value", innerParameter)
    this
  }
}


private fun getActionOverrider(method : PsiMethod, methods: Map<String, List<PsiMethod>>) : PsiMethod? {
  val lastParameter = method.parameterList.parameters.lastOrNull() ?: return null
  val type = lastParameter.type.asSafely<PsiClassType>() ?: return null
  val resolveResult = type.resolveGenerics()
  val resolvedClass = resolveResult.element ?: return null
  if (resolvedClass.qualifiedName != GradleCommonClassNames.GRADLE_API_ACTION) return null
  for (overload in methods[method.name] ?: emptyList()) {
    if (overload.parameters.lastOrNull()?.type?.asSafely<PsiClassType>()?.resolve()?.qualifiedName == GroovyCommonClassNames.GROOVY_LANG_CLOSURE) {
      return null
    }
  }
  val delegate = type.parameters.singleOrNull()?.unwrapWildcard() ?: return null
  // at this point, we have no closure-overload of this method
  return with(LightMethodBuilder(method.manager, method.name)) {
    val parameters = method.parameterList.parameters
    for (parameter in parameters.take(parameters.size - 1)) {
      addParameter(parameter)
    }
    val closure = PsiType.getTypeByName(GroovyCommonClassNames.GROOVY_LANG_CLOSURE, method.project, method.resolveScope)
    val closureParameter = LightParameter(lastParameter.name, closure, lastParameter)
    putUserData(GRADLE_GENERATED_CLOSURE_OVERLOAD_DELEGATE_KEY, delegate)
    addParameter(closureParameter)
    navigationElement = method
    containingClass = method.containingClass
    originInfo = "Generated by decoration of Gradle Action-ending method"
    setMethodReturnType(method.returnType)
    this
  }
}

private fun PsiType.unwrapWildcard() : PsiType = if (this is PsiWildcardType) {
  this.bound ?: PsiType.getTypeByName(CommonClassNames.JAVA_LANG_OBJECT, this.manager.project, this.resolveScope)
} else {
  this
}

internal val GRADLE_GENERATED_CLOSURE_OVERLOAD_DELEGATE_KEY : Key<PsiType> = Key.create("Delegate for Gradle generated closure overload")