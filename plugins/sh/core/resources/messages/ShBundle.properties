sh.code.style.binary.ops.like.and.may.start.a.line=Allow line breaks after binary operators
sh.code.style.choose.path=Choose Path to Shfmt:
sh.code.style.download.link=Download shfmt formatter
sh.code.style.keep.column.alignment.padding=Keep column alignment padding
sh.code.style.minify.program.to.reduce.its.size=Minify program to reduce its size
sh.code.style.unix.line.separator=Use Unix line separators (\\n)
sh.code.style.redirect.operators.will.be.followed.by.a.space=Add space after redirect operators
sh.code.style.switch.cases.will.be.indented=Indent case statements

sh.disable.inspection.text=Disable inspection {0}

sh.explain.command.to.explain=Command to Explain
sh.explain.inspection.text=Explain shell
sh.explain.message.nothing.to.explain=Nothing to explain
sh.explain.title.nothing.to.explain=Nothing to Explain

sh.fmt.cannot.download=Can't download shfmt formatter. Install it manually.
sh.fmt.cannot.update=Can't update shfmt formatter. Rolled back to the previous version.
sh.fmt.formatter=Shfmt formatter
sh.fmt.indent.label=Indent
sh.fmt.update.question=Would you like to update the shell script formatter?
sh.fmt.install.question=Would you like to install a shell script formatter?
sh.fmt.success.update=Shell script formatter was successfully updated
sh.fmt.success.install=Shell script formatter was successfully installed
sh.fmt.missing.formatter=missing formatter

sh.parser.expected.similar.close.bracket=Expected similar close bracket
sh.path.label=Path:

sh.rename.all.occurrences=Rename all occurrences
sh.rename.occurence=Rename {0}

sh.shell.script=Shell script
notification.group.shell.script=Shell script tools available
intention.shell.script=Shell script
filetype.sh.shell.script.description=Shell script
sh.shellcheck.download.label.text=Download shellcheck
sh.shellcheck.cannot.download=Can't download shellcheck. Install it manually.
sh.shellcheck.cannot.update=Can't update shellcheck. Rolled back to the previous version.
sh.shellcheck.path.label=Choose Path to Shellcheck:
sh.shellcheck.install.question=Would you like to install shellcheck to verify your shell scripts?
sh.shellcheck.update.question=Would you like to update shellcheck?
sh.shellcheck.success.install=Shellcheck has been successfully installed
sh.shellcheck.success.update=Shellcheck has been successfully updated
sh.shellcheck.missing=\ missing shellcheck

sh.suppress.inspection=Suppress {0}
sh.unnamed.element.presentable.name=<unnamed>

sh.label.download.shfmt.formatter=Download shfmt formatter
sh.label.choose.interpreter=Choose Interpreter
sh.label.choose.script.working.directory=Choose Script Working Directory
sh.label.choose.shell.script=Choose Shell Script

action.ShGenerateUntilLoop.text=Until Loop
action.ShGenerateUntilLoop.description=Creates until loop
action.ShGenerateWhileLoop.text=While Loop
action.ShGenerateWhileLoop.description=Creates while loop
action.ShGenerateForLoop.text=For Loop
action.ShGenerateForLoop.description=Creates for loop
action.runShellFileAction.text=Run File
action.runShellFileAction.description=Run current shell file in the terminal

sh.color.function.declaration=Function declaration
sh.color.conditional.operators=Conditional operators
sh.color.commands.subshell.command=Commands//subshell command
sh.color.commands.generic.command=Commands//generic command
sh.color.redirection=Redirection
sh.color.backquotes=Backquotes
sh.color.braces.square.brackets=Braces//square brackets
sh.color.braces.curly.brackets=Braces//curly brackets
sh.color.braces.parentheses=Braces//Parentheses
sh.color.here.documents.end=Here documents end
sh.color.here.documents.start=Here documents start
sh.color.here.documents=Here documents
sh.color.shebang.comment=Shebang comment
sh.color.line.comment=Line comment
sh.color.raw.string=Raw string
sh.color.string=String
sh.color.variables.composed.variable=Variables//composed variable
sh.color.variables.variable.declaration=Variables//variable declaration
sh.color.variables.variable.usage=Variables//variable usage
sh.color.keyword=Keyword
sh.color.number=Number

sh.run.interpreter.options=Interpreter options:
sh.run.interpreter.path=Interpreter path:
sh.run.interpreter=Interpreter
sh.run.interpreter.not.found=Interpreter not found
sh.run.interpreter.should.be.executable=Interpreter should be an executable file
sh.run.working.dir=Working directory:
sh.run.working.dir.not.found=Working directory not found
sh.run.script.options=Script options:
sh.run.script.path=Script path:
sh.run.script.not.found=Shell script not found
sh.run.execute.terminal=Execute in the terminal
sh.run.environment.variables=Environment variables:
sh.run.execute.script.text=Script text
sh.run.execute.script.text.title=Script text:
sh.run.execute.script.file=Script file
sh.run.execute=Execute:

sh.livetemplate.description.fori=For loop in list
sh.livetemplate.description.cmd=Command substitution
sh.livetemplate.description.cmd.success.check=Cmd success check
sh.livetemplate.description.tar.compress=tar compress
sh.livetemplate.description.tar.decompress=tar decompress
sh.livetemplate.description.mkdir=Create directory
sh.livetemplate.description.git.branch.create=Create branch
sh.livetemplate.description.git.push=Push branch to remote
sh.livetemplate.description.git.commit=Commit changes
sh.livetemplate.description.curl=Http request
sh.livetemplate.description.rm=Remove file or dir
sh.livetemplate.description.find=Find file or directory
sh.livetemplate.description.heredoc=Multiline string
sh.livetemplate.description.xargs=Execute commands from standard input
sh.livetemplate.description.system.info.linux=Linux system information
sh.livetemplate.description.system.info.mac=Mac OS system information
sh.livetemplate.description.system.kernel.info=Kernel information
sh.livetemplate.description.array.create=Create array
sh.livetemplate.description.array.all=All array elements
sh.livetemplate.description.array.at.index=Elements at index
sh.livetemplate.description.array.length=Array length
sh.livetemplate.description.array.delete=Delete array
sh.livetemplate.description.array.delete.at=Delete from array
sh.livetemplate.description.array.set.element=Array set element at index
sh.livetemplate.description.array.add=Add new item to the end of array
sh.livetemplate.description.array.iteration=Iterate through array
sh.livetemplate.description.if=If statement
sh.livetemplate.description.elif=Elif expression
sh.livetemplate.description.select=Select expression
sh.livetemplate.description.case=Case statement
sh.livetemplate.description.for=For loop by index
sh.livetemplate.description.while=While loop by condition
sh.livetemplate.description.until=Until loop by condition
sh.livetemplate.description.function=Define a function
sh.livetemplate.description.string.equal=String are equal
sh.livetemplate.description.string.not.equal=String not equal
sh.livetemplate.description.string.is.empty=String is empty
sh.livetemplate.description.string.not.empty=String isn't empty
sh.livetemplate.description.number.equal=Numbers are equal
sh.livetemplate.description.number.not.equal=Numbers not equal
sh.livetemplate.description.number.less=Number less than
sh.livetemplate.description.number.less.or.equal=Number less than or equal
sh.livetemplate.description.number.greater=Number greater than
sh.livetemplate.description.number.greater.or.equal=Number greater than or equal
sh.livetemplate.description.file.exists=File exists
sh.livetemplate.description.file.not.empty=File not empty
sh.livetemplate.description.file.readable=File readable
sh.livetemplate.description.file.writable=File writable
sh.livetemplate.description.file.executable=File executable
sh.livetemplate.description.file.equals=File equals
sh.livetemplate.description.file.newer=File newer
sh.livetemplate.description.file.older=File older
sh.livetemplate.description.path.exists=Path exists
sh.livetemplate.description.directory.exists=Directory exists
sh.livetemplate.description.command.exists=Command exists

sh.update=Update
sh.install=Install
sh.no.thanks=No
sh.skip.version=Skip this version
sh.download=Download
sh.invalid.path=Invalid path.
find.usages.type.function=function
# {0} is non-translated 'Shell Script' - language name
sh.run.configuration.description.0.configuration={0} configuration
error.message.cannot.determine.shell.script.parent.directory=Cannot determine shell script parent directory
check1000.is.not.used.specially.and.should.therefore.be.escaped=$ should be escaped.
check1001.this.o.will.be.a.regular.o.in.this.context=This \\o will be a regular 'o' in this context.
check1003.want.to.escape.a.single.quote.echo.this.is.how.it.s.done=Want to escape a single quote? echo 'This is how it'\\''s done'.
check1004.this.backslash.linefeed.is.literal.break.outside.single.quotes.if.you.just.want.to.break.the.line=This backslash+linefeed is literal. Break outside of the single quotes if you want to break the line.
check1007.remove.space.after.if.trying.to.assign.a.value.or.for.empty.string.use.var=Remove space after '=' to assign a value (or for empty string, use var='' ... ).
check.1008.this.shebang.was.unrecognized.shellcheck.only.supports.sh.bash.dash.ksh.add.a.shell.directive.to.specify=This shebang was not recognized. ShellCheck only supports sh/bash/dash/ksh. Add a 'shell' directive to specify.
check.1009.the.mentioned.parser.error.was.in=The mentioned parser error was in \u2026
check.1010.use.semicolon.or.linefeed.before.done.or.quote.to.make.it.literal=Use a semicolon or a linefeed before 'done' (or use quotes to make it literal).
check.1011.this.apostrophe.terminated.the.single.quoted.string=This apostrophe terminated the single-quoted string!
check.1012.is.just.literal.t.here.for.tab.use.printf.instead=`	` is just literal `t` here. To add a tab, use "$(printf '	')" instead.
check.1014.use.if.cmd.then.to.check.exit.code.or.if.cmd.to.check.output=Use 'if cmd; then ...' to check the exit code, or 'if [ "$(cmd)" = .. ]' to check the output.
check.1015.this.is.a.unicode.double.quote.delete.and.retype.it=This is a Unicode double quote. Delete and retype it.
check.1016.this.is.a.unicode.single.quote.delete.and.retype.it=This is a Unicode single quote. Delete and retype it.
check.1017.literal.carriage.return.run.script.through.tr.d=Literal carriage return. Run script through `tr -d '\n'` .
check.1018.this.is.a.unicode.non.breaking.space.delete.it.and.retype.as.space=This is a Unicode non-breaking space. Delete it and retype it with the space key.
check.1019.expected.this.to.be.an.argument.to.the.unary.condition=Expected this to be an argument to the unary condition.
check.1020.you.need.a.space.before.the.if.single.then.else=Add a space before the `]` or `]]`
check.1026.if.grouping.expressions.inside.use=If grouping expressions inside [[..]], use ( .. ).
check.1028.in.you.have.to.escape.or.preferably.combine.expressions=In [..] you have to escape \\( \\) or preferably combine [..] expressions.
check.1029.in.you.shouldn.t.escape.or=In `[[..]]` you shouldn't escape `(` or `)`.
check.1035.you.need.a.space.here=Add a space here.
check.1036.is.invalid.here.did.you.forget.to.escape.it=`(` is invalid here. Did you forget to escape it?
check.1037.braces.are.required.for.positionals.over.9.e.g.10=Braces are required for positionals over 9, e.g. 10.
check.1038.shells.are.space.sensitive.use.cmd.not.cmd=Shells are space sensitive. Use '< <(cmd)', not '<<(cmd)'.
check.1039.remove.indentation.before.end.token.or.use.and.indent.with.tabs=Remove indentation before end token (or use `<<-` and indent with tabs).
check.1040.when.using.you.can.only.indent.with.tabs=When using <<-, indent with tabs.
check.1041.found.eof.further.down.but.not.on.a.separate.line=Found 'eof' further down, but not on a separate line.
check.1042.found.eof.further.down.but.not.on.a.separate.line=Found 'eof' further down, but not on a separate line.
check.1044.couldn.t.find.end.token.eof.in.the.here.document=Couldn't find end token `EOF' in the here document.
check.1045.it.s.not.foo.bar.just.foo.bar=Redundant semicolon in 'foo \\&; bar'. Should be 'foo \\& bar'.
check.1046.couldn.t.find.fi.for.this.if=Couldn't find 'fi' for this 'if'.
check.1047.expected.fi.matching.previously.mentioned.if=Expected 'fi' matching previously mentioned 'if'.
check.1048.can.t.have.empty.then.clauses.use.true.as.a.no.op=Can't have empty then clauses (use 'true' as a no-op).
check.1049.did.you.forget.the.then.for.this.if=Did you forget to specify 'then' for this 'if'?
check.1045.expected.then=Expected 'then'.
check.1051.semicolons.directly.after.then.are.not.allowed.just.remove.it=Semicolons directly after 'then' are not allowed.
check.1052.semicolons.directly.after.then.are.not.allowed.just.remove.it=Semicolons directly after 'then' are not allowed.
check.1053.semicolons.directly.after.else.are.not.allowed.just.remove.it=Semicolons directly after 'else' are not allowed.
check.1054.you.need.a.space.after.the=Add a space after '{'.
check.1058.expected.do=Expected `do`.
check.1061.couldn.t.find.done.for.this.do=Couldn't find 'done' for this 'do'.
check.1062.expected.done.matching.previously.mentioned.do=Expected 'done' matching previously mentioned 'do'.
check.1064.expected.a.to.open.the.function.definition=Expected a '{' to open the function definition.
check.1065.trying.to.declare.parameters.don.t.use.and.refer.to.params.as.1.2=Don't declare parameters. Use () and refer to parameters as $1, $2, and so on.
check.1066.don.t.use.on.the.left.side.of.assignments=Don't use '$' on the left side of assignments.
check.1068.don.t.put.spaces.around.the.in.assignments=Don't put spaces around '=' in assignments.
check.1069.you.need.a.space.before.the=Add a space before '['.
check.1071.shellcheck.only.supports.sh.bash.dash.ksh.scripts.sorry=ShellCheck only supports sh/bash/dash/ksh scripts.
check.1072.unexpected=Unexpected ..
check.1073.couldn.t.parse.this.thing.fix.to.allow.more.checks=Couldn't parse this. Fix to allow more checks.
check.1075.use.elif.instead.of.else.if=Use 'elif' instead of 'else if'.
check.1077.for.command.expansion.the.tick.should.slant.left.vs=For command expansion, use a backtick: (` vs \u00B4).
check.1078.did.you.forget.to.close.this.double.quoted.string=Did you forget to close this double quoted string?
check.1079.this.is.actually.an.end.quote.but.due.to.next.char.it.looks.suspect=This is an end quote, but due to next char, it looks suspicious.
check.1081.scripts.are.case.sensitive.use.if.not.if=Scripts are case sensitive. Use 'if', not 'If'.
check.1082.this.file.has.a.utf.8.bom.remove.it.with.lc.ctype.c.sed.1s.yourscript=This file has a UTF-8 BOM. Remove it with the following command: LC_CTYPE=C sed '1s/^...//' < yourscript
check.1083.this.is.literal.check.expression.missing.or.quote.it=This `{`/`}` is literal. Check if `;` is missing or quote the expression.
check.1084.use.not.for.the.shebang=The shebang is '#!', not '!#'.
check.1086.don.t.use.on.the.iterator.name.in.for.loops=Don't use '$' on the iterator name in for loops.
check.1087.use.braces.when.expanding.arrays.e.g.array.idx.or.var.to.quiet=Use braces when expanding arrays, for example: ${array[idx]} (or ${var}[.. to quiet).
check.1088.parsing.stopped.here.invalid.use.of.parentheses=Parsing stopped here. Invalid use of parentheses?
check.1089.parsing.stopped.here.is.this.keyword.correctly.matched.up=Parsing stopped here. Is this keyword correctly matched?
check.1090.can.t.follow.non.constant.source.use.a.directive.to.specify.location=Can't follow non-constant source. Use a directive to specify the location.
check.1091.not.following.error.message.here=Not following: (error message here)
check.1094.parsing.of.sourced.file.failed.ignoring.it=Parsing of sourced file failed. Ignoring it.
check.1095.you.need.a.space.or.linefeed.between.the.function.name.and.body=You need a space or linefeed between the function name and body.
check.1097.unexpected.for.assignment.use.for.comparison.use=Unexpected '=='. For assignment, use '='. For comparison, put the '==' expression in square brackets.
check.1098.quote.escape.special.characters.when.using.eval.e.g.eval.a.b=Quote or escape special characters when using eval, for example: eval "a=(b)".
check.1099.you.need.a.space.before.the=Add a space before '#'.
check.1100.this.is.a.unicode.dash.delete.and.retype.as.ascii.minus=This is a Unicode dash. Delete and retype as the ASCII minus character.
check.1101.delete.trailing.spaces.after.to.break.line.or.use.quotes.for.literal.space=Delete trailing spaces after \\ to break the line (or use quotes for literal space).
check.1102.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.command.substitution.add.a.space.after.it=Shells disambiguate $(( differently or not at all. If the first $( should start command substitution, add a space after it.
check.1104.use.not.just.for.the.shebang=The shebang is '#!', not '!'.
check.1105.shells.disambiguate.differently.or.not.at.all.if.the.first.should.start.a.subshell.add.a.space.after.it=Shells disambiguate (( differently or not at all. If the first ( should start a subshell, add a space after it.
check.1107.this.directive.is.unknown.it.will.be.ignored=This directive is unknown. It will be ignored.
check.1108.you.need.a.space.before.and.after.the=Add a space before and after '='.
check.1109.this.is.an.unquoted.html.entity.replace.with.corresponding.character=This is an unquoted HTML entity. Replace with the corresponding character.
check.1110.this.is.a.unicode.quote.delete.and.retype.it.or.quote.to.make.literal=This is a Unicode quote. Delete and retype it (or use quotes to make it literal).
check.1111.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.singlequote.for.literal=This is a Unicode quote. Delete and retype it (or use single quotes to make it literal).
check.1112.this.is.a.unicode.quote.delete.and.retype.it.or.ignore.doublequote.for.literal=This is a Unicode quote. Delete and retype it (or use double quotes to make it literal).
check.1113.use.not.just.for.the.sheban=The shebang is '#!', not '#'.
check.1114.remove.leading.spaces.before.the.shebang=Remove leading spaces before the shebang.
check.1115.remove.spaces.between.and.in.the.shebang=Remove spaces between '#' and '!' in the shebang.
check.1116.missing.on.a.expression.or.use.for.arrays=Missing '$' on a '$((..))' expression? If it's an array, use '( ('.
check.1117.backslash.is.literal.in.prefer.explicit.escaping.n=The backslash is literal in "\n". Prefer explicit escaping: "\\n".
check.1118.delete.whitespace.after.the.here.doc.end.token=Delete the whitespace after the here document end token.
check.1119.add.a.linefeed.between.end.token.and.terminating=Add a linefeed between end token and terminating ')'.
check.1120.no.comments.allowed.after.here.doc.token.comment.the.next.line.instead=No comments allowed after here document token. Comment the next line instead.
check.1121.add.terminators.and.other.syntax.on.the.line.with.the.not.here=Add ;/\\& terminators (and other syntax) on the line with '<<', not here.
check.1122.nothing.allowed.after.end.token.to.continue.a.command.put.it.on.the.line.with.the=Nothing allowed after end token. To continue a command, put it on the line with `<<`.
check.1123.shellcheck.directives.are.only.valid.in.front.of.complete.compound.commands.like.if.not.e.g.individual.elif.branches=ShellCheck directives are only valid in front of complete compound commands, like `if`, not individual `elif` branches.
check.1124.shellcheck.directives.are.only.valid.in.front.of.complete.commands.like.case.statements.not.individual.case.branches=ShellCheck directives are only valid in front of complete commands like 'case' statements, not individual case branches.
check.1126.place.shellcheck.directives.before.commands.not.after=Place ShellCheck directives before commands, not after.
check.1127.was.this.intended.as.a.comment.use.in.sh=If this is a comment, use `#`.
check.1128.the.shebang.must.be.on.the.first.line.delete.blanks.and.move.comments=The shebang must be on the first line. Delete blanks and move comments.
check.1129.you.need.a.space.before.the=Add a space before '!'.
check.1130.you.need.a.space.before.the=Add a space before ':'.
check.1131.use.elif.to.start.another.branch=Use `elif` to start another branch.
this.terminates.the.command.escape.it.or.add.space.after.to.silence=This `\\&` terminates the command. Escape it or add a space after `\\&` to silence.
unexpected.start.of.line.if.breaking.lines.should.be.at.the.end.of.the.previous.one=Unexpected start of a new line. If breaking lines, |/||/\\&\\& should be at the end of the previous one.
arrays.implicitly.concatenate.in.use.a.loop.or.explicit.instead.of=Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit '*' instead of '@').
arrays.don.t.work.as.operands.in.use.a.loop.or.concatenate.with.instead.of=Arrays don't work as operands in '[ ]'. Use a loop (or concatenate with '*' instead of '@').
fgrep.is.non.standard.and.deprecated.use.grep.f.instead=fgrep is non-standard and deprecated. Use grep -F instead.
egrep.is.non.standard.and.deprecated.use.grep.e.instead=egrep is non-standard and deprecated. Use grep -E instead.
this.pattern.will.never.match.the.case.statement.s.word.double.check.them=This pattern will never match the case statement's word.
this.word.is.constant.did.you.forget.the.on.a.variable=This word is a constant. Did you forget the '$' character on a variable?
the.arguments.to.this.comparison.can.never.be.equal.make.sure.your.syntax.is.correct=The arguments to this comparison can never be equal. Make sure your syntax is correct.
this.array.element.has.no.value.remove.spaces.after.or.use.for.empty.string=This array element has no value. Remove spaces after '=' or use "" for an empty string.
the.here.is.literal.to.assign.by.index.use.index.value.with.no.spaces.to.keep.as.literal.quote.it=The equals character '=' here is literal. To assign by index, use ( [index]=value ) with no spaces. To keep as literal, use quotes.
elements.in.associative.arrays.need.index.e.g.array.index.value=Elements in associative arrays require an index, for example: array=( [index]=value ) .
you.can.t.have.between.this.redirection.and.the.command.it.should.apply.to=You can't have '|' between this redirection and the command it applies to.
this.redirection.doesn.t.have.a.command.move.to.its.command.or.use.true.as.no.op=This redirection doesn't have a command. Move to its command (or use 'true' as no-op).
ash.scripts.will.be.checked.as.dash.add.shellcheck.shell.dash.to.silence=Ash scripts will be checked as Dash. Add '# shellcheck shell=dash' to silence.
tempfile.is.deprecated.use.mktemp.instead=tempfile is deprecated. Use mktemp instead.
some.finds.don.t.have.a.default.path.specify.explicitly=Some finds don't have a default path. Specify '.' explicitly.
quote.arguments.to.unset.so.they.re.not.glob.expanded=Put arguments in quotes to ignore glob syntax.
this.format.string.has.2.variables.but.is.passed.1.arguments=This format string has 2 variables, but is passed 1 argument.
this.printf.format.string.has.no.variables.other.arguments.are.ignored=This printf format string has no variables. Other arguments are ignored.
check.exit.code.directly.with.e.g.if.mycmd.not.indirectly.with=Check the exit code directly with 'if mycmd;', not indirectly with '$'?.
bash.does.not.support.multidimensional.arrays.use.1d.or.associative.arrays=Bash does not support multidimensional arrays. Use only one-dimensional or associative arrays.
use.array.item.to.append.items.to.an.array=Use 'array+=("item")' to append items to an array.
variable.was.used.as.an.array.but.is.now.assigned.a.string=Variable was used as an array but is now assigned a string.
time.is.undefined.for.compound.commands.time.sh.c.instead='time' is undefined for compound commands. Use 'time sh -c' instead.
time.is.undefined.for.pipelines.time.single.stage.or.bash.c.instead='time' is undefined for pipelines. Use `time` on a single stage or `time bash -c` instead.
quote.this.invalid.brace.expansion.since.it.should.be.passed.literally.to.eval=Quote this invalid brace expansion since it should be passed literally to eval.
when.used.with.p.m.only.applies.to.the.deepest.directory=When used with '-p', '-m' only applies to the deepest directory.
sigkill.sigstop.can.not.be.trapped=SIGKILL and SIGSTOP can not be trapped.
trapping.signals.by.number.is.not.well.defined.prefer.signal.names=Trapping signals by number is not well defined. Prefer signal names.
numerical.eq.does.not.dereference.in.expand.or.use.string.operator=Numerical '-'eq does not dereference in [..]. Expand or use string operator.
in.dash.something.is.not.supported=This feature is not supported in dash.
local.is.only.valid.in.functions='local' is only valid in functions.
this.parent.loop.has.its.index.variable.overridden=This parent loop has its index variable overridden.
prefer.p.q.as.p.a.q.is.not.well.defined=Prefer '[ p ] \\&\\& [ q ]' because '[ p -a q ]' is not well defined.
this.nested.loop.overrides.the.index.variable.of.its.parent=This nested loop overrides the index variable of its parent.
use.cd.exit.in.case.cd.fails=Use cd ... || exit in case cd fails.
this.does.not.export.foo.remove.for.that.or.use.var.to.quiet=This does not export 'FOO'. Remove '$' and '${}' for that, or use '${var?}' to quiet.
read.without.r.will.mangle.backslashes='read' without '-r' will mangle backslashes.
instead.of.1.use.true=Instead of '[ 1 ]', use 'true'.
instead.of.true.just.use.true=Instead of '[ true ]', use 'true'.
0.is.true.use.false.instead='[ 0 ]' is true. Use 'false' instead.
false.is.true.remove.the.brackets='[ false ]' is true. Remove the brackets.
argument.to.implicit.n.is.always.true.due.to.literal.strings=Argument to implicit '-n' is always true due to literal strings.
injecting.filenames.is.fragile.and.insecure.use.parameters=Injecting filenames is fragile and insecure. Use parameters.
declare.and.assign.separately.to.avoid.masking.return.values=Declare and assign separately to avoid masking return values.
var.is.referenced.but.not.assigned='var' is referenced but not assigned.
possible.misspelling.myvariable.may.not.be.assigned.but.my.variable.is=Possible Misspelling: MYVARIABLE may not be assigned, but MY_VARIABLE is.
can.only.return.0.255.other.data.should.be.written.to.stdout=Can only return 0-255. Other data should be written to stdout.
only.one.integer.0.255.can.be.returned.use.stdout.for.other.data=Only one integer 0-255 can be returned. Use stdout for other data.
exec.does.not.automatically.invoke.a.shell.use.exec.sh.c.for.that='-exec' does not automatically invoke a shell. Use '-exec sh -c' for that.
remove.for.numeric.index.or.escape.it.for.string=Remove '$' and '${}' for numeric index, or escape it for string.
tips.depend.on.target.shell.and.yours.is.unknown.add.a.shebang=Tips depend on the target shell. Add a shebang.
literal.tilde.in.path.works.poorly.across.programs=Literal tilde in PATH works poorly across programs.
this.action.ignores.everything.before.the.o.use.to.group=This action ignores everything before '-o'. Use \\( \\) to group.
argument.mixes.string.and.array.use.or.separate.argument=Argument mixes string and array. Use '*' or separate argument.
e.doesn.t.work.with.globs.use.a.for.loop='-e' doesn't work with globs. Use a for loop.
use.grep.q.instead.of.comparing.output.with.n=Use 'grep -q' instead of comparing output with '[ -n .. ]'.
aliases.can.t.use.positional.parameters.use.a.function=Aliases can't use positional parameters. Use a function.
did.you.mean.ifs=Did you mean IFS=$'	' ?
word.is.on.the.form.a.b.c.b.indicated.did.you.mean.abc.or.a.b.c=\ Word is on the form "A"B"C" (B indicated). Did you mean "ABC" or "A\\"B\\"C"?
this.expands.when.defined.not.when.used.consider.escaping=This expands when defined, not when used. Consider escaping.
eq.is.for.integer.comparisons.use.instead='-eq' is for integer comparisons. Use '=' instead.
consider.using.cmd1.cmd2.file.instead.of.individual.redirects=Consider using '{ cmd1; cmd2; } >> file' instead of individual redirects.
expanding.an.array.without.an.index.only.gives.the.first.element=Expanding an array without an index only gives the first element.
consider.using.grep.c.instead.of.grep.wc=Consider using 'grep -c' instead of 'grep|wc'.
brace.expansions.and.globs.are.literal.in.assignments.quote.it.or.use.an.array=Brace expansions and globs are literal in assignments. Use quotes or an array.
assigning.an.array.to.a.string.assign.as.array.or.use.instead.of.to.concatenate=Assigning an array to a string! Assign as array, or use '*' instead of '@' to concatenate.
path.is.the.shell.search.path.use.another.name=PATH is the shell search path. Use another name.
is.not.a.valid.operator.use.a.b.instead='>=' is not a valid operator. Use '! a < b' instead.
to.assign.a.variable.use.just.var.value.no.set=To assign a variable, use 'var=value', not 'set ..'.
foo.references.arguments.but.none.are.ever.passed='foo' references arguments, but none are ever passed.
use.foo.if.function.s.1.should.mean.script.s.1=Use 'foo "$@"' if the function's '$1' argument should mean the script's '$1' argument.
to.run.commands.as.another.user.use.su.c.or.sudo=To run commands as another user, use 'su -c' or 'sudo'.
useless.echo.instead.of.cmd.echo.foo.just.use.cmd.foo=Redundant echo? Instead of 'cmd $(echo foo)', use 'cmd foo'.
use.var.to.ensure.this.never.expands.to=Use "${var:?}" to ensure this never expands to /* .
warning.deletes.a.system.directory=Warning: deletes a system directory.
function.keyword.is.non.standard.delete.it='function' keyword is non-standard. Delete it.
in.use.instead.of.o=In '[\\[..]]', use '||' instead of '-o'.
instead.of.a.b.use.a.b=Instead of '[ a || b ]', use '[ a ] || [ b ]'.
in.use.instead.of.a=In '[\\[..]]', use '\\&\\&' instead of '-a'.
instead.of.a.b.use.a.b2=Instead of '[ a \\&\\& b ]', use '[ a ] \\&\\& [ b ]'.
sc2106.this.only.exits.the.subshell.caused.by.the.pipeline=SC2106: This only exits the subshell caused by the pipeline.
break.is.only.valid.in.loops=`break` is only valid in loops.
in.functions.use.return.instead.of.break=In functions, use 'return' instead of 'break'.
use.a.subshell.to.avoid.having.to.cd.back=Use a ( subshell ) to avoid having to cd back.
ranges.can.only.match.single.chars.mentioned.due.to.duplicates=Ranges can only match single chars (mentioned due to duplicates).
named.class.needs.outer.e.g.digit=Named class needs outer '[]', for example: [[:digit:]\\]
use.for.arithmetics.e.g.i.i.2=Use `$((..))` for arithmetics, for example: i=$((i + 2))
this.expansion.will.not.see.the.mentioned.assignment=This expansion will not see the mentioned assignment.
this.assignment.is.only.seen.by.the.forked.process=This assignment is only seen by the forked process.
on.most.os.shebangs.can.only.specify.a.single.parameter=On most OS's, shebangs can only specify a single parameter.
add.dev.null.to.prevent.ssh.from.swallowing.stdin=Add '< /dev/null' to prevent ssh from swallowing stdin.
sc2094.make.sure.not.to.read.and.write.the.same.file.in.the.same.pipeline=SC2094 Make sure not to read and write the same file in the same pipeline.
remove.exec.if.script.should.continue.after.this.command=Remove "exec " if the script should continue after this command.
remove.backticks.to.avoid.executing.output=Remove backticks to avoid executing the output.
remove.surrounding.to.avoid.executing.output=Remove the surrounding '$()' to avoid executing the output.
quotes.backslashes.in.this.variable.will.not.be.respected=Quotes and backslashes in this variable will not be respected.
quotes.backslashes.will.be.treated.literally.use.an.array=Quotes and backslashes will be treated literally. Use an array.
tilde.does.not.expand.in.quotes.use.home=Tilde does not expand in quotes. Use $HOME.
quote.eof.to.make.here.document.expansions.happen.on.the.server.side.rather.than.on.the.client=Add quotes around 'EOF' to make here documents expand on the server side rather than on the client.
double.quote.to.prevent.globbing.and.word.splitting=Use double quotes to prevent globbing and word splitting.
remove.or.use.expr.to.avoid.executing.output=Remove '$' or use '_=$((expr))' to avoid executing the output.
to.expand.via.indirection.use.name.foo.n.echo.name=To expand via indirection, use name="foo$n"; echo "${!name}".
can.t.match.globs.use.or.grep=`[ .. ]` can't match globs. Use `[[ .. ]]` or grep.
numbers.with.leading.0.are.considered.octal=Numbers with leading 0 are considered octal.
doesn.t.support.decimals.use.bc.or.awk='(( ))' doesn't support decimals. Use 'bc' or 'awk'.
this.expression.is.constant.did.you.forget.a.somewhere=This expression is constant. Did you forget a `$` somewhere?
you.need.spaces.around.the.comparison.operator=You need spaces around the comparison operator.
don.t.quote.rhs.of.it.ll.match.literally.rather.than.as.a.regex=Don't quote rhs of =~, it'll match literally rather than as a regex.
can.t.use.in.use.instead=Can't use `=~` in `[ ]`. Use `[[..]]` instead.
decimals.are.not.supported.either.use.integers.only.or.use.bc.or.awk.to.compare=Decimals are not supported. Either use integers only, or use 'bc' or 'awk' to compare.
is.for.string.comparisons.use.gt.instead='>' is for string comparisons. Use '-gt' instead.
n.doesn.t.work.with.unquoted.arguments.quote.or.use=`-n` doesn't work with unquoted arguments. Quote or use ``[[ ]]``.
to.redirect.stdout.stderr.2.1.must.be.last.or.use.cmd.file.2.1.to.clarify=To redirect stdout+stderr, '2>\\&1' must be last (or use '{ cmd > file; } 2>\\&1' to clarify).
double.quote.array.expansions.to.avoid.re.splitting.elements=Double-quote array expansions to avoid re-splitting elements.
missing.or.terminating.exec.you.can.t.use.and.has.to.be.a.separate.quoted.argument=Missing ';' or '+' terminating '-exec'. Do not use |/||/\\&\\&, and use quotes for ';'.
since.you.double.quoted.this.it.will.not.word.split.and.the.loop.will.only.run.once=Since you double-quoted this, it will not split by words, and the loop will only run once.
this.is.interpreted.as.a.shell.file.redirection.not.a.comparison=This is interpreted as a shell file redirection, not a comparison.
use.single.quotes.otherwise.this.expands.now.rather.than.when.signalled=Use single quotes to expand only when signalled, not right away.
grep.uses.regex.but.this.looks.like.a.glob=Grep uses regex, but this looks like a glob.
quote.the.grep.pattern.so.the.shell.won.t.interpret.it=Quote the grep pattern so the shell won't interpret it.
quote.the.parameter.to.name.so.the.shell.won.t.interpret.it=Quote the parameter to '-name' so the shell won't interpret it.
quote.parameters.to.tr.to.prevent.glob.expansion=Quote parameters to 'tr' to prevent glob expansion.
don.t.use.variables.in.the.printf.format.string.use.printf.s.foo=Don't use variables in the printf format string. Instead, use the following syntax: printf "..%s.." "$foo".
unknown.unaryoperator=Unknown unary operator.
unknown.binary.operator=Unknown binary operator.
you.probably.wanted.here=Use '\\&\\&'.
use.spaces.not.commas.to.separate.array.elements=Use spaces, not commas, to separate array elements.
quote.the.rhs.of.in.to.prevent.glob.matching=Quote the 'rhs of =' in '[[ ]]' to prevent glob matching.
bash.doesn.t.support.variables.in.brace.range.expansions=Bash doesn't support variables in brace range expansions.
this.expression.is.constant.did.you.forget.the.on.a.variable=This expression is constant. Did you forget the `$` on a variable?
is.for.regex.but.this.looks.like.a.glob.use.instead='=~' is for regex, but this looks like a glob. Use '=' instead.
use.with.quotes.to.prevent.whitespace.problems=Use "$@" (with quotes) to prevent whitespace problems.
quote.this.to.prevent.word.splitting=Quote this to prevent word splitting.
iterating.over.ls.output.is.fragile.use.globs=Iterating over ls output is fragile. Use globs.
for.loops.over.find.output.are.fragile.use.find.exec.or.a.while.read.loop=For loops over find output are fragile. Use 'find -exec' or a while read loop.
this.loop.will.only.ever.run.once.for.a.constant.value.did.you.perhaps.mean.to.loop.over.dir.var.or.cmd=This loop will only ever run once for a constant value. Did you mean to loop over 'dir/*', '$var', or '$(cmd)'?
this.is.a.literal.string.to.run.as.a.command.use.instead.of=This is a literal string. To run as a command, use '$(..)' instead of '..' .
bin.sh.was.specified.so.is.not.supported.even.when.sh.is.actually.bash='#!/bin/sh' was specified, so ____ is not supported, even when sh is actually bash.
in.posix.sh.something.is.undefined=In POSIX sh, something is undefined.
use.print0.0.or.find.exec.to.allow.for.non.alphanumeric.filenames=Use '-print0', '-0', or 'find -exec +' to allow for non-alphanumeric filenames.
to.assign.the.output.of.a.command.use.var.cmd=To assign the output of a command, use 'var=$(cmd)'.
if.you.wanted.to.assign.the.output.of.the.pipeline.use.a.b.c=If you wanted to assign the output of the pipeline, use 'a=$(b | c)'.
use.glob.or.glob.so.names.with.dashes.won.t.become.options=Use './\\*glob*' or '-- \\*glob*' so names with dashes won't become options.
foo.appears.unused.verify.it.or.export.it='foo' appears unused. Verify it or export it.
shell.functions.can.t.be.passed.to.external.commands=Shell functions can't be passed to external commands.
use.own.script.or.sh.c.to.run.this.from.su=Use own script or sh -c '..' to run this from su.
var.was.modified.in.a.subshell.that.change.might.be.lost='var' was modified in a subshell. That change might be lost.
modification.of.var.is.local.to.subshell.caused.by.pipeline=Modification of 'var' is local (to subshell caused by pipeline).
note.that.unescaped.this.expands.on.the.client.side=If unescaped, this expands on the client side.
echo.won.t.expand.escape.sequences.consider.printf='echo' won't expand escape sequences. Consider 'printf'.
the.surrounding.quotes.actually.unquote.this.remove.or.escape.them=The surrounding quotes actually unquote this. Remove or escape them.
this.word.is.outside.of.quotes.did.you.intend.to.nest.single.quotes.instead=This word is outside of quotes. Did you intend to 'nest '"'single quotes'"' instead'?
make.sure.all.escape.sequences.are.enclosed.in.to.prevent.line.wrapping.issues=Make sure all escape sequences are enclosed in `\\[..\\]` to prevent line wrapping issues
sudo.doesn.t.affect.redirects.use.sudo.tee.file=`sudo` doesn't affect redirects. Use `..| sudo tee file`
note.that.unlike.globs.o.here.matches.ooo.but.not.oscar=Note that unlike globs, 'o*' here matches 'ooo' but not 'oscar'
don.t.use.around.ranges.in.tr.it.replaces.literal.square.brackets=Don't use '[]' around ranges in 'tr', it replaces literal square brackets.
tr.replaces.sets.of.chars.not.words.mentioned.due.to.duplicates='tr' replaces sets of characters, not words (mentioned due to duplicates).
use.upper.to.support.accents.and.foreign.alphabets=Use '[:upper:]' to support accents and foreign alphabets.
use.lower.to.support.accents.and.foreign.alphabets=Use '[:lower:]' to support accents and foreign alphabets.
increase.precision.by.replacing.a.b.c.with.a.c.b=Increase precision by replacing 'a/b\\*c' with 'a\\*c/b'.
expressions.don.t.expand.in.single.quotes.use.double.quotes.for.that=Expressions don't expand in single quotes, use double quotes for that.
note.that.a.b.c.is.not.if.then.else.c.may.run.when.a.is.true=Note that 'A \\&\\& B || C' is not 'if-then-else'. C may run when A is true.
this.will.expand.once.before.find.runs.not.per.file.found=This will expand once before find runs, not per file found.
to.read.lines.rather.than.words.pipe.redirect.to.a.while.read.loop=To read lines rather than words, pipe or redirect the output to a 'while read' loop.
use.find.instead.of.ls.to.better.handle.non.alphanumeric.filenames=Use `find` instead of `ls` to better handle non-alphanumeric filenames.
don.t.use.ls.grep.use.a.glob.or.a.for.loop.with.a.condition.to.allow.non.alphanumeric.filenames=Don't use 'ls | grep'. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.
sc2009.consider.using.pgrep.instead.of.grepping.ps.output=SC2009 Consider using pgrep instead of grepping ps output.
echo.doesn.t.read.from.stdin.are.you.sure.you.should.be.piping.to.it='echo' doesn't read from stdin. Piping to it is not recommended.
use.instead.of.deprecated=Use '$((..))' instead of the deprecated '$[..]'.
use.notation.instead.of.legacy.backticked=Use '$(...)' notation instead of the legacy backticked `` `...` ``.
useless.echo.instead.of.echo.cmd.just.use.cmd=Redundant `echo`? Instead of `echo $(cmd)`, use `cmd`.
is.unnecessary.on.arithmetic.variables='$' and '${}' are unnecessary on arithmetic variables.
expr.is.antiquated.consider.rewriting.this.using.or='expr' is antiquated. Consider rewriting this using '$((..))', '${}' or '\\[\\[ \\]\\]'.
useless.cat.consider.cmd.file.or.cmd.file.instead=Redundant 'cat'. Consider 'cmd < file | ..' or 'cmd file | ..' instead.
sc2001.see.if.you.can.use.variable.search.replace.instead=SC2001: See if you can use ${variable//search/replace} instead.
consider.adding.a.default.case.even.if.it.just.exits.with.error=Consider adding a default '*)' case, even if it just exits with an error.
flip.leading.and.if.this.should.be.a.quoted.substitution=Flip the leading '$' and '"' if this should be a quoted substitution.
this.shebang.specifies.a.directory.ensure.the.interpreter.is.a.file=This shebang specifies a directory. Ensure the interpreter is a file.
d.only.applies.to.the.first.expansion.of.this.glob.use.a.loop.to.check.any.all='-d' only applies to the first expansion of this glob. Use a loop to check any/all.
prefer.explicit.n.to.check.non.empty.string.or.use.ne.to.check.boolean.integer=Prefer explicit '-n' to check non-empty strings. Use '=' or '-ne' to check booleans and integers.
prefer.explicit.n.to.check.for.output.or.run.command.without.to.check.for.success=Prefer explicit '-n' to check for output. Run command without '[' and '[[' to check for success.
can.only.exit.with.status.0.255.other.data.should.be.written.to.stdout.stderr=Can only exit with status 0-255. Other data should be written to stdout/stderr.
the.exit.status.can.only.be.one.integer.0.255.use.stdout.for.other.data=The exit status can only be one integer 0-255. Use stdout for other data.
the.dot.command.does.not.support.arguments.in.sh.dash.set.them.as.variables=The dot command does not support arguments in sh/dash. Set them as variables.
ensure.the.shebang.uses.the.absolute.path.to.the.interpreter=Ensure the shebang specifies the absolute path to the interpreter.
redirecting.to.from.command.name.instead.of.file.did.you.want.pipes.xargs.or.quote.to.ignore=Redirecting to or from a command name instead of a file. Use pipes or xargs instead (or quote to ignore).
use.n.instead.of.z=Use `[ -n .. ]` instead of `! [ -z .. ]`.
use.n.instead.of.z2=Use `-n` instead of `! -z`.
use.instead.of.to.avoid.subshell.overhead=Use `{ ..; }` instead of `(..)` to avoid subshell overhead.
remove.superfluous.around.test.command=Remove superfluous `(..)` around test command.
remove.superfluous.around.condition=Remove superfluous `(..)` around condition.
can.t.use.sudo.with.builtins.like.cd.did.you.want.sudo.sh.c.instead=Can't use 'sudo' with built-ins like 'cd'. Use 'sudo sh -c' instead.
quote.expansions.in.this.for.loop.glob.to.prevent.wordsplitting.e.g.dir.txt=Quote expansions in this for loop glob to prevent word splitting, for example: "$dir"/*.txt
which.is.non.standard.use.builtin.command.v.instead='which' is non-standard. Use the built-in 'command -v' instead.
this.does.not.read.foo.remove.for.that.or.use.var.to.quiet=This does not read 'foo'. Remove '$' and '${}' or use '${var?}' to quiet.
redirection.applies.to.the.find.command.itself.rewrite.to.work.per.action.or.move.to.end=Redirection applies to the 'find' command itself. Rewrite to work per action (or move to the end).
this.ln.has.no.destination.check.the.arguments.or.specify.explicitly=This 'ln' has no destination. Check the arguments, or specify '.' explicitly.
this.cp.has.no.destination.check.the.arguments=This 'cp' has no destination. Check the arguments.
this.mv.has.no.destination.check.the.arguments=This 'mv' has no destination. Check the arguments.
this.default.assignment.may.cause.dos.due.to.globbing.quote.it=This default assignment may cause DoS due to globbing. Quote it.
this.pattern.never.matches.because.of.a.previous.pattern=This pattern never matches because of a previous pattern.
this.pattern.always.overrides.a.later.one=This pattern always overrides a later one.
invalid.flags.are.not.handled.add.a.case=Invalid flags are not handled. Add a `*)` case.
instead.of.let.expr.prefer.expr=Instead of `let expr`, prefer `(( expr ))` .
this.function.is.only.defined.later.move.the.definition.up=This function is only defined later. Move the definition up.
redirecting.to.echo.a.command.that.doesn.t.read.stdin.bad.quoting.or.missing.xargs=Redirecting to 'echo', a command that doesn't read stdin. Bad quoting or missing xargs?
piping.to.rm.a.command.that.doesn.t.read.stdin.wrong.command.or.missing.xargs=Piping to 'rm', a command that doesn't read stdin. Wrong command or missing xargs?
this.flag.is.used.as.a.command.name.bad.line.break.or.missing=This flag is used as a command name. Bad line break or missing `[ .. ]`?
this.case.is.not.specified.by.getopts=This case is not specified by 'getopts'.
getopts.specified.n.but.it.s.not.handled.by.this.case='getopts' specified '-n', but it's not handled by this 'case'.
use.false.instead.of.empty.conditionals=Use 'false' instead of empty '[' and '[[' conditionals.
this.is.a.glob.used.as.a.command.name.was.it.supposed.to.be.in.array.or.is.it.missing.quoting=This is a glob used as a command name. Was it supposed to be in '${..}' or an array? If not, use quotes.
this.is.a.file.redirection.was.it.supposed.to.be.a.comparison.or.fd.operation=This is a file redirection. Was it supposed to be a comparison or an fd operation?
use.var.command.to.assign.output.or.quote.to.assign.string=Use 'var=$(command)' to assign output (or quote to assign string).
use.or.quote.arguments.to.v.to.avoid.glob.expansion=Use `[[ ]]` or quote arguments of the '-v' option to avoid glob expansion.
prefer.mapfile.or.read.a.to.split.command.output.or.quote.to.avoid.splitting=Prefer 'mapfile' or 'read -a' to split the command output (or quote to avoid splitting).
quote.to.prevent.word.splitting.or.split.robustly.with.mapfile.or.read.a=Quote to prevent word splitting, or split robustly with 'mapfile' or 'read -a'.
is.a.subshell.did.you.mean.a.test.expression='(..)' is a subshell. Did you mean '[ .. ]', a test expression?
globs.are.ignored.in.except.right.of.use.a.loop=Globs are ignored in `[[ ]]` except to the right of '=' and '!='. Use a loop.
globs.don.t.work.as.operands.in.use.a.loop=Globs don't work as operands in '[ ]'. Use a loop.
brace.expansion.doesn.t.happen.in.use.a.loop=Brace expansion doesn't happen in `[[ ]]`. Use a loop.
brace.expansions.don.t.work.as.operands.in.use.a.loop=Brace expansions don't work as operands in '[ ]'. Use a loop.
error.message.can.t.find.info.in.your.path=Can't find the info in your $PATH variable.
# {)} is a file name
line.marker.run.0=Run {0}
i.do.mind.path.placeholder=I do mind
display.name.shell.check=ShellCheck

sh.markdown.runner.title=Run in Terminal