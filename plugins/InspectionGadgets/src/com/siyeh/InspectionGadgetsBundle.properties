plugin.InspectionGadgets.description=Adds over 500 new automated code inspections for IntelliJ IDEA.
error.message.regexp.malformed.naming.pattern=Malformed Naming Pattern
cast.to.concrete.class.display.name=Cast to a concrete class
cast.to.concrete.class.problem.descriptor=Cast to concrete class <code>#ref</code> #loc
class.references.subclass.display.name=Class references one of its subclasses
class.references.subclass.problem.descriptor=Class ''{0}'' references subclass <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=Anonymous class references subclass <code>#ref</code> #loc
collection.declared.by.class.display.name=Collection declared by class, not interface
#{0} - name of the interface
collection.declared.by.class.problem.descriptor=Declaration of <code>#ref</code> should probably be weakened to ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=Ignore local variables
collection.declared.by.class.ignore.private.members.option=Ignore private fields and methods
feature.envy.display.name=Feature Envy
feature.envy.problem.descriptor=Class ''{0}'' accessed repeatedly in method <code>#ref</code> #loc
instance.variable.of.concrete.class.display.name=Instance variable of concrete class
instance.variable.of.concrete.class.problem.descriptor=Instance variable ''{0}'' of concrete class <code>#ref</code> #loc
chain.of.instanceof.checks.display.name=Chain of 'instanceof' checks
chain.of.instanceof.checks.problem.descriptor=Chain of 'instanceof' checks indicates abstraction failure #loc
instanceof.concrete.class.display.name='instanceof' a concrete class
instanceof.concrete.class.problem.descriptor='instanceof' concrete class <code>#ref</code> #loc
instanceof.check.for.this.display.name='instanceof' check for 'this'
instanceof.check.for.this.problem.descriptor='instanceof' check for <code>#ref</code> #loc
local.variable.of.concrete.class.display.name=Local variable of concrete class
local.variable.of.concrete.class.problem.descriptor=Local variable ''{0}'' of concrete class <code>#ref</code> #loc
magic.number.display.name="Magic number"
magic.number.problem.descriptor=Magic number <code>#ref</code> #loc
magic.number.ignore.option=Ignore constants in 'hashCode()' methods
method.return.concrete.class.display.name=Method return of concrete class
method.return.concrete.class.problem.descriptor=Method returns a concrete class <code>#ref</code> #loc
overly.strong.type.cast.display.name=Overly-strong type cast
overly.strong.type.cast.weaken.quickfix=Weaken overly-strong cast
concrete.class.method.parameter.display.name=Method parameter of concrete class
concrete.class.method.parameter.problem.descriptor=Parameter ''{0}'' of concrete class <code>#ref</code> #loc
public.method.not.in.interface.display.name=Public method not exposed in interface
public.method.not.in.interface.problem.descriptor=Public method <code>#ref</code> is not exposed via an interface #loc
static.variable.of.concrete.class.display.name=Static variable of concrete class
static.variable.of.concrete.class.problem.descriptor=Static variable ''{0}'' of concrete class <code>#ref</code> #loc
incompatible.mask.operation.display.name=Incompatible bitwise mask operation
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> is always false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> is always true #loc
pointless.bitwise.expression.display.name=Pointless bitwise expression
pointless.bitwise.expression.ignore.option=Ignore named constant in determinining pointless expressions
pointless.bitwise.expression.problem.descriptor=<code>#ref</code> can be replaced with ''{0}'' #loc
pointless.bitwise.expression.simplify.quickfix=Simplify
shift.operation.by.inappropriate.constant.display.name=Shift operation by inappropriate constant
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Shift operation <code>#ref</code> by overly large constant value #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Shift operation <code>#ref</code> by negative constant value #loc
archaic.system.property.accessors.display.name=Use of archaic system property accessors
archaic.system.property.accessors.problem.descriptor.Integer=Call to <code>Integer.#ref()</code> accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.problem.descriptor.Long=Call to <code>Long.#ref()</code> accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.problem.descriptor.Boolean=Call to <code>Boolean.#ref()</code> accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.replace.parse.quickfix=Replace with parse method
archaic.system.property.accessors.replace.standard.quickfix=Replace with standard property access
equals.called.on.array.display.name='equals()' called on array type
equals.called.on.array.problem.descriptor=<code>#ref()</code> between arrays should probably be 'Arrays.equals()' #loc
equals.called.on.array.replace.quickfix=replace with 'Arrays.equals()'
assignment.to.null.display.name=Assignment to 'null'
assignment.to.null.problem.descriptor=Assignment of variable <code>#ref</code> to null #loc
assignment.to.static.field.from.instance.method.display.name=Assignment to static field from instance method
assignment.to.static.field.from.instance.method.problem.descriptor=Assignment to static field <code>#ref</code> from an instance method #loc
assignment.used.as.condition.display.name=Assignment used as condition
assignment.used.as.condition.problem.descriptor=<code>#ref</code> used as condition #loc
assignment.used.as.condition.replace.quickfix=replace '=' with '=='
cast.conflicts.with.instanceof.display.name=Cast conflicts with 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Cast to <code>#ref</code> conflicts with surrounding 'instanceof' check #loc
casting.to.incompatible.interface.display.name=Casting to incompatible interface
casting.to.incompatible.interface.problem.descriptor=Cast to incompatible interface <code>#ref</code> #loc
collection.added.to.self.display.name=Collection added to self
collection.added.to.self.problem.descriptor=Collection <code>#ref</code> is added to self #loc
non.final.field.compareto.display.name=Non-final field referenced in 'compareTo()'
non.final.field.compareto.problem.descriptor=Non-final field <code>#ref</code> accessed in 'compareTo()' #loc
covariant.compareto.display.name=Covariant 'compareTo()'
covariant.compareto.problem.descriptor=<code>#ref()</code> should take 'Object' as its argument #loc
covariant.equals.display.name=Covariant 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> should take 'Object' as its argument #loc
empty.class.initializer.display.name=Empty class initializer
empty.class.initializer.problem.descriptor=Empty class initializer #loc
empty.class.initializer.delete.quickfix=Delete empty class initializer
statement.with.empty.body.display.name=Statement with empty body
statement.with.empty.body.problem.descriptor=<code>#ref</code> statement has empty body #loc
statement.with.empty.body.include.option=Include statement bodies that are empty code blocks
equals.between.inconvertible.types.display.name='equals()' between objects of inconvertible types
equals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
non.final.field.in.equals.display.name=Non-final field referenced in 'equals()'
non.final.field.in.equals.problem.descriptor=Non-final field <code>#ref</code> accessed in 'equals()'  #loc
equals.doesnt.check.class.parameter.display.name='equals()' method which does not check class of parameter
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref</code> should check the class of its parameter #loc
for.loop.not.use.loop.variable.display.name='for' loop where update or condition does not use loop variable
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>#ref</code> statement has condition which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>#ref</code> statement has update which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>#ref</code> statement has condition and update which do not use the for loop variable #loc
non.final.field.in.hashcode.display.name=Non-final field referenced in 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Non-final field <code>#ref</code> accessed in 'hashCode()'  #loc
result.of.method.call.ignored.display.name=Result of method call ignored
result.of.method.call.ignored.problem.descriptor=result of <code>{0}.#ref()</code> is ignored. #loc
result.of.method.call.ignored.class.column.title=Class name
result.of.method.call.ignored.method.column.title=Method name
result.of.method.call.ignored.non.library.option=Report all ignored non-library calls
infinite.recursion.display.name=Infinite recursion
infinite.recursion.problem.descriptor=Method <code>#ref</code> recurses infinitely, and can only end by throwing an exception #loc
instanceof.with.incompatible.interface.display.name='instanceof' with incompatible interface
instanceof.with.incompatible.interface.problem.descriptor='instanceof' incompatible interface <code>#ref</code> #loc
instantiation.utility.class.display.name=Instantiation of utility class
instantiation.utility.class.problem.descriptor=Instantiation of utility class <code>#ref</code> #loc
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()' which calls 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.#ref()</code> contains call to 'next()' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name='Iterator.next()' which can't throw 'NoSuchElementException'
malformed.format.string.display.name=Malformed format string
malformed.format.string.problem.descriptor.malformed=Format string #ref is malformed #loc
malformed.format.string.problem.descriptor.too.many.arguments=Too many arguments for format string #ref #loc
malformed.format.string.problem.descriptor.too.few.arguments=Too few arguments for format string #ref #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=Format string #ref does not match the type of its arguments #loc
malformed.regular.expression.display.name=Malformed regular expression
malformed.regular.expression.problem.descriptor1=Regular expression <code>#ref</code> is malformed #loc
malformed.regular.expression.problem.descriptor2=Regular expression <code>#ref</code> is malformed: {0} #loc
malformed.xpath.expression.display.name=Malformed XPath expression
malformed.xpath.expression.problem.description=XPath expression <code>#ref</code> is malformed #loc
mismatched.read.write.array.display.name=Mismatched read and write of array
mismatched.read.write.array.problem.descriptor.write.not.read=Contents of array <code>#ref</code> are written to, but never read #loc
mismatched.read.write.array.problem.descriptor.read.not.write=Contents of array <code>#ref</code> are read, but never written to #loc
mismatched.update.collection.display.name=Mismatched query and update of collection
mismatched.update.collection.problem.descriptor.updated.not.queried=Contents of collection <code>#ref</code> are updated, but never queried #loc
mismatched.update.collection.problem.description.queried.not.updated=Contents of collection <code>#ref</code> are queried, but never updated #loc
misspelled.compareto.display.name='compareto()' instead of 'compareTo()'
misspelled.compareto.problem.descriptor=<code>#ref()</code> method should probably be 'compareTo()' #loc
rename.quickfix=Rename
renameto.quickfix=Rename to ''{0}''
misspelled.equals.display.name='equal()' instead of 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> method should probably be equals() #loc
misspelled.hashcode.display.name='hashcode()' instead of 'hashCode()'
misspelled.hashcode.problem.descriptor=<code>#ref()</code> should probably be hashCode() #loc
misspelled.tostring.display.name='tostring()' instead of 'toString()'
misspelled.tostring.problem.descriptor=<code>#ref()</code> method should probably be 'toString()' #loc
non.short.circuit.boolean.expression.display.name=Non-short-circuit boolean expression
non.short.circuit.boolean.expression.problem.descriptor=Non-short-circuit boolean expression <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Replace with short circuit expression
null.argument.to.var.arg.method.display.name=Confusing 'null' argument to var-arg method
null.argument.to.var.arg.method.problem.descriptor=Confusing <code>#ref</code> argument to var-arg method #loc
primitive.array.argument.to.var.arg.method.display.name=Confusing primitive array argument to var-arg method
primitive.array.argument.to.var.arg.method.problem.descriptor=Confusing primitive array argument to var-arg method #loc
object.comparison.display.name=Object comparison using ==, instead of 'equals()'
object.comparison.enumerated.ignore.option=Ignore == between enumerated types
object.comparison.klass.ignore.option=Ignore == on java.lang.Class objects
object.comparison.problem.description=Object values are compared using <code>#ref</code>, not 'equals()' #loc
object.comparison.replace.quickfix=Replace with equals()
object.equals.null.problem.descriptor=<code>.equals(#ref)</code> is probably not what was intended #loc
default.tostring.call.display.name=Call to default 'toString()'
default.tostring.call.problem.descriptor=Call to default 'toString()' on <code>#ref</code> #loc
octal.and.decimal.integers.in.same.array.display.name=Octal and decimal integers in same array
octal.and.decimal.integers.in.same.array.problem.descriptor=Octal and decimal integers in the same array initializer #loc
result.of.object.allocation.ignored.display.name=Result of object allocation ignored
result.of.object.allocation.ignored.problem.descriptor=result of new <code>#ref()</code> is ignored. #loc
use.0index.in.jdbc.resultset.display.name=Use of index 0 in JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Use of index '0' in JDBC ResultSet #loc
return.of.null.display.name=Return of 'null'
return.of.null.problem.descriptor=Return of <code>#ref</code> #loc
return.of.null.arrays.option=Methods that return arrays
return.of.null.quickfix=Annotate method as @Nullable
return.of.null.objects.option=Methods that return objects
return.of.null.collections.option=Methods that return collection objects
static.method.via.subclass.display.name=Static method referenced via subclass
static.method.via.subclass.problem.descriptor=Static method <code>#ref</code> declared on class ''{0}'' but referenced via class ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Rationalize static method call
static.field.via.subclass.display.name=Static field referenced via subclass
static.field.via.subclass.problem.descriptor=Static field <code>#ref</code> declared on class ''{0}'' but referenced via class ''{1}''    #loc
static.field.via.subclass.rationalize.quickfix=Rationalize static field access
string.comparison.display.name=String comparison using '==', instead of 'equals()'
string.comparison.problem.descriptor=String values are compared using <code>#ref</code>, not '.equals()' #loc
string.comparison.replace.quickfix=Replace with equals()
subtraction.in.compareto.display.name=Subtraction in compareTo()
subtraction.in.compareto.problem.descriptor=Subtraction <code>#ref</code> in compareTo() may result in overflow errors #loc
text.label.in.switch.statement.display.name=Text label in 'switch' statement
text.label.in.switch.statement.problem.descriptor=Text label <code>#ref:</code> in 'switch' statement #loc
properties.object.as.hashtable.display.name=Use of Properties object as a Hashtable
properties.object.as.hashtable.problem.descriptor=Call to <code>Hashtable.#ref()</code> on properties object #loc
assignment.replaceable.with.operator.assignment.display.name=Assignment replaceable with operator assignment
unnecessary.code.block.display.name=Unnecessary code block
unnecessary.code.block.unwrap.quickfix=Unwrap block
redundant.local.variable.display.name=Redundant local variable
redundant.local.variable.ignore.option=Ignore immediately returned or thrown variables
redundant.local.variable.annotation.option=Ignore variables which have an annotation (JDK 5.0 only)
static.collection.display.name=Static collection
static.collection.problem.descriptor=Static collection <code>#ref</code> #loc
static.collection.ignore.option=Ignore weak static collections or maps
#field of type java.lang.StringBuffer
stringbuffer.field.display.name=StringBuffer field
#{0} - concrete field type
stringbuffer.field.problem.descriptor=''{0}'' field <code>#ref</code> #loc
gc.call.display.name=Calls to 'System.gc()' or 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> should not be called in production code #loc
array.allocation.zero.length.display.name=Zero-length array allocation
array.allocation.zero.length.problem.descriptor=Allocation of zero length array #loc
multiple.loggers.display.name=Class with multiple loggers
logger.name.option=Logger class name:
multiple.loggers.problem.descriptor=Class <code>#ref</code> declares multiple loggers #loc
no.logger.display.name=Class without logger
no.logger.problem.descriptor=Class <code>#ref</code> does not declare a logger #loc
non.constant.logger.display.name=Non-constant logger
non.constant.logger.problem.descriptor=Non-constant logger field <code>#ref</code> #loc
public.method.without.logging.display.name=Public method without logging
public.method.without.logging.problem.descriptor=Public method without logging <code>#ref</code> #loc
action.reset.telemetry.description=Reset telemetry data

telemetry.table.column.inspection.name=Inspection Name
telemetry.table.column.total.time=Total Run Time (msecs)
telemetry.table.column.average.time=Average Run Time (msecs)
telemetry.table.column.run.count=Total Run Count
telemetry.toolwindow.title=IG Telemetry
action.telemetry.refresh.description=Refresh telemetry display
finalize.doesnt.call.super.display.name='finalize()' does not call 'super.finalize()'
finalize.doesnt.call.super.ignore.option=Ignore for direct subclasses of java.lang.Object
finalize.doesnt.call.super.problem.descriptor=<code>#ref()</code>#loc does not call 'super.finalize()'
finalize.declaration.display.name='finalize()' declaration
finalize.declaration.problem.descriptor=<code>#ref()</code> declared #loc
finalize.not.declared.protected.display.name='finalize()' not declared 'protected'
finalize.not.declared.protected.problem.descriptor=<code>#ref()</code> not declared 'protected' #loc
make.protected.quickfix=Make 'protected'
finalize.called.explicitly.display.name='finalize()' called explicitly
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> called explicitly #loc
java.lang.import.display.name=java.lang import
java.lang.import.problem.descriptor=Unnecessary import from package java.lang #loc
import.display.name=* import
import.problem.descriptor=Package import <code>#ref</code> #loc
redundant.import.display.name=Redundant import
redundant.import.problem.descriptor=Redundant import <code>#ref</code> #loc
import.from.same.package.display.name=Import from same package
import.from.same.package.problem.descriptor=Unnecessary import from same package <code>#ref</code> #loc
single.class.import.display.name=Single class import
single.class.import.problem.descriptor=Single class import <code>#ref</code> #loc
static.import.display.name=Static import
static.import.problem.descriptor=Static import <code>#ref</code>  #loc
static.import.replace.quickfix=Replace with non-static import
unused.import.display.name=Unused import
unused.import.problem.descriptor=Unused import <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' instantiates objects with constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' creates new <code>#ref</code> instances #loc
clone.doesnt.call.super.clone.display.name='clone()' does not call 'super.clone()'
clone.doesnt.call.super.clone.problem.descriptor=<code>#ref()</code> does not call 'super.clone()'
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' does not declare 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code>#loc does not declare 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Declare 'CloneNotSupportedException'
clone.method.in.non.cloneable.class.display.name='clone()' method in non-Cloneable class
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> defined in non-Cloneable class #loc
cloneable.class.without.clone.display.name=Cloneable class without 'clone()'
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> does not define 'clone()' #loc
cloneable.class.without.clone.ignore.option=Ignore classes cloneable due to inheritance
class.without.tostring.display.name=Class without 'toString()'
class.without.tostring.problem.descriptor=Class <code>#ref</code> should probably implement 'toString()', for debugging purposes
use.obsolete.collection.type.display.name=Use of obsolete collection type
use.obsolete.collection.type.problem.descriptor=Obsolete collection type <code>#ref</code> used #loc
inspection.suppression.annotation.display.name=Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor=Inspection suppression annotation <code>#ref</code> #loc
use.system.out.err.display.name=Use of System.out or System.err
use.system.out.err.problem.descriptor=Uses of 'System.out' and 'System.err' should probably be replaced with more robust logging #loc
dumpstack.call.display.name=Call to 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Call to <code>Thread.#ref()</code> should probably be replaced with more robust logging #loc
printstacktrace.call.display.name=Call to 'printStackTrace()'
printstacktrace.call.problem.descriptor=Call to <code>#ref()</code> should probably be replaced with more robust logging #loc
todo.comment.display.name=TODO comment
todo.comment.problem.descriptor=TODO comment <code>#ref</code> #loc
abstract.method.call.in.constructor.display.name=Abstract method call in constructor
abstract.method.call.in.constructor.problem.descriptor=Call to abstract method <code>#ref</code> during object construction #loc
instance.variable.may.not.be.initialized.display.name=Instance variable may not be initialized
instance.variable.may.not.be.initialized.problem.descriptor=Instance variable <code>#ref</code> may not be initialized during object construction #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=Instance variable <code>#ref</code> may not be initialized in 'setUp()'
primitive.fields.ignore.option=Ignore primitive fields
instance.variable.used.before.initialized.display.name=Instance variable used before initialized
instance.variable.used.before.initialized.problem.descriptor=Instance variable <code>#ref</code> used before initialized #loc
non.final.static.variable.initialization.display.name=Non-final static variable is used during class initialization
non.final.static.variable.initialization.problem.descriptor=Non-final static variable <code>#ref</code> used during class initialization #loc
overridable.method.call.in.constructor.display.name=Overridable method call in constructor
overridable.method.call.in.constructor.problem.descriptor=Call to overridable method during object construction #loc
overridden.method.call.in.constructor.display.name=Overridden method call in constructor
overridden.method.call.in.constructor.problem.descriptor=Call to overridden method <code>#ref()</code> during object construction #loc
static.variable.may.not.be.initialized.display.name=Static variable may not be initialized
static.variable.may.not.be.initialized.problem.descriptor=Static variable <code>#ref</code> may not be initialized during class initialization #loc
static.variable.used.before.initialization.display.name=Static variable used before initialization
static.variable.used.before.initialization.problem.descriptor=Static variable <code>#ref</code> used before initialization #loc
this.reference.escaped.in.construction.display.name='this' reference escaped in object construction
this.reference.escaped.in.construction.problem.descriptor=Escape of <code>#ref</code> during object construction #loc
assignment.to.catch.block.parameter.display.name=Assignment to catch block parameter
assignment.to.catch.block.parameter.extract.quickfix=Extract parameter as local variable
assignment.to.for.loop.parameter.display.name=Assignment to 'for' loop parameter
assignment.to.for.loop.parameter.check.foreach.option=Check foreach parameters
assignment.to.for.loop.parameter.problem.descriptor=Assignment to for-loop parameter <code>#ref</code> #loc
assignment.to.method.parameter.display.name=Assignment to method parameter
chained.equality.comparisons.display.name=Chained equality comparisons
confusing.octal.escape.sequence.display.name=Confusing octal escape sequence
increment.decrement.display.name=Value of ++ or -- used
nested.assignment.display.name=Nested assignment
nested.assignment.problem.descriptor=Nested assignment <code>#ref</code> #loc
overloaded.methods.with.same.number.parameters.display.name=Overloaded methods with same number of parameters
overloaded.vararg.method.display.name=Overloaded varargs method
refused.bequest.display.name=Refused bequest
reuse.of.local.variable.display.name=Reuse of local variable
reuse.of.local.variable.split.quickfix=Split local variable
character.comparison.display.name=Character comparison
character.comparison.problem.descriptor=Character comparison <code>#ref</code> in an internationalized context #loc
assignment.collection.array.field.from.parameter.display.name=Assignment to Collection or array field from parameter
assignment.collection.array.field.from.parameter.problem.descriptor.array=Assignment to array field <code>#ref</code> from parameter ''{0}''#loc
assignment.collection.array.field.from.parameter.problem.descriptor.collection=Assignment to Collection field <code>#ref</code> from parameter ''{0}''#loc
assignment.collection.array.field.option=Ignore assignments in private methods
assignment.to.date.calendar.field.from.parameter.display.name=Assignment to Date or Calendar field from parameter
assignment.to.date.calendar.field.from.parameter.problem.descriptor=Assignment to ''{0}'' field <code>#ref</code> from parameter {1}#loc
package.visible.field.display.name=Package-visible field
package.visible.field.problem.descriptor=Package-visible field <code>#ref</code> #loc
package.visible.inner.class.display.name=Package-visible inner class
package.visible.inner.class.problem.descriptor=Package-visible inner class <code>#ref</code> #loc
protected.field.display.name=Protected field
protected.field.problem.descriptor=Protected field <code>#ref</code> #loc
protected.inner.class.display.name=Protected inner class
protected.inner.class.problem.descriptor=Protected inner class <code>#ref</code> #loc
public.field.display.name=Public field
public.field.problem.descriptor=Public field <code>#ref</code> #loc
public.inner.class.display.name=Public inner class
public.inner.class.problem.descriptor=Public inner class <code>#ref</code> #loc
return.of.collection.array.field.display.name=Return of Collection or array field
return.of.collection.array.field.problem.descriptor.array='return' of array field <code>#ref</code> #loc
return.of.collection.array.field.problem.descriptor.collection='return' of Collection field <code>#ref</code> #loc
return.of.collection.array.field.option=Ignore private methods returning an array or collection field
return.date.calendar.field.display.name=Return of Date or Calendar field
return.date.calendar.field.problem.descriptor=Return of ''{0}'' field <code>#ref</code> #loc
accessing.non.public.field.of.another.object.display.name=Accessing a non-public field of another object
accessing.non.public.field.of.another.object.problem.descriptor=Direct access of non-public field <code>#ref</code> on another object #loc
call.to.date.tostring.display.name=Call to 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code>Date.#ref()</code> used in an internationalized context #loc
magic.character.display.name="Magic character"
magic.character.problem.descriptor="Magic character" <code>#ref</code> in an internationalized context #loc
call.to.numeric.tostring.display.name=Call to Numeric 'toString()'
call.to.numeric.tostring.problem.descriptor=Numeric <code>#ref()</code> called in an internationalized context #loc
instantiating.simpledateformat.without.locale.display.name=Instantiating a SimpleDateFormat without a Locale
instantiating.simpledateformat.without.locale.problem.descriptor=Instantiating a <code>#ref</code> without specifying a Locale in an internationalized context #loc
string.compareto.call.display.name=Call to 'String.compareTo()'
string.compareto.call.problem.descriptor=<code>String.#ref()</code> called in an internationalized context #loc
string.concatenation.display.name=String concatenation
string.concatenation.problem.descriptor=String concatenation <code>#ref</code> in an internationalized context #loc
string.concatenation.ignore.system.out.option=Ignore for 'System.out.print' parameters
string.concatenation.ignore.system.err.option=Ignore for 'System.err.print' parameters
string.equalsignorecase.call.display.name=Call to 'String.equalsIgnoreCase()'
string.equalsignorecase.call.problem.descriptor=<code>String.#ref()</code> in an internationalized context #loc
string.equals.call.display.name=Call to 'String.equals()'
string.equals.call.problem.descriptor=<code>String.#ref()</code> in an internationalized context #loc
string.touppercase.tolowercase.without.locale.display.name=Call to 'String.toUpperCase()' or 'toLowerCase()' without a Locale
string.touppercase.tolowercase.without.locale.problem.descriptor=<code>String.#ref()</code> called without specifying a Locale in an internationalized context #loc
use.stringtokenizer.display.name=Use of StringTokenizer
use.stringtokenizer.problem.descriptor=<code>#ref</code> in an internationalized context #loc
time.tostring.call.display.name=Call to 'Time.toString()'
time.tostring.call.problem.descriptor=<code>Time.#ref()</code> in an internationalized context #loc
class.escapes.defined.scope.display.name=Class escapes defined scope
class.escapes.defined.scope.problem.descriptor=Class <code>#ref</code> is made visible outside its defined scope #loc
field.name.hides.in.superclass.display.name=Field name hides field in superclass
field.name.hides.in.superclass.problem.descriptor=Field <code>#ref</code> hides field in superclass #loc
field.name.hides.in.superclass.ignore.option=Ignore superclass fields not visible from subclass
inner.class.field.hides.outer.display.name=Inner class field hides outer class field
inner.class.field.hides.outer.ignore.option=Ignore outer fields not visible from inner class
inner.class.field.hides.outer.problem.descriptor=Inner class field <code>#ref</code> hides outer class field #loc
local.variable.hides.member.variable.display.name=Local variable hides member variable
local.variable.hides.member.variable.problem.descriptor=Local variable <code>#ref</code> hides member variable #loc
local.variable.hides.member.variable.ignore.option=Ignore local variables in static methods
method.overloads.display.name=Method overloads method of superclass
method.overloads.problem.descriptor=Method <code>#ref</code> overloads a compatible method of a superclass, when overriding might have been intended #loc
method.overrides.private.display.name=Method overrides private method of superclass
method.overrides.private.display.name.problem.descriptor=Method <code>#ref()</code> overrides a private method of a superclass #loc
method.overrides.static.display.name=Method overrides static method of superclass
method.overrides.static.problem.descriptor=Method <code>#ref</code> overrides a static method of a superclass #loc
parameter.hides.member.variable.display.name=Parameter hides member variable
parameter.hides.member.variable.problem.descriptor=Parameter <code>#ref</code> hides member variable #loc
parameter.hides.member.variable.ignore.setters.option=Ignore for property setters
parameter.hides.member.variable.ignore.superclass.option=Ignore superclass fields not visible from subclass
parameter.hides.member.variable.ignore.constructors.option=Ignore for constructors
parameter.hides.member.variable.ignore.abstract.methods.option=Ignore for abstract methods
parameter.hides.member.variable.ignore.static.parameters.option=Ignore for static method parameters hiding instance fields
type.parameter.hides.visible.type.display.name=Type parameter hides visible type
type.parameter.hides.visible.type.problem.descriptor=Type parameter <code>#ref</code> hides a visible type ''{0}''#loc
channel.opened.not.closed.display.name=Channel opened but not safely closed
channel.opened.not.closed.problem.descriptor=''{0}'' should be opened in a try block, and closed in a finally block #loc
drivermanager.call.display.name=Use of DriverManager to get JDBC connection
drivermanager.call.problem.descriptor=Call to <code>DriverManager.#ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate resource opened but not safely closed
hibernate.resource.opened.not.closed.problem.descriptor=''{0}'' should be opened in a try block, and closed in a finally block #loc
i.o.resource.opened.not.closed.display.name=I/O resource opened but not safely closed
resource.opened.not.closed.problem.descriptor=''{0}'' should be opened in a try block, and closed in a finally block #loc
jdbc.resource.opened.not.closed.display.name=JDBC resource opened but not safely closed
jdbc.resource.opened.not.closed.problem.descriptor=JDBC ''{0}'' should be opened in a try block, and closed in a finally block #loc
jndi.resource.opened.not.closed.display.name=JNDI resource opened but not safely closed
socket.opened.not.closed.display.name=Socket opened but not safely closed
annotation.class.display.name=Annotation class
annotation.class.problem.descriptor=Annotation class <code>#ref</code> #loc
annotation.display.name=Annotation
annotation.problem.descriptor=Annotation <code>#ref</code> #loc
use.assert.as.identifier.display.name=Use of 'assert' as identifier
use.assert.as.identifier.problem.descriptor=Use of <code>#ref</code> as identifier #loc
assert.statement.display.name='assert' statement
statement.problem.descriptor=<code>#ref</code> statement #loc
auto.boxing.display.name=Auto-boxing
auto.boxing.problem.descriptor=Auto-boxing <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=Make boxing explicit
auto.unboxing.display.name=Auto-unboxing
auto.unboxing.problem.descriptor=Auto-unboxing <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=Make unboxing explicit
use.enum.as.identifier.display.name=Use of 'enum' as identifier
use.enum.as.identifier.problem.descriptor=Use of <code>#ref</code> as identifier #loc
enumerated.class.display.name=Enumerated class
enumerated.class.problem.descriptor=Enumerated class <code>#ref</code> #loc
extended.for.statement.display.name=Extended 'for' statement
extended.for.statement.replace.quickfix=Replace with old-style 'for' statement
variable.argument.method.display.name=Variable argument method
variable.argument.method.problem.descriptor=Variable argument method <code>#ref</code> #loc
variable.argument.method.quickfix=Convert variable argument parameter to array
hardcoded.file.separator.display.name=Hardcoded file separator
hardcoded.file.separator.problem.descriptor=Hardcoded file separator <code>#ref</code> #loc
hardcoded.line.separator.display.name=Hardcoded line separator
hardcoded.line.separator.problem.descriptor=Hardcoded line separator <code>#ref</code> #loc
native.method.display.name=Native method
native.method.problem.descriptor=Methods declared <code>#ref</code> are non-portable #loc
runtime.exec.call.display.name=Call to 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Call to <code>Runtime.#ref()</code> is non-portable #loc
system.exit.call.display.name=Call to 'System.exit()' or related methods
system.exit.call.problem.descriptor=Call to <code>{0}.#ref()</code> is non-portable #loc
system.getenv.call.display.name=Call to 'System.getenv()'
system.getenv.call.problem.descriptor=Call to <code>System.#ref()</code> is non-portable #loc
use.of.awt.peer.class.display.name=Use of AWT peer class
use.of.awt.peer.class.problem.descriptor=Use of AWT peer class <code>#ref</code> is non-portable #loc
use.of.concrete.jdbc.driver.class.display.name=Use of concrete JDBC driver class
use.of.concrete.jdbc.driver.class.problem.descriptor=Use of concrete JDBC driver class <code>#ref</code> is non-portable #loc
use.processbuilder.class.display.name=Use of java.lang.ProcessBuilder class
use.processbuilder.class.problem.descriptor=Use of <code>#ref</code> is non-portable #loc
use.sun.classes.display.name=Use of sun.* classes
use.sun.classes.problem.descriptor=Use of Sun-supplied class <code>#ref</code> is non-portable #loc
abstract.class.with.only.one.direct.inheritor.display.name=Abstract class which has only one direct inheritor
anonymous.inner.may.be.named.static.inner.class.display.name=Anonymous inner class may be a named static inner class
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=Anonymous inner class <code>#ref</code> may be a named static inner class #loc
array.length.in.loop.condition.display.name=Array.length in loop condition
array.length.in.loop.condition.problem.descriptor=Check of array <code>#ref</code> in loop condition #loc
large.array.allocation.no.outofmemoryerror.display.name=Large array allocation with no OutOfMemoryError check
large.array.allocation.no.outofmemoryerror.problem.descriptor=Large array allocation which is not checked for out-of-memory condition #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Maximum number of elements
connection.opened.not.safely.closed.display.name=Connection opened but not safely closed
field.repeatedly.accessed.in.method.display.name=Field repeatedly accessed in method
field.repeatedly.accessed.in.method.problem.descriptor=Field ''{0}'' accessed repeatedly in method <code>#ref</code> #loc
field.repeatedly.accessed.in.method.ignore.option=Ignore final fields
interface.one.inheritor.display.name=Interface which has only one direct inheritor
interface.one.inheritor.problem.descriptor=Interface <code>#ref</code> has only one direct inheritor #loc
method.call.in.loop.condition.display.name=Method call in loop condition
method.call.in.loop.condition.problem.descriptor=Call to method <code>#ref()</code> in loop condition #loc
large.initializer.primitive.type.array.display.name=Overly large initializer for array of primitive type
large.initializer.primitive.type.array.problem.descriptor=Primitive array initializer with too many elements ({0}) #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=Maximum number of elements
private.member.access.between.outer.and.inner.classes.display.name=Private member access between outer and inner classes
private.member.access.between.outer.and.inner.classes.problem.descriptor=Access to private member of class ''{0}'' #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Make ''{0}'' package local
recordstore.opened.not.safely.closed.display.name=RecordStore opened but not safely closed
overly.complex.anonymous.inner.class.display.name=Overly complex anonymous inner class
cyclomatic.complexity.limit.option=Cyclomatic complexity limit:
overly.complex.anonymous.inner.class.problem.descriptor=Overly complex anonymous inner class (cyclomatic complexity = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=Anonymous inner class with too many methods
method.count.limit.option=Method count limit:
anonymous.inner.class.with.too.many.methods.problem.descriptor=Anonymous inner class with too many methods (method count = {0}) #loc
overly.complex.class.display.name=Overly complex class
overly.complex.class.problem.descriptor=<code>#ref</code> is overly complex (cyclomatic complexity = {0}) #loc
overly.coupled.class.display.name=Overly coupled class
overly.coupled.class.class.coupling.limit.option=Class coupling limit:
include.java.system.classes.option=Include couplings to java system classes
include.library.classes.option=Include couplings to library classes
overly.coupled.class.problem.descriptor=<code>#ref</code> is overly coupled (dependencies = {0}) #loc
class.too.deep.display.name=Class too deep in inheritance tree
class.too.deep.inheritance.depth.limit.option=Inheritance depth limit:
class.too.deep.problem.descriptor=<code>#ref</code> is too deep in inheritance tree (inheritance depth = {0}) #loc
inner.class.too.deeply.nested.display.name=Inner class too deeply nested
inner.class.too.deeply.nested.nesting.limit.option=Nesting limit:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> is too deeply nested (nesting level = {0}) #loc
too.many.constructors.display.name=Class with too many constructors
too.many.constructors.count.limit.option=Constructor count limit:
too.many.constructors.problem.descriptor=<code>#ref</code> has too many constructors (constructor count = {0}) #loc
too.many.fields.display.name=Class with too many fields
too.many.fields.count.limit.option=Field count limit:
too.many.fields.problem.descriptor=<code>#ref</code> has too many fields (field count = {0}) #loc
too.many.methods.display.name=Class with too many methods
too.many.methods.problem.descriptor=<code>#ref</code> has too many methods (method count = {0}) #loc
externalizable.with.serialization.methods.display.name=Externalizable class with 'readObject()' or 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=Externalizable class <code>#ref</code> defines readObject() and writeObject() #loc
externalizable.with.serialization.methods.problem.descriptor.write=Externalizable class <code>#ref</code> defines writeObject() #loc
externalizable.with.serialization.methods.problem.descriptor.read=Externalizable class <code>#ref</code> defines readObject() #loc
non.serializable.with.serialversionuid.display.name=Non-serializable class with 'serialVersionUID'
non.serializable.with.serialversionuid.problem.descriptor=Non-serializable class <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.with.serialversionuid.remove.quickfix=Remove 'serialVersionUID' field
non.serializable.class.with.readwriteobject.display.name=Non-serializable class with 'readObject()' or 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both=Non-serializable class <code>#ref</code> defines readObject() and writeObject() #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=Non-serializable class <code>#ref</code> defines writeObject() #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Non-serializable class <code>#ref</code> defines readObject() #loc
readwriteobject.private.display.name='readObject()' or 'writeObject()' not declared 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> not declared 'private' #loc
readobject.initialization.display.name=Instance variable may not be initialized by 'readObject()'
readobject.initialization.problem.descriptor=Instance variable <code>#ref</code> may not be initialized during 'readObject()' call #loc
readresolve.writereplace.protected.display.name='readResolve()' or 'writeReplace()' not declared 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> not declared 'protected' #loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' field not declared 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=<code>#ref</code> field of a Serializable class is not declared 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' field not declared 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=<code>#ref</code> field of a Serializable class is not declared 'private static final long' #loc
serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc
serializable.class.without.serialversionuid.ignore.option=Ignore classes serializable due to inheritance

#dynamic
non.protected.constructor.in.abstract.class.display.name=Constructor not 'protected' in 'abstract' class
unnecessary.qualifier.for.this.display.name=Unnecessary qualifier for 'this'
multiple.declaration.display.name=Multiple variables in one declaration
thread.priority.display.name=Call to 'Thread.setPriority()'
too.broad.scope.display.name=Scope of variable is too broad
infinite.loop.statement.display.name=Infinite loop statement
asserts.without.messages.display.name=Message missing on JUnit assertion
constant.naming.convention.display.name=Constant naming convention
random.double.for.random.integer.display.name=Using 'Random.nextDouble()' to get random integer
test.method.without.assertion.display.name=JUnit test method without any assertions
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' may be 'StringBuilder' (JDK 5.0 only)
comparison.of.short.and.char.display.name=Comparison of 'short' and 'char' values
unnecessary.fully.qualified.name.display.name=Unnecessary fully qualified name
unnecessary.label.on.break.statement.display.name=Unnecessary label on 'break' statement
exception.name.doesnt.end.with.exception.display.name=Exception class name does not end with 'Exception'
bad.exception.declared.display.name=Prohibited exception declared
deserializable.class.in.secure.context.display.name=Deserializable class in secure context
pointless.boolean.expression.display.name=Pointless boolean expression
class.without.constructor.display.name=Class without constructor
break.statement.display.name='break' statement
unconditional.wait.display.name=Unconditional 'wait()' call
cyclomatic.complexity.display.name=Overly complex method
string.to.string.display.name=Redundant 'String.toString()'
constant.on.l.h.s.of.comparison.display.name=Constant on left side of comparison
final.class.display.name='final' class
labeled.statement.display.name=Labeled statement
notify.called.on.condition.display.name='notify()'  or 'notifyAll()' called on Condition object
loop.statements.that.dont.loop.display.name=Loop statement that does not loop
thread.run.display.name=Call to 'Thread.run()'
non.synchronized.method.overrides.synchronized.method.display.name=Non-synchronized method overrides synchronized method
constant.on.r.h.s.of.comparison.display.name=Constant on right side of comparison
synchronize.on.this.display.name=Synchronization on 'this'
single.character.starts.with.display.name=Single character 'startsWith()' or 'endsWith()'
switch.statement.with.too.many.branches.display.name='switch' statement with too many branches
utility.class.without.private.constructor.display.name=Utility class without private constructor
throw.caught.locally.display.name='throw' caught by containing 'try' statement
exception.from.catch.which.doesnt.wrap.display.name='throw' inside 'catch' block which ignores the caught exception
type.parameter.naming.convention.display.name=Type parameter naming convention
multiply.or.divide.by.power.of.two.display.name=Multiply or divide by power of two
serializable.with.unconstructable.ancestor.display.name=Serializable class with unconstructable ancestor
missorted.modifiers.display.name=Missorted modifers
sleep.while.holding.lock.display.name=Call to 'Thread.sleep()' while synchronized
singleton.display.name=Singleton
unnecessary.final.on.parameter.display.name=Unnecessary 'final' for method parameter
thread.death.rethrown.display.name=java.lang.ThreadDeath not rethrown
if.statement.with.too.many.branches.display.name='if' statement with too many branches
redundant.implements.display.name=Redundant interface declaration
nesting.depth.display.name=Overly nested method
return.this.display.name=Return of 'this'
busy.wait.display.name=Busy wait
utility.class.display.name=Utility class
instantiating.object.to.get.class.object.display.name=Instantiating object to get Class object
abstract.class.extends.concrete.class.display.name=Abstract class extends concrete class
parameter.naming.convention.display.name=Method parameter naming convention
integer.division.in.floating.point.context.display.name=Integer division in floating point context
interface.naming.convention.display.name=Interface naming convention
length.one.strings.in.concatenation.display.name=Single character string concatenation
length.one.string.in.indexof.display.name= Single character string parameter in 'String.indexOf()' call
unnecessary.conditional.expression.display.name=Redundant conditional expression
thread.yield.display.name=Call to 'Thread.yield()'
confusing.floating.point.literal.display.name=Confusing floating-point literal
wait.not.in.loop.display.name='wait()' not in loop
string.concatenation.inside.string.buffer.append.display.name=String concatenation inside 'StringBuffer.append()'
class.initializer.display.name=Non-static initializer
enumerated.class.naming.convention.display.name=Enumerated class naming convention
non.thread.safe.lazy.initialization.display.name=Unsafe lazy initialization of static field
call.to.simple.setter.in.class.display.name=Call to simple setter from within class
comparison.to.na.n.display.name=Comparison to Double.NaN or Float.NaN
instance.method.naming.convention.display.name=Instance method naming convention
unnecessary.semicolon.display.name=Unnecessary semicolon
fallthru.in.switch.statement.display.name=Fallthrough in 'switch' statement
call.to.native.method.while.locked.display.name=Call to a native method while locked
switch.statement.display.name='switch' statement
custom.classloader.display.name=Custom ClassLoader
nested.conditional.expression.display.name=Nested conditional expression
duplicate.condition.display.name=Duplicate condition in 'if' statement
method.with.multiple.loops.display.name=Method with multiple loops
non.comment.source.statements.display.name=Overly long method
local.variable.naming.convention.display.name=Local variable naming convention
negated.if.else.display.name='if' statement with negated condition
class.naming.convention.display.name=Class naming convention
serializable.inner.class.with.non.serializable.outer.class.display.name=Serializable non-static inner class without non-Serializable outer class
pointless.arithmetic.expression.display.name=Pointless arithmetic expression
method.name.same.as.class.name.display.name=Method name same as class name
unnecessary.temporary.on.conversion.to.string.display.name=Unnecessary temporary object in conversion to String
unnecessary.continue.display.name=Unnecessary 'continue' statement
inner.class.on.interface.display.name=Inner class of interface
unused.label.display.name=Unused label
multiple.typed.declaration.display.name=Variables of different types in one declaration
overly.complex.boolean.expression.display.name=Overly complex boolean expression
continue.statement.with.label.display.name='continue' statement with label
class.loader2.instantiation.display.name=ClassLoader instantiation
return.from.finally.block.display.name='return' inside 'finally' block
unnecessary.boxing.display.name=Unnecessary boxing
annotation.naming.convention.display.name=Annotation naming convention
checked.exception.class.display.name=Checked exception class
switch.statement.with.confusing.declaration.display.name=Local variable used and declared in different 'switch' branches
cast.that.loses.precision.display.name=Numeric cast that loses precision
manual.array.copy.display.name=Manual array copy
long.literals.ending.with.lowercase.l.display.name=Long literal ending with 'l' instead of 'L'
overly.complex.arithmetic.expression.display.name=Overly complex arithmetic expression
j.unit.abstract.test.class.naming.convention.display.name=JUnit abstract test class naming convention
unnecessary.parentheses.display.name=Unnecessary parentheses
test.case.in.product.code.display.name=JUnit TestCase in product source
serializable.class.in.secure.context.display.name=Serializable class in secure context
static.variable.naming.convention.display.name=Static variable naming convention
nested.method.call.display.name=Nested method call
throw.from.finally.block.display.name='throw' inside 'finally' block
field.accessed.synchronized.and.unsynchronized.display.name=Field accessed in both synchronized and unsynchronized contexts
catch.generic.class.display.name='catch' generic class
abstract.method.overrides.abstract.method.display.name=Abstract method overrides abstract method
static.non.final.field.display.name='static', non-'final' field
substring.zero.display.name=Redundant '.substring(0)'
class.without.no.arg.constructor.display.name=Class without no-arg constructor
unnecessary.return.display.name=Unnecessary 'return' statement
final.static.method.display.name='static' method declared 'final'
constant.declared.in.abstract.class.display.name=Constant declared in abstract class
too.broad.catch.display.name=Overly broad 'catch' block
floating.point.equality.display.name=Floating point equality comparison
thrown.exceptions.per.method.display.name=Method with too many exceptions declared
public.static.array.field.display.name=Public static array field
await.not.in.loop.display.name='await()' not in loop
method.names.differ.only.by.case.display.name=Method names differing only by case
unsecure.random.number.generation.display.name=Unsecure random number generation
parameters.per.method.display.name=Method with too many parameters
unnecessary.unboxing.display.name=Unnecessary unboxing
extends.thread.display.name=Class explicitly extends java.lang.Thread
misspelled.tear.down.display.name='teardown()' instead of 'tearDown()'
test.case.with.constructor.display.name=JUnit TestCase with non-trivial constructors
parameter.name.differs.from.overridden.parameter.display.name=Parameter name differs from parameter in overridden method
final.private.method.display.name='private' method declared 'final'
enum.switch.statement.which.misses.cases.display.name=Enum 'switch' statement that misses case
enum.switch.statement.which.misses.cases.option=Ignore switch statements with a default branch
setup.calls.super.setup.display.name='setUp()' does not call 'super.setUp()'
unconstructable.test.case.display.name=Unconstructable JUnit TestCase
volatile.long.or.double.field.display.name=Volatile long or double field
string.buffer.must.have.initial.capacity.display.name=StringBuffer or StringBuilder without initial capacity
method.may.be.static.display.name=Method may be 'static'
nested.switch.statement.display.name=Nested 'switch' statement
c.style.array.declaration.display.name=C-style array declaration
final.method.in.final.class.display.name='final' method in 'final' class
extends.annotation.display.name=Class extends annotation interface
naked.notify.display.name='notify()' or 'notifyAll()' without corresponding state change
constant.if.statement.display.name=Constant if statement
switch.statement.density.display.name='switch' statement with too low of a branch density
switch.statement.with.too.few.branches.display.name='switch' statement with too few branches
upper.case.field.name.not.constant.display.name=Non-constant field with upper-case name
unnecessary.label.on.continue.statement.display.name=Unnecessary label on 'continue' statement
j.d.b.c.prepare.statement.with.non.constant.string.display.name=Call to 'Connection.prepareStatement()' or related method with non-constant string
synchronize.on.non.final.field.display.name=Synchronization on a non-final field
noop.method.in.abstract.class.display.name=No-op method in abstract class
non.final.field.of.exception.display.name=Non-final field of exception class
nested.try.statement.display.name=Nested 'try' statement
condition.signal.display.name=Call to 'signal()' instead of 'signalAll()'
j.d.b.c.execute.with.non.constant.string.display.name=Call to 'Statement.execute()' or related method with non-constant string
system.set.security.manager.display.name=Call to 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=Call to <code>System.#ref()</code> may pose security concerns #loc
control.flow.statement.without.braces.display.name=Control flow statement without braces
trivial.if.display.name=Redundant 'if' statement
thread.with.default.run.method.display.name=Instantiating a Thread with default 'run()' method
while.loop.spins.on.field.display.name=While loop spins on field
object.equals.null.display.name=Object.equals(null)
test.method.is.public.void.no.arg.display.name=Test method with incorrect signature
if.statement.with.identical.branches.display.name='if' statement with identical branches
multiple.return.points.per.method.display.name=Method with multiple return points.
break.statement.with.label.display.name='break' statement with label
public.constructor.in.non.public.class.display.name='public' constructor in non-'public' class
questionable.name.display.name=Questionable name
empty.finally.block.display.name=Empty 'finally' block
abstract.method.overrides.concrete.method.display.name=Abstract method overrides concrete method
thread.stop.suspend.resume.display.name=Call to 'Thread.stop()', 'suspend()' or 'resume()'
constant.math.call.display.name=Constant call to java.lang.Math or StrictMath
volatile.array.field.display.name=Volatile array field
literal.as.arg.to.string.equals.display.name=expression.equals("literal") rather than "literal".equals(expression)
unnecessary.final.on.local.variable.display.name=Unnecessary 'final' for local variable
inner.class.may.be.static.display.name=Inner class may be 'static'
static.suite.display.name='suite()' method not declared 'static'
redundant.field.initialization.display.name=Redundant field initialization
string.buffer.to.string.in.concatenation.display.name='StringBuffer.toString()' in concatenation
utility.class.with.public.constructor.display.name=Utility class with public constructor
for.loop.replaceable.by.while.display.name='for' loop may be replaced by 'while' loop
missing.deprecated.annotation.display.name=Missing @Deprecated annotation
cloneable.class.in.secure.context.display.name=Cloneable class in secure context
static.inheritance.display.name=Static inheritance
class.name.prefixed.with.package.name.display.name=Class name prefixed with package name
call.to.simple.getter.in.class.display.name=Call to simple getter from within class
class.name.differs.from.file.name.display.name=Class name differs from file name
protected.member.in.final.class.display.name='protected' member in 'final' class
load.library.with.non.constant.string.display.name=Call to 'System.loadLibrary()' with non-constant string
instanceof.catch.parameter.display.name='instanceof' on 'catch' parameter
implicit.numeric.conversion.display.name=Implicit numeric conversion
unnecessary.interface.modifier.display.name=Unnecessary interface modifier
confusing.main.method.display.name=Confusing 'main()' method
octal.literal.display.name=Octal integer
misordered.assert.equals.parameters.display.name=Misordered 'assertEquals()' parameters
unnecessary.constructor.display.name=Redundant no-arg constructor
method.name.same.as.parent.name.display.name=Method name same as parent class name
java.lang.reflect.display.name=Use of java.lang.reflect
while.can.be.foreach.display.name='while' loop replaceable by 'for each'
big.decimal.equals.display.name='equals()' called on BigDecimal
wait.not.in.synchronized.context.display.name='wait()' while not synced
implicit.call.to.super.display.name=Implicit call to 'super()'
empty.catch.block.display.name=Empty 'catch' block
unqualified.static.usage.display.name=Unqualified static usage
simplifiable.j.unit.assertion.display.name=Simplifiable JUnit assertion
object.notify.display.name=Call to 'notify()' instead of 'notifyAll()'
thread.start.in.construction.display.name=Call to 'Thread.start()' during object construction
non.final.clone.display.name=Non-final 'clone()' in secure context
unnecessary.temporary.on.conversion.from.string.display.name=Unnecessary temporary object in conversion from String
unnecessary.this.display.name=Unnecessary 'this' qualifier
runtime.exec.with.non.constant.string.display.name=Call to 'Runtime.exec()' with non-constant string
system.properties.display.name=Access of system properties
chained.method.call.display.name=Chained method calls
notify.not.in.synchronized.context.display.name='notify()' or 'notifyAll()' while not synced
safe.lock.display.name=Lock acquired but not safely unlocked
system.run.finalizers.on.exit.display.name=Call to 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name='for' loop replaceable by 'for each'
type.parameter.extends.object.display.name=Type parameter explicitly extends 'java.lang.Object'
marker.interface.display.name=Marker interface
limited.scope.inner.class.display.name=Limited-scope inner class
switch.statements.without.default.display.name='switch' statement without 'default' branch
unchecked.exception.class.display.name=Unchecked exception class
for.loop.with.missing.component.display.name='for' loop with missing components
for.loop.with.missing.component.collection.loop.option=Ignore collection iterations
double.checked.locking.display.name=Double-checked locking
string.buffer.replaceable.by.string.display.name=Constant StringBuffer may be String
boolean.method.name.must.start.with.question.display.name=Boolean method name must start with question word
class.name.same.as.ancestor.name.display.name=Class name same as ancestor name
error.rethrown.display.name=java.lang.Error not rethrown
serializable.has.serialization.methods.display.name=Serializable class without 'readObject()' and 'writeObject()'
misspelled.set.up.display.name='setup()' instead of 'setUp()'
setup.is.public.void.no.arg.display.name='setUp()' with incorrect signature
missing.override.annotation.display.name=Missing @Override annotation
wait.while.holding.two.locks.display.name='wait()' while holding two locks
empty.class.display.name=Empty class
trivial.string.concatenation.display.name=Concatenation with empty string
empty.synchronized.statement.display.name=Empty 'synchronized' statement
unnecessary.default.display.name=Unnecessary 'default' for enum switch statement
simplifiable.conditional.expression.display.name=Conditional that can be simplified to \\&\\& or ||
simplifiable.if.statement.display.name=If statement may be replaced by \\&\\& or || expression
unnecessary.super.constructor.display.name=Unnecessary call to 'super()'
unnecessarily.qualified.static.usage.display.name=Unnecessarily qualified static usage
bad.exception.caught.display.name=Prohibited exception caught
custom.security.manager.display.name=Custom SecurityManager
teardown.is.public.void.no.arg.display.name='tearDown()' with incorrect signature
string.concatenation.in.loops.display.name=String concatenation in loop
comparing.references.display.name=== used instead of equals()
boolean.constructor.display.name=Boolean constructor call
continue.statement.display.name='continue' statement
extends.object.display.name=Class explicitly extends java.lang.Object
serializable.inner.class.has.serial.version.u.i.d.field.display.name=Serializable non-static inner class without 'serialVersionUID'
static.method.naming.convention.display.name=Static method naming convention
empty.try.block.display.name=Empty 'try' block
field.has.setter.but.no.getter.display.name=Field has setter but no getter
three.negations.per.method.display.name=Method with more than three negations
conditional.expression.display.name=Conditional expression (?:)
unnecessary.enum.modifier.display.name=Unnecessary enum modifier
string.equals.empty.string.display.name='String.equals("")'
teardown.calls.super.teardown.display.name='tearDown()' does not call 'super.tearDown()'
synchronize.on.lock.display.name=Synchronization on a java.util.concurrent.locks.Lock object
field.may.be.static.display.name=Field may be 'static'
class.may.be.interface.display.name=Class may be interface
abstract.class.without.abstract.methods.display.name=Abstract class without abstract methods
divide.by.zero.display.name=Division by zero
default.not.last.case.in.switch.display.name='default' not last case in 'switch'
nested.synchronized.statement.display.name=Nested 'synchronized' statement
constant.conditional.expression.display.name=Constant conditional expression
unused.catch.parameter.display.name=Unused 'catch' parameter
class.in.top.level.package.display.name=Class without package statement
confusing.else.display.name=Confusing 'else' branch
public.field.accessed.in.synchronized.context.display.name=Non-private field accessed in synchronized context
string.replaceable.by.string.buffer.display.name=Non-constant String should be StringBuffer
j.unit.test.class.naming.convention.display.name=JUnit test class naming convention
method.coupling.display.name=Overly coupled method
collections.must.have.initial.capacity.display.name=Collection without initial capacity
anonymous.inner.class.display.name=Anonymous inner class
negated.conditional.display.name=Conditional expression with negated condition
non.reproducible.math.call.display.name=Non-reproducible call to java.lang.Math
multiple.top.level.classes.in.file.display.name=Multiple top level classes in single file
set.replaceable.by.enum.set.display.name=Set replaceable by EnumSet
non.static.inner.class.in.secure.context.display.name=Non-static inner class in secure context
tail.recursion.display.name=Tail recursion
finally.block.cannot.complete.normally.display.name='finally' block which can not complete normally
arithmetic.on.volatile.field.display.name=Arithmetic operation on volatile field
public.static.collection.field.display.name=Public static collection field
non.exception.name.ends.with.exception.display.name=Non-exception class name ends with 'Exception'
synchronized.method.display.name='synchronized' method
enumerated.constant.naming.convention.display.name=Enumerated constant naming convention
final.method.display.name='final' method
transient.field.in.non.serializable.class.display.name=Transient field in non-serializable class
bad.exception.thrown.display.name=Prohibited exception thrown
conditional.expression.with.identical.branches.display.name=Conditional expression with identical branches
raw.use.of.parameterized.type.display.name=Raw use of parameterized class
standard.variable.names.display.name=Standard variable names
instance.variable.naming.convention.display.name=Instance variable naming convention
dollar.sign.in.name.display.name=Use of '$' in identifier
map.replaceable.by.enum.map.display.name=Map replaceable by EnumMap
extends.concrete.collection.display.name=Class explicitly extends a Collection class
continue.or.break.from.finally.block.display.name='continue' or 'break' inside 'finally' block
abstract.method.with.missing.implementations.display.name=Abstract method with missing implementations
object.allocation.in.loop.display.name=Object allocation in loop
wait.called.on.condition.display.name='wait()' called on Condition object
test.case.with.no.test.methods.display.name=JUnit test case with no tests
abstract.class.never.implemented.display.name=Abstract class which has no concrete subclass
interface.never.implemented.display.name=Interface which has no concrete subclass
constant.declared.in.interface.display.name=Constant declared in interface


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=Exception class name <code>#ref</code> does not end with 'Exception' #loc
non.exception.name.ends.with.exception.problem.descriptor=Non-exception class name <code>#ref</code> ends with 'Exception' #loc
class.name.prefixed.with.package.name.problem.descriptor=Class name <code>#ref</code> begins with its package name #loc
class.name.same.as.ancestor.name.problem.descriptor=Class name <code>#ref</code> is the same as one of its superclass' names #loc
method.name.same.as.class.name.problem.descriptor=Method name <code>#ref</code> is the same as its class name #loc
method.name.same.as.parent.name.problem.descriptor=Method name <code>#ref</code> is the same as its parent class name #loc
boolean.method.name.must.start.with.question.problem.descriptor=Boolean method name <code>#ref</code> does not start with question word #loc
questionable.name.problem.descriptor=Questionable name <code>#ref</code> #loc
confusing.main.method.problem.descriptor=Method named <code>#ref</code> without signature 'public static void main(String[])' #loc
upper.case.field.name.not.constant.problem.descriptor=Non-constant field <code>#ref</code> with constant-style name #loc
dollar.sign.in.name.problem.descriptor=identifer <code>#ref</code> contains '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: integer division in floating-point context #loc
comparison.of.short.and.char.problem.descriptor=Equality comparison <code>#ref</code> of short and char values #loc
big.decimal.equals.problem.descriptor=<code>#ref()</code> between BigDecimal values should probably be 'compareTo()' #loc
divide.by.zero.problem.descriptor=Division by zero #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> may produce non-reproducible results #loc
constant.math.call.problem.descriptor=Constant call to <code>#ref()</code> can be simplified #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: floating point values compared for exact equality #loc
fallthru.in.switch.statement.problem.descriptor=<code>#ref</code> fallthrough in 'switch' statement #loc
switch.statements.without.default.problem.descriptor=<code>#ref</code> statement without 'default' branch #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> branch not last case in 'switch' #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> statement does not loop #loc
conditional.expression.with.identical.branches.problem.descriptor=Conditional expression <code>#ref</code> with identical branches #loc
if.statement.with.identical.branches.problem.descriptor=<code>#ref</code> statement with identical branches #loc
duplicate.condition.problem.descriptor=Duplicate condition <code>#ref</code> #loc
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator.#ref()</code> which can't throw 'NoSuchElementException' #loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> statement cannot complete without throwing an exception #loc
confusing.floating.point.literal.problem.descriptor=Confusing floating point literal <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=Overly complex arithmetic expression #loc
overly.complex.boolean.expression.problem.descriptor=Overly complex boolean expression #loc
labeled.statement.problem.descriptor=Labeled statement <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=<code>#ref</code> statement with label #loc
continue.statement.with.label.problem.descriptor=<code>#ref</code> statement with label #loc
conditional.expression.problem.descriptor=Conditional expression <code>#ref</code> #loc
nested.conditional.expression.problem.descriptor=Nested conditional expression <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor=Long literal <code>#ref</code> ends with lowercase 'l' #loc
nested.switch.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
chained.method.call.problem.descriptor=Chained method call <code>#ref()</code> #loc
nested.method.call.problem.descriptor=Nested method call <code>#ref()</code> #loc
octal.literal.problem.descriptor=Octal integer <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=Implicit call to super() <code>#ref</code> #loc
negated.if.else.problem.descriptor=<code>#ref</code> statement with negated condition #loc
negated.conditional.problem.descriptor=Conditional expression with negated condition #loc
confusing.else.problem.descriptor=<code>#ref</code> branch may be unwrapped, as the if branch never completes #loc
switch.statement.with.confusing.declaration.problem.descriptor=Local variable <code>#ref</code> declared in one switch branch and used in another #loc
raw.use.of.parameterized.type.problem.descriptor=Raw use of parameterized class <code>#ref</code> #loc
final.class.problem.descriptor=Class declared <code>#ref</code> #loc
empty.class.problem.descriptor=Class <code>#ref</code> is empty #loc
anonymous.inner.class.problem.descriptor=Anonymous inner class <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=Limited-scope inner class <code>#ref</code> #loc
final.method.problem.descriptor=Method declared <code>#ref</code> #loc
class.initializer.problem.descriptor=Non-static initializer #loc
class.may.be.interface.problem.descriptor=<code>#ref</code> may be interface #loc
non.protected.constructor.in.abstract.class.problem.descriptor=Constructor <code>#ref</code> is not declared 'protected' in 'abstract' class #loc
class.without.constructor.problem.descriptor=<code>#ref</code> has no constructor #loc
abstract.class.without.abstract.methods.problem.descriptor=Class <code>#ref</code> is declared 'abstract', and has no 'abstract' methods #loc
final.method.in.final.class.problem.descriptor=Method declared <code>#ref</code> in 'final' class #loc
protected.member.in.final.class.problem.descriptor=Class member declared <code>#ref</code> in 'final' class #loc
utility.class.with.public.constructor.problem.descriptor=Class <code>#ref</code> has only static members, and a public constructor #loc
utility.class.without.private.constructor.problem.descriptor=Class <code>#ref</code> has only 'static' members, and lacks a 'private' constructor #loc
abstract.method.overrides.concrete.method.problem.descriptor=Abstract method <code>#ref</code> overrides concrete method #loc
abstract.method.with.missing.implementations.problem.descriptor=Abstract method <code>#ref()</code> is not implemented in every subclass #loc
abstract.method.overrides.abstract.method.problem.descriptor=Abstract method <code>#ref</code> overrides abstract method #loc
abstract.class.extends.concrete.class.problem.descriptor=Class <code>#ref</code> is declared 'abstract', and extends a concrete class #loc
static.non.final.field.problem.descriptor=Static non-final field <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=Constant <code>#ref</code> declared in abstract class #loc
constant.declared.in.interface.problem.descriptor=Constant <code>#ref</code> declared in interface #loc
static.inheritance.problem.descriptor=Interface <code>#ref</code> is implemented only for its static constants #loc
class.in.top.level.package.problem.descriptor=Class <code>#ref</code> lacks a package statement #loc
utility.class.problem.descriptor=Class <code>#ref</code> has only 'static' members, indicating procedural construction #loc
singleton.problem.descriptor=Class <code>#ref</code> is a singleton #loc
final.private.method.problem.descriptor='private' method declared <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=No-op Method <code>#ref</code> should be made abstract #loc
final.static.method.problem.descriptor='static' method declared <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> has no no-arg constructor #loc
multiple.top.level.classes.in.file.problem.descriptor=Multiple top level classes in file
class.name.differs.from.file.name.problem.descriptor=Class name <code>#ref</code> differs from file name #loc
marker.interface.problem.descriptor=Marker interface <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=Field <code>#ref</code> has setter but no getter #loc
abstract.class.never.implemented.problem.descriptor=Abstract class <code>#ref</code> has no concrete subclass #loc
interface.never.implemented.problem.descriptor=Interface <code>#ref</code> has no concrete subclass #loc
missing.deprecated.annotation.problem.descriptor=Missing '@Deprecated' annotation on <code>#ref()</code> #loc
missing.override.annotation.problem.descriptor=Missing '@Override' annotation on <code>#ref()</code> #loc
non.thread.safe.lazy.initialization.problem.descriptor=Lazy initialization of static field <code>#ref</code> is not thread-safe #loc
catch.generic.class.problem.descriptor=catch of generic <code>#ref</code> class should be replaced by more precise exception #loc
empty.catch.block.problem.descriptor=Empty <code>#ref</code> block #loc
unused.catch.parameter.problem.descriptor=Unused catch parameter <code>#ref</code> #loc
empty.finally.block.problem.descriptor=Empty <code>#ref</code> block #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> block can not complete normally #loc
empty.try.block.problem.descriptor=Empty <code>#ref</code> block #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
throw.caught.locally.problem.descriptor=<code>#ref</code> caught by containing 'try' statement #loc
throw.caught.locally.ignore.option=Ignore rethrown exceptions
return.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
bad.exception.declared.problem.descriptor=Prohibited exception <code>#ref</code> declared. #loc
bad.exception.caught.problem.descriptor=Prohibited exception <code>#ref</code> caught. #loc
checked.exception.class.problem.descriptor=Checked exception class <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=Unchecked exception class <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=<code>#ref</code> not rethrown #loc
error.rethrown.problem.descriptor=Error <code>#ref</code> not rethrown #loc
nested.try.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> inside 'catch' block ignores the caught exception #loc
instanceof.catch.parameter.problem.descriptor='instanceof' on 'catch' parameter <code>#ref</code> #loc
non.final.field.of.exception.problem.descriptor=Non-final field <code>#ref</code> of exception class #loc
unnecessary.label.on.break.statement.problem.descriptor=Unnecessary label on <code>#ref</code> statement #loc
unnecessary.label.on.continue.statement.problem.descriptor=Unnecessary label on <code>#ref</code> statement #loc
trivial.if.problem.descriptor=<code>#ref</code> statement can be simplified #loc
constant.if.statement.problem.descriptor=<code>#ref</code> statement can be simplified #loc
unnecessary.parentheses.problem.descriptor=Parentheses around <code>#ref</code> are unnecessary #loc
unnecessary.local.variable.problem.descriptor=Local variable <code>#ref</code> is redundant #loc
unnecessary.this.problem.descriptor=<code>#ref</code> is unnecessary in this context #loc
unnecessary.block.statement.problem.descriptor=Braces around this statement are unnecessary #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> is unnecessary as the last statement in a loop #loc
unnecessary.semicolon.problem.descriptor=Unnecessary semicolon <code>#ref</code> #loc
unnecessary.fully.qualified.name.problem.descriptor=Fully qualified name <code>#ref</code> is unnecessary, and can be replaced with an import #loc
unnecessary.qualifier.for.this.problem.descriptor=Qualifier <code>#ref</code> on 'this' is unnecessary in this context #loc
unused.label.problem.descriptor=Unused label <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=Field initialization to <code>#ref</code> is redundant #loc
redundant.implements.problem.descriptor=Redundant interface declaration <code>#ref</code> #loc
extends.object.problem.descriptor=Class <code>#ref</code> explicitly extends java.lang.Object #loc
type.parameter.extends.object.problem.descriptor=Type parameter <code>#ref</code> explicitly extends 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> is unnecessary #loc
unnecessary.constructor.problem.descriptor=No-arg constructor <code>#ref</code> is unnecessary #loc
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> loop statement may be replace by 'while' loop #loc
unnecessary.default.problem.descriptor=<code>#ref</code> branch is unnecessary #loc
unnecessary.boxing.problem.descriptor=Unnecessary boxing <code>#ref</code> #loc
unnecessary.unboxing.problem.descriptor=Unnecessary unboxing <code>#ref</code> #loc
for.can.be.foreach.problem.descriptor=<code>#ref</code> loop replaceable by 'for each'
while.can.be.foreach.problem.descriptor=<code>#ref</code> loop replaceable by 'for each'
too.broad.scope.problem.descriptor=Scope of variable <code>#ref</code> is too broad #loc
return.this.problem.descriptor=Return of <code>#ref</code> #loc
constant.on.l.h.s.of.comparison.problem.descriptor=<code>#ref</code>: constant on left side of comparison #loc
constant.on.r.h.s.of.comparison.problem.descriptor=<code>#ref</code>: constant on right side of comparison #loc
control.flow.statement.without.braces.problem.descriptor=<code>#ref</code> without braces #loc
missorted.modifiers.problem.descriptor=Missorted modifers <code>#ref</code> #loc
c.style.array.declaration.problem.descriptor=C-style array declaration <code>#ref</code> #loc
multiple.declaration.problem.descriptor=Multiple variables in one declaration #loc
multiple.typed.declaration.problem.descriptor=Variables of different types in one declaration #loc
serializable.inner.class.has.serial.version.u.i.d.field.problem.descriptor=Inner class <code>#ref</code> does not define a 'serialVersionUID' field #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=Inner class <code>#ref</code> is serializable while its outer class is not #loc
double.checked.locking.problem.descriptor=Double-checked locking #loc
busy.wait.problem.descriptor=Call to <code>Thread.#ref()</code> in a loop, probably busy-waiting #loc
sleep.while.holding.lock.problem.descriptor=Call to <code>Thread.#ref()</code> while synchronized #loc
arithmetic.on.volatile.field.problem.descriptor=Arithmetic operation on volatile field <code>#ref</code> #loc
call.to.native.method.while.locked.problem.descriptor=Call to native method <code>#ref()</code> in a synchronized context #loc
object.notify.problem.descriptor=<code>#ref</code> should probably be replaced by notifyAll() #loc
condition.signal.problem.descriptor=<code>#ref</code> should probably be replaced by signalAll() #loc
thread.with.default.run.method.problem.descriptor=Instantiating a <code>#ref</code> with default 'run()' method #loc
extends.thread.problem.descriptor=Class <code>#ref</code> explicitly extends 'java.lang.Thread' #loc
naked.notify.problem.descriptor=Call to <code>#ref()</code> without corresponding state change #loc
unconditional.wait.problem.descriptor=Unconditional call to <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=Call to <code>System.#ref()</code> #loc
thread.priority.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
thread.yield.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> loop spins on field #loc
wait.not.in.loop.problem.descriptor=Call to <code>#ref()</code> is not made in a loop #loc
await.not.in.loop.problem.descriptor=Call to <code>#ref()</code> is not made in a loop #loc
wait.called.on.condition.problem.descriptor=Call to <code>#ref()</code> on Condition object #loc
notify.called.on.condition.problem.descriptor=Call to <code>#ref()</code> on Condition object #loc
wait.not.in.synchronized.context.problem.descriptor=Call to <code>#ref()</code> is made outside of a synchronized context  #loc
wait.while.holding.two.locks.problem.descriptor=Call to <code>#ref()</code> is made while holding two locks #loc
notify.not.in.synchronized.context.problem.descriptor=Call to <code>#ref()</code> is made outside of a synchronized context  #loc
thread.run.problem.descriptor=Calls to <code>#ref()</code> should probably be replace by start() #loc
thread.start.in.construction.problem.descriptor=Call to <code>#ref</code> during object construction #loc
synchronize.on.lock.problem.descriptor=Synchronization on a 'java.util.concurrent.locks.Lock' object is unlikely to be intentional #loc
synchronize.on.non.final.field.problem.descriptor=Synchronization on a non-final field <code>#ref</code> is unlikely to have useful semantics #loc
synchronize.on.this.problem.descriptor=Lock operations on 'this' may have unforseen side-effects #loc
nested.synchronized.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
empty.synchronized.statement.problem.descriptor=Empty <code>#ref</code> statement #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=Non-synchronized method <code>#ref</code> overrides synchronized method #loc
public.field.accessed.in.synchronized.context.problem.descriptor=Non-private field <code>#ref</code> accessed in synchronized context  #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Field <code>#ref</code> is accessed in both synchronized and unsynchronized contexts #loc
extended.for.statement.problem.descriptor=Extended <code>#ref</code> statement #loc
object.allocation.in.loop.problem.descriptor=Object allocation <code>#ref</code> in loop #loc
instantiating.object.to.get.class.object.problem.descriptor=Instantiating object to get Class object #loc
field.may.be.static.problem.descriptor=Field <code>#ref</code> may be 'static' #loc
method.may.be.static.problem.descriptor=Method <code>#ref()</code> may be 'static' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> replaceable by EnumMap #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> replaceable by EnumSet #loc
inner.class.may.be.static.problem.descriptor=Inner class <code>#ref</code> may be 'static' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=<code>#ref</code> without initial capacity #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=StringBuffer <code>#ref</code> may be declared as StringBuilder #loc
string.buffer.replaceable.by.string.problem.descriptor=Constant StringBuffer <code>#ref</code> may be declared as String #loc
string.replaceable.by.string.buffer.problem.descriptor=Non-constant String <code>#ref</code> should probably be declared as StringBuffer #loc
collections.must.have.initial.capacity.problem.descriptor=<code>#ref</code> without initial capacity #loc
string.concatenation.in.loops.problem.descriptor=String concatenation <code>#ref</code> in loop #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=String concatenation as argument to <code>{0}.#ref()</code> #loc
boolean.constructor.problem.descriptor=Boolean constructor call <code>#ref</code> #loc
string.to.string.problem.descriptor=<code>#ref</code> is redundant #loc
substring.zero.problem.descriptor=<code>#ref</code> is redundant #loc
string.buffer.to.string.in.concatenation.problem.descriptor=Calls to <code>StringBuffer.#ref()</code> in concatenation #loc
tail.recursion.problem.descriptor=Tail recursive call <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> can be replaced by 'length()==0' #loc
random.double.for.random.integer.problem.descriptor=Using <code>Random.#ref</code> to create random integer #loc
manual.array.copy.problem.descriptor=Manual array copy #loc
java.lang.reflect.problem.descriptor=Use of type <code>#ref</code> from java.lang.reflect #loc
call.to.simple.getter.in.class.problem.descriptor=Call to simple getter <code>#ref()</code> from within class #loc
call.to.simple.setter.in.class.problem.descriptor=Call to simple setter <code>#ref()</code> from within class #loc
asserts.without.messages.problem.descriptor=JUnit <code>#ref()</code> without message #loc
test.case.with.constructor.problem.descriptor=Initialization logic in constructor <code>#ref()</code> instead of 'setUp()'
test.case.with.constructor.problem.descriptor.initializer=Initialization logic in initializer instead of 'setUp()'
misspelled.set.up.problem.descriptor=<code>#ref()</code> probably be setUp() #loc
misordered.assert.equals.parameters.problem.descriptor=Parameters to <code>#ref()</code> in wrong order #loc
misspelled.tear.down.problem.descriptor=<code>#ref()</code> method should probably be tearDown() #loc
static.suite.problem.descriptor=JUnit <code>#ref()</code> methods not declared 'static' #loc
setup.calls.super.setup.problem.descriptor=<code>#ref()</code> does not call 'super.setUp()'
teardown.calls.super.teardown.problem.descriptor=<code>#ref()</code> does not call 'super.tearDown()'
setup.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature
simplifiable.j.unit.assertion.problem.descriptor=<code>#ref()</code> can be simplified #loc
teardown.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature
test.method.without.assertion.problem.descriptor=JUnit test method <code>#ref()</code> contains no assertions #loc
test.case.with.no.test.methods.problem.descriptor=JUnit test case <code>#ref</code> has no tests
test.case.in.product.code.problem.descriptor=Test case <code>#ref</code> should probably be placed in a test source tree #loc
unconstructable.test.case.problem.descriptor=Test case <code>#ref</code> is unusable by most test runners #loc
deserializable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be deserialized, compromising security #loc
serializable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be serialized, compromising security #loc
cloneable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be cloned, compromising security #loc
non.final.clone.problem.descriptor=Non-final <code>#ref()</code> method, compromising security #loc
non.static.inner.class.in.secure.context.problem.descriptor=Non-static inner class <code>#ref</code>, compromising security #loc
runtime.exec.with.non.constant.string.problem.descriptor=Call to <code>Runtime.#ref()</code> with non-constant argument #loc
load.library.with.non.constant.string.problem.descriptor=Call to <code>System.#ref()</code> with non-constant argument #loc
j.d.b.c.execute.with.non.constant.string.problem.descriptor=Call to <code>Statement.#ref()</code> with non-constant argument #loc
j.d.b.c.prepare.statement.with.non.constant.string.problem.descriptor=Call to <code>Connection.#ref()</code> with non-constant argument #loc
custom.classloader.problem.descriptor=Custom ClassLoader class <code>#ref</code> #loc
custom.security.manager.problem.descriptor=Custom SecurityManager class <code>#ref</code> #loc
system.set.problem.descriptor=Call to <code>System.#ref()</code> may pose security concerns #loc
class.loader.instantiation.problem.descriptor=Instantiation of <code>#ref</code> may pose security concerns #loc
public.static.array.field.problem.descriptor=Public static array field <code>#ref</code>, compromising security #loc
public.static.collection.field.problem.descriptor=Public static collection field <code>#ref</code>, compromising security #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=Abstract class <code>#ref</code> has only one direct inheritor #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=Remove redundant abstract method declaration
class.may.be.interface.convert.quickfix=Convert class to interface
class.without.constructor.create.quickfix=Create empty constructor
class.without.no.arg.constructor.ignore.option=Ignore if class has default constructor
extends.annotation.problem.descriptor=Class ''{0}'' explicitly extends annotation interface <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=Class <code>#ref</code> explicitly extends ''{0}'' #loc
inner.class.on.interface.ignore.option=Ignore inner interfaces of interfaces
inner.class.on.interface.problem.descriptor=Interface ''{0}'' has inner class <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=Add @Deprecated annotation
missing.override.annotation.add.quickfix=Add @Override annotation
non.protected.constructor.in.abstract.class.ignore.option=Ignore for non-public classes
public.constructor.in.non.public.class.problem.descriptor=Constructor is declared <code>#ref</code> in non-'public' class ''{0}'' #loc
static.inheritance.replace.quickfix=Replace inheritance with qualified references
utility.class.with.public.constructor.make.quickfix=Make {0, choice, 1#constructor|2#constructors} private
utility.class.without.private.constructor.create.quickfix=Create empty private constructor
utility.class.without.private.constructor.make.quickfix=Make constructor private
annotation.naming.convention.problem.descriptor.short=Annotation name <code>#ref</code> is too short #loc
annotation.naming.convention.problem.descriptor.long=Annotation name <code>#ref</code> is too long #loc
annotation.naming.convention.problem.descriptor.regex.mismatch=Annotation name <code>#ref</code> doesn''t match regex ''{0}'' #loc
class.name.convention.problem.descriptor.short=Class name <code>#ref</code> is too short #loc
class.name.convention.problem.descriptor.long=Class name <code>#ref</code> is too long #loc
class.name.convention.problem.descriptor.regex.mismatch=Class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
constant.name.convention.problem.descriptor.short=Constant name <code>#ref</code> is too short #loc
constant.name.convention.problem.descriptor.long=Constant name <code>#ref</code> is too long #loc
constant.name.convention.problem.descriptor.regex.mismatch=Constant <code>#ref</code> doesn''t match regex ''{0}'' #loc
convention.pattern.option=Pattern:
convention.min.length.option=Min Length:
convention.max.length.option=Max Length:
enumerated.class.naming.convention.problem.descriptor.short=Enumerated class name <code>#ref</code> is too short #loc
enumerated.class.naming.convention.problem.descriptor.long=Enumerated class name <code>#ref</code> is too long #loc
enumerated.class.naming.convention.problem.descriptor.regex.mismatch=Enumerated class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
enumerated.constant.naming.convention.problem.descriptor.short=Enumerated constant name <code>#ref</code> is too short #loc
enumerated.constant.naming.convention.problem.descriptor.long=Enumerated constant name <code>#ref</code> is too long #loc
enumerated.constant.naming.convention.problem.descriptor.regex.mismatch=Enumerated constant <code>#ref</code> doesn''t match regex ''{0}'' #loc
instance.method.name.convention.problem.descriptor.short=Instance method name <code>#ref</code> is too short #loc
instance.method.name.convention.problem.descriptor.long=Instance method name <code>#ref</code> is too long #loc
instance.method.name.convention.problem.descriptor.regex.mismatch=Instance method name <code>#ref</code> doesn''t match regex ''{0}'' #loc
instance.variable.name.convention.problem.descriptor.short=Instance variable name <code>#ref</code> is too short #loc
instance.variable.name.convention.problem.descriptor.long=Instance variable name <code>#ref</code> is too long #loc
instance.variable.name.convention.problem.descriptor.regex.mismatch=Instance variable <code>#ref</code> doesn''t match regex ''{0}'' #loc
interface.name.convention.problem.descriptor.short=Interface name <code>#ref</code> is too short #loc
interface.name.convention.problem.descriptor.long=Interface name <code>#ref</code> is too long #loc
interface.name.convention.problem.descriptor.regex.mismatch=Interface name <code>#ref</code> doesn''t match regex ''{0}'' #loc
j.unit.abstract.test.class.naming.convention.problem.descriptor.short=Abstract JUnit test class name <code>#ref</code> is too short #loc
j.unit.abstract.test.class.naming.convention.problem.descriptor.long=Abstract JUnit test class name <code>#ref</code> is too long #loc
j.unit.abstract.test.class.naming.convention.problem.descriptor.regex.mismatch=Abstract JUnit test class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
j.unit.test.class.naming.convention.problem.descriptor.short=JUnit test class name <code>#ref</code> is too short #loc
j.unit.test.class.naming.convention.problem.descriptor.long=JUnit test class name <code>#ref</code> is too long #loc
j.unit.test.class.naming.convention.problem.descriptor.regex.mismatch=JUnit test class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
local.variable.naming.convention.problem.descriptor.short=Local variable name <code>#ref</code> is too short #loc
local.variable.naming.convention.problem.descriptor.long=Local variable name <code>#ref</code> is too long #loc
local.variable.naming.convention.problem.descriptor.regex.mismatch=Local variable name <code>#ref</code> doesn''t match regex ''{0}'' #loc
local.variable.naming.convention.ignore.option=Ignore for-loop parameters
local.variable.naming.convention.ignore.catch.option=Ignore catch block parameters
method.names.differ.only.by.case.problem.descriptor=Method names <code>#ref</code> and ''{0}'' differ only by case
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignore if overridden parameter contains only one character
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignore if overridden parameter is from a library
parameter.name.differs.from.overridden.parameter.problem.descriptor=Parameter name <code>#ref</code> is different from parameter ''{0}'' overridden #loc
parameter.naming.convention.problem.descriptor.short=Parameter name <code>#ref</code> is too short #loc
parameter.naming.convention.problem.descriptor.long=Parameter name <code>#ref</code> is too long #loc
parameter.naming.convention.problem.descriptor.regex.mismatch=Parameter name <code>#ref</code> doesn''t match regex ''{0}'' #loc
questionable.name.column.title=Name
standard.variable.names.problem.descriptor=Variable name <code>#ref</code> doesn''t have type ''{0}'' #loc
standard.variable.names.problem.descriptor2=Variable name <code>#ref</code> doesn''t have type ''{0}'' or ''{1}'' #loc
static.method.naming.convention.problem.descriptor.short=Static method name <code>#ref</code> is too short #loc
static.method.naming.convention.problem.descriptor.long=Static method name <code>#ref</code> is too long #loc
static.method.naming.convention.problem.descriptor.regex.mismatch=Static method name <code>#ref</code> doesn''t match regex ''{0}'' #loc
static.variable.naming.convention.problem.descriptor.short=Static variable name <code>#ref</code> is too short #loc
static.variable.naming.convention.problem.descriptor.long=Static variable name <code>#ref</code> is too long #loc
static.variable.naming.convention.problem.descriptor.regex.mismatch=Static variable <code>#ref</code> doesn''t match regex ''{0}'' #loc
type.parameter.naming.convention.problem.descriptor.short=Type parameter name <code>#ref</code> is too short #loc
type.parameter.naming.convention.problem.descriptor.long=Type parameter name <code>#ref</code> is too long #loc
boolean.method.name.must.start.with.question.table.column.name=Boolean method name prefix
conditional.expression.with.identical.branches.collapse.quickfix=Collapse conditional expression
confusing.else.unwrap.quickfix=Unwrap else branch
constant.conditional.expression.problem.descriptor=''{0}'' can be simplified to ''{1}'' #loc
constant.conditional.expression.simplify.quickfix=Simplify
enum.switch.statement.which.misses.cases.problem.descriptor=<code>#ref</code> statement on enumerated type ''{0}'' misses cases #loc
for.loop.replaceable.by.while.ignore.option=Ignore 'infinite' for loops without conditions
for.loop.replaceable.by.while.replace.quickfix=Replace with 'while'
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> statement lacks initializer #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> statement lacks condition #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> statement lacks update #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> statement lacks initializer and condition #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> statement lacks initializer and update #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> statement lacks condition and update #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> statement lacks initializer, condition and update #loc
if.statement.with.identical.branches.collapse.quickfix=Collapse 'if' statement
foreach.replace.quickfix=Replace with 'for each'
unnecessary.boxing.remove.quickfix=Remove boxing
unnecessary.unboxing.remove.quickfix=Remove unboxing
misordered.assert.equals.parameters.flip.quickfix=Flip compared parameters
setup.calls.super.setup.add.quickfix=add call to 'super.setUp()'
simplify.j.unit.assertion.simplify.quickfix=Simplify assertion
teardown.calls.super.teardown.add.quickfix=add call to 'super.tearDown()'
test.method.is.public.void.no.arg.problem.descriptor=Test method <code>#ref()</code> is not declared 'public void'
system.properties.problem.descriptor=Call to <code>Integer.#ref()</code> may pose security concerns #loc
system.properties.problem.descriptor1=Call to <code>Boolean.#ref()</code> may pose security concerns #loc
unsecure.random.number.generation.problem.descriptor1=For security purposes, use 'java.security.SecureRandom' instead of <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=For security purposes, use 'java.security.SecureRandom' instead of <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=For security purposes, use 'java.security.SecureRandom' instead of <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=<code>#ref</code> does not define 'readObject()' or 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=<code>#ref</code> does not define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=<code>#ref</code> does not define 'readObject()' #loc
serializable.has.serialization.methods.ignore.option=Ignore classes serializable due to inheritance
serializable.inner.class.has.serial.version.u.i.d.field.ignore.option=Ignore classes serializable due to inheritance
serializable.inner.class.with.non.serializable.outer.class.ignore.option=Ignore classes serializable due to inheritance
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> has an non-serializable ancestor ''{0}'' without a no-arg constructor #loc
transient.field.in.non.serializable.class.problem.descriptor=Field ''{0}'' is marked <code>#ref</code>, in non-Serializable class #loc
transient.field.in.non.serializable.class.remove.quickfix=Remove 'transient'
condition.signal.replace.quickfix=Replace with signalAll()
object.notify.replace.quickfix=Replace with notifyAll()
safe.lock.problem.descriptor=''{0}'' should be locked in a try block, and unlocked in a finally block #loc
synchronized.method.problem.descriptor=Method ''{0}()'' declared <code>#ref</code> #loc
synchronized.method.include.option=Include native methods
synchronized.method.move.quickfix=Move synchronization into method
thread.run.replace.quickfix=Replace with 'start()'
volatile.field.problem.descriptor=Volatile field <code>#ref</code> of type ''{0}'' #loc
exception.class.column.name=Exception class
bad.exception.thrown.problem.descriptor=Prohibited exception ''{0}'' thrown #loc
empty.catch.block.comments.option=Comments count as content
empty.catch.block.ignore.option=Ignore empty catch blocks in JUnit test cases
too.broad.catch.problem.descriptor=Catch of <code>#ref</code> is too broad, masking exception ''{0}''  #loc
too.broad.catch.problem.descriptor1=Catch of <code>#ref</code> is too broad, masking exceptions ''{0}'' and ''{1}''  #loc
unused.catch.parameter.ignore.catch.option=Ignore catch blocks containing comments
unused.catch.parameter.ignore.empty.option=Ignore empty catch blocks in JUnit test cases
add.serialversionuidfield.quickfix=Add 'serialVersionUID' field
delete.import.quickfix=Delete unnecessary import
encapsulate.variable.quickfix=Encapsulate variable
extract.method.quickfix=Extract method
inline.call.quickfix=Inline call
inline.variable.quickfix=Inline variable
introduce.constant.quickfix=Introduce constant
make.cloneable.quickfix=Make class Cloneable
make.initialization.explicit.quickfix=Make initialization explicit
make.private.quickfix=Make 'private'
make.class.serializable.quickfix=Make class Serializable
move.anonymous.to.inner.quickfix=Convert to named inner class
move.class.quickfix=Move class
normalize.declaration.quickfix=Split into multiple declarations
remove.modifier.quickfix=Remove ''{0}'' modifier
replace.inheritance.with.delegation.quickfix=Replace inheritance with delegation
big.decimal.equals.replace.quickfix=replace with 'compareTo()==0'
cast.that.loses.precision.problem.descriptor=Cast to <code>#ref</code> from ''{0}'' may result in loss of precision #loc
comparison.to.na.n.problem.descriptor1=Comparison to <code>#ref</code> is always false #loc
comparison.to.na.n.problem.descriptor2=Comparison to <code>#ref</code> is always true #loc
comparison.to.na.n.replace.quickfix=replace with call to 'isNaN()'
confusing.floating.point.literal.change.quickfix=Change To canonical form
implicit.numeric.conversion.ignore.option=Ignore widening conversions
implicit.numeric.conversion.problem.descriptor=Implicit numeric conversion of <code>#ref</code> from ''{0}'' to ''{1}'' #loc
implicit.numeric.conversion.convert.quickfix=Convert to ''{0}'' literal
implicit.numeric.conversion.make.explicit.quickfix=Make conversion explicit
long.literals.ending.with.lowercase.l.replace.quickfix=Replace 'l' with 'L'
non.reproducible.math.call.replace.quickfix=Replace with StrictMath call
overly.complex.arithmetic.expression.max.number.option=Maximum number of terms:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> can be replaced with ''{0}'' #loc
method.complexity.limit.option=Method complexity limit:
cyclomatic.complexity.problem.descriptor=<code>#ref</code> is overly complex (cyclomatic complexity = {0}) #loc
method.coupling.limit.option=Method coupling limit:
method.coupling.problem.descriptor=<code>#ref</code> is overly coupled (# referenced classes = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contains {0} loops #loc
return.point.limit.option=Return point limit:
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> has {0} return points #loc
nesting.depth.limit.option=Nesting depth limit:
nesting.depth.problem.descriptor=<code>#ref</code> is overly nested (maximum nesting depth = {0}) #loc
non.comment.source.statements.limit.option=Non-comment source statements limit:
non.comment.source.statements.problem.descriptor=<code>#ref</code> is too long (# Non-comment source statements = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> has too many parameters (num parameters = {0}) #loc
parameter.limit.option=Parameter limit:
three.negations.per.method.ignore.option=Ignore negations in equals() methods
three.negations.per.method.problem.descriptor=<code>#ref</code> contains {0} negations #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> has too many exceptions declared (num exceptions = {0}) #loc
thrown.exceptions.per.method.limit.option=Exceptions thrown limit:
call.to.simple.getter.in.class.display.name.ignore.option=Ignore getter calls on other objects
call.to.simple.getter.in.class.inline.quickfix=Inline call to getter
call.to.simple.setter.in.class.display.name.ignore.option=Ignore setter calls on other objects
call.to.simple.setter.in.class.inline.quickfix=Inline call to setter
make.static.quickfix=Make static
length.one.strings.in.concatenation.problem.descriptor=#ref can be replaced by ''{0}'' #loc
length.one.strings.in.concatenation.replace.quickfix=Replace with character
multiply.or.divide.by.power.of.two.replace.quickfix=Replace with shift
string.can.be.simplified.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
string.replace.quickfix=Replace with ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=Replace with direct class object access
manual.array.copy.replace.quickfix=Replace with 'System.arrayCopy()'
method.may.be.static.only.option=Only check private or final methods
method.may.be.static.empty.option=Ignore empty methods
random.double.for.random.integer.replace.quickfix=replace with 'nextInt()'
string.buffer.replaceable.by.string.builder.replace.quickfix=Replace with StringBuilder
string.buffer.to.string.in.concatenation.remove.quickfix=Remove 'toString()'
string.concatenation.in.loops.only.option=Only warn if concatenated string is assigned
string.concatenation.inside.string.buffer.append.replace.quickfix=Replace with chained append() calls
string.equals.empty.string.replace.quickfix=Replace with 'length()==0'
tail.recursion.replace.quickfix=Replace tail recursion with iteration
if.statement.with.too.many.branches.max.option=Maximum number of branches:
if.statement.with.too.many.branches.problem.descriptor='<code>#ref</code>' has too many branches ({0}) #loc
negated.conditional.ignore.option=Ignore '!= null' comparisons
negated.conditional.invert.quickfix=Invert condition
negated.if.else.ignore.option=Ignore '!= null' comparisons
negated.if.else.invert.quickfix=Invert If Condition
overly.complex.boolean.expression.overly.option=Maximum number of terms:
pointless.boolean.expression.ignore.option=Ignore named constant in determinining pointless expressions
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
simplifiable.if.statement.problem.descriptor=<code>#ref</code> statement can be replaced by ''{0}'' #loc
switch.statement.density.min.option=Minimum density of branches: %
switch.statement.density.problem.descriptor='<code>#ref</code>' has too low of a branch density ({0}%) #loc
switch.statement.with.too.few.branches.min.option=Minimum number of branches:
switch.statement.with.too.few.branches.problem.descriptor='<code>#ref</code>' has too few branches ({0}), and should probably be replaced by an ''if'' statement #loc
switch.statement.without.default.ignore.option=Ignore if all cases of an enumerated type are covered
unnecessary.label.remove.quickfix=Remove label
unnecessary.return.problem.descriptor=<code>#ref</code> is unnecessary as the last statement in a constructor #loc
unnecessary.return.problem.descriptor1=<code>#ref</code> is unnecessary as the last statement in a method returning 'void' #loc
unused.label.remove.quickfix=Remove unused label
unnecessarily.qualified.static.usage.problem.descriptor=Unnecessarily qualified static method call <code>#ref()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Unnecessarily qualified static access <code>#ref</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=Ignore unnecessarily qualified field accesses
unnecessarily.qualified.static.usage.ignore.method.option=Ignore unnecessarily qualified method calls
unnecessary.interface.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for interfaces #loc
unnecessary.interface.modifier.problem.descriptor1=Modifiers <code>#ref</code> are redundant for interface methods #loc
unnecessary.interface.modifier.problem.descriptor2=Modifier <code>#ref</code> is redundant for interface methods #loc
unnecessary.interface.modifier.problem.descriptor3=Modifiers <code>#ref</code> are redundant for interface fields #loc
unnecessary.interface.modifier.problem.descriptor4=Modifier <code>#ref</code> is redundant for interface fields #loc
smth.unnecessary.remove.quickfix=Remove unnecessary ''{0}''
unqualified.static.usage.problem.descriptor=Unqualified static method call <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Unqualified static field access <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=Ignore unqualified field accesses
unqualified.static.usage.ignore.method.option=Ignore unqualified method calls
unqualified.static.usage.qualify.field.quickfix=Qualify static field access
unqualified.static.usage.qualify.method.quickfix=Qualify static method call
too.broad.scope.allow.option=<html>Allow initializer of variables to construct objects. Potentially unsafe: quick fix may modify semantics if the constructor has non-local side-effects.</html>
too.broad.scope.only.blocks.option=Only report variables that can be moved into inner blocks
too.broad.scope.narrow.quickfix=Narrow scope of ''{0}''
too.broad.scope.status.bar.remove.highlighting.message=Press Escape to remove the highlighting
unnecessary.enum.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for enum constructors #loc
unnecessary.enum.modifier.problem.descriptor1=Modifier <code>#ref</code> is redundant for inner enums #loc
literal.as.arg.to.string.equals.problem.descriptor=#ref is argument of ''{0}()'', instead of its target.
literal.as.arg.to.string.equals.flip.quickfix=Flip 'equals()'
unnecessary.final.on.local.variable.problem.descriptor=Unnecessary <code>#ref</code> for variable ''{0}'' #loc
unnecessary.final.on.parameter.problem.descriptor=Unnecessary <code>#ref</code> for parameter ''{0}'' #loc
c.style.array.declaration.replace.quickfix=Replace with Java-style array declaration
chained.method.call.ignore.option=Ignore chained method calls in field initializers
introduce.variable.quickfix=Introduce variable
flip.comparision.quickfix=Flip comparison
control.flow.statement.without.braces.add.quickfix=Add braces
extends.object.remove.quickfix=Remove redundant 'extends Object'
implicit.call.to.super.ignore.option=Ignore for direct subclasses of java.lang.Object
implicit.call.to.super.make.explicit.quickfix=Make construction of super() explicit
missorted.modifiers.require.option=Require annotations to be sorted before keywords
missorted.modifiers.sort.quickfix=Sort modifers
nested.method.call.ignore.option=Ignore nested method calls in field initializers
redundant.field.initialization.remove.quickfix=Remove initializer
redundant.implements.remove.quickfix=Remove redundant interface declaration
unnecessary.constructor.remove.quickfix=Remove redundant constructor
unnecessary.fully.qualified.name.ignore.option=Ignore fully qualified names in javadoc
unnecessary.fully.qualified.name.replace.quickfix=Replace with import
unnecessary.parentheses.remove.quickfix=Remove unnecessary parentheses
unnecessary.qualifier.for.this.remove.quickfix=Remove unnecessary qualifier
unnecessary.semicolon.remove.quickfix=Remove unnecessary semicolon
unnecessary.super.constructor.remove.quickfix=Remove unnecessary super()
unnecessary.this.remove.quickfix=Remove unnecessary 'this.'
overly.strong.type.cast.problem.descriptor=Cast to <code>#ref</code> can be weakened to ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Include constant fields in count
field.count.inspection.static.final.fields.count.as.constant.checkbox=Static final fields count as constant
make.method.final.fix.name=Make method ''{0}()'' final
non.boolean.method.name.must.not.start.with.question.display.name=Non-boolean method name must not start with question word
non.boolean.method.name.must.not.start.with.question.problem.descriptor=Non-boolean method name <code>#ref</code> starts with a question word #loc
boolean.aonstructor.simplify.quickfix=Simplify
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc can be simplified to ''{0}''
# 0 - replacement exception
unnecessary.temporary.on.conversion.from.string.fix.name=Replace with ''{0}''
only.report.qualified.static.usages.option=Only report qualified static usages from a static context
unqualified,static.usage.only.report.static.usages.option=Only report static usages from a non-static context
create.documentation.count.inspections.message={0} Inspections
create.documentation.count.quick.fixes.message={0} Quick Fixes
create.documentation.couldn.t.instantiate.class=Couldn''t instantiate {0}
create.documentation.couldnt.access.class=Couldn''t access {0}
create.documentation.couldnt.cast.class=Couldn''t cast {0}
create.documentation.inspections.enabled.by.default.message=Inspections enabled by default:
create.documentation.couldnt.find.documentation.file.error.message=Couldn''t find documentation file: {0}
create.documentation.unused.documentation.file.error.message=Unused documentation file: {0}
assignment.to.catch.block.parameter.problem.descriptor=Assignment to catch block parameter <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=Assignment to method parameter <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=Value of post-increment expression <code>#ref</code> is used #loc
value.of.post.decrement.problem.descriptor=Value of post-decrement expression <code>#ref</code> is used #loc
value.of.pre.increment.problem.descriptor=Value of pre-increment expression <code>#ref</code> is used #loc
value.of.pre.decrement.problem.descriptor=Value of pre-decrement expression <code>#ref</code> is used #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> could be simplified to ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignore conditional operators
assignment.replaceable.with.operator.replace.quickfix=Replace '=' with ''{0}{1}''
button.add=Add
button.delete=Delete
button.reset=Reset
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignore == between objects of a type with only private constructors
redundant.method.override.display.name=Method is identical to its super method
redundant.method.override.problem.descriptor=Method <code>#ref()</code> is identical to its super method
redundant.method.override.quickfix=Remove redundant method
refused.bequest.problem.descriptor=Method <code>#ref()</code> ignores defined method in superclass #loc
reqused.bequest.ignore.empty.super.methods.option=Ignore empty super methods (degrades performance of this inspection)
ovetly.complex.boolean.expression.ignore.pure.conjunctions.and.disjunctions.option=Ignore pure conjunctions and disjunctions
pointless.indexof.comparison.display.name=Pointless 'indexOf()' comparison
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> is always true
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> is always false
reuse.of.local.variable.problem.descriptor=Reuse of local variable <code>#ref</code> #loc
button.remove=Remove
bad.exception.declared.ignore.exceptions.declared.in.junit.test.cases.option=Ignore exceptions declared in JUnit test cases
single.character.startswith.display.name=Single character 'startsWith()' or 'endsWith()'
single.character.startswith.problem.descriptor=Single character <code>#ref()</code> could be replaced by 'charAt()' expression #loc
indexof.replaceable.by.contains.display.name='indexOf()' expression is replaceable by 'contains()'
indexof.replaceable.by.contains.problem.descriptor=<code>#ref</code> can be replaced by ''{0}'' #loc
replace.indexof.with.contains.quickfix=Replace 'indexOf()' with 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=Multiple methods named <code>#ref</code> with the same number of parameters
overloaded.vararg.method.problem.descriptor=Overloaded varargs method <code>#ref</code>
overloaded.vararg.constructor.problem.descriptor=Overloaded varargs constructor <code>#ref</code>
cached.number.constructor.call.display.name=Number constructor call with primitive argument
cached.number.constructor.call.problem.descriptor=Number constructor call with primitive argument <code>#ref</code> #loc
cached.number.constructor.call.quickfix=Replace with ''{0}.valueOf()'' call
chained.equality.comparisons.problem.descriptor=Chained equality comparison <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=String <code>#ref</code> contains potentially confusing octal escape sequence #loc
field.accessed.synchronized.and.unsynchronized.option=Simple getters and setters are considered field accesses too
method.overrides.package.local.method.display.name=Method overrides package local method of superclass located in other package
method.overrides.package.local.method.problem.descriptor=Method <code>#ref()</code> overrides a package local method of a superclass located in another package #loc
suspicious.to.array.call.display.name=Suspicious 'Collections.toArray()' call
suspicious.to.array.call.problem.descriptor=Array of type ''{0}[]'' expected
suspicious.system.arraycopy.display.name=Suspicious 'System.arraycopy()' call
suspicious.system.arraycopy.problem.descriptor1=parameter 'srcPos' may not be negative
suspicious.system.arraycopy.problem.descriptor2=parameter 'destPos' may not be negative
suspicious.system.arraycopy.problem.descriptor3=parameter 'length' may not be negative
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> is not of an array type
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> is not of an array type
suspicious.system.arraycopy.problem.descriptor6=destination parameter <code>#ref</code> is not of the same type as the source parameter
raw.use.of.parameterized.type.ignore.new.objects.option=Ignore construction of new objects
raw.use.of.parameterized.type.ignore.type.casts.option=Ignore type casts
method.only.used.from.inner.class.display.name=Private method only used from inner class
method.only.used.from.inner.class.problem.descriptor.anonymous.extending=Method <code>#ref()</code>#loc is only used from an anonymous class extending ''{0}''
method.only.used.from.inner.class.problem.descriptor.anonymous.implementing=Method <code>#ref()</code>#loc is only used from an anonymous class implementing ''{0}''
method.only.used.from.inner.class.problem.descriptor=Method <code>#ref()</code>#loc is only used from inner class ''{0}''
method.only.used.from.inner.class.ignore.option=Ignore methods accessed from an anonymous class
format.decode.error.requires.both.0.and.1=requires both {0} and {1}
format.decode.any=any
format.decode.date.time=Date/Time
format.decode.char=char
format.decode.integer.type=integer type
format.decode.floating.point=floating point
single.character.startswith.quickfix=Replace with 'charAt()'
interface.never.implemented.option=Ignore interfaces which only delare constants
size.replaceable.by.isempty.display.name='size() == 0' replaceable by 'isEmpty()'
size.replaceable.by.isempty.problem.descriptor=<code>#ref</code> can be replaced by ''{0}''
size.replaceable.by.isempty.quickfix=Replace with 'isEmpty()'
loop.condition.not.updated.inside.loop.display.name=Loop variable not updated inside loop
loop.condition.not.updated.inside.loop.problem.descriptor='#ref' is not updated inside loop
utility.class.without.private.constructor.option=Ignore classes with only a main method
super.class.logger.option=Ignore classes with an accessible logger declared in a super class
static.method.only.used.in.one.class.display.name=Static method only used from one other class
static.method.only.used.in.one.class.problem.descriptor=Static method <code>#ref</code> is only used from class ''{0}''
static.method.only.used.in.one.class.problem.descriptor.anonymous.implementing=Static method <code>#ref</code> is only used from an anonymous class implementing ''{0}''
static.method.only.used.in.one.class.problem.descriptor.anonymous.extending=Static method <code>#ref</code> is only used from an anonymous class extending ''{0}''
static.method.only.used.in.one.class.quickfix=Move method
unary.plus.display.name=Unary plus
unary.plus.problem.descriptor=Unary <code>#ref</code> operator #loc
await.without.corresponding.signal.display.name='await()' without corresponding 'signal()'
await.without.corresponding.signal.problem.descriptor=Call to <code>#ref</code> without corresponding <code>signal()</code> or <code>signalAll()</code> #loc
signal.without.corresponding.await.display.name='signal()' without corresponding 'await()'
signal.without.corresponding.await.problem.descriptor=Call to <code>#ref</code> without corresponding <code>await()</code> #loc
wait.without.corresponding.notify.display.name='wait()' without corresponding 'notify()'
wait.without.corresponding.notify.problem.descriptor=Call to <code>#ref</code> without corresponding <code>notify()</code> or <code>notifyAll()</code> #loc
notify.without.corresponding.wait.display.name='notify()' without corresponding 'wait()'
notify.without.corresponding.wait.problem.descriptor=Call to <code>#ref</code> without corresponding <code>wait()</code> #loc
integer.multiplication.implicit.cast.to.long.display.name=Integer multiplication or shift implicitly cast to long
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: integer multiplication or shift implicitly cast to long #loc
wait.or.await.without.timeout.display.name='wait()' or 'await()' without timeout
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> without timeout #loc
boolean.field.always.negated.display.name=Boolean field always negated on read
boolean.field.always.negated.problem.descriptor=Boolean field {0} is always negated
test.global.display.name=Test Global Inspection
method.return.always.ignored.display.name=Return value of method is always ignored
method.return.always.ignored.problem.descriptor=Return value of method {0} is always ignored
method.return.always.constant.display.name=Method returns per-class constant
method.return.always.constant.problem.descriptor=Method {0} returns a per-class constant
class.with.too.many.dependencies.display.name=Class with too many dependencies
class.with.too.many.dependencies.problem.descriptor=Class {0} has too many dependencies ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=Class with too many transitive dependencies
class.with.too.many.transitive.dependencies.problem.descriptor=Class {0} has too many transitive dependencies ({1} > {2})
class.with.too.many.dependents.display.name=Class with too many dependents
class.with.too.many.dependents.problem.descriptor=Class {0} has too many dependents ({1} > {2})
class.with.too.many.transitive.dependents.display.name=Class with too many transitive dependents
class.with.too.many.transitive.dependents.problem.descriptor=Class {0} has too many transitive dependencies ({1} > {2})
class.with.too.many.dependencies.max.option=Maximum number of dependencies
class.with.too.many.dependents.max.option=Maximum number of dependents
class.with.too.many.transitive.dependencies.max.option=Maximum number of transitive dependencies
class.with.too.many.transitive.dependents.max.option=Maximum number of transitive dependents
cyclic.class.dependency.display.name=Cyclic class dependency
cyclic.class.dependency.problem.descriptor=Class {0} is cyclically dependent on {1} other classes
cyclic.package.dependency.display.name=Cyclic package dependency
cyclic.package.dependency.problem.descriptor=Package {0} is cyclically dependent on {1} other packages
class.unconnected.to.package.display.name=Class independent of it's package
class.unconnected.to.package.problem.descriptor=Class {0} has no dependencies or dependents in it's package
package.with.too.many.classes.display.name=Package with too many classes
package.with.too.many.classes.problem.descriptor=Package {0} contains too many classes ({1} > {2})
package.with.too.many.classes.max.option=Maximum number of classes
package.with.too.few.classes.display.name=Package with too few classes
package.with.too.few.classes.problem.descriptor=Package {0} contains too few classes ({1} < {2})
package.with.too.few.classes.max.option=Minimum number of classes
module.with.too.many.classes.display.name=Module with too many classes
module.with.too.many.classes.problem.descriptor=Module {0} contains too many classes ({1} > {2})
module.with.too.many.classes.max.option=Maximum number of classes
module.with.too.few.classes.display.name=Module with too few classes
module.with.too.few.classes.problem.descriptor=Module {0} contains too few classes ({1} < {2})
module.with.too.few.classes.max.option=Minimum number of classes
package.in.multiple.modules.display.name=Package with classes in multiple modules
package.in.multiple.modules.problem.descriptor=Package {0} has classes in multiple modules
disjoint.package.display.name=Package with disjoint dependency graph
disjoint.package.problem.descriptor=Package {0} can be decomposed into {1} independent packages
package.naming.convention.problem.descriptor.short=Package name <code>{0}</code> is too short
package.naming.convention.problem.descriptor.long=Package name <code>{0}</code> is too long
package.naming.convention.problem.descriptor.regex.mismatch=Package name <code>{0}</code> doesn''t match regex ''{1}''
cyclic.class.initialization.display.name=Cyclic class initialization dependency
cyclic.class.initialization.problem.descriptor=Initialization of class {0} is cyclically dependent on {1} other classes
before.or.after.is.public.void.no.arg.display.name=Malformed @Before or @After method
before.or.after.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature for a @Before or @After method
before.class.or.after.class.is.public.static.void.no.arg.display.name=Malformed @BeforeClass or @AfterClass method
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature for a @BeforeClass or @AfterClass method
string.constructor.display.name=Redundant String constructor call
string.constructor.problem.descriptor=<code>#ref</code> is redundant #loc
string.constructor.replace.arg.quickfix=Replace with arg
string.constructor.replace.empty.quickfix=Replace with empty string
string.constructor.substring.parameter.option=Ignore string constructor calls with '.substring()' call parameter
design.for.extension.display.name=Class with too many transitive dependents
design.for.extension.problem.descriptor=Method <code>#ref</code> may be overriden and its functionality ignored #loc
bad.oddness.display.name=Suspicious test for oddness
bad.oddness.problem.descriptor=Test for oddness <code>#ref</code> will fail on negative values #loc
comparator.not.serializable.display.name=Comparator class not declared Serializable
comparator.not.serializable.problem.descriptor=Comparator class <code>#ref</code> is not declared as Serializable #loc
non.serializable.field.in.serializable.class.display.name=Non-serializable field in a Serializable class
non.serializable.field.in.serializable.class.problem.descriptor=Non-serializable field '#ref' in a Serializable class #loc
non.serializable.object.passed.to.object.stream.display.name=Non-serializable object passed to ObjectOutputStream
non.serializable.object.passed.to.object.stream.problem.descriptor=Non-serializable object passed to ObjectOutputStream #loc
non.serializable.object.bound.to.http.session.display.name=Non-serializable object bound to HttpSession
non.serializable.object.bound.to.http.session.problem.descriptor=Non-serializable object bound to HttpSession #loc
reflection.for.unavailable.annotation.display.name=Reflective access to a source-only annotation
reflection.for.unavailable.annotation.problem.descriptor=Annotation '#ref' is not retained for reflective access #loc

