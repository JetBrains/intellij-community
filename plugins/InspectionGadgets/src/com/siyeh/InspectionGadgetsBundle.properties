plugin.InspectionGadgets.description=Adds over 500 new automated code inspections for IntelliJ IDEA.
error.message.regexp.malformed.naming.pattern=Malformed Naming Pattern
error.message.regexp.malformed.pattern=Malformed Regular Expression Pattern
cast.to.concrete.class.display.name=Cast to a concrete class
cast.to.concrete.class.problem.descriptor=Cast to concrete class <code>{0}</code> #loc
class.references.subclass.display.name=Class references one of its subclasses
class.references.subclass.problem.descriptor=Class ''{0}'' references subclass <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=Anonymous class references subclass <code>#ref</code> #loc
collection.declared.by.class.display.name=Collection declared by class, not interface
#{0} - name of the interface
collection.declared.by.class.problem.descriptor=Declaration of <code>#ref</code> should probably be weakened to ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=Ignore local variables
collection.declared.by.class.ignore.private.members.option=Ignore private fields and methods
feature.envy.display.name=Feature envy
feature.envy.problem.descriptor=Class ''{0}'' accessed repeatedly in method <code>#ref()</code> #loc
instance.variable.of.concrete.class.display.name=Type of instance field is concrete class
instance.variable.of.concrete.class.problem.descriptor=Type of field ''{0}'' is concrete class <code>#ref</code> #loc
chain.of.instanceof.checks.display.name=Chain of 'instanceof' checks
chain.of.instanceof.checks.problem.descriptor=Chain of 'instanceof' checks indicates abstraction failure #loc
instanceof.concrete.class.display.name='instanceof' a concrete class
instanceof.concrete.class.problem.descriptor='instanceof' concrete class <code>#ref</code> #loc
instanceof.check.for.this.display.name='instanceof' check for 'this'
instanceof.check.for.this.problem.descriptor='instanceof' check for <code>#ref</code> #loc
local.variable.of.concrete.class.display.name=Local variable of concrete class
local.variable.of.concrete.class.problem.descriptor=Local variable ''{0}'' of concrete class <code>#ref</code> #loc
magic.number.display.name="Magic number"
magic.number.problem.descriptor=Magic number <code>#ref</code> #loc
magic.number.ignore.option=Ignore constants in 'hashCode()' methods
method.return.concrete.class.display.name=Method return of concrete class
method.return.concrete.class.problem.descriptor=Method returns a concrete class <code>#ref</code> #loc
overly.strong.type.cast.display.name=Overly-strong type cast
overly.strong.type.cast.weaken.quickfix=Weaken overly-strong cast
concrete.class.method.parameter.display.name=Method parameter of concrete class
concrete.class.method.parameter.problem.descriptor=Parameter ''{0}'' of concrete class <code>#ref</code> #loc
public.method.not.in.interface.display.name='public' method not exposed in interface
public.method.not.in.interface.problem.descriptor='public' method <code>#ref()</code> is not exposed via an interface #loc
public.method.not.in.interface.option=<html>Ignore if the containing class does not implement a non-library interface</html>
static.variable.of.concrete.class.display.name=Static field of concrete class
static.variable.of.concrete.class.problem.descriptor=Static field ''{0}'' of concrete class <code>#ref</code> #loc
incompatible.mask.operation.display.name=Incompatible bitwise mask operation
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> is always false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> is always true #loc
pointless.bitwise.expression.display.name=Pointless bitwise expression
pointless.bitwise.expression.ignore.option=Ignore named constants in determining pointless expressions
pointless.bitwise.expression.simplify.quickfix=Simplify
shift.operation.by.inappropriate.constant.display.name=Shift operation by inappropriate constant
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Shift operation <code>#ref</code> by overly large constant value #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Shift operation <code>#ref</code> by negative constant value #loc
archaic.system.property.accessors.display.name=Use of archaic system property accessors
archaic.system.property.accessors.problem.descriptor.Integer=Call to <code>Integer.#ref()</code> accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.problem.descriptor.Long=Call to <code>Long.#ref()</code> accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.problem.descriptor.Boolean=Call to <code>Boolean.#ref()</code> accesses system properties, perhaps confusingly #loc
archaic.system.property.accessors.replace.parse.quickfix=Replace with parse method
archaic.system.property.accessors.replace.standard.quickfix=Replace with standard property access
equals.called.on.array.display.name='equals()' called on array
equals.called.on.array.problem.descriptor=<code>#ref()</code> between arrays should probably be 'Arrays.equals()' #loc
replace.with.arrays.equals=Replace with 'Arrays.equals()'
replace.with.arrays.deep.equals=Replace with 'Arrays.deepEquals()'
assignment.to.null.display.name=Assignment to 'null'
assignment.to.null.problem.descriptor=Assignment of variable <code>#ref</code> to 'null' #loc
assignment.to.null.option=Ignore assignments to fields
assignment.to.static.field.from.instance.method.display.name=Assignment to static field from instance method
assignment.to.static.field.from.instance.method.problem.descriptor=Assignment to static field <code>#ref</code> from an instance method #loc
assignment.used.as.condition.display.name=Assignment used as condition
assignment.used.as.condition.problem.descriptor=<code>#ref</code> used as condition #loc
assignment.used.as.condition.replace.quickfix=Replace '=' with '=='
cast.conflicts.with.instanceof.display.name=Cast conflicts with 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Cast <code>#ref</code> conflicts with surrounding 'instanceof' check #loc
casting.to.incompatible.interface.display.name=Casting to incompatible interface
casting.to.incompatible.interface.problem.descriptor=Cast to incompatible interface <code>#ref</code> #loc
collection.added.to.self.display.name=Collection added to self
collection.added.to.self.problem.descriptor=Collection <code>#ref</code> is added to self #loc
non.final.field.compareto.display.name=Non-final field referenced in 'compareTo()'
non.final.field.compareto.problem.descriptor=Non-final field <code>#ref</code> accessed in 'compareTo()' #loc
covariant.compareto.display.name=Covariant 'compareTo()'
covariant.compareto.problem.descriptor=<code>#ref()</code> should take 'Object' as its argument #loc
covariant.equals.display.name=Covariant 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> should take 'Object' as its argument #loc
empty.class.initializer.display.name=Empty class initializer
empty.class.initializer.problem.descriptor=Empty class initializer #loc
empty.class.initializer.delete.quickfix=Delete empty class initializer
statement.with.empty.body.display.name=Statement with empty body
statement.with.empty.body.problem.descriptor=<code>#ref</code> statement has empty body #loc
statement.with.empty.body.include.option=Include statement bodies that are empty code blocks
equals.between.inconvertible.types.display.name='equals()' between objects of inconvertible types
equals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
non.final.field.in.equals.display.name=Non-final field referenced in 'equals()'
non.final.field.in.equals.problem.descriptor=Non-final field <code>#ref</code> accessed in 'equals()'  #loc
equals.doesnt.check.class.parameter.display.name='equals()' method which does not check class of parameter
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> should check the class of its parameter #loc
for.loop.not.use.loop.variable.display.name='for' loop where update or condition does not use loop variable
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>#ref</code> statement has condition which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>#ref</code> statement has update which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>#ref</code> statement has condition and update which do not use the for loop variable #loc
non.final.field.in.hashcode.display.name=Non-final field referenced in 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Non-final field <code>#ref</code> accessed in 'hashCode()' #loc
result.of.method.call.ignored.display.name=Result of method call ignored
result.of.method.call.ignored.problem.descriptor=Result of <code>{0}.#ref()</code> is ignored #loc
result.of.method.call.ignored.class.column.title=Class name
result.of.method.call.ignored.method.column.title=Method name
result.of.method.call.ignored.non.library.option=Report all ignored non-library calls
infinite.recursion.display.name=Infinite recursion
infinite.recursion.problem.descriptor=Method <code>#ref()</code> recurses infinitely, and can only end by throwing an exception #loc
instanceof.with.incompatible.interface.display.name='instanceof' with incompatible interface
instanceof.with.incompatible.interface.problem.descriptor='instanceof' incompatible interface <code>#ref</code> #loc
instantiation.utility.class.display.name=Instantiation of utility class
instantiation.utility.class.problem.descriptor=Instantiation of utility class <code>#ref</code> #loc
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()' which calls 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.#ref()</code> contains call to 'next()' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name='Iterator.next()' which can't throw 'NoSuchElementException'
malformed.format.string.display.name=Malformed format string
malformed.format.string.problem.descriptor.malformed=Format string <code>#ref</code> is malformed #loc
malformed.format.string.problem.descriptor.too.many.arguments=Too many arguments for format string <code>#ref</code> #loc
malformed.format.string.problem.descriptor.too.few.arguments=Too few arguments for format string <code>#ref</code> #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=Format string <code>#ref</code> does not match the type of its arguments #loc
malformed.regular.expression.display.name=Malformed regular expression
malformed.regular.expression.problem.descriptor1=Regular expression <code>#ref</code> is malformed #loc
malformed.regular.expression.problem.descriptor2=Regular expression <code>#ref</code> is malformed: {0} #loc
malformed.xpath.expression.display.name=Malformed XPath expression
malformed.xpath.expression.problem.description=XPath expression <code>#ref</code> is malformed #loc
mismatched.read.write.array.display.name=Mismatched read and write of array
mismatched.read.write.array.problem.descriptor.write.not.read=Contents of array <code>#ref</code> are written to, but never read #loc
mismatched.read.write.array.problem.descriptor.read.not.write=Contents of array <code>#ref</code> are read, but never written to #loc
mismatched.update.collection.display.name=Mismatched query and update of collection
mismatched.update.collection.problem.descriptor.updated.not.queried=Contents of collection <code>#ref</code> are updated, but never queried #loc
mismatched.update.collection.problem.description.queried.not.updated=Contents of collection <code>#ref</code> are queried, but never updated #loc
misspelled.compareto.display.name='compareto()' instead of 'compareTo()'
misspelled.compareto.problem.descriptor=<code>#ref()</code> method should probably be 'compareTo()' #loc
rename.quickfix=Rename
renameto.quickfix=Rename to ''{0}''
misspelled.equals.display.name='equal()' instead of 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> method should probably be 'equals()' #loc
misspelled.hashcode.display.name='hashcode()' instead of 'hashCode()'
misspelled.hashcode.problem.descriptor=<code>#ref()</code> should probably be 'hashCode()' #loc
misspelled.tostring.display.name='tostring()' instead of 'toString()'
misspelled.tostring.problem.descriptor=<code>#ref()</code> method should probably be 'toString()' #loc
non.short.circuit.boolean.expression.display.name=Non-short-circuit boolean expression
non.short.circuit.boolean.expression.problem.descriptor=Non-short-circuit boolean expression <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Replace with short circuit expression
null.argument.to.var.arg.method.display.name=Confusing 'null' argument to var-arg method
null.argument.to.var.arg.method.problem.descriptor=Confusing <code>#ref</code> argument to var-arg method #loc
primitive.array.argument.to.var.arg.method.display.name=Confusing primitive array argument to var-arg method
primitive.array.argument.to.var.arg.method.problem.descriptor=Confusing primitive array argument to var-arg method #loc
object.comparison.display.name=Object comparison using '==', instead of 'equals()'
object.comparison.enumerated.ignore.option=Ignore '==' between enumerated types
object.comparison.klass.ignore.option=Ignore '==' on 'java.lang.Class' objects
object.comparison.problem.description=Object values are compared using <code>#ref</code>, not 'equals()' #loc
object.comparison.replace.quickfix=Replace with 'equals()'
object.equals.null.problem.descriptor=<code>.equals(#ref)</code> is probably not what was intended #loc
default.tostring.call.display.name=Call to default 'toString()'
default.tostring.call.problem.descriptor=Call to default 'toString()' on <code>#ref</code> #loc
octal.and.decimal.integers.in.same.array.display.name=Octal and decimal integers in same array
octal.and.decimal.integers.in.same.array.problem.descriptor=Octal and decimal integers in the same array initializer #loc
result.of.object.allocation.ignored.display.name=Result of object allocation ignored
result.of.object.allocation.ignored.problem.descriptor=Result of <code>new #ref()</code> is ignored. #loc
use.0index.in.jdbc.resultset.display.name=Use of index 0 in JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Use of index '0' in JDBC ResultSet #loc
return.of.null.display.name=Return of 'null'
return.of.null.problem.descriptor=Return of <code>#ref</code> #loc
return.of.null.arrays.option=Report methods that return arrays
return.of.null.quickfix=Annotate method as @Nullable
return.of.null.objects.option=Report methods that return objects
return.of.null.collections.option=Report methods that return collection objects
return.of.null.ignore.private.option=Ignore private methods
static.method.via.subclass.display.name=Static method referenced via subclass
static.method.via.subclass.problem.descriptor=Static method <code>#ref()</code> declared on class ''{0}'' but referenced via class ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Rationalize static method call
static.field.via.subclass.display.name=Static field referenced via subclass
static.field.via.subclass.problem.descriptor=Static field <code>#ref</code> declared on class ''{0}'' but referenced via class ''{1}'' #loc
static.field.via.subclass.rationalize.quickfix=Rationalize static field access
string.comparison.display.name=String comparison using '==', instead of 'equals()'
number.comparison.display.name=Number comparison using '==', instead of 'equals()'
string.comparison.problem.descriptor=String values are compared using <code>#ref</code>, not '.equals()' #loc
number.comparison.problem.descriptor=Number objects are compared using <code>#ref</code>, not '.equals()' #loc
subtraction.in.compareto.display.name=Subtraction in 'compareTo()'
subtraction.in.compareto.problem.descriptor=Subtraction <code>#ref</code> in 'compareTo()' may result in overflow errors #loc
text.label.in.switch.statement.display.name=Text label in 'switch' statement
text.label.in.switch.statement.problem.descriptor=Text label <code>#ref:</code> in 'switch' statement #loc
properties.object.as.hashtable.display.name=Use of Properties object as a Hashtable
properties.object.as.hashtable.problem.descriptor=Call to <code>Hashtable.#ref()</code> on properties object #loc
assignment.replaceable.with.operator.assignment.display.name=Assignment replaceable with operator assignment
unnecessary.code.block.display.name=Unnecessary code block
unnecessary.code.block.unwrap.quickfix=Unwrap block
redundant.local.variable.display.name=Redundant local variable
redundant.local.variable.ignore.option=Ignore immediately returned or thrown variables
redundant.local.variable.annotation.option=Ignore variables which have an annotation (JDK 5.0 only)
static.collection.display.name=Static collection
static.collection.problem.descriptor=Static collection <code>#ref</code> #loc
static.collection.ignore.option=Ignore weak static collections or maps
#field of type java.lang.StringBuffer
stringbuffer.field.display.name=StringBuffer field
#{0} - concrete field type
stringbuffer.field.problem.descriptor=''{0}'' field <code>#ref</code> #loc
gc.call.display.name=Calls to 'System.gc()' or 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> should not be called in production code #loc
array.allocation.zero.length.display.name=Zero-length array allocation
array.allocation.zero.length.problem.descriptor=Allocation of zero length array #loc
multiple.loggers.display.name=Class with multiple loggers
logger.name.option=Logger &class name:
multiple.loggers.problem.descriptor=Class <code>#ref</code> declares multiple loggers #loc
no.logger.display.name=Class without logger
no.logger.problem.descriptor=Class <code>#ref</code> does not declare a logger #loc
non.constant.logger.display.name=Non-constant logger
non.constant.logger.problem.descriptor=Non-constant logger field <code>#ref</code> #loc
public.method.without.logging.display.name='public' method without logging
public.method.without.logging.problem.descriptor='public' method <code>#ref</code> has no logging statement #loc
action.reset.telemetry.description=Reset telemetry data

telemetry.table.column.inspection.name=Inspection
telemetry.table.column.total.time=Total Run Time (ms)
telemetry.table.column.average.time=Average Run Time (ms)
telemetry.table.column.run.count=Run Count
telemetry.toolwindow.title=IG Telemetry
action.telemetry.refresh.description=Refresh telemetry display
finalize.doesnt.call.super.display.name='finalize()' does not call 'super.finalize()'
finalize.doesnt.call.super.ignore.option=Ignore for direct subclasses of 'java.lang.Object'
ignore.trivial.finalizers.option=Ignore for trivial 'finalize()' implementations
finalize.doesnt.call.super.problem.descriptor=<code>#ref()</code> #loc does not call 'super.finalize()'
finalize.declaration.display.name='finalize()' declaration
finalize.declaration.problem.descriptor=<code>#ref()</code> declared #loc
finalize.not.declared.protected.display.name='finalize()' not declared 'protected'
finalize.not.declared.protected.problem.descriptor=<code>#ref()</code> not declared 'protected' #loc
make.protected.quickfix=Make 'protected'
finalize.called.explicitly.display.name='finalize()' called explicitly
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> called explicitly #loc
java.lang.import.display.name='java.lang' import
java.lang.import.problem.descriptor=Unnecessary import from package 'java.lang' #loc
import.display.name='*' import
import.problem.descriptor=Package import <code>#ref</code> #loc
redundant.import.display.name=Redundant import
redundant.import.problem.descriptor=Redundant import <code>#ref</code> #loc
import.from.same.package.display.name=Import from same package
import.from.same.package.problem.descriptor=Unnecessary import from same package <code>#ref</code> #loc
single.class.import.display.name=Single class import
single.class.import.problem.descriptor=Single class import <code>#ref</code> #loc
static.import.display.name=Static import
static.import.problem.descriptor=Static import <code>#ref</code>  #loc
static.import.replace.quickfix=Replace with non-static import
unused.import.display.name=Unused import
unused.import.problem.descriptor=Unused import <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' instantiates objects with constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' creates new <code>#ref</code> instances #loc
clone.doesnt.call.super.clone.display.name='clone()' does not call 'super.clone()'
clone.doesnt.call.super.clone.problem.descriptor=<code>#ref()</code> does not call 'super.clone()' #loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' does not declare 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc does not declare 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Declare 'CloneNotSupportedException'
clone.method.in.non.cloneable.class.display.name='clone()' method in non-Cloneable class
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> defined in non-Cloneable class ''{0}'' #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> defined in non-Cloneable interface ''{0}'' #loc
cloneable.class.without.clone.display.name=Cloneable class without 'clone()'
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> does not define 'clone()' #loc
cloneable.class.without.clone.ignore.option=Ignore classes cloneable due to inheritance
class.without.tostring.display.name=Class without 'toString()'
class.without.tostring.problem.descriptor=Class <code>#ref</code> should probably implement 'toString()', for debugging purposes #loc
use.obsolete.collection.type.display.name=Use of obsolete collection type
use.obsolete.collection.type.problem.descriptor=Obsolete collection type <code>#ref</code> used #loc
use.obsolete.collection.type.ignore.library.arguments.option=Ignore obsolete collection types where they are required
inspection.suppression.annotation.display.name=Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor=Inspection suppression annotation <code>#ref</code> #loc
use.system.out.err.display.name=Use of System.out or System.err
use.system.out.err.problem.descriptor=Uses of 'System.out' and 'System.err' should probably be replaced with more robust logging #loc
dumpstack.call.display.name=Call to 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Call to <code>Thread.#ref()</code> should probably be replaced with more robust logging #loc
printstacktrace.call.display.name=Call to 'printStackTrace()'
printstacktrace.call.problem.descriptor=Call to <code>#ref()</code> should probably be replaced with more robust logging #loc
todo.comment.display.name=TODO comment
todo.comment.problem.descriptor=TODO comment <code>#ref</code> #loc
abstract.method.call.in.constructor.display.name=Abstract method call in constructor
abstract.method.call.in.constructor.problem.descriptor=Call to abstract method <code>#ref()</code> during object construction #loc
instance.variable.may.not.be.initialized.display.name=Instance field may not be initialized
instance.variable.may.not.be.initialized.problem.descriptor=Instance field <code>#ref</code> may not be initialized during object construction #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=Instance field <code>#ref</code> may not be initialized during object construction or 'setUp()' call #loc
primitive.fields.ignore.option=Ignore primitive fields
instance.variable.used.before.initialized.display.name=Instance field used before initialization
instance.variable.used.before.initialized.problem.descriptor=Instance field <code>#ref</code> used before initialized #loc
non.final.static.variable.initialization.display.name=Non-final static field is used during class initialization
non.final.static.variable.initialization.problem.descriptor=Non-final static field <code>#ref</code> used during class initialization #loc
overridable.method.call.in.constructor.display.name=Overridable method call during object construction
overridable.method.call.in.constructor.problem.descriptor=Call to overridable method during object construction #loc
overridden.method.call.in.constructor.display.name=Overridden method call during object construction
overridden.method.call.in.constructor.problem.descriptor=Call to overridden method <code>#ref()</code> during object construction #loc
static.variable.may.not.be.initialized.display.name=Static field may not be initialized
static.variable.may.not.be.initialized.problem.descriptor=Static field <code>#ref</code> may not be initialized during class initialization #loc
static.variable.used.before.initialization.display.name=Static field used before initialization
static.variable.used.before.initialization.problem.descriptor=Static field <code>#ref</code> used before initialization #loc
this.reference.escaped.in.construction.display.name='this' reference escaped in object construction
this.reference.escaped.in.construction.problem.descriptor=Escape of <code>#ref</code> during object construction #loc
assignment.to.catch.block.parameter.display.name=Assignment to catch block parameter
extract.parameter.as.local.variable.quickfix=Extract parameter as local variable
assignment.to.for.loop.parameter.display.name=Assignment to 'for' loop parameter
assignment.to.for.loop.parameter.check.foreach.option=Check foreach parameters
assignment.to.for.loop.parameter.problem.descriptor=Assignment to for-loop parameter <code>#ref</code> #loc
assignment.to.method.parameter.display.name=Assignment to method parameter
chained.equality.comparisons.display.name=Chained equality comparisons
confusing.octal.escape.sequence.display.name=Confusing octal escape sequence
increment.decrement.display.name=Value of ++ or -- used
nested.assignment.display.name=Nested assignment
nested.assignment.problem.descriptor=Nested assignment <code>#ref</code> #loc
overloaded.methods.with.same.number.parameters.display.name=Overloaded methods with same number of parameters
overloaded.vararg.method.display.name=Overloaded variable argument method
refused.bequest.display.name=Refused bequest
reuse.of.local.variable.display.name=Reuse of local variable
reuse.of.local.variable.split.quickfix=Split local variable
character.comparison.display.name=Character comparison
character.comparison.problem.descriptor=Character comparison <code>#ref</code> in an internationalized context #loc
assignment.collection.array.field.from.parameter.display.name=Assignment to Collection or array field from parameter
assignment.collection.array.field.from.parameter.problem.descriptor.array=Assignment to array field <code>#ref</code> from parameter ''{0}'' #loc
assignment.collection.array.field.from.parameter.problem.descriptor.collection=Assignment to Collection field <code>#ref</code> from parameter ''{0}'' #loc
assignment.collection.array.field.option=Ignore assignments in private methods
assignment.to.date.calendar.field.from.parameter.display.name=Assignment to Date or Calendar field from parameter
assignment.to.date.calendar.field.from.parameter.problem.descriptor=Assignment to ''{0}'' field <code>#ref</code> from parameter {1} #loc
package.visible.field.display.name=Package-visible field
package.visible.field.problem.descriptor=Package-visible field <code>#ref</code> #loc
package.visible.inner.class.display.name=Package-visible inner class
package.visible.inner.class.problem.descriptor=Package-visible inner class <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=Ignore package-visible inner enums
protected.field.display.name=Protected field
protected.field.problem.descriptor=Protected field <code>#ref</code> #loc
protected.inner.class.display.name=Protected inner class
protected.inner.class.problem.descriptor=Protected inner class <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=Ignore 'protected' inner enums
public.field.display.name='public' field
public.field.problem.descriptor='public' field <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=Ignore 'public final' fields of an enum type
public.inner.class.display.name='public' inner class
public.inner.class.problem.descriptor='public' inner class <code>#ref</code> #loc
public.inner.class.ignore.enum.option=Ignore 'public' inner enums
return.of.collection.array.field.display.name=Return of Collection or array field
return.of.collection.array.field.problem.descriptor.array='return' of array field <code>#ref</code> #loc
return.of.collection.array.field.problem.descriptor.collection='return' of Collection field <code>#ref</code> #loc
return.of.collection.array.field.option=Ignore private methods returning an array or collection field
return.date.calendar.field.display.name=Return of Date or Calendar field
return.date.calendar.field.problem.descriptor=Return of ''{0}'' field <code>#ref</code> #loc
accessing.non.public.field.of.another.object.display.name=Accessing a non-public field of another object
accessing.non.public.field.of.another.object.problem.descriptor=Direct access of non-public field <code>#ref</code> on another object #loc
call.to.date.tostring.display.name=Call to 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code>Date.#ref()</code> used in an internationalized context #loc
magic.character.display.name="Magic character"
magic.character.problem.descriptor="Magic character" <code>#ref</code> in an internationalized context #loc
call.to.numeric.tostring.display.name=Call to Numeric 'toString()'
call.to.numeric.tostring.problem.descriptor=Numeric <code>#ref()</code> called in an internationalized context #loc
instantiating.simpledateformat.without.locale.display.name=Instantiating a SimpleDateFormat without a Locale
instantiating.simpledateformat.without.locale.problem.descriptor=Instantiating a <code>#ref</code> without specifying a Locale in an internationalized context #loc
string.compareto.call.display.name=Call to 'String.compareTo()'
string.compareto.call.problem.descriptor=<code>String.#ref()</code> called using internationalized strings #loc
string.concatenation.display.name=String concatenation
string.concatenation.problem.descriptor=String concatenation <code>#ref</code> in an internationalized context #loc
string.concatenation.ignore.system.out.option=Ignore for 'System.out.print' arguments
string.concatenation.ignore.system.err.option=Ignore for 'System.err.print' arguments
string.concatenation.ignore.assert.option=Ignore for assert statement arguments
string.concatenation.ignore.exceptions.option=Ignore for throwable arguments
string.concatenation.ignore.constant.initializers.option=Ignore for initializers of constants
string.concatenation.ignore.in.test.code=Ignore in test code
string.equalsignorecase.call.display.name=Call to 'String.equalsIgnoreCase()'
string.equalsignorecase.call.problem.descriptor=<code>String.#ref()</code> using internationalized strings #loc
string.equals.call.display.name=Call to 'String.equals()'
string.equals.call.problem.descriptor=<code>String.#ref()</code> using internationalized strings #loc
string.touppercase.tolowercase.without.locale.display.name=Call to 'String.toUpperCase()' or 'toLowerCase()' without a Locale
string.touppercase.tolowercase.without.locale.problem.descriptor=<code>String.#ref()</code> called without specifying a Locale using internationalized strings #loc
use.stringtokenizer.display.name=Use of StringTokenizer
use.stringtokenizer.problem.descriptor=<code>#ref</code> in an internationalized context #loc
time.tostring.call.display.name=Call to 'Time.toString()'
time.tostring.call.problem.descriptor=<code>Time.#ref()</code> in an internationalized context #loc
class.escapes.defined.scope.display.name=Class escapes defined scope
class.escapes.defined.scope.problem.descriptor=Class <code>#ref</code> is made visible outside its defined scope #loc
field.name.hides.in.superclass.display.name=Field name hides field in superclass
field.name.hides.in.superclass.problem.descriptor=Field <code>#ref</code> hides field in superclass #loc
field.name.hides.in.superclass.ignore.option=Ignore superclass fields not visible from subclass
inner.class.field.hides.outer.display.name=Inner class field hides outer class field
inner.class.field.hides.outer.ignore.option=Ignore outer fields not visible from inner class
inner.class.field.hides.outer.problem.descriptor=Inner class field <code>#ref</code> hides outer class field #loc
local.variable.hides.member.variable.display.name=Local variable hides member variable
local.variable.hides.member.variable.problem.descriptor=Local variable <code>#ref</code> hides member variable #loc
local.variable.hides.member.variable.ignore.option=Ignore local variables in static methods
method.overloads.display.name=Method overloads method of superclass
method.overloads.problem.descriptor=Method <code>#ref()</code> overloads a compatible method of a superclass, when overriding might have been intended #loc
method.overrides.private.display.name=Method overrides private method of superclass
method.overrides.private.display.name.problem.descriptor=Method <code>#ref()</code> overrides a private method of a superclass #loc
method.overrides.static.display.name=Method overrides static method of superclass
method.overrides.static.problem.descriptor=Method <code>#ref()</code> overrides a static method of a superclass #loc
parameter.hides.member.variable.display.name=Parameter hides member variable
parameter.hides.member.variable.problem.descriptor=Parameter <code>#ref</code> hides member variable #loc
parameter.hides.member.variable.ignore.setters.option=Ignore for property setters
parameter.hides.member.variable.ignore.superclass.option=Ignore superclass fields not visible from subclass
parameter.hides.member.variable.ignore.constructors.option=Ignore for constructors
parameter.hides.member.variable.ignore.abstract.methods.option=Ignore for abstract methods
parameter.hides.member.variable.ignore.static.parameters.option=Ignore for static method parameters hiding instance fields
type.parameter.hides.visible.type.display.name=Type parameter hides visible type
type.parameter.hides.visible.type.problem.descriptor=Type parameter <code>#ref</code> hides a visible type ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=Anonymous class variable hides variable in containing method
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=Anonymous class parameter <code>#ref</code> hides variable in containing method #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=Anonymous class field <code>#ref</code> hides variable in containing method #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=Anonymous class local variable <code>#ref</code> hides variable in containing method #loc
channel.opened.not.closed.display.name=Channel opened but not safely closed
channel.opened.not.closed.problem.descriptor=''{0}'' should be opened in front of a ''try'' block and closed in the corresponding ''finally'' block #loc
drivermanager.call.display.name=Use of DriverManager to get JDBC connection
drivermanager.call.problem.descriptor=Call to <code>DriverManager.#ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate resource opened but not safely closed
hibernate.resource.opened.not.closed.problem.descriptor=''{0}'' should be opened in front of a ''try'' block and closed in the corresponding ''finally'' block #loc
i.o.resource.opened.not.closed.display.name=I/O resource opened but not safely closed
resource.opened.not.closed.problem.descriptor=''{0}'' should be opened in front of a ''try'' block and closed in the corresponding ''finally'' block #loc
jdbc.resource.opened.not.closed.display.name=JDBC resource opened but not safely closed
jdbc.resource.opened.not.closed.problem.descriptor=JDBC ''{0}'' should be opened in front of a ''try'' block and closed in the corresponding ''finally'' block #loc
jndi.resource.opened.not.closed.display.name=JNDI resource opened but not safely closed
socket.opened.not.closed.display.name=Socket opened but not safely closed
annotation.class.display.name=Annotation class
annotation.class.problem.descriptor=Annotation class <code>#ref</code> #loc
annotation.display.name=Annotation
annotation.problem.descriptor=Annotation <code>#ref</code> #loc
use.assert.as.identifier.display.name=Use of 'assert' as identifier
use.assert.as.identifier.problem.descriptor=Use of <code>#ref</code> as identifier #loc
assert.statement.display.name='assert' statement
statement.problem.descriptor=<code>#ref</code> statement #loc
auto.boxing.display.name=Auto-boxing
auto.boxing.problem.descriptor=Auto-boxing <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=Make boxing explicit
auto.boxing.ignore.added.to.collection.option=Ignore expressions added to a collection
auto.unboxing.display.name=Auto-unboxing
auto.unboxing.problem.descriptor=Auto-unboxing <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=Make unboxing explicit
use.enum.as.identifier.display.name=Use of 'enum' as identifier
use.enum.as.identifier.problem.descriptor=Use of <code>#ref</code> as identifier #loc
enumerated.class.display.name=Enumerated class
enumerated.class.problem.descriptor=Enumerated class <code>#ref</code> #loc
extended.for.statement.display.name=Extended 'for' statement
extended.for.statement.replace.quickfix=Replace with old-style 'for' statement
variable.argument.method.display.name=Variable argument method
variable.argument.method.problem.descriptor=Variable argument method <code>#ref()</code> #loc
variable.argument.method.quickfix=Convert variable argument parameter to array
hardcoded.file.separator.display.name=Hardcoded file separator
hardcoded.file.separator.problem.descriptor=Hardcoded file separator <code>#ref</code> #loc
hardcoded.file.separator.include.option=Include "example/*" in recognized MIME media types
hardcoded.line.separator.display.name=Hardcoded line separator
hardcoded.line.separator.problem.descriptor=Hardcoded line separator <code>#ref</code> #loc
native.method.display.name=Native method
native.method.problem.descriptor=Methods declared <code>#ref</code> are non-portable #loc
runtime.exec.call.display.name=Call to 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Call to <code>Runtime.#ref()</code> is non-portable #loc
system.exit.call.display.name=Call to 'System.exit()' or related methods
system.exit.call.problem.descriptor=Call to <code>{0}.#ref()</code> is non-portable #loc
system.getenv.call.display.name=Call to 'System.getenv()'
system.getenv.call.problem.descriptor=Call to <code>System.#ref()</code> is non-portable #loc
use.of.awt.peer.class.display.name=Use of AWT peer class
use.of.awt.peer.class.problem.descriptor=Use of AWT peer class <code>#ref</code> is non-portable #loc
use.of.concrete.jdbc.driver.class.display.name=Use of concrete JDBC driver class
use.of.concrete.jdbc.driver.class.problem.descriptor=Use of concrete JDBC driver class <code>#ref</code> is non-portable #loc
use.processbuilder.class.display.name=Use of 'java.lang.ProcessBuilder' class
use.processbuilder.class.problem.descriptor=Use of <code>#ref</code> is non-portable #loc
use.sun.classes.display.name=Use of sun.* classes
use.sun.classes.problem.descriptor=Use of Sun-supplied class <code>#ref</code> is non-portable #loc
abstract.class.with.only.one.direct.inheritor.display.name=Abstract class which has only one direct inheritor
anonymous.inner.may.be.named.static.inner.class.display.name=Anonymous inner class may be a named static inner class
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=Anonymous inner class <code>#ref</code> may be a named static inner class #loc
array.length.in.loop.condition.display.name=Array.length in loop condition
array.length.in.loop.condition.problem.descriptor=Check of array <code>#ref</code> in loop condition #loc
large.array.allocation.no.outofmemoryerror.display.name=Large array allocation with no OutOfMemoryError check
large.array.allocation.no.outofmemoryerror.problem.descriptor=Large array allocation which is not checked for out-of-memory condition #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Maximum number of elements
connection.opened.not.safely.closed.display.name=Connection opened but not safely closed
field.repeatedly.accessed.in.method.display.name=Field repeatedly accessed in method
field.repeatedly.accessed.in.method.problem.descriptor=Field ''{0}'' accessed repeatedly in method <code>#ref(0</code> #loc
field.repeatedly.accessed.in.method.ignore.option=Ignore final fields
interface.one.inheritor.display.name=Interface which has only one direct inheritor
interface.one.inheritor.problem.descriptor=Interface <code>#ref</code> has only one direct inheritor #loc
method.call.in.loop.condition.display.name=Method call in loop condition
method.call.in.loop.condition.problem.descriptor=Call to method <code>#ref()</code> in loop condition #loc
large.initializer.primitive.type.array.display.name=Overly large initializer for array of primitive type
large.initializer.primitive.type.array.problem.descriptor=Primitive array initializer with too many elements ({0}) #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=Maximum number of elements
private.member.access.between.outer.and.inner.classes.display.name=Private member access between outer and inner classes
private.member.access.between.outer.and.inner.classes.problem.descriptor=Access to private member of class ''{0}'' #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Make ''{0}'' package-local
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Make ''{0}'' constructor package-local
recordstore.opened.not.safely.closed.display.name=RecordStore opened but not safely closed
overly.complex.anonymous.inner.class.display.name=Overly complex anonymous inner class
cyclomatic.complexity.limit.option=Cyclomatic complexity limit:
overly.complex.anonymous.inner.class.problem.descriptor=Overly complex anonymous inner class (cyclomatic complexity = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=Anonymous inner class with too many methods
method.count.limit.option=Method count limit:
anonymous.inner.class.with.too.many.methods.problem.descriptor=Anonymous inner class with too many methods (method count = {0}) #loc
overly.complex.class.display.name=Overly complex class
overly.complex.class.problem.descriptor=<code>#ref</code> is overly complex (cyclomatic complexity = {0}) #loc
overly.coupled.class.display.name=Overly coupled class
overly.coupled.class.class.coupling.limit.option=Class coupling limit:
include.java.system.classes.option=Include couplings to java system classes
include.library.classes.option=Include couplings to library classes
overly.coupled.class.problem.descriptor=<code>#ref</code> is overly coupled (dependencies = {0}) #loc
class.too.deep.display.name=Class too deep in inheritance tree
class.too.deep.inheritance.depth.limit.option=Inheritance depth limit:
class.too.deep.problem.descriptor=<code>#ref</code> is too deep in inheritance tree (inheritance depth = {0}) #loc
inner.class.too.deeply.nested.display.name=Inner class too deeply nested
inner.class.too.deeply.nested.nesting.limit.option=Nesting limit:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> is too deeply nested (nesting level = {0}) #loc
too.many.constructors.display.name=Class with too many constructors
too.many.constructors.count.limit.option=Constructor count limit:
too.many.constructors.problem.descriptor=<code>#ref</code> has too many constructors (constructor count = {0}) #loc
too.many.fields.display.name=Class with too many fields
too.many.fields.count.limit.option=Field count limit:
too.many.fields.problem.descriptor=<code>#ref</code> has too many fields (field count = {0}) #loc
too.many.methods.display.name=Class with too many methods
too.many.methods.problem.descriptor=<code>#ref</code> has too many methods (method count = {0}) #loc
externalizable.with.serialization.methods.display.name=Externalizable class with 'readObject()' or 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=Externalizable class <code>#ref</code> defines 'readObject()' and 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=Externalizable class <code>#ref</code> defines 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=Externalizable class <code>#ref</code> defines 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=Non-serializable class with 'serialVersionUID'
non.serializable.class.with.serialversionuid.problem.descriptor=Non-serializable class <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=Non-serializable interface <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=Non-serializable @interface <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=Non-serializable anonymous class extending <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.with.serialversionuid.remove.quickfix=Remove 'serialVersionUID' field
non.serializable.class.with.readwriteobject.display.name=Non-serializable class with 'readObject()' or 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both=Non-serializable class <code>#ref</code> defines 'readObject()' and 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=Non-serializable class <code>#ref</code> defines 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Non-serializable class <code>#ref</code> defines 'readObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.both=Non-serializable anonymous class extending <code>#ref</code> defines 'readObject()' and 'writeObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.write=Non-serializable anonymous class extending <code>#ref</code> defines 'writeObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.read=Non-serializable anonymous class extending <code>#ref</code> defines 'readObject()' #loc
readwriteobject.private.display.name='readObject()' or 'writeObject()' not declared 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> not declared 'private' #loc
readobject.initialization.display.name=Instance field may not be initialized by 'readObject()'
readobject.initialization.problem.descriptor=Instance field <code>#ref</code> may not be initialized during 'readObject()' call #loc
readresolve.writereplace.protected.display.name='readResolve()' or 'writeReplace()' not declared 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> not declared 'protected' #loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' field not declared 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=<code>#ref</code> field of a Serializable class is not declared 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' field not declared 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=<code>#ref</code> field of a Serializable class is not declared 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=Make serialVersionUID 'private static final'
serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc
serializable.class.without.serialversionuid.ignore.option=Ignore classes serializable due to inheritance

#dynamic
non.protected.constructor.in.abstract.class.display.name='public' constructor in 'abstract' class
unnecessary.qualifier.for.this.display.name=Unnecessary qualifier for 'this'
multiple.declaration.display.name=Multiple variables in one declaration
thread.priority.display.name=Call to 'Thread.setPriority()'
too.broad.scope.display.name=Scope of variable is too broad
infinite.loop.statement.display.name=Infinite loop statement
asserts.without.messages.display.name=Message missing on JUnit assertion
constant.naming.convention.display.name=Constant naming convention
random.double.for.random.integer.display.name=Using 'Random.nextDouble()' to get random integer
test.method.without.assertion.display.name=JUnit test method without any assertions
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' may be 'StringBuilder'
comparison.of.short.and.char.display.name=Comparison of 'short' and 'char' values
unnecessary.fully.qualified.name.display.name=Unnecessary fully qualified name
unnecessary.label.on.break.statement.display.name=Unnecessary label on 'break' statement
exception.name.doesnt.end.with.exception.display.name=Exception class name does not end with 'Exception'
bad.exception.declared.display.name=Prohibited exception declared
deserializable.class.in.secure.context.display.name=Deserializable class in secure context
pointless.boolean.expression.display.name=Pointless boolean expression
class.without.constructor.display.name=Class without constructor
break.statement.display.name='break' statement
unconditional.wait.display.name=Unconditional 'wait()' call
cyclomatic.complexity.display.name=Overly complex method
string.to.string.display.name=Redundant 'String.toString()'
constant.on.lhs.of.comparison.display.name=Constant on left side of comparison
final.class.display.name='final' class
labeled.statement.display.name=Labeled statement
notify.called.on.condition.display.name='notify()'  or 'notifyAll()' called on java.util.concurrent.locks.Condition object
loop.statements.that.dont.loop.display.name=Loop statement that does not loop
thread.run.display.name=Call to 'Thread.run()'
non.synchronized.method.overrides.synchronized.method.display.name=Unsynchronized method overrides synchronized method
constant.on.rhs.of.comparison.display.name=Constant on right side of comparison
synchronize.on.this.display.name=Synchronization on 'this'
switch.statement.with.too.many.branches.display.name='switch' statement with too many branches
utility.class.without.private.constructor.display.name=Utility class without private constructor
throw.caught.locally.display.name='throw' caught by containing 'try' statement
exception.from.catch.which.doesnt.wrap.display.name='throw' inside 'catch' block which ignores the caught exception
type.parameter.naming.convention.display.name=Type parameter naming convention
multiply.or.divide.by.power.of.two.display.name=Multiply or divide by power of two
multiply.or.divide.by.power.of.two.divide.option=Check divisions by a power of two also
serializable.with.unconstructable.ancestor.display.name=Serializable class with unconstructable ancestor
missorted.modifiers.display.name=Missorted modifiers
sleep.while.holding.lock.display.name=Call to 'Thread.sleep()' while synchronized
singleton.display.name=Singleton
thread.death.rethrown.display.name='java.lang.ThreadDeath' not rethrown
if.statement.with.too.many.branches.display.name='if' statement with too many branches
redundant.implements.display.name=Redundant interface declaration
nesting.depth.display.name=Overly nested method
return.this.display.name=Return of 'this'
busy.wait.display.name=Busy wait
utility.class.display.name=Utility class
instantiating.object.to.get.class.object.display.name=Instantiating object to get Class object
abstract.class.extends.concrete.class.display.name=Abstract class extends concrete class
parameter.naming.convention.display.name=Method parameter naming convention
integer.division.in.floating.point.context.display.name=Integer division in floating point context
interface.naming.convention.display.name=Interface naming convention
length.one.strings.in.concatenation.display.name=Single character string concatenation
length.one.string.in.indexof.display.name= Single character string argument in 'String.indexOf()' call
unnecessary.conditional.expression.display.name=Redundant conditional expression
thread.yield.display.name=Call to 'Thread.yield()'
confusing.floating.point.literal.display.name=Confusing floating-point literal
wait.not.in.loop.display.name='wait()' not in loop
string.concatenation.inside.string.buffer.append.display.name=String concatenation as argument to 'StringBuffer.append()' call
class.initializer.display.name=Non-'static' initializer
enumerated.class.naming.convention.display.name=Enumerated class naming convention
non.thread.safe.lazy.initialization.display.name=Unsafe lazy initialization of 'static' field
call.to.simple.setter.in.class.display.name=Call to simple setter from within class
comparison.to.nan.display.name=Comparison to Double.NaN or Float.NaN
instance.method.naming.convention.display.name=Instance method naming convention
unnecessary.semicolon.display.name=Unnecessary semicolon
fallthru.in.switch.statement.display.name=Fallthrough in 'switch' statement
call.to.native.method.while.locked.display.name=Call to a native method while locked
switch.statement.display.name='switch' statement
custom.classloader.display.name=Custom ClassLoader
nested.conditional.expression.display.name=Nested conditional expression
duplicate.condition.display.name=Duplicate condition in 'if' statement
duplicate.boolean.branch.display.name=Duplicate condition on '\\&\\&' or '||'
method.with.multiple.loops.display.name=Method with multiple loops
non.comment.source.statements.display.name=Overly long method
local.variable.naming.convention.display.name=Local variable naming convention
negated.if.else.display.name='if' statement with negated condition
class.naming.convention.display.name=Class naming convention
serializable.inner.class.with.non.serializable.outer.class.display.name=Serializable non-'static' inner class with non-Serializable outer class
pointless.arithmetic.expression.display.name=Pointless arithmetic expression
method.name.same.as.class.name.display.name=Method name same as class name
unnecessary.temporary.on.conversion.to.string.display.name=Unnecessary temporary object in conversion to String
unnecessary.continue.display.name=Unnecessary 'continue' statement
inner.class.on.interface.display.name=Inner class of interface
unused.label.display.name=Unused label
multiple.typed.declaration.display.name=Variables of different types in one declaration
overly.complex.boolean.expression.display.name=Overly complex boolean expression
continue.statement.with.label.display.name='continue' statement with label
class.loader.instantiation.display.name=ClassLoader instantiation
return.from.finally.block.display.name='return' inside 'finally' block
unnecessary.boxing.display.name=Unnecessary boxing
annotation.naming.convention.display.name=Annotation naming convention
checked.exception.class.display.name=Checked exception class
switch.statement.with.confusing.declaration.display.name=Local variable used and declared in different 'switch' branches
cast.that.loses.precision.display.name=Numeric cast that loses precision
manual.array.copy.display.name=Manual array copy
manual.array.to.collection.copy.display.name=Manual array to collection copy
long.literals.ending.with.lowercase.l.display.name='long' literal ending with 'l' instead of 'L'
overly.complex.arithmetic.expression.display.name=Overly complex arithmetic expression
junit.abstract.test.class.naming.convention.display.name=JUnit abstract test class naming convention
unnecessary.parentheses.display.name=Unnecessary parentheses
test.case.in.product.code.display.name=JUnit TestCase in product source
test.method.in.product.code.display.name=JUnit test method in product source
serializable.class.in.secure.context.display.name=Serializable class in secure context
static.variable.naming.convention.display.name='static' field naming convention
nested.method.call.display.name=Nested method call
throw.from.finally.block.display.name='throw' inside 'finally' block
field.accessed.synchronized.and.unsynchronized.display.name=Field accessed in both synchronized and unsynchronized contexts
abstract.method.overrides.abstract.method.display.name=Abstract method overrides abstract method
static.non.final.field.display.name='static', non-'final' field
substring.zero.display.name=Redundant '.substring(0)'
class.without.no.arg.constructor.display.name=Class without no-arg constructor
unnecessary.return.display.name=Unnecessary 'return' statement
final.static.method.display.name='static' method declared 'final'
constant.declared.in.abstract.class.display.name=Constant declared in abstract class
too.broad.catch.display.name=Overly broad 'catch' block
floating.point.equality.display.name=Floating point equality comparison
thrown.exceptions.per.method.display.name=Method with too many exceptions declared
public.static.array.field.display.name='public static' array field
await.not.in.loop.display.name='await()' not in loop
method.names.differ.only.by.case.display.name=Method names differing only by case
method.names.differ.only.by.case.ignore.override.option=Ignore if method is override of super method
unsecure.random.number.generation.display.name=Insecure random number generation
parameters.per.method.display.name=Method with too many parameters
parameters.per.constructor.display.name=Constructor with too many parameters
unnecessary.unboxing.display.name=Unnecessary unboxing
extends.thread.display.name=Class explicitly extends 'java.lang.Thread'
misspelled.tear.down.display.name='teardown()' instead of 'tearDown()'
test.case.with.constructor.display.name=JUnit TestCase with non-trivial constructors
parameter.name.differs.from.overridden.parameter.display.name=Parameter name differs from parameter in overridden method
final.private.method.display.name='private' method declared 'final'
enum.switch.statement.which.misses.cases.display.name=Enum 'switch' statement that misses case
enum.switch.statement.which.misses.cases.option=Ignore switch statements with a default branch
setup.calls.super.setup.display.name='setUp()' does not call 'super.setUp()'
unconstructable.test.case.display.name=Unconstructable JUnit TestCase
volatile.long.or.double.field.display.name=Volatile long or double field
string.buffer.must.have.initial.capacity.display.name=StringBuffer or StringBuilder without initial capacity
method.may.be.static.display.name=Method may be 'static'
class.initializer.may.be.static.display.name=Class initializer may be 'static'
nested.switch.statement.display.name=Nested 'switch' statement
c.style.array.declaration.display.name=C-style array declaration
final.method.in.final.class.display.name='final' method in 'final' class
extends.annotation.display.name=Class extends annotation interface
naked.notify.display.name='notify()' or 'notifyAll()' without corresponding state change
constant.if.statement.display.name=Constant 'if' statement
switch.statement.density.display.name='switch' statement with too low of a branch density
switch.statement.with.too.few.branches.display.name='switch' statement with too few branches
upper.case.field.name.not.constant.display.name=Non-constant field with upper-case name
unnecessary.label.on.continue.statement.display.name=Unnecessary label on 'continue' statement
jdbc.prepare.statement.with.non.constant.string.display.name='Connection.prepare*()' call with non-constant string
synchronize.on.non.final.field.display.name=Synchronization on a non-final field
noop.method.in.abstract.class.display.name=No-op method in abstract class
non.final.field.of.exception.display.name=Non-final field of exception class
nested.try.statement.display.name=Nested 'try' statement
condition.signal.display.name=Call to 'signal()' instead of 'signalAll()'
jdbc.execute.with.non.constant.string.display.name='Statement.execute()' call with non-constant string
system.set.security.manager.display.name=Call to 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=Call to <code>System.#ref()</code> may pose security concerns #loc
control.flow.statement.without.braces.display.name=Control flow statement without braces
trivial.if.display.name=Redundant 'if' statement
thread.with.default.run.method.display.name=Instantiating a Thread with default 'run()' method
while.loop.spins.on.field.display.name='while' loop spins on field
object.equals.null.display.name=Object.equals(null)
test.method.is.public.void.no.arg.display.name=Test method with incorrect signature
if.statement.with.identical.branches.display.name='if' statement with identical branches
multiple.return.points.per.method.display.name=Method with multiple return points
break.statement.with.label.display.name='break' statement with label
public.constructor.in.non.public.class.display.name='public' constructor in non-public class
questionable.name.display.name=Questionable name
empty.finally.block.display.name=Empty 'finally' block
abstract.method.overrides.concrete.method.display.name=Abstract method overrides concrete method
thread.stop.suspend.resume.display.name=Call to 'Thread.stop()', 'suspend()' or 'resume()'
constant.math.call.display.name=Constant call to 'java.lang.Math'
volatile.array.field.display.name=Volatile array field
literal.as.arg.to.string.equals.display.name='expression.equals("literal")' rather than '"literal".equals(expression)'
inner.class.may.be.static.display.name=Inner class may be 'static'
static.suite.display.name='suite()' method not declared 'static'
redundant.field.initialization.display.name=Redundant field initialization
string.buffer.to.string.in.concatenation.display.name='StringBuffer.toString()' in concatenation
utility.class.with.public.constructor.display.name=Utility class with 'public' constructor
for.loop.replaceable.by.while.display.name='for' loop may be replaced with 'while' loop
missing.deprecated.annotation.display.name=Missing @Deprecated annotation
cloneable.class.in.secure.context.display.name=Cloneable class in secure context
static.inheritance.display.name=Static inheritance
class.name.prefixed.with.package.name.display.name=Class name prefixed with package name
call.to.simple.getter.in.class.display.name=Call to simple getter from within class
class.name.differs.from.file.name.display.name=Class name differs from file name
protected.member.in.final.class.display.name='protected' member in 'final' class
load.library.with.non.constant.string.display.name=Call to 'System.loadLibrary()' with non-constant string
instanceof.catch.parameter.display.name='instanceof' on 'catch' parameter
implicit.numeric.conversion.display.name=Implicit numeric conversion
unnecessary.interface.modifier.display.name=Unnecessary interface modifier
confusing.main.method.display.name=Confusing 'main()' method
octal.literal.display.name=Octal integer
misordered.assert.equals.parameters.display.name=Misordered 'assertEquals()' parameters
unnecessary.constructor.display.name=Redundant no-arg constructor
method.name.same.as.parent.name.display.name=Method name same as parent class name
java.lang.reflect.display.name=Use of 'java.lang.reflect'
while.can.be.foreach.display.name='while' loop replaceable with 'for each'
big.decimal.equals.display.name='equals()' called on java.math.BigDecimal
wait.not.in.synchronized.context.display.name='wait()' while not synchronized
implicit.call.to.super.display.name=Implicit call to 'super()'
empty.catch.block.display.name=Empty 'catch' block
unqualified.static.usage.display.name=Unqualified static access
simplifiable.junit.assertion.display.name=Simplifiable JUnit assertion
object.notify.display.name=Call to 'notify()' instead of 'notifyAll()'
thread.start.in.construction.display.name=Call to 'Thread.start()' during object construction
non.final.clone.display.name=Non-final 'clone()' in secure context
unnecessary.temporary.on.conversion.from.string.display.name=Unnecessary temporary object in conversion from String
unnecessary.this.display.name=Unnecessary 'this' qualifier
runtime.exec.with.non.constant.string.display.name=Call to 'Runtime.exec()' with non-constant string
system.properties.display.name=Access of system properties
chained.method.call.display.name=Chained method calls
notify.not.in.synchronized.context.display.name='notify()' or 'notifyAll()' while not synchronized
safe.lock.display.name=Lock acquired but not safely unlocked
system.run.finalizers.on.exit.display.name=Call to 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name='for' loop replaceable with 'for each'
type.parameter.extends.object.display.name=Type parameter explicitly extends 'java.lang.Object'
marker.interface.display.name=Marker interface
limited.scope.inner.class.display.name=Limited-scope inner class
switch.statements.without.default.display.name='switch' statement without 'default' branch
unchecked.exception.class.display.name=Unchecked exception class
for.loop.with.missing.component.display.name='for' loop with missing components
for.loop.with.missing.component.collection.loop.option=Ignore collection iterations
double.checked.locking.display.name=Double-checked locking
double.checked.locking.problem.descriptor=Double-checked locking #loc
double.checked.locking.ignore.on.volatiles.option=Ignore double-checked locking on volatile fields
string.buffer.replaceable.by.string.display.name=Constant StringBuffer may be String
boolean.method.name.must.start.with.question.display.name=Boolean method name must start with question word
class.name.same.as.ancestor.name.display.name=Class name same as ancestor name
error.rethrown.display.name='java.lang.Error' not rethrown
serializable.has.serialization.methods.display.name=Serializable class without 'readObject()' and 'writeObject()'
misspelled.set.up.display.name='setup()' instead of 'setUp()'
setup.is.public.void.no.arg.display.name='setUp()' with incorrect signature
missing.override.annotation.display.name=Missing @Override annotation
wait.while.holding.two.locks.display.name='wait()' while holding two locks
empty.class.display.name=Empty class
trivial.string.concatenation.display.name=Concatenation with empty string
empty.synchronized.statement.display.name=Empty 'synchronized' statement
unnecessary.default.display.name=Unnecessary 'default' for enum 'switch' statement
simplifiable.conditional.expression.display.name=Conditional that can be simplified to \\&\\& or ||
simplifiable.if.statement.display.name='if' statement may be replaced with \\&\\& or || expression
unnecessary.super.constructor.display.name=Unnecessary call to 'super()'
unnecessarily.qualified.static.usage.display.name=Unnecessarily qualified static access
bad.exception.caught.display.name=Prohibited exception caught
custom.security.manager.display.name=Custom SecurityManager
teardown.is.public.void.no.arg.display.name='tearDown()' with incorrect signature
string.concatenation.in.loops.display.name=String concatenation in loop
comparing.references.display.name='==' used instead of 'equals()'
boolean.constructor.display.name=Boolean constructor call
continue.statement.display.name='continue' statement
extends.object.display.name=Class explicitly extends 'java.lang.Object'
serializable.inner.class.has.serial.version.uid.field.display.name=Serializable non-'static' inner class without 'serialVersionUID'
static.method.naming.convention.display.name='static' method naming convention
empty.try.block.display.name=Empty 'try' block
field.has.setter.but.no.getter.display.name=Field has setter but no getter
three.negations.per.method.display.name=Method with more than three negations
conditional.expression.display.name=Conditional expression (?:)
unnecessary.enum.modifier.display.name=Unnecessary enum modifier
string.equals.empty.string.display.name='String.equals("")'
teardown.calls.super.teardown.display.name='tearDown()' does not call 'super.tearDown()'
synchronize.on.lock.display.name=Synchronization on a Lock object
synchronized.on.literal.object.name=Synchronization on an object initialized with a literal
field.may.be.static.display.name=Field may be 'static'
class.may.be.interface.display.name=Class may be interface
abstract.class.without.abstract.methods.display.name=Abstract class without abstract methods
divide.by.zero.display.name=Division by zero
default.not.last.case.in.switch.display.name='default' not last case in 'switch' statement
nested.synchronized.statement.display.name=Nested 'synchronized' statement
constant.conditional.expression.display.name=Constant conditional expression
unused.catch.parameter.display.name=Unused 'catch' parameter
class.in.top.level.package.display.name=Class without package statement
confusing.else.display.name=Confusing 'else' branch
public.field.accessed.in.synchronized.context.display.name=Non-private field accessed in synchronized context
string.replaceable.by.string.buffer.display.name=Non-constant String should be StringBuilder
junit.test.class.naming.convention.display.name=JUnit test class naming convention
method.coupling.display.name=Overly coupled method
collections.must.have.initial.capacity.display.name=Collection without initial capacity
anonymous.inner.class.display.name=Anonymous inner class
negated.conditional.display.name=Conditional expression with negated condition
non.reproducible.math.call.display.name=Non-reproducible call to 'java.lang.Math'
multiple.top.level.classes.in.file.display.name=Multiple top level classes in single file
set.replaceable.by.enum.set.display.name=Set replaceable with EnumSet
non.static.inner.class.in.secure.context.display.name=Non-'static' inner class in secure context
tail.recursion.display.name=Tail recursion
finally.block.cannot.complete.normally.display.name='finally' block which can not complete normally
non.atomic.operation.on.volatile.field.display.name=Non-atomic operation on volatile field
public.static.collection.field.display.name='public static' collection field
non.exception.name.ends.with.exception.display.name=Non-exception class name ends with 'Exception'
synchronized.method.display.name='synchronized' method
enumerated.constant.naming.convention.display.name=Enumerated constant naming convention
final.method.display.name='final' method
transient.field.in.non.serializable.class.display.name=Transient field in non-serializable class
bad.exception.thrown.display.name=Prohibited exception thrown
conditional.expression.with.identical.branches.display.name=Conditional expression with identical branches
raw.use.of.parameterized.type.display.name=Raw use of parameterized class
standard.variable.names.display.name=Standard variable names
instance.variable.naming.convention.display.name=Instance field naming convention
dollar.sign.in.name.display.name=Use of '$' in identifier
map.replaceable.by.enum.map.display.name=Map replaceable with EnumMap
extends.concrete.collection.display.name=Class explicitly extends a Collection class
continue.or.break.from.finally.block.display.name='continue' or 'break' inside 'finally' block
abstract.method.with.missing.implementations.display.name=Abstract method with missing implementations
object.allocation.in.loop.display.name=Object allocation in loop
wait.called.on.condition.display.name='wait()' called on java.util.concurrent.locks.Condition object
test.case.with.no.test.methods.display.name=JUnit test case with no tests
abstract.class.never.implemented.display.name=Abstract class which has no concrete subclass
interface.never.implemented.display.name=Interface which has no concrete subclass
constant.declared.in.interface.display.name=Constant declared in interface


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=Exception class name <code>#ref</code> does not end with 'Exception' #loc
non.exception.name.ends.with.exception.problem.descriptor=Non-exception class name <code>#ref</code> ends with 'Exception' #loc
class.name.prefixed.with.package.name.problem.descriptor=Class name <code>#ref</code> begins with its package name #loc
class.name.same.as.ancestor.name.problem.descriptor=Class name <code>#ref</code> is the same as one of its superclass' names #loc
method.name.same.as.class.name.problem.descriptor=Method name <code>#ref</code> is the same as its class name #loc
method.name.same.as.parent.name.problem.descriptor=Method name <code>#ref</code> is the same as its parent class name #loc
boolean.method.name.must.start.with.question.problem.descriptor=Boolean method name <code>#ref</code> does not start with question word #loc
questionable.name.problem.descriptor=Questionable name <code>#ref</code> #loc
confusing.main.method.problem.descriptor=Method named <code>#ref</code> without signature 'public static void main(String[])' #loc
upper.case.field.name.not.constant.problem.descriptor=Non-constant field <code>#ref</code> with constant-style name #loc
dollar.sign.in.name.problem.descriptor=Identifier <code>#ref</code> contains '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: integer division in floating-point context #loc
comparison.of.short.and.char.problem.descriptor=Equality comparison <code>#ref</code> of short and char values #loc
big.decimal.equals.problem.descriptor=<code>#ref()</code> between BigDecimal values should probably be 'compareTo()' #loc
divide.by.zero.problem.descriptor=Division by zero #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> may produce non-reproducible results #loc
constant.math.call.problem.descriptor=Constant call to <code>#ref()</code> can be simplified #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: floating point values compared for exact equality #loc
fallthru.in.switch.statement.problem.descriptor=<code>#ref</code> fallthrough in 'switch' statement #loc
switch.statements.without.default.problem.descriptor=<code>#ref</code> statement without 'default' branch #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> branch not last case in 'switch' statement #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> statement does not loop #loc
conditional.expression.with.identical.branches.problem.descriptor=Conditional expression <code>#ref</code> with identical branches #loc
if.statement.with.identical.branches.problem.descriptor=<code>#ref</code> statement with identical branches #loc
duplicate.condition.problem.descriptor=Duplicate condition <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=Ignore method calls in condition
duplicate.boolean.branch.problem.descriptor=Duplicate branch <code>#ref</code> #loc
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator.#ref()</code> which can't throw 'NoSuchElementException' #loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> statement cannot complete without throwing an exception #loc
confusing.floating.point.literal.problem.descriptor=Confusing floating point literal <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=Overly complex arithmetic expression #loc
overly.complex.boolean.expression.problem.descriptor=Overly complex boolean expression #loc
labeled.statement.problem.descriptor=Labeled statement <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=<code>#ref</code> statement with label #loc
continue.statement.with.label.problem.descriptor=<code>#ref</code> statement with label #loc
conditional.expression.problem.descriptor=Conditional expression <code>#ref</code> #loc
conditional.expression.option=Ignore for simple assignments and returns
nested.conditional.expression.problem.descriptor=Nested conditional expression <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' literal <code>#ref</code> ends with lowercase 'l' #loc
nested.switch.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
chained.method.call.problem.descriptor=Chained method call <code>#ref()</code> #loc
nested.method.call.problem.descriptor=Nested method call <code>#ref()</code> #loc
octal.literal.problem.descriptor=Octal integer <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=Implicit call to 'super()' #loc
negated.if.else.problem.descriptor=<code>#ref</code> statement with negated condition #loc
negated.conditional.problem.descriptor=Conditional expression with negated condition #loc
confusing.else.problem.descriptor=<code>#ref</code> branch may be unwrapped, as the 'if' branch never completes #loc
switch.statement.with.confusing.declaration.problem.descriptor=Local variable <code>#ref</code> declared in one 'switch' branch and used in another #loc
raw.use.of.parameterized.type.problem.descriptor=Raw use of parameterized class <code>#ref</code> #loc
final.class.problem.descriptor=Class declared <code>#ref</code> #loc
empty.class.problem.descriptor=Class <code>#ref</code> is empty #loc
empty.class.file.without.class.problem.descriptor=Java file does not declare any class #loc
empty.anonymous.class.problem.descriptor=Anonymous class is empty #loc
anonymous.inner.class.problem.descriptor=Anonymous inner class <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=Limited-scope inner class <code>#ref</code> #loc
final.method.problem.descriptor=Method declared <code>#ref</code> #loc
class.initializer.problem.descriptor=Non-'static' initializer #loc
class.may.be.interface.problem.descriptor=<code>#ref</code> may be interface #loc
non.protected.constructor.in.abstract.class.problem.descriptor=Constructor <code>#ref</code> is not declared 'protected' in 'abstract' class #loc
class.without.constructor.problem.descriptor=<code>#ref</code> has no constructor #loc
abstract.class.without.abstract.methods.problem.descriptor=Class <code>#ref</code> is declared 'abstract', and has no 'abstract' methods #loc
final.method.in.final.class.problem.descriptor=Method declared <code>#ref</code> in 'final' class #loc
protected.member.in.final.class.problem.descriptor=Class member declared <code>#ref</code> in 'final' class #loc
utility.class.with.public.constructor.problem.descriptor=Class <code>#ref</code> has only 'static' members, and a 'public' constructor #loc
utility.class.without.private.constructor.problem.descriptor=Class <code>#ref</code> has only 'static' members, and lacks a 'private' constructor #loc
abstract.method.overrides.concrete.method.problem.descriptor=Abstract method <code>#ref()</code> overrides concrete method #loc
abstract.method.with.missing.implementations.problem.descriptor=Abstract method <code>#ref()</code> is not implemented in every subclass #loc
abstract.method.overrides.abstract.method.problem.descriptor=Abstract method <code>#ref()</code> overrides abstract method #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignore methods with a different JavaDoc than their super methods
abstract.class.extends.concrete.class.problem.descriptor=Class <code>#ref</code> is declared 'abstract', and extends a concrete class #loc
static.non.final.field.problem.descriptor='static' non-'final' field <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=Constant <code>#ref</code> declared in abstract class #loc
constant.declared.in.interface.problem.descriptor=Constant <code>#ref</code> declared in interface #loc
static.inheritance.problem.descriptor=Interface <code>#ref</code> is implemented only for its 'static' constants #loc
class.in.top.level.package.problem.descriptor=Class <code>#ref</code> lacks a package statement #loc
utility.class.problem.descriptor=Class <code>#ref</code> has only 'static' members, indicating procedural construction #loc
singleton.problem.descriptor=Class <code>#ref</code> is a singleton #loc
final.private.method.problem.descriptor='private' method declared <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=No-op Method <code>#ref()</code> should be made abstract #loc
final.static.method.problem.descriptor='static' method declared <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> has no no-arg constructor #loc
multiple.top.level.classes.in.file.problem.descriptor=Multiple top level classes in file
class.name.differs.from.file.name.problem.descriptor=Class name <code>#ref</code> differs from file name #loc
marker.interface.problem.descriptor=Marker interface <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=Field <code>#ref</code> has setter but no getter #loc
abstract.class.never.implemented.problem.descriptor=Abstract class <code>#ref</code> has no concrete subclass #loc
interface.never.implemented.problem.descriptor=Interface <code>#ref</code> has no concrete subclass #loc
missing.deprecated.annotation.problem.descriptor=Missing '@Deprecated' annotation on <code>#ref()</code> #loc
missing.override.annotation.problem.descriptor=Missing '@Override' annotation on <code>#ref()</code> #loc
non.thread.safe.lazy.initialization.problem.descriptor=Lazy initialization of 'static' field <code>#ref</code> is not thread-safe #loc
empty.catch.block.problem.descriptor=Empty <code>#ref</code> block #loc
unused.catch.parameter.problem.descriptor=Unused 'catch' parameter <code>#ref</code> #loc
used.catch.parameter.named.ignore.problem.descriptor='catch' parameter named <code>#ref</code> is used #loc
empty.finally.block.problem.descriptor=Empty <code>#ref</code> block #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> block can not complete normally #loc
empty.try.block.problem.descriptor=Empty <code>#ref</code> block #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
throw.caught.locally.problem.descriptor=<code>#ref</code> caught by containing 'try' statement #loc
throw.caught.locally.ignore.option=Ignore rethrown exceptions
return.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
bad.exception.declared.problem.descriptor=Prohibited exception <code>#ref</code> declared. #loc
bad.exception.caught.problem.descriptor=Prohibited exception <code>#ref</code> caught. #loc
checked.exception.class.problem.descriptor=Checked exception class <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=Unchecked exception class <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=<code>#ref</code> not rethrown #loc
error.rethrown.problem.descriptor=Error <code>#ref</code> not rethrown #loc
nested.try.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> inside 'catch' block ignores the caught exception #loc
instanceof.catch.parameter.problem.descriptor='instanceof' on 'catch' parameter <code>#ref</code> #loc
non.final.field.of.exception.problem.descriptor=Non-final field <code>#ref</code> of exception class #loc
unnecessary.label.on.break.statement.problem.descriptor=Unnecessary label on <code>#ref</code> statement #loc
unnecessary.label.on.continue.statement.problem.descriptor=Unnecessary label on <code>#ref</code> statement #loc
trivial.if.problem.descriptor=<code>#ref</code> statement can be simplified #loc
constant.if.statement.problem.descriptor=<code>#ref</code> statement can be simplified #loc
unnecessary.parentheses.problem.descriptor=Parentheses around <code>#ref</code> are unnecessary #loc
unnecessary.local.variable.problem.descriptor=Local variable <code>#ref</code> is redundant #loc
unnecessary.this.problem.descriptor=<code>#ref</code> is unnecessary in this context #loc
unnecessary.block.statement.problem.descriptor=Braces around this statement are unnecessary #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> is unnecessary as the last statement in a loop #loc
unnecessary.semicolon.problem.descriptor=Unnecessary semicolon <code>#ref</code> #loc
unnecessary.fully.qualified.name.problem.descriptor1=Fully qualified name <code>#ref</code> is unnecessary, and can be replaced with an import #loc
unnecessary.fully.qualified.name.problem.descriptor2=Fully qualified name <code>#ref</code> is unnecessary, and the qualification can be removed #loc
unnecessary.qualifier.for.this.problem.descriptor=Qualifier <code>#ref</code> on 'this' is unnecessary in this context #loc
unused.label.problem.descriptor=Unused label <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=Field initialization to <code>#ref</code> is redundant #loc
redundant.implements.problem.descriptor=Redundant interface declaration <code>#ref</code> #loc
extends.object.problem.descriptor=Class <code>#ref</code> explicitly extends 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=Type parameter <code>#ref</code> explicitly extends 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=Wildcard type argument <code>#ref</code> explicitly extends 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> is unnecessary #loc
unnecessary.constructor.problem.descriptor=No-arg constructor <code>#ref()</code> is redundant #loc
unnecessary.constructor.annotation.option=Ignore constructors with an annotation
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> loop statement may be replace by 'while' loop #loc
unnecessary.default.problem.descriptor=<code>#ref</code> branch is unnecessary #loc
unnecessary.boxing.problem.descriptor=Unnecessary boxing <code>#ref</code> #loc
unnecessary.unboxing.problem.descriptor=Unnecessary unboxing <code>#ref</code> #loc
for.can.be.foreach.problem.descriptor=<code>#ref</code> loop replaceable with 'for each' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> loop replaceable with 'for each' #loc
too.broad.scope.problem.descriptor=Scope of variable <code>#ref</code> is too broad #loc
return.this.problem.descriptor=Return of <code>#ref</code> #loc
constant.on.lhs.of.comparison.problem.descriptor=<code>#ref</code>: constant on left side of comparison #loc
constant.on.rhs.of.comparison.problem.descriptor=<code>#ref</code>: constant on right side of comparison #loc
control.flow.statement.without.braces.problem.descriptor=<code>#ref</code> without braces #loc
missorted.modifiers.problem.descriptor=Missorted modifiers <code>#ref</code> #loc
c.style.array.declaration.problem.descriptor=C-style array declaration <code>#ref</code> #loc
multiple.declaration.problem.descriptor=Multiple variables in one declaration #loc
multiple.typed.declaration.problem.descriptor=Variables of different types in one declaration #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=Inner class <code>#ref</code> does not define a 'serialVersionUID' field #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=Inner class <code>#ref</code> is serializable while its outer class is not #loc
busy.wait.problem.descriptor=Call to <code>Thread.#ref()</code> in a loop, probably busy-waiting #loc
sleep.while.holding.lock.problem.descriptor=Call to <code>Thread.#ref()</code> while synchronized #loc
non.atomic.operation.on.volatile.field.problem.descriptor=Non-atomic operation on volatile field <code>#ref</code> #loc
call.to.native.method.while.locked.problem.descriptor=Call to native method <code>#ref()</code> in a synchronized context #loc
object.notify.problem.descriptor=<code>#ref</code> should probably be replaced with 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> should probably be replaced with 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=Instantiating a <code>#ref</code> with default 'run()' method #loc
extends.thread.problem.descriptor=Class <code>#ref</code> explicitly extends 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=Anonymous class explicitly extends 'java.lang.Thread' #loc
naked.notify.problem.descriptor=Call to <code>#ref()</code> without corresponding state change #loc
unconditional.wait.problem.descriptor=Unconditional call to <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=Call to <code>System.#ref()</code> #loc
thread.priority.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
thread.yield.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> loop spins on field #loc
wait.not.in.loop.problem.descriptor=Call to <code>#ref()</code> is not made in a loop #loc
await.not.in.loop.problem.descriptor=Call to <code>#ref()</code> is not made in a loop #loc
wait.called.on.condition.problem.descriptor=Call to <code>#ref()</code> on Condition object #loc
notify.called.on.condition.problem.descriptor=Call to <code>#ref()</code> on Condition object #loc
wait.not.in.synchronized.context.problem.descriptor=Call to <code>#ref</code> while not synchronized on ''{0}'' #loc
wait.while.holding.two.locks.problem.descriptor=Call to <code>#ref()</code> is made while holding two locks #loc
notify.not.in.synchronized.context.problem.descriptor=Call to <code>#ref()</code> is made outside of a synchronized context #loc
thread.run.problem.descriptor=Calls to <code>#ref()</code> should probably be replaced with 'start()' #loc
thread.start.in.construction.problem.descriptor=Call to <code>#ref</code> during object construction #loc
synchronize.on.lock.problem.descriptor=Synchronization on a ''{0}'' object is unlikely to be intentional #loc
synchronized.on.literal.object.descriptor=Synchronization on {0} <code>#ref</code> which is initialized by a literal #loc
synchronize.on.non.final.field.problem.descriptor=Synchronization on a non-final field <code>#ref</code> #loc
synchronize.on.this.problem.descriptor=Lock operations on 'this' may have unforeseen side-effects #loc
nested.synchronized.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
empty.synchronized.statement.problem.descriptor=Empty <code>#ref</code> statement #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=Unsynchronized method <code>#ref()</code> overrides synchronized method #loc
public.field.accessed.in.synchronized.context.problem.descriptor=Non-private field <code>#ref</code> accessed in synchronized context  #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Field <code>#ref</code> is accessed in both synchronized and unsynchronized contexts #loc
extended.for.statement.problem.descriptor=Extended <code>#ref</code> statement #loc
object.allocation.in.loop.problem.descriptor=Object allocation <code>#ref</code> in loop #loc
instantiating.object.to.get.class.object.problem.descriptor=Instantiating object to get Class object #loc
field.may.be.static.problem.descriptor=Field <code>#ref</code> may be 'static' #loc
method.may.be.static.problem.descriptor=Method <code>#ref()</code> may be 'static' #loc
class.initializer.may.be.static.problem.descriptor=Class initializer may be 'static' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> replaceable with EnumMap #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> replaceable with EnumSet #loc
inner.class.may.be.static.problem.descriptor=Inner class <code>#ref</code> may be 'static' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=<code>#ref</code> without initial capacity #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=StringBuffer <code>#ref</code> may be declared as StringBuilder #loc
string.buffer.replaceable.by.string.problem.descriptor=Constant StringBuffer <code>#ref</code> may be declared as String #loc
string.replaceable.by.string.buffer.problem.descriptor=Non-constant String <code>#ref</code> should probably be declared as StringBuilder #loc
collections.must.have.initial.capacity.problem.descriptor=<code>#ref</code> without initial capacity #loc
string.concatenation.in.loops.problem.descriptor=String concatenation <code>#ref</code> in loop #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=String concatenation as argument to <code>{0}.#ref()</code> call #loc
boolean.constructor.problem.descriptor=Boolean constructor call <code>#ref</code> #loc
string.to.string.problem.descriptor=<code>#ref</code> is redundant #loc
substring.zero.problem.descriptor=<code>#ref</code> is redundant #loc
string.buffer.to.string.in.concatenation.problem.descriptor=Calls to <code>StringBuffer.#ref()</code> in concatenation #loc
tail.recursion.problem.descriptor=Tail recursive call <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> can be replaced with 'length()==0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> can be replaced with 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=Using <code>Random.#ref</code> to create random integer #loc
manual.array.copy.problem.descriptor=Manual array copy #loc
manual.array.to.collection.copy.problem.descriptor=Manual array to collection copy #loc
java.lang.reflect.problem.descriptor=Use of type <code>#ref</code> from 'java.lang.reflect' #loc
call.to.simple.getter.in.class.problem.descriptor=Call to simple getter <code>#ref()</code> from within class #loc
call.to.simple.setter.in.class.problem.descriptor=Call to simple setter <code>#ref()</code> from within class #loc
asserts.without.messages.problem.descriptor=JUnit <code>#ref()</code> without message #loc
test.case.with.constructor.problem.descriptor=Initialization logic in constructor <code>#ref()</code> instead of 'setUp()' #loc
test.case.with.constructor.problem.descriptor.initializer=Initialization logic in initializer instead of 'setUp()'
misspelled.set.up.problem.descriptor=<code>#ref()</code> probably be 'setUp()' #loc
misordered.assert.equals.parameters.problem.descriptor=Parameters to <code>#ref()</code> in wrong order #loc
misspelled.tear.down.problem.descriptor=<code>#ref()</code> method should probably be 'tearDown()' #loc
static.suite.problem.descriptor=JUnit <code>#ref()</code> methods not declared 'static' #loc
setup.calls.super.setup.problem.descriptor=<code>#ref()</code> does not call 'super.setUp()' #loc
teardown.calls.super.teardown.problem.descriptor=<code>#ref()</code> does not call 'super.tearDown()' #loc
setup.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> can be simplified to ''{0}'' #loc
teardown.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature #loc
test.method.without.assertion.problem.descriptor=JUnit test method <code>#ref()</code> contains no assertions #loc
test.case.with.no.test.methods.problem.descriptor=JUnit test case <code>#ref</code> has no tests #loc
test.case.in.product.code.problem.descriptor=Test case <code>#ref</code> should probably be placed in a test source tree #loc
test.method.in.product.code.problem.descriptor=Test method <code>.#ref()</code> should probably be placed in a test source tree #loc
unconstructable.test.case.problem.descriptor=Test case <code>#ref</code> is unusable by most test runners #loc
deserializable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be deserialized, compromising security #loc
serializable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be serialized, compromising security #loc
cloneable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be cloned, compromising security #loc
non.final.clone.problem.descriptor=Non-final <code>#ref()</code> method, compromising security #loc
non.static.inner.class.in.secure.context.problem.descriptor=Non-'static' inner class <code>#ref</code>, compromising security #loc
runtime.exec.with.non.constant.string.problem.descriptor=Call to <code>Runtime.#ref()</code> with non-constant argument #loc
load.library.with.non.constant.string.problem.descriptor=Call to <code>System.#ref()</code> with non-constant argument #loc
jdbc.execute.with.non.constant.string.problem.descriptor=Call to <code>Statement.#ref()</code> with non-constant argument #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Call to <code>Connection.#ref()</code> with non-constant argument #loc
custom.classloader.problem.descriptor=Custom ClassLoader class <code>#ref</code> #loc
custom.security.manager.problem.descriptor=Custom SecurityManager class <code>#ref</code> #loc
system.set.problem.descriptor=Call to <code>System.#ref()</code> may pose security concerns #loc
class.loader.instantiation.problem.descriptor=Instantiation of <code>#ref</code> may pose security concerns #loc
public.static.array.field.problem.descriptor='public static' array field <code>#ref</code>, compromising security #loc
public.static.collection.field.problem.descriptor='public static' collection field <code>#ref</code>, compromising security #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=Abstract class <code>#ref</code> has only one direct inheritor #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=Remove redundant abstract method declaration
class.may.be.interface.convert.quickfix=Convert class to interface
class.without.constructor.create.quickfix=Create empty constructor
class.without.no.arg.constructor.ignore.option=Ignore if class has default constructor
extends.annotation.problem.descriptor=Class ''{0}'' explicitly extends annotation interface <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=Class <code>#ref</code> explicitly extends ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=Anonymous class explicitly extends ''{0}'' #loc
inner.class.on.interface.ignore.option=Ignore inner interfaces of interfaces
inner.class.on.interface.problem.descriptor=Interface ''{0}'' has inner class <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=Add @Deprecated annotation
missing.override.annotation.add.quickfix=Add @Override annotation
non.protected.constructor.in.abstract.class.ignore.option=Ignore for non-public classes
public.constructor.in.non.public.class.problem.descriptor=Constructor is declared <code>#ref</code> in non-public class ''{0}'' #loc
static.inheritance.replace.quickfix=Replace inheritance with qualified references in {0}
utility.class.with.public.constructor.make.quickfix=Make {0, choice, 1#constructor|2#constructors} private
utility.class.without.private.constructor.create.quickfix=Create empty private constructor
utility.class.without.private.constructor.make.quickfix=Make constructor private
annotation.naming.convention.problem.descriptor.short=Annotation name <code>#ref</code> is too short #loc
annotation.naming.convention.problem.descriptor.long=Annotation name <code>#ref</code> is too long #loc
annotation.naming.convention.problem.descriptor.regex.mismatch=Annotation name <code>#ref</code> doesn''t match regex ''{0}'' #loc
class.name.convention.problem.descriptor.short=Class name <code>#ref</code> is too short #loc
class.name.convention.problem.descriptor.long=Class name <code>#ref</code> is too long #loc
class.name.convention.problem.descriptor.regex.mismatch=Class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
constant.naming.convention.problem.descriptor.short=Constant name <code>#ref</code> is too short #loc
constant.naming.convention.problem.descriptor.long=Constant name <code>#ref</code> is too long #loc
constant.naming.convention.problem.descriptor.regex.mismatch=Constant <code>#ref</code> doesn''t match regex ''{0}'' #loc
constant.naming.convention.immutables.option=Only check 'static final' fields with immutable types
convention.pattern.option=Pattern:
convention.min.length.option=Min length:
convention.max.length.option=Max length:
enumerated.class.naming.convention.problem.descriptor.short=Enumerated class name <code>#ref</code> is too short #loc
enumerated.class.naming.convention.problem.descriptor.long=Enumerated class name <code>#ref</code> is too long #loc
enumerated.class.naming.convention.problem.descriptor.regex.mismatch=Enumerated class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
enumerated.constant.naming.convention.problem.descriptor.short=Enumerated constant name <code>#ref</code> is too short #loc
enumerated.constant.naming.convention.problem.descriptor.long=Enumerated constant name <code>#ref</code> is too long #loc
enumerated.constant.naming.convention.problem.descriptor.regex.mismatch=Enumerated constant <code>#ref</code> doesn''t match regex ''{0}'' #loc
instance.method.name.convention.problem.descriptor.short=Instance method name <code>#ref</code> is too short #loc
instance.method.name.convention.problem.descriptor.long=Instance method name <code>#ref</code> is too long #loc
instance.method.name.convention.problem.descriptor.regex.mismatch=Instance method name <code>#ref</code> doesn''t match regex ''{0}'' #loc
instance.variable.name.convention.problem.descriptor.short=Instance field name <code>#ref</code> is too short #loc
instance.variable.name.convention.problem.descriptor.long=Instance field name <code>#ref</code> is too long #loc
instance.variable.name.convention.problem.descriptor.regex.mismatch=Instance field <code>#ref</code> doesn''t match regex ''{0}'' #loc
interface.name.convention.problem.descriptor.short=Interface name <code>#ref</code> is too short #loc
interface.name.convention.problem.descriptor.long=Interface name <code>#ref</code> is too long #loc
interface.name.convention.problem.descriptor.regex.mismatch=Interface name <code>#ref</code> doesn''t match regex ''{0}'' #loc
junit.abstract.test.class.naming.convention.problem.descriptor.short=Abstract JUnit test class name <code>#ref</code> is too short #loc
junit.abstract.test.class.naming.convention.problem.descriptor.long=Abstract JUnit test class name <code>#ref</code> is too long #loc
junit.abstract.test.class.naming.convention.problem.descriptor.regex.mismatch=Abstract JUnit test class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
junit.test.class.naming.convention.problem.descriptor.short=JUnit test class name <code>#ref</code> is too short #loc
junit.test.class.naming.convention.problem.descriptor.long=JUnit test class name <code>#ref</code> is too long #loc
junit.test.class.naming.convention.problem.descriptor.regex.mismatch=JUnit test class name <code>#ref</code> doesn''t match regex ''{0}'' #loc
local.variable.naming.convention.problem.descriptor.short=Local variable name <code>#ref</code> is too short #loc
local.variable.naming.convention.problem.descriptor.long=Local variable name <code>#ref</code> is too long #loc
local.variable.naming.convention.problem.descriptor.regex.mismatch=Local variable name <code>#ref</code> doesn''t match regex ''{0}'' #loc
local.variable.naming.convention.ignore.option=Ignore for-loop parameters
local.variable.naming.convention.ignore.catch.option=Ignore 'catch' block parameters
method.names.differ.only.by.case.problem.descriptor=Method names <code>#ref</code> and ''{0}'' differ only by case #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignore if overridden parameter contains only one character
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignore if overridden parameter is from a library
parameter.name.differs.from.overridden.parameter.problem.descriptor=Parameter name <code>#ref</code> is different from parameter ''{0}'' overridden #loc
parameter.naming.convention.problem.descriptor.short=Parameter name <code>#ref</code> is too short #loc
parameter.naming.convention.problem.descriptor.long=Parameter name <code>#ref</code> is too long #loc
parameter.naming.convention.problem.descriptor.regex.mismatch=Parameter name <code>#ref</code> doesn''t match regex ''{0}'' #loc
questionable.name.column.title=Name
standard.variable.names.problem.descriptor=Variable named <code>#ref</code> doesn''t have type ''{0}'' #loc
standard.variable.names.problem.descriptor2=Variable named <code>#ref</code> doesn''t have type ''{0}'' or ''{1}'' #loc
standard.variable.names.ignore.override.option=Ignore for parameter names identical to super method parameters
static.method.naming.convention.problem.descriptor.short='static' method name <code>#ref</code> is too short #loc
static.method.naming.convention.problem.descriptor.long='static' method name <code>#ref</code> is too long #loc
static.method.naming.convention.problem.descriptor.regex.mismatch='static' method name <code>#ref</code> doesn''t match regex ''{0}'' #loc
static.variable.naming.convention.problem.descriptor.short='static' field name <code>#ref</code> is too short #loc
static.variable.naming.convention.problem.descriptor.long='static' field name <code>#ref</code> is too long #loc
static.variable.naming.convention.problem.descriptor.regex.mismatch='static' field <code>#ref</code> doesn''t match regex ''{0}'' #loc
static.variable.naming.convention.mutable.option=Check 'static final' fields with a mutable type
type.parameter.naming.convention.problem.descriptor.short=Type parameter name <code>#ref</code> is too short #loc
type.parameter.naming.convention.problem.descriptor.long=Type parameter name <code>#ref</code> is too long #loc
boolean.method.name.must.start.with.question.table.column.name=Boolean method name prefix
conditional.expression.with.identical.branches.collapse.quickfix=Collapse conditional expression
confusing.else.unwrap.quickfix=Remove redundant 'else'
constant.conditional.expression.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=Simplify
enum.switch.statement.which.misses.cases.problem.descriptor=<code>#ref</code> statement on enumerated type ''{0}'' misses cases #loc
for.loop.replaceable.by.while.ignore.option=Ignore 'infinite' for loops without conditions
for.loop.replaceable.by.while.replace.quickfix=Replace with 'while'
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> statement lacks initializer #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> statement lacks condition #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> statement lacks update #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> statement lacks initializer and condition #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> statement lacks initializer and update #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> statement lacks condition and update #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> statement lacks initializer, condition and update #loc
if.statement.with.identical.branches.collapse.quickfix=Collapse 'if' statement
foreach.replace.quickfix=Replace with 'for each'
unnecessary.boxing.remove.quickfix=Remove boxing
unnecessary.unboxing.remove.quickfix=Remove unboxing
misordered.assert.equals.parameters.flip.quickfix=Flip compared parameters
setup.calls.super.setup.add.quickfix=Add call to 'super.setUp()'
simplify.junit.assertion.simplify.quickfix=Simplify assertion
teardown.calls.super.teardown.add.quickfix=Add call to 'super.tearDown()'
test.method.is.public.void.no.arg.problem.descriptor1=Test method <code>#ref()</code> should probably not have parameters #loc
test.method.is.public.void.no.arg.problem.descriptor2=Test method <code>#ref()</code> is not declared 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=Test method <code>#ref()</code> should not be 'static' #loc
system.properties.problem.descriptor=Call to <code>Integer.#ref()</code> may pose security concerns #loc
system.properties.problem.descriptor1=Call to <code>Boolean.#ref()</code> may pose security concerns #loc
unsecure.random.number.generation.problem.descriptor1=For security purposes, use 'java.security.SecureRandom' instead of <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=For security purposes, use 'java.security.SecureRandom' instead of <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=For security purposes, use 'java.security.SecureRandom' instead of <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=Serializable class <code>#ref</code> does not define 'readObject()' or 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=Serializable class <code>#ref</code> does not define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=Serializable class <code>#ref</code> does not define 'readObject()' #loc
serializable.has.serialization.methods.ignore.option=Ignore classes serializable due to inheritance
serializable.inner.class.has.serial.version.uid.field.ignore.option=Ignore classes serializable due to inheritance
serializable.inner.class.with.non.serializable.outer.class.ignore.option=Ignore classes serializable due to inheritance
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> has an non-serializable ancestor ''{0}'' without a no-arg constructor #loc
transient.field.in.non.serializable.class.problem.descriptor=Field ''{0}'' is marked <code>#ref</code>, in non-Serializable class #loc
transient.field.in.non.serializable.class.remove.quickfix=Remove 'transient'
condition.signal.replace.quickfix=Replace with 'signalAll()'
object.notify.replace.quickfix=Replace with 'notifyAll()'
safe.lock.problem.descriptor=''{0}'' should be locked in front of a ''try'' block and unlocked in the corresponding ''finally'' block #loc
synchronized.method.problem.descriptor=Method ''{0}()'' declared <code>#ref</code> #loc
synchronized.method.include.option=Include native methods
synchronized.method.move.quickfix=Move synchronization into method
thread.run.replace.quickfix=Replace with 'start()'
volatile.field.problem.descriptor=Volatile field <code>#ref</code> of type ''{0}'' #loc
exception.class.column.name=Exception class
bad.exception.thrown.problem.descriptor=Prohibited exception ''{0}'' thrown #loc
empty.catch.block.comments.option=Comments count as content
empty.catch.block.ignore.option=Ignore empty 'catch' blocks in tests
empty.catch.block.ignore.ignore.option=Ignore for 'catch' parameters named 'ignore' or 'ignored'
too.broad.catch.problem.descriptor=''catch'' of <code>#ref</code> is too broad, masking exception ''{0}'' #loc
too.broad.catch.problem.descriptor1=''catch'' of <code>#ref</code> is too broad, masking exceptions ''{0}'' and ''{1}'' #loc
unused.catch.parameter.ignore.catch.option=Ignore for 'catch' blocks containing comments
unused.catch.parameter.ignore.empty.option=Ignore unused 'catch' parameters in tests
add.serialversionuidfield.quickfix=Add 'serialVersionUID' field
delete.import.quickfix=Delete unnecessary import
encapsulate.variable.quickfix=Encapsulate field ''{0}''
extract.method.quickfix=Extract method
inline.call.quickfix=Inline call
inline.variable.quickfix=Inline variable
pointless.nullcheck.display.name=Pointless 'null' check
pointless.nullcheck.problem.descriptor=Pointless 'null' check can be removed
pointless.nullcheck.simplify.quickfix=Simplify
introduce.constant.quickfix=Introduce constant
make.class.cloneable.quickfix=Make class 'Cloneable'
make.interface.cloneable.quickfix=Make interface 'Cloneable'
make.initialization.explicit.quickfix=Make initialization explicit
make.class.serializable.quickfix=Make class 'Serializable'
move.anonymous.to.inner.quickfix=Convert to named inner class
anonymous.inner.may.be.named.static.inner.class.quickfix=Convert to named 'static' inner class
move.class.quickfix=Move class
normalize.declaration.quickfix=Split into multiple declarations
remove.modifier.quickfix=Remove ''{0}'' modifier
replace.inheritance.with.delegation.quickfix=Replace inheritance with delegation
big.decimal.equals.replace.quickfix=Replace with 'compareTo()==0'
cast.that.loses.precision.problem.descriptor=Cast to <code>#ref</code> from ''{0}'' may result in loss of precision #loc
comparison.to.nan.problem.descriptor1=Comparison to <code>#ref</code> is always false #loc
comparison.to.nan.problem.descriptor2=Comparison to <code>#ref</code> is always true #loc
comparison.to.nan.replace.quickfix=Replace with 'isNaN()'
confusing.floating.point.literal.change.quickfix=Change To canonical form
implicit.numeric.conversion.ignore.widening.conversion.option=Ignore widening conversions
implicit.numeric.conversion.ignore.char.conversion.option=Ignore conversions from and to char
implicit.numeric.conversion.ignore.constant.conversion.option=Ignore conversions from constants and literals
implicit.numeric.conversion.problem.descriptor=Implicit numeric conversion of <code>#ref</code> from ''{0}'' to ''{1}'' #loc
implicit.numeric.conversion.convert.quickfix=Convert to ''{0}'' literal
implicit.numeric.conversion.make.explicit.quickfix=Make conversion explicit
long.literals.ending.with.lowercase.l.replace.quickfix=Replace 'l' with 'L'
non.reproducible.math.call.replace.quickfix=Replace with 'StrictMath' call
overly.complex.arithmetic.expression.max.number.option=Maximum number of terms:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> can be replaced with ''{0}'' #loc
method.complexity.limit.option=Method complexity limit:
cyclomatic.complexity.problem.descriptor=<code>#ref</code> is overly complex (cyclomatic complexity = {0}) #loc
method.coupling.limit.option=Method coupling limit:
method.coupling.problem.descriptor=<code>#ref</code> is overly coupled (# referenced classes = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contains {0} loops #loc
return.point.limit.option=&Return point limit:
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> has {0} return points #loc
nesting.depth.limit.option=Nesting depth limit:
nesting.depth.problem.descriptor=<code>#ref</code> is overly nested (maximum nesting depth = {0}) #loc
non.comment.source.statements.limit.option=Non-comment source statements limit:
non.comment.source.statements.problem.descriptor=<code>#ref</code> is too long (# Non-comment source statements = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> has too many parameters (num parameters = {0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> has too many parameters (num parameters = {0}) #loc
parameter.limit.option=Parameter limit:
three.negations.per.method.ignore.option=Ignore negations in 'equals()' methods
three.negations.per.method.problem.descriptor=<code>#ref</code> contains {0} negations #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> has too many exceptions declared (num exceptions = {0}) #loc
thrown.exceptions.per.method.limit.option=Exceptions thrown limit:
call.to.simple.getter.in.class.ignore.option=Ignore getter calls on other objects
call.to.private.simple.getter.in.class.option=Only report getter is private
call.to.simple.getter.in.class.inline.quickfix=Inline call to getter
call.to.simple.setter.in.class.ignore.option=Ignore setter calls on other objects
call.to.private.setter.in.class.option=Only report when setter is private
call.to.simple.setter.in.class.inline.quickfix=Inline call to setter
make.static.quickfix=Make static
length.one.strings.in.concatenation.replace.quickfix=Replace with character
multiply.or.divide.by.power.of.two.replace.quickfix=Replace with shift
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
boolean.expression.can.be.simplified.polyadic.problem.descriptor=<code>#ref</code> can be simplified #loc
trivial.string.concatenation.problem.descriptor=Empty string used in concatenation
string.replace.quickfix=Replace concatenation with ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=Replace with direct class object access
manual.array.copy.replace.quickfix=Replace with 'System.arrayCopy()'
manual.array.to.collection.copy.replace.quickfix=Replace with 'Collections.addAll(...,...)'
method.may.be.static.only.option=Only check private or final methods
method.may.be.static.empty.option=Ignore empty methods
random.double.for.random.integer.replace.quickfix=Replace with 'nextInt()'
string.buffer.replaceable.by.string.builder.replace.quickfix=Replace with StringBuilder
string.buffer.to.string.in.concatenation.remove.quickfix=Remove 'toString()'
string.concatenation.in.loops.only.option=Only warn if string is repeatedly appended
string.concatenation.inside.string.buffer.append.replace.quickfix=Replace with chained 'append()' calls
string.equals.empty.string.replace.quickfix=Replace with 'length()==0'
string.equals.empty.string.replace.quickfix2=Replace with 'isEmpty()'
tail.recursion.replace.quickfix=Replace tail recursion with iteration
if.statement.with.too.many.branches.max.option=Maximum number of branches:
if.statement.with.too.many.branches.problem.descriptor='<code>#ref</code>' has too many branches ({0}) #loc
negated.conditional.ignore.option=Ignore '!= null' comparisons
negated.conditional.invert.quickfix=Invert condition
negated.if.else.ignore.option=Ignore '!= null' comparisons
negated.if.else.invert.quickfix=Invert If Condition
overly.complex.boolean.expression.max.terms.option=Maximum number of terms:
pointless.boolean.expression.ignore.option=Ignore named constant in determining pointless expressions
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
simplifiable.if.statement.problem.descriptor=<code>#ref</code> statement can be replaced with ''{0}'' #loc
switch.statement.density.min.option=Minimum density of branches: %
switch.statement.density.problem.descriptor='<code>#ref</code>' has too low of a branch density ({0}%) #loc
switch.statement.with.too.few.branches.min.option=Minimum number of branches:
switch.statement.with.too.few.branches.problem.descriptor='<code>#ref</code>' has too few branches ({0}), and should probably be replaced with an ''if'' statement #loc
switch.statement.without.default.ignore.option=Ignore if all cases of an enumerated type are covered
unnecessary.label.remove.quickfix=Remove label
unnecessary.return.problem.descriptor=<code>#ref</code> is unnecessary as the last statement in a constructor #loc
unnecessary.return.problem.descriptor1=<code>#ref</code> is unnecessary as the last statement in a method returning 'void' #loc
unused.label.remove.quickfix=Remove unused label
unnecessarily.qualified.static.usage.problem.descriptor=Unnecessarily qualified static method call <code>#ref()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Unnecessarily qualified static access <code>#ref</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=Ignore unnecessarily qualified field accesses
unnecessarily.qualified.static.usage.ignore.method.option=Ignore unnecessarily qualified method calls
unnecessary.interface.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for interfaces #loc
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor=Modifier <code>#ref</code> is redundant for inner interfaces of interfaces #loc
unnecessary.interface.modifier.inner.interface.of.class.problem.descriptor=Modifier <code>#ref</code> is redundant for inner interfaces of classes #loc
unnecessary.interface.modifier.problem.descriptor2=Modifier <code>#ref</code> is redundant for interface methods #loc
unnecessary.interface.modifier.problem.descriptor3=Modifier <code>#ref</code> is redundant for inner classes of interfaces #loc
unnecessary.interface.modifier.problem.descriptor4=Modifier <code>#ref</code> is redundant for interface fields #loc
smth.unnecessary.remove.quickfix=Remove unnecessary ''{0}''
unqualified.static.usage.problem.descriptor=Unqualified static method call <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Unqualified static field access <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=Ignore unqualified field accesses
unqualified.static.usage.ignore.method.option=Ignore unqualified method calls
unqualified.static.usage.qualify.field.quickfix=Qualify static field access
unqualified.static.usage.qualify.method.quickfix=Qualify static method call
too.broad.scope.allow.option=<html>Allow initializer of variables to construct objects.<br>(Potentially unsafe: quick fix may modify semantics if the constructor has non-local side-effects)</html>
too.broad.scope.only.blocks.option=Only report variables that can be moved into inner blocks
too.broad.scope.narrow.quickfix=Narrow scope of ''{0}''
press.escape.to.remove.highlighting.message=Press Escape to remove the highlighting
unnecessary.enum.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for enum constructors #loc
unnecessary.enum.modifier.problem.descriptor1=Modifier <code>#ref</code> is redundant for inner enums #loc
literal.as.arg.to.string.equals.problem.descriptor=<code>#ref</code> is argument of ''{0}()'', instead of its target #loc
literal.as.arg.to.string.equals.flip.quickfix=Flip 'equals()'
c.style.array.declaration.replace.quickfix=Replace with Java-style array declaration
chained.method.call.ignore.option=Ignore chained method calls in field initializers
chained.method.call.ignore.this.super.option=Ignore chained method calls in 'this()' and 'super()' calls
introduce.variable.quickfix=Introduce variable
flip.comparison.quickfix=Flip comparison
control.flow.statement.without.braces.add.quickfix=Add braces
extends.object.remove.quickfix=Remove redundant 'extends Object'
implicit.call.to.super.ignore.option=Ignore for direct subclasses of 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Make call to 'super()' explicit
missorted.modifiers.require.option=Require annotations to be sorted before keywords
missorted.modifiers.sort.quickfix=Sort modifiers
nested.method.call.ignore.option=Ignore nested method calls in field initializers
redundant.field.initialization.remove.quickfix=Remove initializer
redundant.implements.remove.quickfix=Remove redundant interface declaration
unnecessary.constructor.remove.quickfix=Remove redundant constructor
unnecessary.fully.qualified.name.ignore.option=Ignore fully qualified names in javadoc
unnecessary.fully.qualified.name.replace.quickfix=Replace with import
unnecessary.fully.qualified.name.remove.quickfix=Remove qualification
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message1=1 fully qualified name replaced with import (press Escape to remove highlighting)
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message2={0} fully qualified names replaced with import (press Escape to remove highlighting)
unnecessary.parentheses.remove.quickfix=Remove unnecessary parentheses
unnecessary.qualifier.for.this.remove.quickfix=Remove unnecessary qualifier
unnecessary.semicolon.remove.quickfix=Remove unnecessary semicolon
unnecessary.super.constructor.remove.quickfix=Remove unnecessary 'super()'
unnecessary.this.remove.quickfix=Remove unnecessary 'this.'
overly.strong.type.cast.problem.descriptor=Cast to <code>#ref</code> can be weakened to ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Include constant fields in count
field.count.inspection.static.final.fields.count.as.constant.checkbox='static final' fields count as constant
make.method.final.fix.name=Make method ''{0}()'' final
make.class.final.fix.name=Make class ''{0}'' final
non.boolean.method.name.must.not.start.with.question.display.name=Non-boolean method name must not start with question word
non.boolean.method.name.must.not.start.with.question.problem.descriptor=Non-boolean method name <code>#ref</code> starts with a question word #loc
boolean.constructor.simplify.quickfix=Simplify
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc can be simplified to ''{0}''
# 0 - replacement exception
unnecessary.temporary.on.conversion.from.string.fix.name=Replace with ''{0}''
only.report.qualified.static.usages.option=Only report qualified static access from a static context
unqualified,static.usage.only.report.static.usages.option=Only report static access from a non-static context
create.documentation.count.inspections.message={0} Inspections
create.documentation.count.quick.fixes.message={0} Quick Fixes
create.documentation.couldn.t.instantiate.class=Couldn''t instantiate {0}
create.documentation.couldnt.access.class=Couldn''t access {0}
create.documentation.couldnt.cast.class=Couldn''t cast {0}
create.documentation.inspections.enabled.by.default.message=Inspections enabled by default:
create.documentation.couldnt.find.documentation.file.error.message=Couldn''t find documentation file: {0}
create.documentation.unused.documentation.file.error.message=Unused documentation file: {0}
assignment.to.catch.block.parameter.problem.descriptor=Assignment to 'catch' block parameter <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=Assignment to method parameter <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=Value of post-increment expression <code>#ref</code> is used #loc
value.of.post.decrement.problem.descriptor=Value of post-decrement expression <code>#ref</code> is used #loc
value.of.pre.increment.problem.descriptor=Value of pre-increment expression <code>#ref</code> is used #loc
value.of.pre.decrement.problem.descriptor=Value of pre-decrement expression <code>#ref</code> is used #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> could be simplified to ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignore conditional operators
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignore the obscure ^ and % operators
assignment.replaceable.with.operator.replace.quickfix=Replace '=' with ''{0}=''
button.add=&Add
button.delete=Delete
button.reset=Reset
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignore '==' between objects of a type with only private constructors
redundant.method.override.display.name=Method is identical to its super method
redundant.method.override.problem.descriptor=Method <code>#ref()</code> is identical to its super method #loc
redundant.method.override.quickfix=Remove redundant method
refused.bequest.problem.descriptor=Method <code>#ref()</code> ignores defined method in superclass #loc
refused.bequest.ignore.empty.super.methods.option=Ignore empty super methods (degrades performance of this inspection)
overly.complex.boolean.expression.ignore.option=Ignore pure conjunctions and disjunctions
pointless.indexof.comparison.display.name=Pointless 'indexOf()' comparison
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> is always true #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> is always false #loc
reuse.of.local.variable.problem.descriptor=Reuse of local variable <code>#ref</code> #loc
button.remove=&Remove
single.character.startswith.display.name=Single character 'startsWith()' or 'endsWith()'
single.character.startswith.problem.descriptor=Single character <code>#ref()</code> could be replaced with 'charAt()' expression #loc
indexof.replaceable.by.contains.display.name='indexOf()' expression is replaceable with 'contains()'
replace.indexof.with.contains.quickfix=Replace 'indexOf()' with 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=Multiple methods named <code>#ref</code> with the same number of parameters #loc
overloaded.vararg.method.problem.descriptor=Overloaded variable argument method <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=Overloaded variable argument constructor <code>#ref</code> #loc
cached.number.constructor.call.display.name=Number constructor call with primitive argument
cached.number.constructor.call.problem.descriptor=Number constructor call with primitive argument <code>#ref</code> #loc
cached.number.constructor.call.quickfix=Replace with ''{0}.valueOf()'' call
chained.equality.comparisons.problem.descriptor=Chained equality comparison <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=String <code>#ref</code> contains potentially confusing octal escape sequence #loc
field.accessed.synchronized.and.unsynchronized.option=Simple getters and setters are considered field accesses too
method.overrides.package.local.method.display.name=Method overrides package-local method of superclass located in other package
method.overrides.package.local.method.problem.descriptor=Method <code>#ref()</code> overrides a package-local method of a superclass located in another package #loc
suspicious.to.array.call.display.name=Suspicious 'Collections.toArray()' call
suspicious.to.array.call.problem.descriptor=Array of type ''{0}[]'' expected #loc
suspicious.system.arraycopy.display.name=Suspicious 'System.arraycopy()' call
suspicious.system.arraycopy.problem.descriptor1=Parameter 'srcPos' may not be negative #loc
suspicious.system.arraycopy.problem.descriptor2=Parameter 'destPos' may not be negative #loc
suspicious.system.arraycopy.problem.descriptor3=Parameter 'length' may not be negative #loc
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> is not of an array type #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> is not of an array type #loc
suspicious.system.arraycopy.problem.descriptor6=Source parameter type ''{0}'' is not assignable to destination parameter <code>#ref</code> of type ''{1}'' #loc
raw.use.of.parameterized.type.ignore.new.objects.option=Ignore construction of new objects
raw.use.of.parameterized.type.ignore.type.casts.option=Ignore type casts
method.only.used.from.inner.class.display.name=Private method only used from inner class
method.only.used.from.inner.class.problem.descriptor.anonymous.extending=Method <code>#ref()</code>#loc is only used from an anonymous class extending ''{0}'' #loc
method.only.used.from.inner.class.problem.descriptor.anonymous.implementing=Method <code>#ref()</code>#loc is only used from an anonymous class implementing ''{0}'' #loc
method.only.used.from.inner.class.problem.descriptor=Method <code>#ref()</code>#loc is only used from inner class ''{0}'' #loc
method.only.used.from.inner.class.ignore.option=Ignore methods accessed from an &anonymous class
ignore.static.methods.accessed.from.a.non.static.inner.class=Ignore '&static' methods accessed from a non-'static' inner class
only.report.static.methods=&Only report 'static' methods
format.decode.error.requires.both.0.and.1=requires both {0} and {1}
format.decode.any=any
format.decode.date.time=Date/Time
format.decode.char=char
format.decode.integer.type=integer type
format.decode.floating.point=floating point
single.character.startswith.quickfix=Replace with 'charAt()'
interface.never.implemented.option=Ignore interfaces which only declare constants
size.replaceable.by.isempty.display.name='size() == 0' replaceable with 'isEmpty()'
size.replaceable.by.isempty.quickfix=Replace with 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option=Ignore expressions which would be replaced with '!isEmpty()'
loop.condition.not.updated.inside.loop.display.name=Loop variable not updated inside loop
loop.condition.not.updated.inside.loop.problem.descriptor='#ref' is not updated inside loop #loc
utility.class.without.private.constructor.option=Ignore classes with only a main method
super.class.logger.option=Ignore classes with an accessible logger declared in a super class
static.method.only.used.in.one.class.display.name=Static method only used from one other class
static.method.only.used.in.one.class.problem.descriptor=Static method <code>#ref()</code> is only used from class ''{0}'' #loc
static.method.only.used.in.one.class.problem.descriptor.anonymous.implementing=Static method <code>#ref()</code> is only used from an anonymous class implementing ''{0}'' #loc
static.method.only.used.in.one.class.problem.descriptor.anonymous.extending=Static method <code>#ref()</code> is only used from an anonymous class extending ''{0}'' #loc
static.method.only.used.in.one.class.quickfix=Move method
unary.plus.display.name=Unary plus
unary.plus.problem.descriptor=Unary <code>#ref</code> operator #loc
await.without.corresponding.signal.display.name='await()' without corresponding 'signal()'
await.without.corresponding.signal.problem.descriptor=Call to <code>#ref</code> without corresponding <code>signal()</code> or <code>signalAll()</code> #loc
signal.without.corresponding.await.display.name='signal()' without corresponding 'await()'
signal.without.corresponding.await.problem.descriptor=Call to <code>#ref</code> without corresponding <code>await()</code> #loc
wait.without.corresponding.notify.display.name='wait()' without corresponding 'notify()'
wait.without.corresponding.notify.problem.descriptor=Call to <code>#ref</code> without corresponding <code>notify()</code> or <code>notifyAll()</code> #loc
notify.without.corresponding.wait.display.name='notify()' without corresponding 'wait()'
notify.without.corresponding.wait.problem.descriptor=Call to <code>#ref</code> without corresponding <code>wait()</code> #loc
integer.multiplication.implicit.cast.to.long.display.name=Integer multiplication or shift implicitly cast to long
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: integer multiplication or shift implicitly cast to long #loc
integer.multiplication.implicit.cast.to.long.option=<html>Ignore compile time constant expressions which do not overflow</html>
wait.or.await.without.timeout.display.name='wait()' or 'await()' without timeout
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> without timeout #loc
boolean.field.always.negated.display.name=Boolean field always negated on read
boolean.field.always.negated.problem.descriptor=Boolean field {0} is always negated #loc
test.global.display.name=Test Global Inspection
method.return.always.ignored.display.name=Return value of method is always ignored
method.return.always.ignored.problem.descriptor=Return value of method {0} is always ignored #loc
method.return.always.constant.display.name=Method returns per-class constant
method.return.always.constant.problem.descriptor=Method <code>#ref()</code> returns a per-class constant #loc
class.with.too.many.dependencies.display.name=Class with too many dependencies
class.with.too.many.dependencies.problem.descriptor=Class {0} has too many dependencies ({1} > {2}) #loc
class.with.too.many.transitive.dependencies.display.name=Class with too many transitive dependencies
class.with.too.many.transitive.dependencies.problem.descriptor=Class {0} has too many transitive dependencies ({1} > {2}) #loc
class.with.too.many.dependents.display.name=Class with too many dependents
class.with.too.many.dependents.problem.descriptor=Class {0} has too many dependents ({1} > {2}) #loc
class.with.too.many.transitive.dependents.display.name=Class with too many transitive dependents
class.with.too.many.transitive.dependents.problem.descriptor=Class {0} has too many transitive dependencies ({1} > {2}) #loc
class.with.too.many.dependencies.max.option=Maximum number of dependencies
class.with.too.many.dependents.max.option=Maximum number of dependents
class.with.too.many.transitive.dependencies.max.option=Maximum number of transitive dependencies
class.with.too.many.transitive.dependents.max.option=Maximum number of transitive dependents
cyclic.class.dependency.display.name=Cyclic class dependency
cyclic.class.dependency.problem.descriptor=Class {0} is cyclically dependent on {1} other classes #loc
cyclic.package.dependency.display.name=Cyclic package dependency
cyclic.package.dependency.problem.descriptor=Package {0} is cyclically dependent on {1} other packages #loc
class.unconnected.to.package.display.name=Class independent of its package
class.unconnected.to.package.problem.descriptor=Class <code>#ref</code> has no dependencies or dependents in its package #loc
package.with.too.many.classes.display.name=Package with too many classes
package.with.too.many.classes.problem.descriptor=Package {0} contains too many classes ({1} > {2}) #loc
package.with.too.many.classes.max.option=Maximum number of classes
package.with.too.few.classes.display.name=Package with too few classes
package.with.too.few.classes.problem.descriptor=Package {0} contains too few classes ({1} < {2}) #loc
package.with.too.few.classes.min.option=Minimum number of classes
module.with.too.many.classes.display.name=Module with too many classes
module.with.too.many.classes.problem.descriptor=Module {0} contains too many classes ({1} > {2}) #loc
module.with.too.many.classes.max.option=Maximum number of classes
module.with.too.few.classes.display.name=Module with too few classes
module.with.too.few.classes.problem.descriptor=Module {0} contains too few classes ({1} < {2}) #loc
module.with.too.few.classes.min.option=Minimum number of classes
package.in.multiple.modules.display.name=Package with classes in multiple modules
package.in.multiple.modules.problem.descriptor=Package {0} has classes in multiple modules #loc
disjoint.package.display.name=Package with disjoint dependency graph
disjoint.package.problem.descriptor=Package {0} can be decomposed into {1} independent packages #loc
package.naming.convention.display.name=Package naming convention
package.naming.convention.problem.descriptor.short=Package name <code>{0}</code> is too short
package.naming.convention.problem.descriptor.long=Package name <code>{0}</code> is too long
package.naming.convention.problem.descriptor.regex.mismatch=Package name <code>{0}</code> doesn''t match regex ''{1}''
cyclic.class.initialization.display.name=Cyclic class initialization dependency
cyclic.class.initialization.problem.descriptor=Initialization of class {0} is cyclically dependent on {1} other classes #loc
before.or.after.is.public.void.no.arg.display.name=Malformed @Before or @After method
before.or.after.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature for a @Before or @After method #loc
before.class.or.after.class.is.public.static.void.no.arg.display.name=Malformed @BeforeClass or @AfterClass method
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature for a @BeforeClass or @AfterClass method #loc
string.constructor.display.name=Redundant String constructor call
string.constructor.problem.descriptor=<code>#ref</code> is redundant #loc
string.constructor.replace.arg.quickfix=Replace with arg
string.constructor.replace.empty.quickfix=Replace with empty string
string.constructor.substring.parameter.option=Ignore string constructor calls with '.substring()' call parameter
design.for.extension.display.name=Design for extension
design.for.extension.problem.descriptor=Method <code>#ref()</code> may be overridden and its functionality ignored #loc
bad.oddness.display.name=Suspicious test for oddness
bad.oddness.problem.descriptor=Test for oddness <code>#ref</code> will fail on negative values #loc
comparator.not.serializable.display.name=Comparator class not declared Serializable
comparator.not.serializable.problem.descriptor=Comparator class <code>#ref</code> is not declared as Serializable #loc
non.serializable.field.in.serializable.class.display.name=Non-serializable field in a Serializable class
non.serializable.field.in.serializable.class.problem.descriptor=Non-serializable field '#ref' in a Serializable class #loc
non.serializable.object.passed.to.object.stream.display.name=Non-serializable object passed to ObjectOutputStream
non.serializable.object.passed.to.object.stream.problem.descriptor=Non-serializable object passed to ObjectOutputStream #loc
non.serializable.object.bound.to.http.session.display.name=Non-serializable object bound to HttpSession
non.serializable.object.bound.to.http.session.problem.descriptor=Non-serializable object bound to HttpSession #loc
reflection.for.unavailable.annotation.display.name=Reflective access to a source-only annotation
reflection.for.unavailable.annotation.problem.descriptor=Annotation '#ref' is not retained for reflective access #loc
access.to.static.field.locked.on.instance.display.name=Access to static field locked on instance data
access.to.static.field.locked.on.instance.problem.descriptor=Access to static field <code>#ref</code> locked on instance data #loc
make.method.ctr.quickfix=Make method constructor
replace.all.dot.display.name=Call to String.replaceAll(".", ...)
replace.all.dot.problem.descriptor=Call to <code>String.#ref(".", ...)</code> #loc
constant.string.intern.display.name=Call to 'intern()' on String constant
constant.string.intern.problem.descriptor=<code>.#ref()</code> on compile-time constant is unnecessary #loc
constant.string.intern.quickfix=Remove '.intern()'
class.extends.utility.class.display.name=Class extends utility class
class.extends.utility.class.problem.descriptor=Class <code>#ref</code> extends utility class ''{0}'' #loc
public.constructor.in.non.public.class.quickfix=Make constructor ''{0}''
assignment.to.method.parameter.ignore.transformation.option=<html>Ignore if assignment is a transformation of the original parameter</html>
type.parameter.extends.final.class.display.name=Type parameter extends final class
type.parameter.extends.final.class.problem.descriptor1=Type parameter <code>#ref</code> extends final class ''{0}'' #loc
type.parameter.extends.final.class.problem.descriptor2=Wildcard type argument <code>#ref</code> extends final class ''{0}'' #loc
type.parameter.extends.final.class.quickfix=Replace type parameter with actual class
double.negation.display.name=Double negation
double.negation.problem.descriptor=Double negation in <code>#ref</code> #loc
double.negation.quickfix=Remove double negation
exception.from.catch.which.doesntwrap.ignore.option=Ignore if result of exception method call is used
comparable.implemented.but.equals.not.overridden.display.name=Comparable implemented but 'equals()' not overridden
comparable.implemented.but.equals.not.overridden.problem.descriptor=Class <code>#ref</code> implements 'java.lang.Comparable' but does not override 'equals()' #loc
unqualified.field.access.display.name=Instance field access not qualified with 'this'
unqualified.field.access.problem.descriptor=Instance field access <code>#ref</code> is not qualified with 'this' #loc
unqualified.method.access.display.name=Instance method call not qualified with 'this'
unqualified.method.access.problem.descriptor=Instance method call <code>#ref</code> is not qualified with 'this' #loc
add.this.qualifier.quickfix=Add 'this' qualifier
feature.envy.ignore.test.cases.option=Ignore feature envy in tests
while.loop.spins.on.field.ignore.non.empty.loops.option=Only warn if the loop is empty
method.may.be.synchronized.problem.descriptor=Method <code>#ref()</code> with synchronized block could be synchronized method #loc
method.may.be.synchronized.display.name=Method with synchronized block could be synchronized method
method.may.be.synchronized.quickfix=Make method synchronized and remove synchronized block
fallthru.in.switch.statement.quickfix=Add 'break'
law.of.demeter.display.name=Method call violates Law of Demeter
law.of.demeter.problem.descriptor=<code>#ref()</code> call violates Law of Demeter #loc
law.of.demeter.ignore.library.calls.option=Ignore calls on library methods
assertequals.between.inconvertible.types.display.name='assertEquals()' between objects of inconvertible types
assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
enumeration.can.be.iteration.display.name=Enumeration can be iteration
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> can be replaced with ''{0}'' construct #loc
enumeration.can.be.iteration.quickfix=Replace with 'Iterator' construct
equals.hashcode.called.on.url.display.name='equals()' or 'hashCode()' called on java.net.URL object
equals.hashcode.called.on.url.problem.descriptor=Call to <code>#ref()</code> on URL object #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> may contain URL objects #loc
collection.contains.url.display.name=Map or Set may contain java.net.URL objects
implicit.array.to.string.problem.descriptor=Implicit call to 'toString()' on array <code>#ref</code> #loc
explicit.array.to.string.problem.descriptor=Call to '#ref()' on array #loc
implicit.array.to.string.method.call.problem.descriptor=Implicit call to 'toString()' on array returned by call to <code>#ref</code> #loc
implicit.array.to.string.display.name=Call to 'toString()' on array
implicit.array.to.string.quickfix=Wrap with ''{0}'' expression
suspicious.indent.after.control.statement.problem.descriptor=<code>#ref</code> statement has suspicious indentation #loc
suspicious.indent.after.control.statement.display.name=Suspicious indentation after control statement without braces
unpredictable.big.decimal.constructor.call.display.name=Unpredictable BigDecimal constructor call
unpredictable.big.decimal.constructor.call.problem.descriptor=Unpredictable <code>new #ref()</code> call #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignore constructor calls with variable or method call arguments
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignore constructor calls with multiple literals (e.g. 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.quickfix=Replace with ''new BigDecimal("{0}")''
unnecessary.unary.minus.display.name=Unnecessary unary minus
unnecessary.unary.minus.problem.descriptor=Unnecessary unary minus #loc
unnecessary.unary.minus.quickfix=Remove unary minus and invert parent operation sign
make.field.final.quickfix=Make ''{0}'' final
increment.decrement.used.as.expression.quickfix=Extract ''{0}'' to separate statement
ignore.classes.in.hierarchy.column.name=Ignore subclasses of
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignore casts with a matching instanceof expression
return.of.collection.field.quickfix=Replace with ''{0}''
access.to.non.thread.safe.static.field.from.instance.display.name=Non thread-safe static field access
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Access to non thread-safe static field <code>#ref</code> of type ''{0}'' #loc
access.to.non.thread.safe.static.field.from.instance.option.title=Non thread safe classes
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Choose non thread safe class
non.thread.safe.types.column.name=Non Thread-safe Types
transient.field.not.initialized.display.name=Transient field is not initialized on deserialization
transient.field.not.initialized.problem.descriptor=Transient field <code>#ref</code> not initialized on deserialization #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=Call to 'String.concat()' can be replaced with '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=Call to <code>#ref()</code> can be replaced with '+' expression #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Replace 'concat()' call with '+'
new.string.buffer.with.char.argument.display.name=StringBuffer constructor call with 'char' argument
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> with argument of type 'char' #loc
new.string.buffer.with.char.argument.quickfix=Replace char argument with String literal
comparator.method.parameter.not.used.display.name='Comparator.compare()' method does not use parameter
comparator.method.parameter.not.used.problem.descriptor='compare()' parameter <code>#ref</code> is not used #loc
to.array.call.with.zero.length.array.argument.display.name=Call to 'Collection.toArray()' with zero-length array argument
to.array.call.with.zero.length.array.argument.problem.descriptor=Call to <code>#ref()</code> with zero-length array argument ''{0}'' #loc
to.array.call.with.zero.length.array.argument.quickfix=Replace with ''{0}''
throwable.instance.never.thrown.display.name=Throwable instance not thrown
throwable.instance.never.thrown.runtime.exception.problem.descriptor=Runtime exception instance <code>#ref</code> is not thrown #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=Checked exception instance <code>#ref</code> is not thrown #loc
throwable.instance.never.thrown.error.problem.descriptor=Error instance <code>#ref</code> is not thrown #loc
throwable.instance.never.thrown.problem.descriptor=Throwable instance <code>#ref</code> is not thrown #loc
type.may.be.weakened.display.name=Type may be weakened
type.may.be.weakened.problem.descriptor=Type of variable <code>#ref</code> may be weakened to {0} #loc
type.may.be.weakened.method.problem.descriptor=Return type of method <code>#ref</code> may be weakened to {0} #loc
type.may.be.weakened.parameter.problem.descriptor=Type of parameter <code>#ref</code> may be weakened to {0} #loc
type.may.be.weakened.field.problem.descriptor=Type of field <code>#ref</code> may be weakened to {0} #loc
type.may.be.weakened.quickfix=Weaken type to ''{0}''
type.may.be.weakened.ignore.option=Use &righthand type as weakest type in assignments
type.may.be.weakened.collection.method.option=Use &parameterized type of collection for method call arguments
type.may.be.weakened.do.not.weaken.to.object.option=Do not &weaken to 'java.lang.Object'
ignore.guard.clauses.option=Ignore &guard clauses
ignore.for.equals.methods.option=Ignore for '&equals()' methods
caught.exception.immediately.rethrown.display.name=Caught exception is immediately rethrown
caught.exception.immediately.rethrown.problem.descriptor=Caught exception <code>#ref</code> is immediately rethrown #loc
delete.catch.section.quickfix=Delete 'catch' section
remove.try.catch.quickfix=Remove 'try catch' statement
loop.with.implicit.termination.condition.display.name=Loop with implicit termination condition
loop.with.implicit.termination.condition.dowhile.problem.descriptor=<code>#ref-while</code> loop with implicit termination condition #loc
loop.with.implicit.termination.condition.problem.descriptor=<code>#ref</code> loop with implicit termination condition #loc
loop.with.implicit.termination.condition.quickfix=Make condition explicit
ignore.iterator.loop.variables=Ignore java.util.Iterator loop variables
rename.catch.parameter.to.ignored=Rename 'catch' parameter to 'ignored'
unnecessary.super.qualifier.display.name=Unnecessary 'super' qualifier
unnecessary.super.qualifier.problem.descriptor=Qualifier <code>#ref</code> is unnecessary in this context #loc
unnecessary.super.qualifier.quickfix=Remove unnecessary 'super.'
collections.field.access.replaceable.by.method.call.display.name=Collections.EMPTY_* field access replaceable with 'Collections.empty*()' method call
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> replaceable with ''Collections.{0}'' #loc
collections.field.access.replaceable.by.method.call.quickfix=Replace with ''{0}''
synchronization.on.local.variable.or.method.parameter.display.name=Synchronization on local variable or method parameter
synchronization.on.local.variable.problem.descriptor=Synchronization on local variable <code>#ref</code> #loc
synchronization.on.method.parameter.problem.descriptor=Synchronization on method parameter <code>#ref</code> #loc
too.broad.catch.quickfix=Add ''catch'' clause for ''{0}''
too.broad.catch.option=<html>&Only warn on RuntimeException, Exception, Error or Throwable<html>
unnecessary.call.to.string.valueof.display.name=Unnecessary call to 'String.valueOf()'
unnecessary.call.to.string.valueof.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
unnecessary.call.to.string.valueof.quickfix=Replace with ''{0}''
throwable.result.of.method.call.ignored.display.name=Throwable result of method call ignored
throwable.result.of.method.call.ignored.problem.descriptor=Result of <code>#ref()</code> not thrown #loc
char.used.in.arithmetic.context.display.name=Char expression used in arithmetic context
char.used.in.arithmetic.context.problem.descriptor='char' <code>#ref</code> used in arithmetic context #loc
char.used.in.arithmetic.context.quickfix=Convert to String literal
char.used.in.arithmetic.context.cast.quickfix=Insert cast to {0}
unnecessary.constant.array.creation.expression.display.name=Constant array creation expression can be replaced with array initializer
unnecessary.constant.array.creation.expression.problem.descriptor=<code>#ref</code> can be replaced with array initializer expression #loc
unnecessary.constant.array.creation.expression.quickfix=Replace with array initializer expression
ambiguous.method.call.display.name=Inherited method called which hides method in outer class
ambiguous.method.call.problem.descriptor=<code>#ref()</code> inherited from ''{0}'' hides method from outer class ''{1}'' #loc
ambiguous.method.call.quickfix=Qualify method call with 'this.'
change.modifier.quickfix=Make ''{0}''
the.whole.project=the whole project
this.class=this class
assertequals.may.be.assertsame.display.name='assertEquals()' may be 'assertSame()'
assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> may be 'assertSame()' #loc
logger.initialized.with.foreign.class.quickfix=Replace with ''{0}.class''
logger.initialized.with.foreign.class.problem.descriptor=Logger initializer with foreign class <code>#ref</code> #loc
logger.initialized.with.foreign.class.display.name=Logger initialized with foreign class
logger.factory.method.name=Logger factory &method:
make.static.final.quickfix=Make ''{0}'' static final
logging.condition.disagrees.with.log.statement.display.name=Logging condition does not match log statement
logging.condition.disagrees.with.log.statement.problem.descriptor=Logging condition <code>#ref()</code> does not match ''{0}()'' log statement #loc
log.statement.guarded.by.log.condition.display.name=Log statement not guarded by log condition
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> log statement not guarded by log condition #loc
log.statement.guarded.by.log.condition.quickfix=Surround with log condition
key.set.iteration.may.use.entry.set.display.name=Iteration over 'keySet()' may be replaced with 'entrySet()' iteration
key.set.iteration.may.use.entry.set.problem.descriptor=Iteration over <code>#ref</code> may be replaced with 'entrySet()' iteration #loc
key.set.iteration.may.use.entry.set.quickfix=Replace with 'entrySet()' iteration
string.replaceable.by.string.buffer.in.loop.option=Only warn when appending in a loop
declare.collection.as.interface.quickfix=Weaken to ''{0}''
non.exception.name.ends.with.exception.quickfix=Make ''{0}'' extend ''java.lang.Exception''
constant.value.variable.use.display.name=Use of variable whose value is known to be constant
constant.value.variable.use.problem.descriptor=Value of <code>#ref</code> is known to be constant #loc
replace.reference.with.expression.quickfix=Replace with ''{0}''
unnecessary.parentheses.option=Ignore clarifying parentheses
unnecessary.parentheses.conditional.option=Ignore parentheses around the condition of conditional expressions
field.may.be.final.display.name=Field may be final
field.may.be.final.problem.descriptor=Field <code>#ref</code> may be 'final' #loc
cast.that.loses.precision.option=Ignore casts from int to char
variable.not.used.inside.if.display.name=Reference checked for 'null' is not used inside 'if'
variable.not.used.inside.if.problem.descriptor=<code>#ref</code> is not used inside if #loc
if.may.be.conditional.display.name='if' statement could be replaced with simple conditional expression
if.may.be.conditional.problem.descriptor=<code>#ref</code> could be replaced with simple conditional expression #loc
if.may.be.conditional.quickfix=Replace with conditional expression
redundant.string.format.call.display.name=Redundant call to 'String.format()'
redundant.string.format.call.problem.descriptor=Redundant call to <code>#ref</code> #loc
redundant.string.format.call.quickfix=Remove redundant call to 'String.format()'
junit4.test.method.in.class.extending.junit3.testcase.display.name=JUnit 4 test method in class extending JUnit 3 TestCase
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=@Test annotated method <code>#ref</code> inside class extending JUnit 3 TestCase #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=@Ignore annotated method <code>#ref</code> won't be ignored #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.fix=Remove @Ignore and rename method to ''{0}''
equals.called.on.enum.constant.display.name='equals()' called on Enum value
equals.called.on.enum.constant.problem.descriptor=<code>#ref</code> called on Enum value #loc
equals.called.on.enum.constant.quickfix=Replace 'equals()' with '=='
int.literal.may.be.long.literal.display.name='int' literal cast to 'long' could be 'long' literal
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> could be replaced with ''{0}'' #loc
int.literal.may.be.long.literal.quickfix=Replace with ''{0}''
constant.assert.condition.display.name='assert' statement condition is constant
constant.assert.condition.problem.descriptor=Assert condition <code>#ref</code> is constant #loc
assert.with.side.effects.display.name='assert' statement with side effects
assert.with.side.effects.problem.descriptor=<code>#ref</code> has side effects #loc
method.count.ignore.getters.setters.option=&Ignore simple getter and setter methods
orred.not.equal.expression.display.name=Identical reference in '!=' expression on both sides of '||' expression
orred.not.equal.expression.problem.descriptor=<code>#ref</code> is always true #loc
orred.not.equal.expression.quickfix=Change '||' to '\\&\\&'
class.new.instance.display.name=Unsafe call to 'Class.newInstance()'
class.new.instance.problem.descriptor=Call to <code>#ref()</code> may throw undeclared checked exceptions #loc
class.new.instance.quickfix=Replace with 'Class.getConstructor().newInstance()' call
dynamic.regex.replaceable.by.compiled.pattern.display.name=Dynamic regular expression could be replaced by compiled Pattern
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> could be replaced with compiled java.util.regex.Pattern construct #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Replace with call to method of compiled 'Pattern' constant
ignore.serializable.option=Ignore java.io.Serializable
ignore.cloneable.option=Ignore 'java.lang.Cloneable'
listener.may.use.adapter.display.name=Class may extend adapter instead of implementing listener
listener.may.use.adapter.problem.descriptor=Class ''{0}'' may extend ''{1}'' instead of implementing <code>#ref</code> #loc
listener.may.use.adapter.quickfix=Replace with ''extends {0}''
listener.may.use.adapter.emtpy.methods.option=&Only warn when empty implementing methods are found
unnecessary.inherit.doc.display.name=Unnecessary {@inheritDoc} Javadoc Comment
unnecessary.inherit.doc.problem.descriptor=Javadoc comment containing only <code>#ref</code> is unnecessary #loc
unnecessary.inherit.doc.quickfix=Remove unnecessary @inheritDoc
multiple.exceptions.declared.on.test.method.display.name=Multiple exceptions declared on test method
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> could be replaced with 'throws Exception' #loc
multiple.exceptions.declared.on.test.method.quickfix=Replace with 'throws Exception'
unnecessary.javadoc.link.display.name=Unnecessary Javadoc link
unnecessary.javadoc.link.super.method.problem.descriptor=<code>#ref</code> pointing to super method is unnecessary #loc
unnecessary.javadoc.link.this.method.problem.descriptor=<code>#ref</code> pointing to this method is unnecessary #loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>#ref</code> pointing to containing class is unnecessary #loc
unnecessary.javadoc.link.quickfix=Remove unnecessary '{0}'
thread.local.not.static.final.display.name=ThreadLocal field not declared static final
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> is not declared 'static final' #loc
remove.try.finally.block.quickfix=Remove 'try-finally' block
remove.finally.block.quickfix=Remove 'finally' block
remove.leading.zero.to.make.decimal.quickfix=Remove leading zero to make decimal
convert.octal.literal.to.decimal.literal.quickfix=Convert octal literal to decimal literal
ignore.single.field.static.imports.option=Ignore single &field static imports
ignore.single.method.static.imports.option=Ignore single &method static imports
ignore.methods.with.boolean.return.type.option=Ignore methods with &Boolean return type
ignore.boolean.methods.in.an.interface.option=Ignore boolean methods in an @&interface
ignore.methods.overriding.super.method=Ignore methods &overriding a super method
ignored.io.resource.types=Ignored I/O resource types
choose.io.resource.type.to.ignore=Choose I/O resource type to ignore
ignore.accesses.from.the.same.class=Ignore accesses from the same class
ignore.accesses.from.equals.method=Ignore accesses from 'equals()' method
ignore.branches.of.switch.statements=Ignore branches of 'switch' statements
ignore.equals.hashcode.and.tostring=Ignore 'equals()', 'hashCode()' and 'toString()' methods
ignore.methods.in.anonymous.classes=Ignore methods in anonymous classes
class.name=Class name
method.name.pattern=Method name pattern
query.column.name=Query names start with
update.column.name=Update names start with
assert.keyword.is.considered.an.assertion='assert' keyword is considered an assertion
expected.exception.never.thrown.display.name=Expected exception never thrown in test method body
expected.exception.never.thrown.problem.descriptor=Expected <code>#ref</code> never thrown in body of ''{0}()'' #loc
choose.logger.class=Choose logger class
logger.class.names=Logger class names
bad.exception.declared.ignore.exceptions.declared.in.tests.option=&Ignore exceptions declared in tests
allow.resource.to.be.opened.inside.a.try.block=Allow resource to be opened inside a 'try' block
log.method.name=Log method name
log.condition.text=Log condition text
ignore.if.annotated.by=Ignore if annotated by
choose.annotation.class=Choose annotation class
only.weaken.to.an.interface=Only weaken to an interface
unqualified.inner.class.access.display.name=Unqualified inner class access
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> is not qualified with outer class #loc
unqualified.inner.class.access.quickfix=Qualify with outer class
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' is unnecessarily qualified with <code>#ref</code> #loc
unnecessarily.qualified.inner.class.access.display.name=Unnecessarily qualified inner class access
unnecessarily.qualified.inner.class.access.quickfix=Remove qualifier
synchronization.on.static.field.display.name=Synchronization on 'static' field
synchronization.on.static.field.problem.descriptor=Synchronization on 'static' field <code>#ref</code> #loc
assertequals.called.on.arrays.display.name='assertEquals()' called on array
assertequals.called.on.arrays.problem.descriptor=<code>#ref()</code> called on array #loc
assertequals.called.on.arrays.quickfix=Replace with 'assertArrayEquals()'
overly.broad.throws.clause.display.name=Overly broad 'throws' clause
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> is too broad, masking exception ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> is too broad, masking exceptions ''{0}'' and ''{1}'' #loc
overly.broad.throws.clause.quickfix1=Add specific exceptions
overly.broad.throws.clause.quickfix2=Replace with specific exceptions
unnecessarily.qualified.statically.imported.element.display.name=Unnecessarily qualified statically imported element
unnecessarily.qualified.statically.imported.element.problem.descriptor=Statically imported element ''{0}'' is unnecessarily qualified with <code>#ref</code> #loc
unnecessarily.qualified.statically.imported.element.quickfix=Remove unnecessary qualifier
ignore.instanceof.on.library.classes=Ignore instanceof on library classes
assertequals.may.be.assertsame.quickfix=Replace with 'assertSame()'
for.can.be.foreach.option=Report indexed 'java.util.List' loops
for.can.be.foreach.option2=Do not report iterations over untyped collections
cast.conflicts.with.instanceof.quickfix1=Replace ''{0}'' with ''{1}'' in cast
cast.conflicts.with.instanceof.quickfix2=Replace ''{0}'' with ''{1}'' in instanceof
double.checked.locking.quickfix=Make ''{0}'' 'volatile'
double.literal.may.be.float.literal.display.name='double' literal cast to 'float' could be 'float' literal
double.literal.may.be.float.literal.problem.descriptor=<code>#ref</code> could be replaced with ''{0}'' #loc
double.literal.may.be.float.literal.quickfix=Replace with ''{0}''
multiple.declaration.option=Ignore 'for' loop declarations
simplifiable.annotation.display.name=Simplifiable annotation
simplifiable.annotation.problem.descriptor=Annotation <code>#ref</code> may be replaced with ''{0}'' #loc
simplifiable.annotation.quickfix=Simplify annotation
overloaded.methods.with.same.number.parameters.option=<html>Ignore overloaded methods whose parameter types are definitely incompatible</html>
string.concatenation.in.format.call.display.name=String concatenation as argument to 'format()' call
string.concatenation.in.format.call.problem.descriptor=String concatenation as argument to 'format()' call #loc
string.concatenation.in.format.call.quickfix=Pass ''{0}'' as argument to ''format()''
string.concatenation.in.message.format.call.display.name=String concatenation as argument to 'MessageFormat.format()' call
string.concatenation.in.message.format.call.problem.descriptor=String concatenation as argument to 'MessageFormat.format()' call #loc
shift.out.of.range.quickfix=Replace ''{0}'' with ''{1}''
boxing.boxed.value.display.name=Boxing of already boxed value
boxing.boxed.value.problem.descriptor=Boxing of already boxed <code>#ref</code> #loc
boxing.boxed.value.quickfix=Remove unnecessary boxing
unnecessary.javadoc.link.option=Ignore inline links to super methods
constant.junit.assert.argument.display.name=Constant JUnit assert argument
constant.junit.assert.argument.problem.descriptor=Argument <code>#ref</code> is constant #loc
test.case.with.no.test.methods.option=Ignore test cases which have super classes with test methods
package.dot.html.may.be.package.info.display.name='package.html' may be converted to 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> is ignored because <code>package-info.java</code> exists
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> may be converted to <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix=Delete 'package.html'
package.dot.html.delete.command=package.html deletion
package.dot.html.may.be.package.info.convert.quickfix=Convert to 'package-info.java'
package.dot.html.convert.command=package.html to package-info.java conversion
choose.super.class.to.ignore=Choose class
ignore.anonymous.inner.classes=Ignore anonymous inner classes
try.with.identical.catches.display.name=Identical 'catch' branches in 'try' statement
try.with.identical.catches.problem.descriptor=Identical 'catch' branches in 'try' statement #loc
if.can.be.switch.display.name='if' replaceable with 'switch'
if.can.be.switch.problem.descriptor=<code>#ref</code> statement replaceable with 'switch' statement #loc
if.can.be.switch.quickfix=Replace with 'switch'
if.can.be.switch.minimum.branch.option=Minimum number of branches
if.can.be.switch.int.option=Suggest switch on numbers
if.can.be.switch.enum.option=Suggest switch on enums
unnecessarily.qualified.inner.class.access.option=Ignore references for which an import is needed
unqualified.inner.class.access.option=Ignore references to local inner classes
try.with.identical.catches.quickfix=Collapse catch blocks into multi-catch
confusing.else.option=<html>Also report when there are no more statements after the 'if' statement</html>
html.tag.can.be.javadoc.tag.display.name=<code>...</code> can be replaced with {@code ...}
html.tag.can.be.javadoc.tag.problem.descriptor1=<code>#ref...&lt;/code&gt;</code> can be replaced with '{@code ...}' #loc
html.tag.can.be.javadoc.tag.problem.descriptor2=<code>&lt;code&gt;...#ref</code> can be replaced with '{@code ...}' #loc
html.tag.can.be.javadoc.tag.quickfix=Replace with '{@code ...}'
try.finally.can.be.try.with.resources.display.name='try finally' replaceable with 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> can use automatic resource management
try.finally.can.be.try.with.resources.quickfix=Replace with 'try' with resources
array.comparison.display.name=Array comparison using '==', instead of 'Arrays.equals()'
array.comparison.problem.descriptor=Array objects are compared using <code>#ref</code>, not 'Arrays.equals()' #loc
array.hash.code.display.name='hashCode()' called on array
array.hash.code.problem.descriptor=<code>#ref()</code> called on array should probably be 'Arrays.hashCode()' #loc
arrays.deep.hash.code.quickfix=Replace with 'Arrays.deepHashCode()'
arrays.hash.code.quickfix=Replace with 'Arrays.hashCode()'
method.can.be.variable.arity.method.display.name=Method can be variable arity method
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> can be converted to variable arity method
method.can.be.variable.arity.method.ignore.byte.short.option=<html>Ignore methods with a last parameter of type byte[] or short[]</html>
convert.to.variable.arity.method.quickfix=Convert to variable arity method
mismatched.string.builder.query.update.display.name=Mismatched query and update of StringBuilder
mismatched.string.builder.updated.problem.descriptor=Contents of {0} <code>#ref</code> are updated, but never queried #loc
mismatched.string.builder.queried.problem.descriptor=Contents of {0} <code>#ref</code> are queried, but never updated #loc
math.random.cast.to.int.display.name='Math.random()' cast to 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> cast to 'int' is always rounded down to '0' #loc
math.random.cast.to.int.quickfix=Add parentheses to perform multiplication before cast
boolean.variable.always.inverted.display.name=Boolean variable is always inverted
boolean.field.always.inverted.problem.descriptor=Boolean field <code>#ref</code> is always inverted
boolean.variable.always.inverted.problem.descriptor=Boolean variable <code>#ref</code> is always inverted
boolean.variable.always.inverted.quickfix=Invert ''{0}''
unnecessary.explicit.numeric.cast.display.name=Unnecessary explicit numeric cast
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' unnecessarily cast to <code>#ref</code>
unnecessary.explicit.numeric.cast.quickfix=Remove cast
null.thrown.display.name='null' thrown
null.thrown.problem.descriptor=<code>#ref</code> thrown
null.thrown.quickfix=Replace with 'new NullPointerException()'
element.only.used.from.test.code.display.name=Symbol only used from test code
class.only.used.from.test.code.problem.descriptor=class <code>#ref</code> only used from test code #loc
method.only.used.from.test.code.problem.descriptor=method <code>#ref</code> only called from test code #loc
field.only.used.from.test.code.problem.descriptor=field <code>#ref</code> only accessed from test code #loc
unnecessary.final.on.local.variable.or.parameter.display.name=Unnecessary 'final' on local variable or parameter
unnecessary.final.on.local.variable.problem.descriptor=Unnecessary <code>#ref</code> on variable ''{0}'' #loc
unnecessary.final.on.parameter.problem.descriptor=Unnecessary <code>#ref</code> on parameter ''{0}'' #loc
unnecessary.final.report.local.variables.option=Report local variables
unnecessary.final.report.parameters.option=Report parameters
unnecessary.final.on.parameter.only.interface.option=Only warn on abstract or interface methods
choose.exception.class=Choose Exception class
class.independent.of.module.display.name=Class independent of its module
class.independent.of.module.problem.descriptor=Class <code>#ref</code> has no dependencies or dependents in its module #loc
class.only.used.in.one.module.display.name=Class only used from one other module
class.only.used.in.one.module.problem.descriptor=Class <code>#ref</code> has only dependencies on and/or dependents in module ''{0}'' #loc
empty.directory.display.name=Empty directory
empty.directories.problem.descriptor=Empty directory <code>{0}</code>
empty.directories.only.under.source.roots.option=Only report empty directories located under a source folder
empty.directories.delete.quickfix=Delete empty directory ''{0}''
simplifiable.equals.expression.display.name=Unnecessary 'null' check before 'equals()' call
simplifiable.equals.expression.problem.descriptor=Unnecessary 'null' check
simplifiable.equals.expression.quickfix=Flip '.equals()' and remove unnecessary 'null' check
cast.to.concrete.class.option=Ignore casts to an abstract class type
instanceof.interfaces.option=Ignore instanceof abstract class
instance.variable.of.concrete.class.option=Ignore instance fields whose type is an abstract class
local.variable.of.concrete.class.option=Ignore local variables whose type is an abstract class
method.return.of.concrete.class.option=Ignore methods whose return type is an abstract class
parameter.of.concrete.class.option=Ignore parameters whose type is abstract class
static.variable.of.concrete.class.option=Ignore static fields whose type is an abstract class
class.only.used.in.one.package.display.name=Class only used from one other package
class.only.used.in.one.package.problem.descriptor=Class <code>#ref</code> has only dependencies on and/or dependents in package ''{0}'' #loc
unnecessary.return.option=Ignore in then branch branch of 'if' statement with 'else' branch
usage.of.obsolete.assert.display.name=Usage of obsolete 'junit.framework.Assert'
use.of.obsolete.assert.problem.descriptor=Call to <code>#ref()</code> from 'org.junit.framework.Assert' should be replaced with call to method from 'org.junit.Assert'
use.of.obsolete.assert.quickfix=Replace with 'org.junit.Assert' method call
properties.object.as.hashtable.set.quickfix=Replace with call to 'setProperty()'
properties.object.as.hashtable.get.quickfix=Replace with call to 'getProperty()'
ignored.junit.test.display.name=JUnit test annotated with '@Ignore'
ignored.junit.test.classproblem.descriptor=Test class ''{0}'' annotated with <code>#ref</code>
ignored.junit.test.method.problem.descriptor=Test method ''{0}()'' annotated with <code>#ref</code>
unclear.binary.expression.display.name=Unclear binary expression
unclear.binary.expression.problem.descriptor=Expression could use clarifying parentheses #loc
unclear.binary.expression.quickfix=Add clarifying parentheses
new.exception.without.arguments.display.name=Exception constructor called without arguments
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> without arguments
absolute.alignment.in.user.interface.display.name=Absolute alignment used in AWT/Swing code
absolute.alignment.in.user.interface.problem.descriptor=Absolute alignment constant <code>{0}.#ref</code> used
absolute.alignment.in.user.interface.quickfix=Replace with ''{0}.{1}''
throws.runtime.exception.display.name='RuntimeException' declared in 'throws' clause
throws.runtime.exception.problem.descriptor=Runtime exception <code>#ref</code> declared in 'throws' clause
throws.runtime.exception.quickfix=Remove ''{0}'' from ''throws'' clause
