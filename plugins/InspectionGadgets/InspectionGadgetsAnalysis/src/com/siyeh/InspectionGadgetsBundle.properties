cast.to.concrete.class.display.name=Cast to a concrete class
cast.to.concrete.class.problem.descriptor=Cast to concrete class <code>{0}</code> #loc
class.references.subclass.display.name=Class references one of its subclasses
class.references.subclass.problem.descriptor=Class ''{0}'' references subclass <code>#ref</code> #loc
class.references.subclass.problem.descriptor.anonymous=Anonymous class references subclass <code>#ref</code> #loc
collection.declared.by.class.display.name=Collection declared by class, not interface
collection.declared.by.class.problem.descriptor=Declaration of <code>#ref</code> should probably be weakened to ''{0}'' #loc
collection.declared.by.class.ignore.locals.option=Ignore local variables
collection.declared.by.class.ignore.private.members.option=Ignore 'private' fields and methods
feature.envy.display.name=Feature envy
feature.envy.problem.descriptor=Class ''{0}'' accessed repeatedly in method <code>#ref()</code> #loc
instance.variable.of.concrete.class.display.name=Type of instance field is concrete class
instance.variable.of.concrete.class.problem.descriptor=Type of field ''{0}'' is concrete class <code>#ref</code> #loc
chain.of.instanceof.checks.display.name=Chain of 'instanceof' checks
chain.of.instanceof.checks.problem.descriptor=Chain of 'instanceof' checks indicates abstraction failure #loc
chain.of.class.equality.checks.problem.descriptor=Chain of class equality checks indicates abstraction failure #loc
instanceof.concrete.class.display.name='instanceof' a concrete class
instanceof.concrete.class.problem.descriptor='instanceof' concrete class <code>#ref</code> #loc
instanceof.check.for.this.display.name='instanceof' check for 'this'
instanceof.check.for.this.problem.descriptor='instanceof' check for <code>#ref</code> #loc
local.variable.of.concrete.class.display.name=Local variable of concrete class
local.variable.of.concrete.class.problem.descriptor=Local variable ''{0}'' of concrete class <code>#ref</code> #loc
magic.number.display.name=Magic number
magic.number.problem.descriptor=Magic number <code>#ref</code> #loc
method.return.concrete.class.display.name=Method return of concrete class
method.return.concrete.class.problem.descriptor=Method returns a concrete class <code>#ref</code> #loc
overly.strong.type.cast.display.name=Overly strong type cast
overly.strong.type.cast.weaken.quickfix=Weaken overly strong cast
concrete.class.method.parameter.display.name=Method parameter of concrete class
concrete.class.method.parameter.problem.descriptor=Parameter ''{0}'' of concrete class <code>#ref</code> #loc
public.method.not.in.interface.display.name='public' method not exposed in interface
public.method.not.in.interface.problem.descriptor='public' method <code>#ref()</code> is not exposed via an interface #loc
public.method.not.in.interface.option=<html>Ignore if the containing class does not implement a non-library interface</html>
static.variable.of.concrete.class.display.name=Static field of concrete class
static.variable.of.concrete.class.problem.descriptor=Static field ''{0}'' of concrete class <code>#ref</code> #loc
incompatible.mask.operation.display.name=Incompatible bitwise mask operation
incompatible.mask.operation.problem.descriptor.always.false=<code>#ref</code> is always false #loc
incompatible.mask.operation.problem.descriptor.always.true=<code>#ref</code> is always true #loc
pointless.bitwise.expression.display.name=Pointless bitwise expression
pointless.bitwise.expression.simplify.quickfix=Simplify
shift.operation.by.inappropriate.constant.display.name=Shift operation by inappropriate constant
shift.operation.by.inappropriate.constant.problem.descriptor.too.large=Shift operation <code>#ref</code> by overly large constant value #loc
shift.operation.by.inappropriate.constant.problem.descriptor.negative=Shift operation <code>#ref</code> by negative constant value #loc
equals.called.on.array.display.name='equals()' called on array
equals.called.on.array.problem.descriptor=<code>#ref()</code> between arrays should probably be 'Arrays.equals()' #loc
replace.with.arrays.equals=Replace with 'Arrays.equals()'
replace.with.arrays.deep.equals=Replace with 'Arrays.deepEquals()'
assignment.to.null.display.name='null' assignment
assignment.to.null.problem.descriptor='null' assigned to variable <code>#ref</code> #loc
assignment.to.null.option=Ignore assignments to fields
assignment.to.static.field.from.instance.method.display.name=Assignment to static field from instance context
assignment.to.static.field.from.instance.method.problem.descriptor=Assignment to static field <code>#ref</code> from instance context #loc
assignment.used.as.condition.display.name=Assignment used as condition
assignment.used.as.condition.problem.descriptor=<code>#ref</code> used as condition #loc
assignment.used.as.condition.replace.quickfix=Replace '=' with '=='
cast.conflicts.with.instanceof.display.name=Cast conflicts with 'instanceof'
cast.conflicts.with.instanceof.problem.descriptor=Cast <code>#ref</code> conflicts with surrounding 'instanceof' check #loc
casting.to.incompatible.interface.display.name=Casting to incompatible interface
casting.to.incompatible.interface.problem.descriptor=Cast to incompatible interface <code>#ref</code> #loc
collection.added.to.self.display.name=Collection added to self
collection.added.to.self.problem.descriptor=''{0}()'' called on collection <code>#ref</code> with itself as argument #loc
non.final.field.compareto.display.name=Non-final field referenced in 'compareTo()'
non.final.field.compareto.problem.descriptor=Non-final field <code>#ref</code> accessed in 'compareTo()' #loc
covariant.equals.display.name=Covariant 'equals()'
covariant.equals.problem.descriptor=<code>#ref()</code> should take 'Object' as its argument #loc
empty.class.initializer.display.name=Empty class initializer
empty.class.initializer.problem.descriptor=Empty class initializer #loc
empty.class.initializer.delete.quickfix=Delete empty class initializer
statement.with.empty.body.display.name=Statement with empty body
statement.with.empty.body.problem.descriptor=<code>#ref</code> statement has empty body #loc
statement.with.empty.body.include.option=Include statement bodies that are empty code blocks
equals.between.inconvertible.types.display.name='equals()' between objects of inconvertible types
equals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
equals.called.on.suspicious.object.display.name='equals()' called on StringBuilder
equals.called.on.suspicious.object.problem.descriptor=Suspicious call ''equals'' on ''{0}'' object
non.final.field.in.equals.display.name=Non-final field referenced in 'equals()'
non.final.field.in.equals.problem.descriptor=Non-final field <code>#ref</code> accessed in 'equals()'  #loc
equals.doesnt.check.class.parameter.display.name='equals()' method which does not check class of parameter
equals.doesnt.check.class.parameter.problem.descriptor=<code>#ref()</code> should check the class of its parameter #loc
for.loop.not.use.loop.variable.display.name='for' loop where update or condition does not use loop variable
for.loop.not.use.loop.variable.problem.descriptor.condition=<code>#ref</code> statement has condition which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.update=<code>#ref</code> statement has update which does not use the for loop variable #loc
for.loop.not.use.loop.variable.problem.descriptor.both.condition.and.update=<code>#ref</code> statement has condition and update which do not use the for loop variable #loc
non.final.field.in.hashcode.display.name=Non-final field referenced in 'hashCode()'
non.final.field.in.hashcode.problem.descriptor=Non-final field <code>#ref</code> accessed in 'hashCode()' #loc
result.of.method.call.ignored.display.name=Result of method call ignored
result.of.method.call.ignored.problem.descriptor=Result of <code>{0}.#ref()</code> is ignored #loc
result.of.method.call.ignored.class.column.title=Class name
result.of.method.call.ignored.method.column.title=Method name regex
result.of.method.call.ignored.non.library.option=Report all ignored non-library calls
infinite.recursion.display.name=Infinite recursion
infinite.recursion.problem.descriptor=Method <code>#ref()</code> recurses infinitely, and can only end by throwing an exception #loc
instanceof.with.incompatible.interface.display.name='instanceof' with incompatible interface
instanceof.with.incompatible.interface.problem.descriptor='instanceof' incompatible interface <code>#ref</code> #loc
instantiation.utility.class.display.name=Instantiation of utility class
instantiation.utility.class.problem.descriptor=Instantiation of utility class <code>#ref</code> #loc
iterator.hasnext.which.calls.next.display.name='Iterator.hasNext()' which calls 'next()'
iterator.hasnext.which.calls.next.problem.descriptor=<code>Iterator.#ref()</code> contains call to 'next()' #loc
iterator.next.does.not.throw.nosuchelementexception.display.name='Iterator.next()' which can't throw 'NoSuchElementException'
malformed.format.string.display.name=Malformed format string
malformed.format.string.problem.descriptor.malformed=Format string <code>#ref</code> is malformed #loc
malformed.format.string.problem.descriptor.illegal=Illegal format string specifier: {0} #loc
malformed.format.string.problem.descriptor.too.many.arguments=Too many arguments for format string (found: {0}, expected: {1}) #loc
malformed.format.string.problem.descriptor.too.few.arguments=Too few arguments for format string (found: {0}, expected: {1}) #loc
malformed.format.string.problem.descriptor.arguments.do.not.match.type=Argument type ''{0}'' does not match the type of the format specifier ''{1}'' #loc
malformed.regular.expression.display.name=Malformed regular expression
malformed.regular.expression.problem.descriptor1=Regular expression <code>#ref</code> is malformed #loc
malformed.regular.expression.problem.descriptor2=Regular expression <code>#ref</code> is malformed: {0} #loc
malformed.xpath.expression.display.name=Malformed XPath expression
malformed.xpath.expression.problem.description=XPath expression <code>#ref</code> is malformed #loc
mismatched.read.write.array.display.name=Mismatched read and write of array
mismatched.read.write.array.problem.descriptor.write.not.read=Contents of array <code>#ref</code> are written to, but never read #loc
mismatched.read.write.array.problem.descriptor.read.not.write=Contents of array <code>#ref</code> are read, but never written to #loc
mismatched.update.collection.display.name=Mismatched query and update of collection
mismatched.update.collection.problem.descriptor.updated.not.queried=Contents of collection <code>#ref</code> are updated, but never queried #loc
mismatched.update.collection.problem.description.queried.not.updated=Contents of collection <code>#ref</code> are queried, but never updated #loc
rename.quickfix=Rename
renameto.quickfix=Rename to ''{0}''
misspelled.equals.display.name='equal()' instead of 'equals()'
misspelled.equals.problem.descriptor=<code>#ref()</code> method should probably be 'equals()' #loc
non.short.circuit.boolean.expression.display.name=Non-short-circuit boolean expression
non.short.circuit.boolean.expression.problem.descriptor=Non-short-circuit boolean expression <code>#ref</code> #loc
non.short.circuit.boolean.expression.replace.quickfix=Replace with short circuit expression
null.argument.to.var.arg.method.display.name=Confusing argument to varargs method
null.argument.to.var.arg.method.problem.descriptor=Confusing argument <code>#ref</code>, unclear if a varargs or non-varargs call is desired #loc
primitive.array.argument.to.var.arg.method.display.name=Confusing primitive array argument to varargs method
primitive.array.argument.to.var.arg.method.problem.descriptor=Confusing primitive array argument to varargs method #loc
object.comparison.display.name=Object comparison using '==', instead of 'equals()'
object.comparison.enumerated.ignore.option=Ignore '==' between enumerated types
object.comparison.klass.ignore.option=Ignore '==' between final class types without 'equals()' implementation
object.comparison.problem.description=Object values are compared using <code>#ref</code>, not 'equals()' #loc
equality.to.equals.quickfix=Replace '==' with 'equals()'
inequality.to.not.equals.quickfix=Replace '!=' with '!equals()'
equality.to.safe.equals.quickfix=Replace '==' with null-safe 'equals()'
inequality.to.safe.not.equals.quickfix=Replace '!=' with null-safe '!equals()'
object.equals.null.problem.descriptor=<code>.equals(#ref)</code> is always ''false'' #loc
default.tostring.call.display.name=Call to default 'toString()'
default.tostring.call.problem.descriptor=Call to default 'toString()' on <code>#ref</code> #loc
octal.and.decimal.integers.in.same.array.display.name=Octal and decimal integers in same array
octal.and.decimal.integers.in.same.array.problem.descriptor=Octal and decimal integers in the same array initializer #loc
result.of.object.allocation.ignored.display.name=Result of object allocation ignored
result.of.object.allocation.ignored.problem.descriptor=Result of <code>new #ref()</code> is ignored #loc
use.0index.in.jdbc.resultset.display.name=Use of index 0 in JDBC ResultSet
use.0index.in.jdbc.resultset.problem.descriptor=Use of index '0' in JDBC ResultSet #loc
use.0index.in.jdbc.prepared.statement.problem.descriptor=Use of index '0' in JDBC PreparedStatement #loc
return.of.null.display.name=Return of 'null'
return.of.null.problem.descriptor=Return of <code>#ref</code> #loc
return.of.null.arrays.option=Report methods that return arrays
return.of.null.quickfix=Annotate method as @Nullable
return.of.null.objects.option=Report methods that return objects
return.of.null.collections.option=Report methods that return collection objects
return.of.null.ignore.private.option=Ignore 'private' methods
return.of.null.optional.quickfix=Replace with ''{0}.{1}()''
return.of.null.optional.quickfix.family=Replace with 'Optional.empty()'
static.method.via.subclass.display.name=Static method referenced via subclass
static.method.via.subclass.problem.descriptor=Static method <code>#ref()</code> declared in class ''{0}'' but referenced via subclass ''{1}'' #loc
static.method.via.subclass.rationalize.quickfix=Rationalize static method call
static.field.via.subclass.display.name=Static field referenced via subclass
static.field.via.subclass.problem.descriptor=Static field <code>#ref</code> declared in class ''{0}'' but referenced via subclass ''{1}'' #loc
static.field.via.subclass.rationalize.quickfix=Rationalize static field access
string.comparison.display.name=String comparison using '==', instead of 'equals()'
number.comparison.display.name=Number comparison using '==', instead of 'equals()'
string.comparison.problem.descriptor=String values are compared using <code>#ref</code>, not 'equals()' #loc
number.comparison.problem.descriptor=Number objects are compared using <code>#ref</code>, not 'equals()' #loc
subtraction.in.compareto.display.name=Subtraction in 'compareTo()'
subtraction.in.compareto.problem.descriptor=Subtraction <code>#ref</code> in 'compareTo()' may result in overflow errors #loc
text.label.in.switch.statement.display.name=Text label in 'switch' statement
text.label.in.switch.statement.problem.descriptor=Text label <code>#ref:</code> in 'switch' statement #loc
properties.object.as.hashtable.display.name=Use of Properties object as a Hashtable
properties.object.as.hashtable.problem.descriptor=Call to <code>Hashtable.#ref()</code> on properties object #loc
assignment.replaceable.with.operator.assignment.display.name=Assignment replaceable with operator assignment
unnecessary.code.block.display.name=Unnecessary code block
unnecessary.code.block.unwrap.quickfix=Unwrap block
redundant.local.variable.display.name=Redundant local variable
redundant.local.variable.ignore.option=Ignore immediately returned or thrown variables
redundant.local.variable.annotation.option=Ignore variables which have an annotation
static.collection.display.name=Static collection
static.collection.problem.descriptor=Static collection <code>#ref</code> #loc
static.collection.ignore.option=Ignore weak static collections or maps
stringbuffer.field.display.name=StringBuilder field
stringbuffer.field.problem.descriptor=''{0}'' field <code>#ref</code> #loc
gc.call.display.name=Calls to 'System.gc()' or 'Runtime.gc()'
gc.call.problem.descriptor=<code>#ref</code> should not be called in production code #loc
array.allocation.zero.length.display.name=Zero-length array allocation
array.allocation.zero.length.problem.descriptor=Allocation of zero length array #loc
constant.for.zero.length.array.display.name=Unnecessary zero length array usage
constant.for.zero.length.array.problem.descriptor=Zero length array can be changed to constant #loc
constant.for.zero.length.array.quickfix.family=Replace with constant
replace.with=Replace with ''{0}''
multiple.loggers.display.name=Class with multiple loggers
logger.name.option=Logger &class name:
multiple.loggers.problem.descriptor=Class <code>#ref</code> declares multiple loggers #loc
no.logger.display.name=Class without logger
no.logger.problem.descriptor=Class <code>#ref</code> does not declare a logger #loc
non.constant.logger.display.name=Non-constant logger
non.constant.logger.problem.descriptor=Non-constant logger field <code>#ref</code> #loc
public.method.without.logging.display.name='public' method without logging
public.method.without.logging.problem.descriptor='public' method <code>#ref()</code> has no logging call #loc
ignore.trivial.finalizers.option=Ignore for trivial 'finalize()' implementations
finalize.declaration.display.name='finalize()' declaration
finalize.declaration.problem.descriptor=<code>#ref()</code> declared #loc
finalize.not.declared.protected.display.name='finalize()' not declared 'protected'
finalize.not.declared.protected.problem.descriptor=<code>#ref()</code> not declared 'protected' #loc
make.protected.quickfix=Make 'protected'
finalize.called.explicitly.display.name='finalize()' called explicitly
finalize.called.explicitly.problem.descriptor=<code>#ref()</code> called explicitly #loc
java.lang.import.display.name='java.lang' import
java.lang.import.problem.descriptor=Unnecessary import from package 'java.lang' #loc
import.display.name='*' import
import.problem.descriptor=Package import <code>#ref</code> #loc
redundant.import.display.name=Redundant import
redundant.import.problem.descriptor=Redundant import <code>#ref</code> #loc
import.from.same.package.display.name=Import from same package
import.from.same.package.problem.descriptor=Unnecessary import from same package <code>#ref</code> #loc
single.class.import.display.name=Single class import
single.class.import.problem.descriptor=Single class import <code>#ref</code> #loc
static.import.display.name=Static import
static.import.problem.descriptor=Static import <code>#ref</code>  #loc
static.import.replace.quickfix=Replace with non-static import
unused.import.display.name=Unused import
unused.import.problem.descriptor=Unused import <code>#ref</code> #loc
clone.instantiates.objects.with.constructor.display.name='clone()' instantiates objects with constructor
clone.instantiates.objects.with.constructor.problem.descriptor='clone()' creates new <code>#ref</code> instances #loc
clone.doesnt.declare.clonenotsupportedexception.display.name='clone()' does not declare 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.problem.descriptor=<code>#ref()</code> #loc does not declare 'CloneNotSupportedException'
clone.doesnt.declare.clonenotsupportedexception.declare.quickfix=Declare 'CloneNotSupportedException'
clone.method.in.non.cloneable.class.display.name='clone()' method in non-Cloneable class
clone.method.in.non.cloneable.class.problem.descriptor=<code>#ref()</code> defined in non-Cloneable class ''{0}'' #loc
clone.method.in.non.cloneable.interface.problem.descriptor=<code>#ref()</code> defined in non-Cloneable interface ''{0}'' #loc
cloneable.class.without.clone.display.name=Cloneable class without 'clone()'
cloneable.class.without.clone.problem.descriptor=<code>#ref</code> does not define 'clone()' #loc
cloneable.class.without.clone.ignore.option=Ignore classes cloneable due to inheritance
cloneable.class.without.clone.quickfix=Generate 'clone()' method
class.without.tostring.display.name=Class without 'toString()'
class.without.tostring.problem.descriptor=Class <code>#ref</code> should probably implement 'toString()', for debugging purposes #loc
use.obsolete.collection.type.display.name=Use of obsolete collection type
use.obsolete.collection.type.problem.descriptor=Obsolete collection type <code>#ref</code> used #loc
use.obsolete.collection.type.ignore.library.arguments.option=Ignore obsolete collection types where they are required
inspection.suppression.annotation.display.name=Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor=Inspection suppression annotation <code>#ref</code> #loc
use.system.out.err.display.name=Use of System.out or System.err
use.system.out.err.problem.descriptor=Uses of <code>#ref</code> should probably be replaced with more robust logging #loc
dumpstack.call.display.name=Call to 'Thread.dumpStack()'
dumpstack.call.problem.descriptor=Call to <code>Thread.#ref()</code> should probably be replaced with more robust logging #loc
printstacktrace.call.display.name=Call to 'printStackTrace()'
printstacktrace.call.problem.descriptor=Call to <code>#ref()</code> should probably be replaced with more robust logging #loc
abstract.method.call.in.constructor.display.name=Abstract method called during object construction
abstract.method.call.in.constructor.problem.descriptor=Call to 'abstract' method <code>#ref()</code> during object construction #loc
instance.variable.may.not.be.initialized.display.name=Instance field may not be initialized
instance.variable.may.not.be.initialized.problem.descriptor=Instance field <code>#ref</code> may not be initialized during object construction #loc
instance.Variable.may.not.be.initialized.problem.descriptor.junit=Instance field <code>#ref</code> may not be initialized during object construction or 'setUp()' call #loc
primitive.fields.ignore.option=Ignore primitive fields
instance.variable.used.before.initialized.display.name=Instance field used before initialization
instance.variable.used.before.initialized.problem.descriptor=Instance field <code>#ref</code> used before initialized #loc
non.final.static.variable.initialization.display.name=Non-final static field is used during class initialization
non.final.static.variable.initialization.problem.descriptor=Non-final static field <code>#ref</code> used during class initialization #loc
overridable.method.call.in.constructor.display.name=Overridable method called during object construction
overridable.method.call.in.constructor.problem.descriptor=Call to overridable method <code>#ref()</code> during object construction #loc
overridden.method.call.in.constructor.display.name=Overridden method called during object construction
overridden.method.call.in.constructor.problem.descriptor=Call to overridden method <code>#ref()</code> during object construction #loc
static.variable.may.not.be.initialized.display.name=Static field may not be initialized
static.variable.may.not.be.initialized.problem.descriptor=Static field <code>#ref</code> may not be initialized during class initialization #loc
static.variable.used.before.initialization.display.name=Static field used before initialization
static.variable.used.before.initialization.problem.descriptor=Static field <code>#ref</code> used before initialization #loc
this.reference.escaped.in.construction.display.name='this' reference escaped in object construction
this.reference.escaped.in.construction.problem.descriptor=Escape of <code>#ref</code> during object construction #loc
assignment.to.catch.block.parameter.display.name=Assignment to catch block parameter
extract.parameter.as.local.variable.quickfix=Extract parameter as local variable
assignment.to.for.loop.parameter.display.name=Assignment to 'for' loop parameter
assignment.to.for.loop.parameter.check.foreach.option=Check foreach parameters
assignment.to.for.loop.parameter.problem.descriptor=Assignment to for-loop parameter <code>#ref</code> #loc
assignment.to.method.parameter.display.name=Assignment to method parameter
chained.equality.comparisons.display.name=Chained equality comparisons
confusing.octal.escape.sequence.display.name=Confusing octal escape sequence
increment.decrement.display.name=Value of ++ or -- used
nested.assignment.display.name=Result of assignment used
nested.assignment.problem.descriptor=Result of assignment expression used #loc
overloaded.methods.with.same.number.parameters.display.name=Overloaded methods with same number of parameters
overloaded.vararg.method.display.name=Overloaded varargs method
refused.bequest.display.name=Method does not call super method
reuse.of.local.variable.display.name=Reuse of local variable
reuse.of.local.variable.split.quickfix=Split local variable
character.comparison.display.name=Character comparison
character.comparison.problem.descriptor=Character comparison <code>#ref</code> in an internationalized context #loc
assignment.collection.array.field.from.parameter.display.name=Assignment to Collection or array field from parameter
assignment.collection.array.field.from.parameter.problem.descriptor.array=Assignment to array field <code>#ref</code> from parameter ''{0}'' #loc
assignment.collection.array.field.from.parameter.problem.descriptor.collection=Assignment to Collection field <code>#ref</code> from parameter ''{0}'' #loc
assignment.collection.array.field.option=Ignore assignments in 'private' methods
assignment.to.date.calendar.field.from.parameter.display.name=Assignment to Date or Calendar field from parameter
assignment.to.date.calendar.field.from.parameter.problem.descriptor=Assignment to ''{0}'' field <code>#ref</code> from parameter {1} #loc
package.visible.field.display.name=Package-visible field
package.visible.field.problem.descriptor=Package-visible field <code>#ref</code> #loc
package.visible.inner.class.display.name=Package-visible inner class
package.visible.inner.class.problem.descriptor=Package-visible inner class <code>#ref</code> #loc
package.visible.inner.class.ignore.enum.option=Ignore package-visible inner enums
package.visible.inner.class.ignore.interface.option=Ignore package-visible inner interfaces
protected.field.display.name=Protected field
protected.field.problem.descriptor=Protected field <code>#ref</code> #loc
protected.inner.class.display.name=Protected inner class
protected.inner.class.problem.descriptor=Protected inner class <code>#ref</code> #loc
protected.inner.class.ignore.enum.option=Ignore 'protected' inner enums
protected.inner.class.ignore.interface.option=Ignore 'protected' inner interfaces
public.field.display.name='public' field
public.field.problem.descriptor='public' field <code>#ref</code> #loc
public.field.ignore.enum.type.fields.option=Ignore 'public final' fields of an enum type
public.inner.class.display.name='public' inner class
public.inner.class.problem.descriptor='public' inner class <code>#ref</code> #loc
public.inner.class.ignore.enum.option=Ignore 'public' inner enums
public.inner.class.ignore.interface.option=Ignore 'public' inner interfaces
return.of.collection.array.field.display.name=Return of Collection or array field
return.of.collection.array.field.problem.descriptor.array='return' of array field <code>#ref</code> #loc
return.of.collection.array.field.problem.descriptor.collection='return' of Collection field <code>#ref</code> #loc
return.of.collection.array.field.option=Ignore 'private' methods returning an array or collection field
return.date.calendar.field.display.name=Return of Date or Calendar field
return.date.calendar.field.problem.descriptor=Return of ''{0}'' field <code>#ref</code> #loc
return.date.calendar.field.quickfix=Return clone of ''{0}''
accessing.non.public.field.of.another.object.display.name=Accessing a non-public field of another object
accessing.non.public.field.of.another.object.problem.descriptor=Direct access of non-public field <code>#ref</code> on another object #loc
call.to.date.tostring.display.name=Call to 'Date.toString()'
call.to.date.tostring.problem.descriptor=<code>Date.#ref()</code> used in an internationalized context #loc
magic.character.display.name=Magic character
magic.character.problem.descriptor=Magic character <code>#ref</code> in an internationalized context #loc
call.to.numeric.tostring.display.name=Call to Numeric 'toString()'
call.to.numeric.tostring.problem.descriptor=Numeric <code>#ref()</code> called in an internationalized context #loc
instantiating.simpledateformat.without.locale.display.name=Instantiating a SimpleDateFormat without a Locale
instantiating.simpledateformat.without.locale.problem.descriptor=Instantiating a <code>#ref</code> without specifying a Locale in an internationalized context #loc
string.concatenation.display.name=String concatenation
string.concatenation.problem.descriptor=String concatenation <code>#ref</code> in an internationalized context #loc
inspection.option.ignore.system.out=Ignore for 'System.out.print' arguments
inspection.option.ignore.system.err=Ignore for 'System.err.print' arguments
inspection.option.ignore.assert=Ignore for assert statement description arguments
inspection.option.ignore.exceptions=Ignore for constructor arguments of Throwable subclasses
inspection.option.ignore.nonnls=Ignore when annotated via @NonNls
inspection.option.ignore.constant.initializers=Ignore for initializers of constant fields
inspection.option.ignore.in.annotations=Ignore in annotations
inspection.option.ignore.in.tostring=Ignore inside toString() methods
inspection.option.ignore.as.initial.capacity=Ignore initial capacity for StringBuilders and Collections
inspection.option.ignore.in.hashcode=Ignore constants in 'hashCode()' methods
string.touppercase.tolowercase.without.locale.display.name=Call to 'String.toUpperCase()' or 'toLowerCase()' without a Locale
string.touppercase.tolowercase.without.locale.problem.descriptor=<code>String.#ref()</code> called without specifying a Locale using internationalized strings #loc
use.stringtokenizer.display.name=Use of StringTokenizer
use.stringtokenizer.problem.descriptor=<code>#ref</code> in an internationalized context #loc
time.tostring.call.display.name=Call to 'Time.toString()'
time.tostring.call.problem.descriptor=<code>Time.#ref()</code> in an internationalized context #loc
class.escapes.defined.scope.display.name=Non-accessible class is exposed
class.escapes.defined.scope.display.module.option=Module's API exposes not exported classes (Java 9+)
class.escapes.defined.scope.display.public.option=Public API exposes non-accessible classes
class.escapes.defined.scope.display.package.option=Package-local API exposes private classes
class.escapes.defined.scope.problem.descriptor=Class <code>#ref</code> is exposed outside its defined scope #loc
class.escapes.defined.scope.java9.modules.descriptor=Class <code>#ref</code> is not exported from module ''{0}''
field.name.hides.in.superclass.display.name=Field name hides field in superclass
field.name.hides.in.superclass.problem.descriptor=Field <code>#ref</code> hides field in superclass #loc
field.name.hides.in.superclass.ignore.option=Ignore superclass fields not visible from subclass
inner.class.field.hides.outer.display.name=Inner class field hides outer class field
inner.class.field.hides.outer.ignore.option=Ignore outer fields not visible from inner class
inner.class.field.hides.outer.problem.descriptor=Inner class field <code>#ref</code> hides outer class field #loc
local.variable.hides.member.variable.display.name=Local variable hides field
local.variable.hides.member.variable.problem.descriptor=Local variable <code>#ref</code> hides field in class ''{0}'' #loc
local.variable.hides.member.variable.ignore.option=Ignore local variables in a static context
method.overloads.display.name=Method overloads method of superclass
method.overloads.problem.descriptor=Method <code>#ref()</code> overloads a compatible method of a superclass, when overriding might have been intended #loc
method.overloads.report.incompatible.option=Report even if parameter types are not compatible
method.overrides.private.display.name.problem.descriptor=Method <code>#ref()</code> overrides a 'private' method of a superclass #loc
method.overrides.static.display.name=Method overrides static method of superclass
method.overrides.static.problem.descriptor=Method <code>#ref()</code> overrides a static method of a superclass #loc
parameter.hides.member.variable.display.name=Parameter hides field
parameter.hides.member.variable.problem.descriptor=Parameter <code>#ref</code> hides field in class ''{0}'' #loc
parameter.hides.member.variable.ignore.setters.option=Ignore for property setters
parameter.hides.member.variable.ignore.superclass.option=Ignore superclass fields not visible from subclass
parameter.hides.member.variable.ignore.constructors.option=Ignore for constructors
parameter.hides.member.variable.ignore.abstract.methods.option=Ignore for abstract methods
parameter.hides.member.variable.ignore.static.parameters.option=Ignore for static method parameters hiding instance fields
type.parameter.hides.visible.type.display.name=Type parameter hides visible type
type.parameter.hides.visible.type.problem.descriptor=Type parameter <code>#ref</code> hides visible type ''{0}'' #loc
type.parameter.hides.type.parameter.problem.descriptor=Type parameter <code>#ref</code> hides type parameter ''{0}'' #loc
anonymous.class.variable.hides.containing.method.variable.display.name=Anonymous class variable hides variable in containing method
anonymous.class.parameter.hides.containing.method.variable.problem.descriptor=Anonymous class parameter <code>#ref</code> hides variable in containing method #loc
anonymous.class.field.hides.containing.method.variable.problem.descriptor=Anonymous class field <code>#ref</code> hides variable in containing method #loc
anonymous.class.variable.hides.containing.method.variable.problem.descriptor=Anonymous class local variable <code>#ref</code> hides variable in containing method #loc
channel.opened.not.closed.display.name=Channel opened but not safely closed
drivermanager.call.display.name=Use of DriverManager to get JDBC connection
drivermanager.call.problem.descriptor=Call to <code>DriverManager.#ref()</code> #loc
hibernate.resource.opened.not.closed.display.name=Hibernate resource opened but not safely closed
i.o.resource.opened.not.closed.display.name=I/O resource opened but not safely closed
resource.opened.not.closed.problem.descriptor=''{0}'' should be opened in front of a ''try'' block and closed in the corresponding ''finally'' block #loc
jdbc.resource.opened.not.closed.display.name=JDBC resource opened but not safely closed
jndi.resource.opened.not.closed.display.name=JNDI resource opened but not safely closed
socket.opened.not.closed.display.name=Socket opened but not safely closed
annotation.class.display.name=Annotation class
annotation.class.problem.descriptor=Annotation class <code>#ref</code> #loc
annotation.display.name=Annotation
annotation.problem.descriptor=Annotation <code>#ref</code> #loc
use.assert.as.identifier.display.name=Use of 'assert' as identifier
use.assert.as.identifier.problem.descriptor=Use of <code>#ref</code> as identifier #loc
assert.statement.display.name='assert' statement
statement.problem.descriptor=<code>#ref</code> statement #loc
auto.boxing.display.name=Auto-boxing
auto.boxing.problem.descriptor=Auto-boxing <code>#ref</code> #loc
auto.boxing.make.boxing.explicit.quickfix=Make boxing explicit
auto.boxing.ignore.added.to.collection.option=Ignore expressions added to a collection
auto.unboxing.display.name=Auto-unboxing
auto.unboxing.problem.descriptor=Auto-unboxing <code>#ref</code> #loc
auto.unboxing.make.unboxing.explicit.quickfix=Make unboxing explicit
use.enum.as.identifier.display.name=Use of 'enum' as identifier
use.enum.as.identifier.problem.descriptor=Use of <code>#ref</code> as identifier #loc
enumerated.class.display.name=Enumerated class
enumerated.class.problem.descriptor=Enumerated class <code>#ref</code> #loc
extended.for.statement.display.name=Extended 'for' statement
extended.for.statement.replace.quickfix=Replace with old-style 'for' statement
variable.argument.method.display.name=Varargs method
variable.argument.method.problem.descriptor=Varargs method <code>#ref()</code> #loc
variable.argument.method.quickfix=Convert varargs parameter to array
hardcoded.file.separator.display.name=Hardcoded file separator
hardcoded.file.separator.problem.descriptor=Hardcoded file separator <code>#ref</code> #loc
hardcoded.file.separator.include.option=Include "example/*" in recognized MIME media types
hardcoded.line.separator.display.name=Hardcoded line separator
hardcoded.line.separator.problem.descriptor=Hardcoded line separator <code>#ref</code> #loc
native.method.display.name=Native method
native.method.problem.descriptor=Methods declared <code>#ref</code> are non-portable #loc
runtime.exec.call.display.name=Call to 'Runtime.exec()'
runtime.exec.call.problem.descriptor=Call to <code>Runtime.#ref()</code> is non-portable #loc
system.exit.call.display.name=Call to 'System.exit()' or related methods
system.exit.call.problem.descriptor=Call to <code>{0}.#ref()</code> is non-portable #loc
system.exit.call.ignore.option=Ignore in main method
system.getenv.call.display.name=Call to 'System.getenv()'
system.getenv.call.problem.descriptor=Call to <code>System.#ref()</code> is non-portable #loc
use.of.awt.peer.class.display.name=Use of AWT peer class
use.of.awt.peer.class.problem.descriptor=Use of AWT peer class <code>#ref</code> is non-portable #loc
use.of.concrete.jdbc.driver.class.display.name=Use of concrete JDBC driver class
use.of.concrete.jdbc.driver.class.problem.descriptor=Use of concrete JDBC driver class <code>#ref</code> is non-portable #loc
use.processbuilder.class.display.name=Use of 'java.lang.ProcessBuilder' class
use.processbuilder.class.problem.descriptor=Use of <code>#ref</code> is non-portable #loc
use.sun.classes.display.name=Use of sun.* classes
use.sun.classes.problem.descriptor=Use of Sun-supplied class <code>#ref</code> is non-portable #loc
abstract.class.with.only.one.direct.inheritor.display.name=Abstract class which has only one direct inheritor
anonymous.inner.may.be.named.static.inner.class.display.name=Anonymous class may be a named 'static' inner class
anonymous.inner.may.be.named.static.inner.class.problem.descriptor=Anonymous class <code>#ref</code> may be a named 'static' inner class #loc
array.length.in.loop.condition.display.name=Array.length in loop condition
array.length.in.loop.condition.problem.descriptor=Check of array <code>#ref</code> in loop condition #loc
large.array.allocation.no.outofmemoryerror.display.name=Large array allocation with no OutOfMemoryError check
large.array.allocation.no.outofmemoryerror.problem.descriptor=Large array allocation which is not checked for out-of-memory condition #loc
large.array.allocation.no.outofmemoryerror.maximum.number.of.elements.option=Maximum number of elements:
connection.opened.not.safely.closed.display.name=Connection opened but not safely closed
interface.one.inheritor.display.name=Interface which has only one direct inheritor
interface.one.inheritor.problem.descriptor=Interface <code>#ref</code> has only one direct inheritor #loc
method.call.in.loop.condition.display.name=Method call in loop condition
method.call.in.loop.condition.problem.descriptor=Call to method <code>#ref()</code> in loop condition #loc
large.initializer.primitive.type.array.display.name=Overly large initializer for array of primitive type
large.initializer.primitive.type.array.problem.descriptor=Primitive array initializer with too many elements ({0}) #loc
large.initializer.primitive.type.array.maximum.number.of.elements.option=Maximum number of elements:
private.member.access.between.outer.and.inner.classes.display.name=Synthetic accessor call
private.member.access.between.outer.and.inner.classes.problem.descriptor=Access to 'private' member of class ''{0}'' requires synthetic accessor call #loc
private.member.access.between.outer.and.inner.classes.make.local.quickfix=Make ''{0}'' package-private
private.member.access.between.outer.and.inner.classes.make.constructor.package.local.quickfix=Make ''{0}'' constructor package-private
recordstore.opened.not.safely.closed.display.name=RecordStore opened but not safely closed
overly.complex.anonymous.inner.class.display.name=Overly complex anonymous class
cyclomatic.complexity.limit.option=Cyclomatic complexity limit:
overly.complex.anonymous.inner.class.problem.descriptor=Overly complex anonymous class (cyclomatic complexity = {0}) #loc
anonymous.inner.class.with.too.many.methods.display.name=Anonymous inner class with too many methods
method.count.limit.option=Method count limit:
anonymous.inner.class.with.too.many.methods.problem.descriptor=Anonymous inner class with too many methods (method count = {0}) #loc
overly.complex.class.display.name=Overly complex class
overly.complex.class.problem.descriptor=Overly complex class <code>#ref</code> (cyclomatic complexity = {0}) #loc
overly.coupled.class.display.name=Overly coupled class
overly.coupled.class.class.coupling.limit.option=Class coupling limit:
include.java.system.classes.option=Include couplings to java system classes
include.library.classes.option=Include couplings to library classes
overly.coupled.class.problem.descriptor=<code>#ref</code> is overly coupled (dependencies = {0}) #loc
class.too.deep.display.name=Class too deep in inheritance tree
class.too.deep.inheritance.depth.limit.option=Inheritance depth limit:
class.too.deep.problem.descriptor=<code>#ref</code> is too deep in inheritance tree (inheritance depth = {0}) #loc
inner.class.too.deeply.nested.display.name=Inner class too deeply nested
inner.class.too.deeply.nested.nesting.limit.option=Nesting limit:
inner.class.too.deeply.nested.problem.descriptor=<code>#ref</code> is too deeply nested (nesting level = {0}) #loc
too.many.constructors.display.name=Class with too many constructors
too.many.constructors.count.limit.option=Constructor count limit:
too.many.constructors.ignore.deprecated.option=Ignore deprecated constructors
too.many.constructors.problem.descriptor=<code>#ref</code> has too many constructors (constructor count = {0}) #loc
too.many.fields.display.name=Class with too many fields
too.many.fields.count.limit.option=Field count limit:
too.many.fields.problem.descriptor=<code>#ref</code> has too many fields (field count = {0}) #loc
too.many.methods.display.name=Class with too many methods
too.many.methods.problem.descriptor=<code>#ref</code> has too many methods (method count = {0}) #loc
externalizable.with.serialization.methods.display.name=Externalizable class with 'readObject()' or 'writeObject()'
externalizable.with.serialization.methods.problem.descriptor.both=Externalizable class <code>#ref</code> defines 'readObject()' and 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.write=Externalizable class <code>#ref</code> defines 'writeObject()' #loc
externalizable.with.serialization.methods.problem.descriptor.read=Externalizable class <code>#ref</code> defines 'readObject()' #loc
non.serializable.with.serialversionuid.display.name=Non-serializable class with 'serialVersionUID'
non.serializable.class.with.serialversionuid.problem.descriptor=Non-serializable class <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.interface.with.serialversionuid.problem.descriptor=Non-serializable interface <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.@interface.with.serialversionuid.problem.descriptor=Non-serializable @interface <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.anonymous.with.serialversionuid.problem.descriptor=Non-serializable anonymous class extending <code>#ref</code> defines a 'serialVersionUID' field #loc
non.serializable.with.serialversionuid.remove.quickfix=Remove 'serialVersionUID' field
non.serializable.class.with.readwriteobject.display.name=Non-serializable class with 'readObject()' or 'writeObject()'
non.serializable.class.with.readwriteobject.problem.descriptor.both=Non-serializable class <code>#ref</code> defines 'readObject()' and 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.write=Non-serializable class <code>#ref</code> defines 'writeObject()' #loc
non.serializable.class.with.readwriteobject.problem.descriptor.read=Non-serializable class <code>#ref</code> defines 'readObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.both=Non-serializable anonymous class extending <code>#ref</code> defines 'readObject()' and 'writeObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.write=Non-serializable anonymous class extending <code>#ref</code> defines 'writeObject()' #loc
non.serializable.anonymous.with.readwriteobject.problem.descriptor.read=Non-serializable anonymous class extending <code>#ref</code> defines 'readObject()' #loc
readwriteobject.private.display.name='readObject()' or 'writeObject()' not declared 'private'
readwriteobject.private.problem.descriptor=<code>#ref</code> not declared 'private' #loc
readobject.initialization.display.name=Instance field may not be initialized by 'readObject()'
readobject.initialization.problem.descriptor=Instance field <code>#ref</code> may not be initialized during 'readObject()' call #loc
readresolve.writereplace.protected.display.name='readResolve()' or 'writeReplace()' not declared 'protected'
readresolve.writereplace.protected.problem.descriptor=<code>#ref()</code> not declared 'protected' #loc
serialpersistentfields.with.wrong.signature.display.name='serialPersistentFields' field not declared 'private static final ObjectStreamField[]'
serialpersistentfields.with.wrong.signature.problem.descriptor=<code>#ref</code> field of a Serializable class is not declared 'private static final ObjectStreamField[]' #loc
serialversionuid.private.static.final.long.display.name='serialVersionUID' field not declared 'private static final long'
serialversionuid.private.static.final.long.problem.descriptor=<code>#ref</code> field of a Serializable class is not declared 'private static final long' #loc
serialversionuid.private.static.final.long.quickfix=Make serialVersionUID 'private static final'
serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc

#dynamic
non.protected.constructor.in.abstract.class.display.name='public' constructor in 'abstract' class
unnecessary.qualifier.for.this.display.name=Unnecessary qualifier for 'this' or 'super'
multiple.declaration.display.name=Multiple variables in one declaration
thread.priority.display.name=Call to 'Thread.setPriority()'
too.broad.scope.display.name=Scope of variable is too broad
infinite.loop.statement.display.name=Infinite loop statement
asserts.without.messages.display.name=Message missing on JUnit assertion
constant.naming.convention.display.name=Constant naming convention
constant.naming.convention.element.description=Constant
random.double.for.random.integer.display.name=Using 'Random.nextDouble()' to get random integer
test.method.without.assertion.display.name=JUnit test method without any assertions
string.buffer.replaceable.by.string.builder.display.name='StringBuffer' may be 'StringBuilder'
comparison.of.short.and.char.display.name=Comparison of 'short' and 'char' values
unnecessary.fully.qualified.name.display.name=Unnecessary fully qualified name
ignore.in.module.statements.option=Ignore in Java 9 module statements
unnecessary.label.on.break.statement.display.name=Unnecessary label on 'break' statement
exception.name.doesnt.end.with.exception.display.name=Exception class name does not end with 'Exception'
bad.exception.declared.display.name=Prohibited exception declared
pointless.boolean.expression.display.name=Pointless boolean expression
class.without.constructor.display.name=Class without constructor
break.statement.display.name='break' statement
unconditional.wait.display.name=Unconditional 'wait()' call
cyclomatic.complexity.display.name=Overly complex method
string.to.string.display.name=Redundant 'String.toString()'
constant.on.lhs.of.comparison.display.name=Constant on left side of comparison
final.class.display.name='final' class
labeled.statement.display.name=Labeled statement
notify.called.on.condition.display.name='notify()'  or 'notifyAll()' called on 'java.util.concurrent.locks.Condition' object
loop.statements.that.dont.loop.display.name=Loop statement that does not loop
thread.run.display.name=Call to 'Thread.run()'
non.synchronized.method.overrides.synchronized.method.display.name=Unsynchronized method overrides synchronized method
constant.on.rhs.of.comparison.display.name=Constant on right side of comparison
synchronize.on.this.display.name=Synchronization on 'this'
switch.statement.with.too.many.branches.display.name='switch' statement with too many branches
utility.class.without.private.constructor.display.name=Utility class without 'private' constructor
throw.caught.locally.display.name='throw' caught by containing 'try' statement
exception.from.catch.which.doesnt.wrap.display.name='throw' inside 'catch' block which ignores the caught exception
type.parameter.naming.convention.display.name=Type parameter naming convention
type.parameter.naming.convention.element.description=Type parameter
multiply.or.divide.by.power.of.two.display.name=Multiply or divide by power of two
multiply.or.divide.by.power.of.two.divide.option=Check divisions by a power of two also
serializable.with.unconstructable.ancestor.display.name=Serializable class with unconstructable ancestor
missorted.modifiers.display.name=Missorted modifiers
sleep.while.holding.lock.display.name=Call to 'Thread.sleep()' while synchronized
singleton.display.name=Singleton
thread.death.rethrown.display.name='java.lang.ThreadDeath' not rethrown
if.statement.with.too.many.branches.display.name='if' statement with too many branches
redundant.implements.display.name=Redundant interface declaration
nesting.depth.display.name=Overly nested method
return.this.display.name=Return of 'this'
busy.wait.display.name=Busy wait
utility.class.display.name=Utility class
instantiating.object.to.get.class.object.display.name=Instantiating object to get Class object
abstract.class.extends.concrete.class.display.name=Abstract class extends concrete class
parameter.naming.convention.display.name=Method parameter naming convention
parameter.naming.convention.element.description=Parameter
integer.division.in.floating.point.context.display.name=Integer division in floating point context
interface.naming.convention.display.name=Interface naming convention
interface.naming.convention.element.description=Interface
length.one.strings.in.concatenation.display.name=Single character string concatenation
length.one.string.in.indexof.display.name= Single character string argument in 'String.indexOf()' call
unnecessary.conditional.expression.display.name=Redundant conditional expression
thread.yield.display.name=Call to 'Thread.yield()'
confusing.floating.point.literal.display.name=Confusing floating-point literal
wait.not.in.loop.display.name='wait()' not in loop
string.concatenation.inside.string.buffer.append.display.name=String concatenation as argument to 'StringBuilder.append()' call
class.initializer.display.name=Non-'static' initializer
enumerated.class.naming.convention.display.name=Enumerated class naming convention
enumerated.class.naming.convention.element.description=Enumerated class
non.thread.safe.lazy.initialization.display.name=Unsafe lazy initialization of 'static' field
call.to.simple.setter.in.class.display.name=Call to simple setter from within class
comparison.to.nan.display.name=Comparison to Double.NaN or Float.NaN
instance.method.naming.convention.display.name=Instance method naming convention
instance.method.naming.convention.element.description=Instance method
unnecessary.semicolon.display.name=Unnecessary semicolon
fallthru.in.switch.statement.display.name=Fallthrough in 'switch' statement
call.to.native.method.while.locked.display.name=Call to a native method while locked
switch.statement.display.name='switch' statement
custom.classloader.display.name=Custom ClassLoader
nested.conditional.expression.display.name=Nested conditional expression
duplicate.condition.display.name=Duplicate condition in 'if' statement
duplicate.boolean.branch.display.name=Duplicate condition on '\\&\\&' or '||'
method.with.multiple.loops.display.name=Method with multiple loops
non.comment.source.statements.display.name=Overly long method
local.variable.naming.convention.display.name=Local variable naming convention
local.variable.naming.convention.element.description=Local variable
negated.if.else.display.name='if' statement with negated condition
class.naming.convention.display.name=Class naming convention
class.naming.convention.element.description=Class
abstract.class.naming.convention.display.name=Abstract class naming convention
abstract.class.naming.convention.element.description=Abstract class
serializable.inner.class.with.non.serializable.outer.class.display.name=Serializable non-'static' inner class with non-Serializable outer class
pointless.arithmetic.expression.display.name=Pointless arithmetic expression
method.name.same.as.class.name.display.name=Method name same as class name
unnecessary.temporary.on.conversion.to.string.display.name=Unnecessary temporary object in conversion to String
unnecessary.continue.display.name=Unnecessary 'continue' statement
inner.class.on.interface.display.name=Inner class of interface
unused.label.display.name=Unused label
multiple.typed.declaration.display.name=Variables of different types in one declaration
overly.complex.boolean.expression.display.name=Overly complex boolean expression
continue.statement.with.label.display.name='continue' statement with label
class.loader.instantiation.display.name=ClassLoader instantiation
return.from.finally.block.display.name='return' inside 'finally' block
unnecessary.boxing.display.name=Unnecessary boxing
annotation.naming.convention.display.name=Annotation naming convention
annotation.naming.convention.element.description=Annotation
checked.exception.class.display.name=Checked exception class
switch.statement.with.confusing.declaration.display.name=Local variable used and declared in different 'switch' branches
cast.that.loses.precision.display.name=Numeric cast that loses precision
manual.array.copy.display.name=Manual array copy
manual.array.to.collection.copy.display.name=Manual array to collection copy
long.literals.ending.with.lowercase.l.display.name='long' literal ending with 'l' instead of 'L'
overly.complex.arithmetic.expression.display.name=Overly complex arithmetic expression
junit.abstract.test.class.naming.convention.display.name=JUnit abstract test class naming convention
junit.abstract.test.class.naming.convention.element.description=Abstract JUnit test class
unnecessary.parentheses.display.name=Unnecessary parentheses
test.case.in.product.code.display.name=JUnit TestCase in product source
test.method.in.product.code.display.name=JUnit test method in product source
serializable.class.in.secure.context.display.name=Serializable class in secure context
static.variable.naming.convention.display.name='static' field naming convention
static.variable.naming.convention.element.description='static' field
nested.method.call.display.name=Nested method call
throw.from.finally.block.display.name='throw' inside 'finally' block
field.accessed.synchronized.and.unsynchronized.display.name=Field accessed in both synchronized and unsynchronized contexts
abstract.method.overrides.abstract.method.display.name=Abstract method overrides abstract method
static.non.final.field.display.name='static', non-'final' field
static.non.final.field.option=Only report 'public' fields
substring.zero.display.name=Redundant 'substring(0)' call
class.without.no.arg.constructor.display.name=Class without no-arg constructor
unnecessary.return.display.name=Unnecessary 'return' statement
final.static.method.display.name='static' method declared 'final'
constant.declared.in.abstract.class.display.name=Constant declared in abstract class
too.broad.catch.display.name=Overly broad 'catch' block
floating.point.equality.display.name=Floating point equality comparison
thrown.exceptions.per.method.display.name=Method with too many exceptions declared
public.static.array.field.display.name='public static' array field
await.not.in.loop.display.name='await()' not in loop
method.names.differ.only.by.case.display.name=Method names differing only by case
unsecure.random.number.generation.display.name=Insecure random number generation
parameters.per.method.display.name=Method with too many parameters
parameters.per.constructor.display.name=Constructor with too many parameters
unnecessary.unboxing.display.name=Unnecessary unboxing
extends.thread.display.name=Class directly extends 'java.lang.Thread'
test.case.with.constructor.display.name=JUnit TestCase with non-trivial constructors
parameter.name.differs.from.overridden.parameter.display.name=Parameter name differs from parameter in overridden method
final.private.method.display.name='private' method declared 'final'
enum.switch.statement.which.misses.cases.display.name=Enum 'switch' statement that misses case
enum.switch.statement.which.misses.cases.option=Ignore switch statements with a default branch
unconstructable.test.case.display.name=Unconstructable JUnit TestCase
volatile.long.or.double.field.display.name=Volatile long or double field
string.buffer.must.have.initial.capacity.display.name=StringBuilder without initial capacity
method.may.be.static.display.name=Method may be 'static'
class.initializer.may.be.static.display.name=Class initializer may be 'static'
class.initializer.option=Only warn when the class has one or more constructors
class.initializer.move.code.to.constructor.quickfix=Move initializer code to constructor
nested.switch.statement.display.name=Nested 'switch' statement
c.style.array.declaration.display.name=C-style array declaration
final.method.in.final.class.display.name='final' method in 'final' class
extends.annotation.display.name=Class extends annotation interface
naked.notify.display.name='notify()' or 'notifyAll()' without corresponding state change
constant.if.statement.display.name=Constant 'if' statement
switch.statement.density.display.name='switch' statement with too low of a branch density
switch.statement.with.too.few.branches.display.name='switch' statement with too few branches
upper.case.field.name.not.constant.display.name=Non-constant field with upper-case name
unnecessary.label.on.continue.statement.display.name=Unnecessary label on 'continue' statement
jdbc.prepare.statement.with.non.constant.string.display.name=Call to 'Connection.prepare*()' with non-constant string
synchronize.on.non.final.field.display.name=Synchronization on a non-final field
noop.method.in.abstract.class.display.name=No-op method in abstract class
non.final.field.of.exception.display.name=Non-final field of exception class
nested.try.statement.display.name=Nested 'try' statement
condition.signal.display.name=Call to 'signal()' instead of 'signalAll()'
jdbc.execute.with.non.constant.string.display.name=Call to 'Statement.execute()' with non-constant string
system.set.security.manager.display.name=Call to 'System.setSecurityManager()'
system.set.security.manager.problem.descriptor=Call to <code>System.#ref()</code> may pose security concerns #loc
control.flow.statement.without.braces.display.name=Control flow statement without braces
trivial.if.display.name=Redundant 'if' statement
thread.with.default.run.method.display.name=Instantiating a Thread with default 'run()' method
while.loop.spins.on.field.display.name='while' loop spins on field
while.loop.spins.on.field.fix.family.name=Fix spin loop
while.loop.spins.on.field.fix.volatile=Make ''{0}'' volatile
while.loop.spins.on.field.fix.spinwait=Add Thread.onSpinWait()
while.loop.spins.on.field.fix.volatile.spinwait=Make ''{0}'' volatile and add Thread.onSpinWait()
object.equals.null.display.name=Object.equals(null)
test.method.is.public.void.no.arg.display.name=Malformed test method
if.statement.with.identical.branches.display.name='if' statement with identical branches
multiple.return.points.per.method.display.name=Method with multiple return points
break.statement.with.label.display.name='break' statement with label
public.constructor.in.non.public.class.display.name='public' constructor in non-public class
questionable.name.display.name=Questionable name
empty.finally.block.display.name=Empty 'finally' block
abstract.method.overrides.concrete.method.display.name=Abstract method overrides concrete method
thread.stop.suspend.resume.display.name=Call to 'Thread.stop()', 'suspend()' or 'resume()'
constant.math.call.display.name=Constant call to 'java.lang.Math'
volatile.array.field.display.name=Volatile array field
literal.as.arg.to.string.equals.display.name='expression.equals("literal")' rather than '"literal".equals(expression)'
inner.class.may.be.static.display.name=Inner class may be 'static'
static.suite.display.name='suite()' method not declared 'static'
redundant.field.initialization.display.name=Redundant field initialization
string.buffer.to.string.in.concatenation.display.name='StringBuilder.toString()' in concatenation
utility.class.with.public.constructor.display.name=Utility class with 'public' constructor
for.loop.replaceable.by.while.display.name='for' loop may be replaced with 'while' loop
missing.deprecated.annotation.display.name=Missing @Deprecated annotation
cloneable.class.in.secure.context.display.name=Cloneable class in secure context
static.inheritance.display.name=Static inheritance
class.name.prefixed.with.package.name.display.name=Class name prefixed with package name
call.to.simple.getter.in.class.display.name=Call to simple getter from within class
class.name.differs.from.file.name.display.name=Class name differs from file name
protected.member.in.final.class.display.name='protected' member in 'final' class
load.library.with.non.constant.string.display.name=Call to 'System.loadLibrary()' with non-constant string
instanceof.catch.parameter.display.name='instanceof' on 'catch' parameter
implicit.numeric.conversion.display.name=Implicit numeric conversion
unnecessary.interface.modifier.display.name=Unnecessary interface modifier
confusing.main.method.display.name=Confusing 'main()' method
octal.literal.display.name=Octal integer
misordered.assert.equals.arguments.display.name=Misordered 'assertEquals()' arguments
unnecessary.constructor.display.name=Redundant no-arg constructor
method.name.same.as.parent.name.display.name=Method name same as parent class name
while.can.be.foreach.display.name='while' loop replaceable with 'foreach'
big.decimal.equals.display.name='equals()' called on 'java.math.BigDecimal'
implicit.call.to.super.display.name=Implicit call to 'super()'
empty.catch.block.display.name=Empty 'catch' block
unqualified.static.usage.display.name=Unqualified static access
simplifiable.junit.assertion.display.name=Simplifiable JUnit assertion
simplifiable.testng.assertion.display.name=Simplifiable TestNG assertion
object.notify.display.name=Call to 'notify()' instead of 'notifyAll()'
thread.start.in.construction.display.name=Call to 'Thread.start()' during object construction
non.final.clone.display.name=Non-final 'clone()' in secure context
unnecessary.temporary.on.conversion.from.string.display.name=Unnecessary temporary object in conversion from String
unnecessary.this.display.name=Unnecessary 'this' qualifier
unnecessary.this.ignore.assignments.option=Ignore field assignments
runtime.exec.with.non.constant.string.display.name=Call to 'Runtime.exec()' with non-constant string
system.properties.display.name=Access of system properties
chained.method.call.display.name=Chained method calls
safe.lock.display.name=Lock acquired but not safely unlocked
system.run.finalizers.on.exit.display.name=Call to 'System.runFinalizersOnExit()'
for.can.be.foreach.display.name='for' loop replaceable with 'foreach'
type.parameter.extends.object.display.name=Type parameter explicitly extends 'java.lang.Object'
marker.interface.display.name=Marker interface
limited.scope.inner.class.display.name=Limited-scope inner class
switch.statements.without.default.display.name='switch' statement without 'default' branch
unchecked.exception.class.display.name=Unchecked exception class
for.loop.with.missing.component.display.name='for' loop with missing components
for.loop.with.missing.component.collection.loop.option=Ignore collection iterations
double.checked.locking.display.name=Double-checked locking
double.checked.locking.problem.descriptor=Double-checked locking #loc
double.checked.locking.ignore.on.volatiles.option=Ignore double-checked locking on volatile fields
string.buffer.replaceable.by.string.display.name='StringBuilder' can be replaced with 'String'
boolean.method.name.must.start.with.question.display.name=Boolean method name must start with question word
class.name.same.as.ancestor.name.display.name=Class name same as ancestor name
error.rethrown.display.name='java.lang.Error' not rethrown
serializable.has.serialization.methods.display.name=Serializable class without 'readObject()' and 'writeObject()'
serializable.has.serialization.methods.ignore.option=Ignore classes that do not define instance fields
missing.override.annotation.display.name=Missing @Override annotation
wait.while.holding.two.locks.display.name='wait()' while holding two locks
empty.class.display.name=Empty class
trivial.string.concatenation.display.name=Concatenation with empty string
empty.synchronized.statement.display.name=Empty 'synchronized' statement
unnecessary.default.display.name=Unnecessary 'default' for enum 'switch' statement
simplifiable.conditional.expression.display.name=Simplifiable conditional expression
simplifiable.if.statement.display.name='if' statement may be replaced with \\&\\& or || expression
unnecessary.super.constructor.display.name=Unnecessary call to 'super()'
unnecessarily.qualified.static.usage.display.name=Unnecessarily qualified static access
bad.exception.caught.display.name=Prohibited exception caught
custom.security.manager.display.name=Custom SecurityManager
string.concatenation.in.loops.display.name=String concatenation in loop
boolean.constructor.display.name=Boolean constructor call
continue.statement.display.name='continue' statement
extends.object.display.name=Class explicitly extends 'java.lang.Object'
serializable.inner.class.has.serial.version.uid.field.display.name=Serializable non-'static' inner class without 'serialVersionUID'
static.method.naming.convention.display.name='static' method naming convention
static.method.naming.convention.element.description='static' method
empty.try.block.display.name=Empty 'try' block
field.has.setter.but.no.getter.display.name=Field has setter but no getter
three.negations.per.method.display.name=Method with more than three negations
conditional.expression.display.name=Conditional expression (?:)
unnecessary.enum.modifier.display.name=Unnecessary enum modifier
string.equals.empty.string.display.name='String.equals("")'
synchronize.on.lock.display.name=Synchronization on a Lock object
synchronized.on.literal.object.name=Synchronization on an object initialized with a literal
field.may.be.static.display.name=Field may be 'static'
class.may.be.interface.display.name=Abstract class may be interface
abstract.class.without.abstract.methods.display.name=Abstract class without abstract methods
divide.by.zero.display.name=Divide by zero
default.not.last.case.in.switch.display.name='default' not last case in 'switch' statement
nested.synchronized.statement.display.name=Nested 'synchronized' statement
constant.conditional.expression.display.name=Constant conditional expression
unused.catch.parameter.display.name=Unused 'catch' parameter
redundant.else.display.name=Redundant 'else'
public.field.accessed.in.synchronized.context.display.name=Non-private field accessed in synchronized context
string.replaceable.by.string.buffer.display.name=Non-constant String should be StringBuilder
junit.test.class.naming.convention.display.name=JUnit test class naming convention
junit.test.class.naming.convention.element.description=JUnit test class
method.coupling.display.name=Overly coupled method
collections.must.have.initial.capacity.display.name=Collection without initial capacity
anonymous.inner.class.display.name=Anonymous inner class
negated.conditional.display.name=Conditional expression with negated condition
non.reproducible.math.call.display.name=Non-reproducible call to 'java.lang.Math'
multiple.top.level.classes.in.file.display.name=Multiple top level classes in single file
set.replaceable.by.enum.set.display.name=Set replaceable with EnumSet
non.static.inner.class.in.secure.context.display.name=Non-'static' inner class in secure context
tail.recursion.display.name=Tail recursion
finally.block.cannot.complete.normally.display.name='finally' block which can not complete normally
non.atomic.operation.on.volatile.field.display.name=Non-atomic operation on volatile field
public.static.collection.field.display.name='public static' collection field
non.exception.name.ends.with.exception.display.name=Non-exception class name ends with 'Exception'
synchronized.method.display.name='synchronized' method
enumerated.constant.naming.convention.display.name=Enumerated constant naming convention
enumerated.constant.naming.convention.element.description=Enumerated constant
final.method.display.name='final' method
transient.field.in.non.serializable.class.display.name=Transient field in non-serializable class
bad.exception.thrown.display.name=Prohibited exception thrown
conditional.expression.with.identical.branches.display.name=Conditional expression with identical branches
conditional.can.be.pushed.inside.expression.display.name=Conditional can be pushed inside branch expression
conditional.can.be.pushed.inside.expression.option=Ignore when conditional will be only argument of a method call
conditional.can.be.pushed.inside.expression.quickfix=Push conditional expression inside branch
raw.use.of.parameterized.type.display.name=Raw use of parameterized class
standard.variable.names.display.name=Standard variable names
instance.variable.naming.convention.display.name=Instance field naming convention
instance.variable.naming.convention.element.description=Instance field
dollar.sign.in.name.display.name=Use of '$' in identifier
map.replaceable.by.enum.map.display.name=Map replaceable with EnumMap
extends.concrete.collection.display.name=Class explicitly extends a Collection class
continue.or.break.from.finally.block.display.name='continue' or 'break' inside 'finally' block
abstract.method.with.missing.implementations.display.name=Abstract method with missing implementations
object.allocation.in.loop.display.name=Object allocation in loop
wait.called.on.condition.display.name='wait()' called on 'java.util.concurrent.locks.Condition' object
test.case.with.no.test.methods.display.name=JUnit test case with no tests
abstract.class.never.implemented.display.name=Abstract class which has no concrete subclass
interface.never.implemented.display.name=Interface which has no concrete subclass
constant.declared.in.interface.display.name=Constant declared in interface


#problem descriptors
exception.name.doesnt.end.with.exception.problem.descriptor=Exception class name <code>#ref</code> does not end with 'Exception' #loc
non.exception.name.ends.with.exception.problem.descriptor=Non-exception class name <code>#ref</code> ends with 'Exception' #loc
class.name.prefixed.with.package.name.problem.descriptor=Class name <code>#ref</code> begins with its package name #loc
class.name.same.as.ancestor.name.problem.descriptor=Class name <code>#ref</code> is the same as one of its superclass' names #loc
method.name.same.as.class.name.problem.descriptor=Method name <code>#ref</code> is the same as its class name #loc
method.name.same.as.parent.name.problem.descriptor=Method name <code>#ref</code> is the same as its parent class name #loc
boolean.method.name.must.start.with.question.problem.descriptor=Boolean method name <code>#ref</code> does not start with question word #loc
questionable.name.problem.descriptor=Questionable name <code>#ref</code> #loc
confusing.main.method.problem.descriptor=Method named <code>#ref</code> without signature 'public static void main(String[])' #loc
upper.case.field.name.not.constant.problem.descriptor=Non-constant field <code>#ref</code> with constant-style name #loc
dollar.sign.in.name.problem.descriptor=Identifier <code>#ref</code> contains '$' #loc
integer.division.in.floating.point.context.problem.descriptor=<code>#ref</code>: integer division in floating-point context #loc
comparison.of.short.and.char.problem.descriptor=Equality comparison <code>#ref</code> of short and char values #loc
big.decimal.equals.problem.descriptor=<code>#ref()</code> between BigDecimal values should probably be 'compareTo()' #loc
divide.by.zero.problem.descriptor=Division by zero #loc
non.reproducible.math.call.problem.descriptor=<code>Math.#ref()</code> may produce non-reproducible results #loc
constant.math.call.problem.descriptor=Constant call to <code>#ref()</code> can be simplified #loc
floating.point.equality.problem.descriptor=<code>#ref</code>: floating point values compared for exact equality #loc
fallthru.in.switch.statement.problem.descriptor=Fallthrough in 'switch' statement #loc
switch.statements.without.default.problem.descriptor=<code>#ref</code> statement without 'default' branch #loc
default.not.last.case.in.switch.problem.descriptor=<code>#ref</code> branch not last case in 'switch' statement #loc
loop.statements.that.dont.loop.problem.descriptor=<code>#ref</code> statement does not loop #loc
conditional.expression.with.identical.branches.problem.descriptor=Conditional expression <code>#ref</code> with identical branches #loc
conditional.can.be.pushed.inside.expression.problem.descriptor=Conditional expression can be pushed inside branch #loc
if.statement.with.identical.branches.problem.descriptor=<code>#ref</code> statement with identical branches #loc
duplicate.condition.problem.descriptor=Duplicate condition <code>#ref</code> #loc
duplicate.condition.ignore.method.calls.option=Ignore conditions with side effects
duplicate.boolean.branch.problem.descriptor=Duplicate branch <code>#ref</code> #loc
iterator.next.does.not.throw.nosuchelementexception.problem.descriptor=<code>Iterator.#ref()</code> which can't throw 'NoSuchElementException' #loc
infinite.loop.statement.problem.descriptor=<code>#ref</code> statement cannot complete without throwing an exception #loc
confusing.floating.point.literal.problem.descriptor=Confusing floating point literal <code>#ref</code> #loc
overly.complex.arithmetic.expression.problem.descriptor=Overly complex arithmetic expression #loc
overly.complex.boolean.expression.problem.descriptor=Overly complex boolean expression ({0} terms) #loc
labeled.statement.problem.descriptor=Labeled statement <code>#ref:</code> #loc
break.statement.with.label.problem.descriptor=<code>#ref</code> statement with label #loc
continue.statement.with.label.problem.descriptor=<code>#ref</code> statement with label #loc
conditional.expression.problem.descriptor=Conditional expression <code>#ref</code> #loc
conditional.expression.option=Ignore for simple assignments and returns
nested.conditional.expression.problem.descriptor=Nested conditional expression <code>#ref</code> #loc
long.literals.ending.with.lowercase.l.problem.descriptor='long' literal <code>#ref</code> ends with lowercase 'l' #loc
nested.switch.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
chained.method.call.problem.descriptor=Chained method call <code>#ref()</code> #loc
nested.method.call.problem.descriptor=Nested method call <code>#ref()</code> #loc
octal.literal.problem.descriptor=Octal integer <code>#ref</code> #loc
implicit.call.to.super.problem.descriptor=Implicit call to 'super()' #loc
negated.if.else.problem.descriptor=<code>#ref</code> statement with negated condition #loc
negated.conditional.problem.descriptor=Conditional expression with negated condition #loc
redundant.else.problem.descriptor=<code>#ref</code> branch may be unwrapped, as the 'if' branch never completes normally #loc
switch.statement.with.confusing.declaration.problem.descriptor=Local variable <code>#ref</code> declared in one 'switch' branch and used in another #loc
raw.use.of.parameterized.type.problem.descriptor=Raw use of parameterized class <code>#ref</code> #loc
final.class.problem.descriptor=Class declared <code>#ref</code> #loc
empty.class.problem.descriptor=Class <code>#ref</code> is empty #loc
empty.class.file.without.class.problem.descriptor=Java file does not declare any class #loc
empty.anonymous.class.problem.descriptor=Anonymous class is empty #loc
anonymous.inner.class.problem.descriptor=Anonymous inner class <code>#ref</code> #loc
limited.scope.inner.class.problem.descriptor=Limited-scope inner class <code>#ref</code> #loc
final.method.problem.descriptor=Method declared <code>#ref</code> #loc
class.initializer.problem.descriptor=Non-'static' initializer #loc
class.may.be.interface.problem.descriptor=Abstract class <code>#ref</code> may be interface #loc
non.protected.constructor.in.abstract.class.problem.descriptor=Constructor <code>#ref()</code> is not declared 'protected' in 'abstract' class #loc
class.without.constructor.problem.descriptor=Class <code>#ref</code> has no constructor #loc
abstract.class.without.abstract.methods.problem.descriptor=Class <code>#ref</code> is declared 'abstract', and has no 'abstract' methods #loc
final.method.in.final.class.problem.descriptor=Method declared <code>#ref</code> in 'final' class #loc
protected.member.in.final.class.problem.descriptor=Class member declared <code>#ref</code> in 'final' class #loc
utility.class.with.public.constructor.problem.descriptor=Class <code>#ref</code> has only 'static' members, and a 'public' constructor #loc
utility.class.without.private.constructor.problem.descriptor=Class <code>#ref</code> has only 'static' members, and lacks a 'private' constructor #loc
abstract.method.overrides.concrete.method.problem.descriptor=Abstract method <code>#ref()</code> overrides concrete method #loc
abstract.method.with.missing.implementations.problem.descriptor=Abstract method <code>#ref()</code> is not implemented in every subclass #loc
abstract.method.overrides.abstract.method.problem.descriptor=Abstract method <code>#ref()</code> overrides abstract method #loc
abstract.method.overrides.abstract.method.ignore.different.javadoc.option=Ignore methods with different Javadoc than their super methods
abstract.method.overrides.abstract.method.ignore.different.annotations.option=Ignore methods with different annotations than their super methods
abstract.class.extends.concrete.class.problem.descriptor=Class <code>#ref</code> is declared 'abstract', and extends a concrete class #loc
static.non.final.field.problem.descriptor='static' non-'final' field <code>#ref</code> #loc
constant.declared.in.abstract.class.problem.descriptor=Constant <code>#ref</code> declared in abstract class #loc
constant.declared.in.interface.problem.descriptor=Constant <code>#ref</code> declared in interface #loc
static.inheritance.problem.descriptor=Interface <code>#ref</code> is implemented only for its 'static' constants #loc
utility.class.problem.descriptor=Class <code>#ref</code> has only 'static' members, indicating procedural construction #loc
singleton.problem.descriptor=Class <code>#ref</code> is a singleton #loc
final.private.method.problem.descriptor='private' method declared <code>#ref</code> #loc
noop.method.in.abstract.class.problem.descriptor=No-op Method <code>#ref()</code> should be made abstract #loc
final.static.method.problem.descriptor='static' method declared <code>#ref</code> #loc
class.without.no.arg.constructor.problem.descriptor=<code>#ref</code> has no no-arg constructor #loc
multiple.top.level.classes.in.file.problem.descriptor=Multiple top level classes in file
class.name.differs.from.file.name.problem.descriptor=Class name <code>#ref</code> differs from file name #loc
marker.interface.problem.descriptor=Marker interface <code>#ref</code> #loc
field.has.setter.but.no.getter.problem.descriptor=Field <code>#ref</code> has setter but no getter #loc
abstract.class.never.implemented.problem.descriptor=Abstract class <code>#ref</code> has no concrete subclass #loc
interface.never.implemented.problem.descriptor=Interface <code>#ref</code> has no concrete subclass #loc
missing.deprecated.annotation.problem.descriptor=Missing '@Deprecated' annotation #loc
missing.deprecated.tag.problem.descriptor=Missing '@deprecated' Javadoc tag explanation #loc
missing.deprecated.tag.option=Warn on missing @deprecated Javadoc tag explanation
missing.override.annotation.problem.descriptor=Missing '@Override' annotation on <code>#ref()</code> #loc
missing.override.annotation.in.overriding.problem.descriptor=Overridden methods are not annotated with '@Override'
non.thread.safe.lazy.initialization.problem.descriptor=Lazy initialization of 'static' field <code>#ref</code> is not thread-safe #loc
empty.catch.block.problem.descriptor=Empty <code>#ref</code> block #loc
unused.catch.parameter.problem.descriptor=Unused 'catch' parameter <code>#ref</code> #loc
used.catch.parameter.named.ignore.problem.descriptor='catch' parameter named <code>#ref</code> is used #loc
empty.finally.block.problem.descriptor=Empty <code>#ref</code> block #loc
finally.block.cannot.complete.normally.problem.descriptor=<code>#ref</code> block can not complete normally #loc
empty.try.block.problem.descriptor=Empty <code>#ref</code> block #loc
throw.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
possible.throw.from.finally.block.problem.descriptor=<code>{0}</code> might be thrown inside ''finally'' block #loc
throw,from.finally.block.everywhere.option=Warn everywhere declared exceptions may be thrown
throw.caught.locally.problem.descriptor=<code>#ref</code> caught by containing 'try' statement #loc
throw.caught.locally.ignore.option=Ignore rethrown exceptions
return.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
continue.or.break.from.finally.block.problem.descriptor=<code>#ref</code> inside 'finally' block #loc
bad.exception.declared.problem.descriptor=Prohibited exception <code>#ref</code> declared #loc
bad.exception.caught.problem.descriptor=Prohibited exception <code>#ref</code> caught #loc
checked.exception.class.problem.descriptor=Checked exception class <code>#ref</code> #loc
unchecked.exception.class.problem.descriptor=Unchecked exception class <code>#ref</code> #loc
thread.death.rethrown.problem.descriptor=ThreadDeath <code>#ref</code> not rethrown #loc
error.rethrown.problem.descriptor=Error <code>#ref</code> not rethrown #loc
nested.try.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
exception.from.catch.which.doesnt.wrap.problem.descriptor=<code>#ref</code> inside 'catch' block ignores the caught exception #loc
instanceof.catch.parameter.problem.descriptor='instanceof' on 'catch' parameter <code>#ref</code> #loc
non.final.field.of.exception.problem.descriptor=Non-final field <code>#ref</code> of exception class #loc
unnecessary.label.on.break.statement.problem.descriptor=Unnecessary label on <code>#ref</code> statement #loc
unnecessary.label.on.continue.statement.problem.descriptor=Unnecessary label on <code>#ref</code> statement #loc
trivial.if.problem.descriptor=<code>#ref</code> statement can be simplified #loc
constant.if.statement.problem.descriptor=<code>#ref</code> statement can be simplified #loc
unnecessary.parentheses.problem.descriptor=Parentheses around <code>#ref</code> are unnecessary #loc
unnecessary.local.variable.problem.descriptor=Local variable <code>#ref</code> is redundant #loc
unnecessary.this.problem.descriptor=<code>#ref</code> is unnecessary in this context #loc
unnecessary.block.statement.problem.descriptor=Braces around this statement are unnecessary #loc
unnecessary.continue.problem.descriptor=<code>#ref</code> is unnecessary as the last statement in a loop #loc
unnecessary.semicolon.problem.descriptor=Unnecessary semicolon <code>#ref</code> #loc
unnecessary.fully.qualified.name.problem.descriptor1=Qualifier <code>#ref</code> is unnecessary, and can be replaced with an import #loc
unnecessary.fully.qualified.name.problem.descriptor2=Qualifier <code>#ref</code> is unnecessary and can be removed #loc
unnecessary.qualifier.for.this.problem.descriptor=Qualifier <code>#ref</code> on 'this' is unnecessary in this context #loc
unnecessary.qualifier.for.super.problem.descriptor=Qualifier <code>#ref</code> on 'super' is unnecessary in this context #loc
unused.label.problem.descriptor=Unused label <code>#ref</code> #loc
redundant.field.initialization.problem.descriptor=Field initialization to <code>#ref</code> is redundant #loc
redundant.implements.problem.descriptor=Redundant interface declaration <code>#ref</code> #loc
extends.object.problem.descriptor=Class <code>#ref</code> explicitly extends 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor1=Type parameter <code>#ref</code> explicitly extends 'java.lang.Object' #loc
type.parameter.extends.object.problem.descriptor2=Wildcard type argument <code>#ref</code> explicitly extends 'java.lang.Object' #loc
unnecessary.super.constructor.problem.descriptor=<code>#ref</code> is unnecessary #loc
unnecessary.constructor.problem.descriptor=No-arg constructor <code>#ref()</code> is redundant #loc
unnecessary.constructor.annotation.option=Ignore constructors with an annotation
for.loop.replaceable.by.while.problem.descriptor=<code>#ref</code> loop statement may be replace by 'while' loop #loc
unnecessary.default.problem.descriptor=<code>#ref</code> branch is unnecessary #loc
unnecessary.boxing.problem.descriptor=Unnecessary boxing <code>#ref</code> #loc
unnecessary.unboxing.problem.descriptor=Unnecessary unboxing <code>#ref</code> #loc
unnecessary.boxing.superfluous.option=Only report truly superfluously boxed expressions
unnecessary.unboxing.superfluous.option=Only report truly superfluously unboxed expressions
for.can.be.foreach.problem.descriptor=<code>#ref</code> loop replaceable with 'foreach' #loc
while.can.be.foreach.problem.descriptor=<code>#ref</code> loop replaceable with 'foreach' #loc
too.broad.scope.problem.descriptor=Scope of variable <code>#ref</code> is too broad #loc
return.this.problem.descriptor=Return of <code>#ref</code> #loc
constant.on.lhs.of.comparison.problem.descriptor=<code>#ref</code>: constant on left side of comparison #loc
constant.on.rhs.of.comparison.problem.descriptor=<code>#ref</code>: constant on right side of comparison #loc
control.flow.statement.without.braces.problem.descriptor=<code>{0}</code> without braces #loc
missorted.modifiers.problem.descriptor=Missorted modifiers <code>#ref</code> #loc
cstyle.array.variable.declaration.problem.descriptor=C-style array declaration of {0, choice, 1#field|2#parameter|3#local variable} <code>#ref</code> #loc
cstyle.array.method.declaration.problem.descriptor=C-style array declaration of the return type of method <code>#ref()</code>#loc
multiple.declaration.problem.descriptor=Multiple variables in one declaration #loc
multiple.typed.declaration.problem.descriptor=Variables of different types in one declaration #loc
serializable.inner.class.has.serial.version.uid.field.problem.descriptor=Inner class <code>#ref</code> does not define a 'serialVersionUID' field #loc
serializable.inner.class.with.non.serializable.outer.class.problem.descriptor=Inner class <code>#ref</code> is serializable while its outer class is not #loc
busy.wait.problem.descriptor=Call to <code>Thread.#ref()</code> in a loop, probably busy-waiting #loc
sleep.while.holding.lock.problem.descriptor=Call to <code>Thread.#ref()</code> while synchronized #loc
non.atomic.operation.on.volatile.field.problem.descriptor=Non-atomic operation on volatile field <code>#ref</code> #loc
call.to.native.method.while.locked.problem.descriptor=Call to native method <code>#ref()</code> in a synchronized context #loc
object.notify.problem.descriptor=<code>#ref</code> should probably be replaced with 'notifyAll()' #loc
condition.signal.problem.descriptor=<code>#ref</code> should probably be replaced with 'signalAll()' #loc
thread.with.default.run.method.problem.descriptor=Instantiating a <code>#ref</code> with default 'run()' method #loc
extends.thread.problem.descriptor=Class <code>#ref</code> directly extends 'java.lang.Thread' #loc
anonymous.extends.thread.problem.descriptor=Anonymous class directly extends 'java.lang.Thread' #loc
naked.notify.problem.descriptor=Call to <code>#ref()</code> without corresponding state change #loc
unconditional.wait.problem.descriptor=Unconditional call to <code>#ref()</code> #loc
system.run.finalizers.on.exit.problem.descriptor=Call to <code>System.#ref()</code> #loc
thread.priority.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
thread.yield.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
thread.stop.suspend.resume.problem.descriptor=Call to <code>Thread.#ref()</code> #loc
while.loop.spins.on.field.problem.descriptor=<code>#ref</code> loop spins on field #loc
wait.not.in.loop.problem.descriptor=Call to <code>#ref()</code> is not made in a loop #loc
await.not.in.loop.problem.descriptor=Call to <code>#ref()</code> is not made in a loop #loc
wait.called.on.condition.problem.descriptor=Call to <code>#ref()</code> on Condition object #loc
notify.called.on.condition.problem.descriptor=Call to <code>#ref()</code> on Condition object #loc
wait.while.holding.two.locks.problem.descriptor=Call to <code>#ref()</code> is made while holding two locks #loc
thread.run.problem.descriptor=Calls to <code>#ref()</code> should probably be replaced with 'start()' #loc
thread.start.in.construction.problem.descriptor=Call to <code>#ref</code> during object construction #loc
synchronize.on.lock.problem.descriptor=Synchronization on a ''{0}'' object is unlikely to be intentional #loc
synchronized.on.literal.object.problem.descriptor=Synchronization on {0} <code>#ref</code> which is initialized by a literal #loc
synchronized.on.direct.literal.object.problem.descriptor=Synchronization on {0} literal <code>#ref</code> #loc
synchronized.on.possibly.literal.object.problem.descriptor=Synchronization on {0} <code>#ref</code> #loc
synchronize.on.non.final.field.problem.descriptor=Synchronization on a non-final field <code>#ref</code> #loc
synchronized.on.literal.object.warn.on.all.option=Warn on all possible literals
synchronize.on.this.problem.descriptor=Lock operations on 'this' may have unforeseen side-effects #loc
synchronize.on.class.problem.descriptor=Lock operations on a class may have unforeseen side-effects #loc
nested.synchronized.statement.problem.descriptor=Nested <code>#ref</code> statement #loc
empty.synchronized.statement.problem.descriptor=Empty <code>#ref</code> statement #loc
non.synchronized.method.overrides.synchronized.method.problem.descriptor=Unsynchronized method <code>#ref()</code> overrides synchronized method #loc
public.field.accessed.in.synchronized.context.problem.descriptor=Non-private field <code>#ref</code> accessed in synchronized context  #loc
field.accessed.synchronized.and.unsynchronized.problem.descriptor=Field <code>#ref</code> is accessed in both synchronized and unsynchronized contexts #loc
extended.for.statement.problem.descriptor=Extended <code>#ref</code> statement #loc
object.allocation.in.loop.problem.descriptor=Object allocation <code>new #ref()</code> in loop #loc
instantiating.object.to.get.class.object.problem.descriptor=Instantiating object to get Class object #loc
field.may.be.static.problem.descriptor=Field <code>#ref</code> may be 'static' #loc
method.may.be.static.problem.descriptor=Method <code>#ref()</code> may be 'static' #loc
class.initializer.may.be.static.problem.descriptor=Class initializer may be 'static' #loc
map.replaceable.by.enum.map.problem.descriptor=<code>#ref</code> replaceable with 'EnumMap' #loc
set.replaceable.by.enum.set.problem.descriptor=<code>#ref</code> replaceable with 'EnumSet' #loc
inner.class.may.be.static.problem.descriptor=Inner class <code>#ref</code> may be 'static' #loc
string.buffer.must.have.initial.capacity.problem.descriptor=<code>new #ref()</code> without initial capacity #loc
string.buffer.replaceable.by.string.builder.problem.descriptor=<code>StringBuffer #ref</code> may be declared as 'StringBuilder' #loc
string.buffer.replaceable.by.string.problem.descriptor=<code>{0} #ref</code> can be replaced with ''String'' #loc
new.string.buffer.replaceable.by.string.problem.descriptor=<code>#ref</code> can be replaced with 'String' #loc
string.replaceable.by.string.buffer.problem.descriptor=Non-constant <code>String #ref</code> should probably be declared as ''StringBuilder'' #loc
collections.must.have.initial.capacity.problem.descriptor=<code>new #ref()</code> without initial capacity #loc
string.concatenation.in.loops.problem.descriptor=String concatenation <code>#ref</code> in loop #loc
string.concatenation.inside.string.buffer.append.problem.descriptor=String concatenation as argument to <code>{0}.#ref()</code> call #loc
boolean.constructor.problem.descriptor=Boolean constructor call #loc
string.to.string.problem.descriptor=<code>#ref</code> is redundant #loc
substring.zero.problem.descriptor=<code>#ref</code> is redundant #loc
string.buffer.to.string.in.concatenation.problem.descriptor=Call to <code>{0}.#ref()</code> in concatenation #loc
tail.recursion.problem.descriptor=Tail recursive call <code>#ref()</code> #loc
string.equals.empty.string.problem.descriptor=<code>#ref("")</code> can be replaced with 'length()==0' #loc
string.equals.empty.string.is.empty.problem.descriptor=<code>#ref("")</code> can be replaced with 'isEmpty()' #loc
random.double.for.random.integer.problem.descriptor=Using <code>Random.#ref</code> to create random integer #loc
manual.array.copy.problem.descriptor=Manual array copy #loc
manual.array.to.collection.copy.problem.descriptor=Manual array to collection copy #loc
call.to.simple.getter.in.class.problem.descriptor=Call to simple getter <code>#ref()</code> from within class #loc
call.to.simple.setter.in.class.problem.descriptor=Call to simple setter <code>#ref()</code> from within class #loc
asserts.without.messages.problem.descriptor=JUnit <code>#ref()</code> without message #loc
test.case.with.constructor.problem.descriptor=Initialization logic in constructor <code>#ref()</code> instead of 'setUp()' #loc
test.case.with.constructor.problem.descriptor.initializer=Initialization logic in initializer instead of 'setUp()'
misordered.assert.equals.arguments.problem.descriptor=Arguments to <code>#ref()</code> in wrong order #loc
static.suite.problem.descriptor=JUnit <code>#ref()</code> methods not declared 'static' #loc
simplifiable.junit.assertion.problem.descriptor=<code>#ref()</code> can be simplified to ''{0}'' #loc
test.method.without.assertion.problem.descriptor=JUnit test method <code>#ref()</code> contains no assertions #loc
test.case.with.no.test.methods.problem.descriptor=JUnit test case <code>#ref</code> has no tests #loc
test.case.in.product.code.problem.descriptor=Test case <code>#ref</code> should probably be placed in a test source tree #loc
test.method.in.product.code.problem.descriptor=Test method <code>#ref()</code> should probably be placed in a test source tree #loc
unconstructable.test.case.problem.descriptor=Test case <code>#ref</code> is not constructable by most test runners #loc
deserializable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be deserialized, compromising security #loc
serializable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be serialized, compromising security #loc
serializable.deserializable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be serialized and deserialized, compromising security #loc
cloneable.class.in.secure.context.problem.descriptor=Class <code>#ref</code> may be cloned, compromising security #loc
cloneable.class.in.secure.context.quickfix=Add 'clone()' method which always throws exception
remove.cloneable.quickfix=Remove 'Cloneable' from implements clause
non.final.clone.problem.descriptor=Non-final <code>#ref()</code> method, compromising security #loc
non.static.inner.class.in.secure.context.problem.descriptor=Non-'static' inner class <code>#ref</code>, compromising security #loc
runtime.exec.with.non.constant.string.problem.descriptor=Call to <code>Runtime.#ref()</code> with non-constant argument #loc
load.library.with.non.constant.string.problem.descriptor=Call to <code>{0}.#ref()</code> with non-constant argument #loc
jdbc.execute.with.non.constant.string.problem.descriptor=Call to <code>Statement.#ref()</code> with non-constant argument #loc
jdbc.prepare.statement.with.non.constant.string.problem.descriptor=Call to <code>Connection.#ref()</code> with non-constant argument #loc
custom.classloader.problem.descriptor=Custom ClassLoader class <code>#ref</code> #loc
custom.security.manager.problem.descriptor=Custom SecurityManager class <code>#ref</code> #loc
system.set.problem.descriptor=Call to <code>System.#ref()</code> may pose security concerns #loc
class.loader.instantiation.problem.descriptor=Instantiation of <code>#ref</code> may pose security concerns #loc
public.static.array.field.problem.descriptor='public static' array field <code>#ref</code>, compromising security #loc
public.static.collection.field.problem.descriptor='public static' collection field <code>#ref</code>, compromising security #loc
abstract.class.with.only.one.direct.inheritor.problem.descriptor=Abstract class <code>#ref</code> has only one direct inheritor #loc

#other
abstract.method.overrides.abstract.method.remove.quickfix=Remove redundant abstract method declaration
class.may.be.interface.convert.quickfix=Convert class to interface
class.without.constructor.create.quickfix=Generate empty constructor
class.without.no.arg.constructor.ignore.option=Ignore if class has default constructor
extends.annotation.problem.descriptor=Class ''{0}'' implements annotation interface <code>#ref</code> #loc
extends.annotation.interface.problem.descriptor=Interface ''{0}'' extends annotation interface <code>#ref</code> #loc
extends.concrete.collection.problem.descriptor=Class <code>#ref</code> explicitly extends ''{0}'' #loc
anonymous.extends.concrete.collection.problem.descriptor=Anonymous class explicitly extends ''{0}'' #loc
inner.class.on.interface.ignore.option=Ignore inner interfaces of interfaces
inner.class.on.interface.problem.descriptor=Interface ''{0}'' has inner class <code>#ref</code> #loc
missing.deprecated.annotation.add.quickfix=Add @Deprecated annotation
non.protected.constructor.in.abstract.class.ignore.option=Ignore for non-public classes
public.constructor.in.non.public.class.problem.descriptor=Constructor is declared <code>#ref</code> in non-public class ''{0}'' #loc
static.inheritance.replace.quickfix=Replace inheritance with qualified references in {0}
utility.class.with.public.constructor.make.quickfix=Make {0, choice, 1#constructor|2#constructors} 'private'
utility.class.without.private.constructor.create.quickfix=Generate empty 'private' constructor
utility.class.without.private.constructor.make.quickfix=Make constructor 'private'
naming.convention.problem.descriptor.short={0} name <code>#ref</code> is too short ({1} < {2}) #loc
naming.convention.problem.descriptor.long={0} name <code>#ref</code> is too long ({1} > {2}) #loc
naming.convention.problem.descriptor.regex.mismatch={0} name <code>#ref</code> doesn''t match regex ''{1}'' #loc
constant.naming.convention.immutables.option=Only check 'static final' fields with immutable types
local.variable.naming.convention.ignore.option=Ignore for-loop parameters
local.variable.naming.convention.ignore.catch.option=Ignore 'catch' block parameters
method.names.differ.only.by.case.problem.descriptor=Method name <code>#ref</code> and method name ''{0}'' differ only by case #loc
parameter.name.differs.from.overridden.parameter.ignore.character.option=Ignore if overridden parameter contains only one character
parameter.name.differs.from.overridden.parameter.ignore.library.option=Ignore if overridden parameter is from a library
parameter.name.differs.from.overridden.parameter.problem.descriptor=Parameter name <code>#ref</code> is different from parameter ''{0}'' overridden #loc
questionable.name.column.title=Name
standard.variable.names.problem.descriptor=Variable named <code>#ref</code> doesn''t have type ''{0}'' #loc
standard.variable.names.problem.descriptor2=Variable named <code>#ref</code> doesn''t have type ''{0}'' or ''{1}'' #loc
standard.variable.names.ignore.override.option=Ignore for parameter names identical to super method parameters
static.variable.naming.convention.mutable.option=Check 'static final' fields with a mutable type
boolean.method.name.must.start.with.question.table.column.name=Boolean method name prefix
conditional.expression.with.identical.branches.collapse.quickfix=Collapse conditional expression
redundant.else.unwrap.quickfix=Remove redundant 'else'
constant.conditional.expression.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
constant.conditional.expression.simplify.quickfix=Simplify
constant.conditional.expression.simplify.quickfix.sideEffect=Extract side effects and simplify
enum.switch.statement.which.misses.cases.problem.descriptor=<code>#ref</code> statement on enumerated type ''{0}'' misses cases #loc
for.loop.replaceable.by.while.ignore.option=Ignore 'infinite' for loops without conditions
for.loop.replaceable.by.while.replace.quickfix=Replace with 'while'
for.loop.with.missing.component.problem.descriptor1=<code>#ref</code> statement lacks initializer #loc
for.loop.with.missing.component.problem.descriptor2=<code>#ref</code> statement lacks condition #loc
for.loop.with.missing.component.problem.descriptor3=<code>#ref</code> statement lacks update #loc
for.loop.with.missing.component.problem.descriptor4=<code>#ref</code> statement lacks initializer and condition #loc
for.loop.with.missing.component.problem.descriptor5=<code>#ref</code> statement lacks initializer and update #loc
for.loop.with.missing.component.problem.descriptor6=<code>#ref</code> statement lacks condition and update #loc
for.loop.with.missing.component.problem.descriptor7=<code>#ref</code> statement lacks initializer, condition and update #loc
if.statement.with.identical.branches.collapse.quickfix=Collapse 'if' statement
foreach.replace.quickfix=Replace with 'foreach'
unnecessary.boxing.remove.quickfix=Remove boxing
unnecessary.unboxing.remove.quickfix=Remove unboxing
misordered.assert.equals.arguments.flip.quickfix=Flip compared arguments
simplify.junit.assertion.simplify.quickfix=Simplify assertion
test.method.is.public.void.no.arg.problem.descriptor1=Test method <code>#ref()</code> should probably not have parameters #loc
test.method.is.public.void.no.arg.problem.descriptor2=Test method <code>#ref()</code> is not declared 'public void' #loc
test.method.is.public.void.no.arg.problem.descriptor3=Test method <code>#ref()</code> should not be 'static' #loc
system.properties.problem.descriptor=Call to <code>Integer.#ref()</code> may pose security concerns #loc
system.properties.problem.descriptor1=Call to <code>Boolean.#ref()</code> may pose security concerns #loc
unsecure.random.number.generation.problem.descriptor1=For security purposes, use 'java.security.SecureRandom' instead of <code>java.lang.Math.#ref()</code> #loc
unsecure.random.number.generation.problem.descriptor2=For security purposes, use 'java.security.SecureRandom' instead of <code>java.util.#ref</code> #loc
unsecure.random.number.generation.problem.descriptor3=For security purposes, use 'java.security.SecureRandom' instead of <code>#ref</code> #loc
serializable.has.serialization.methods.problem.descriptor=Serializable class <code>#ref</code> does not define 'readObject()' or 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor1=Serializable class <code>#ref</code> does not define 'writeObject()' #loc
serializable.has.serialization.methods.problem.descriptor2=Serializable class <code>#ref</code> does not define 'readObject()' #loc
serializable.with.unconstructable.ancestor.problem.descriptor=<code>#ref</code> has a non-serializable ancestor ''{0}'' without no-arg constructor #loc
transient.field.in.non.serializable.class.problem.descriptor=Field ''{0}'' is marked <code>#ref</code>, in non-Serializable class #loc
transient.field.in.non.serializable.class.remove.quickfix=Remove 'transient'
condition.signal.replace.quickfix=Replace with 'signalAll()'
object.notify.replace.quickfix=Replace with 'notifyAll()'
safe.lock.problem.descriptor=''{0}'' should be locked in front of a ''try'' block and unlocked in the corresponding ''finally'' block #loc
synchronized.method.problem.descriptor=Method ''{0}()'' declared <code>#ref</code> #loc
synchronized.method.include.option=Include native methods
synchronized.method.ignore.synchronized.super.option=Ignore methods overriding a synchronized method
synchronized.method.move.quickfix=Move synchronization into method
thread.run.replace.quickfix=Replace with 'start()'
volatile.field.problem.descriptor=Volatile field <code>#ref</code> of type ''{0}'' #loc
string.format.choose.class=Choose Formatter class
string.format.class.column.name=Additional formatter classes
string.format.class.method.name=Additional formatter methods
exception.class.column.name=Exception class
bad.exception.thrown.problem.descriptor=Prohibited exception ''{0}'' thrown #loc
empty.catch.block.comments.option=Comments count as content
empty.catch.block.ignore.ignore.option=Ignore when 'catch' parameter is named 'ignore' or 'ignored'
too.broad.catch.problem.descriptor=''catch'' of <code>#ref</code> is too broad, masking exception ''{0}'' #loc
too.broad.catch.problem.descriptor1=''catch'' of <code>#ref</code> is too broad, masking exceptions ''{0}'' and ''{1}'' #loc
unused.catch.parameter.ignore.catch.option=Ignore when 'catch' block contains a comment
add.serialversionuidfield.quickfix=Add 'serialVersionUID' field
delete.import.quickfix=Delete unnecessary import
encapsulate.variable.quickfix=Encapsulate field ''{0}''
extract.method.quickfix=Extract method
inline.call.quickfix=Inline call
inline.variable.quickfix=Inline variable
pointless.nullcheck.display.name=Unnecessary 'null' check before 'instanceof' expression or call
pointless.nullcheck.problem.descriptor.instanceof=Unnecessary 'null' check before 'instanceof' expression
pointless.nullcheck.problem.descriptor.call=Unnecessary ''null'' check before ''{0}'' call
pointless.nullcheck.simplify.quickfix=Remove unnecessary ''{0}'' condition
introduce.constant.quickfix=Introduce constant
make.initialization.explicit.quickfix=Make initialization explicit
move.anonymous.to.inner.quickfix=Convert to named inner class
anonymous.inner.may.be.named.static.inner.class.quickfix=Convert to named 'static' inner class
move.class.quickfix=Move class
normalize.declaration.quickfix=Split into multiple declarations
remove.modifier.quickfix=Remove ''{0}'' modifier
replace.inheritance.with.delegation.quickfix=Replace inheritance with delegation
big.decimal.equals.replace.quickfix=Replace with 'compareTo()==0'
cast.that.loses.precision.problem.descriptor=Cast from ''{0}'' to <code>#ref</code> may result in loss of precision #loc
cast.that.loses.precision.negative.problem.descriptor=Cast from ''{0}'' to <code>#ref</code> may result in loss of precision for negative argument #loc
comparison.to.nan.problem.descriptor1=Comparison to <code>#ref</code> is always false #loc
comparison.to.nan.problem.descriptor2=Comparison to <code>#ref</code> is always true #loc
comparison.to.nan.replace.quickfix=Replace with 'isNaN()'
confusing.floating.point.literal.change.quickfix=Change to canonical form
implicit.numeric.conversion.ignore.widening.conversion.option=Ignore widening conversions
implicit.numeric.conversion.ignore.char.conversion.option=Ignore conversions from and to char
implicit.numeric.conversion.ignore.constant.conversion.option=Ignore conversions from constants and literals
implicit.numeric.conversion.problem.descriptor=Implicit numeric conversion of <code>#ref</code> from ''{0}'' to ''{1}'' #loc
implicit.numeric.conversion.convert.quickfix=Convert to ''{0}''
implicit.numeric.conversion.make.explicit.quickfix=Make conversion explicit
long.literals.ending.with.lowercase.l.replace.quickfix=Replace 'l' with 'L'
non.reproducible.math.call.replace.quickfix=Replace with 'StrictMath' call
overly.complex.arithmetic.expression.max.number.option=Maximum number of terms:
expression.can.be.replaced.problem.descriptor=<code>#ref</code> can be replaced with ''{0}'' #loc
method.complexity.limit.option=Method complexity limit:
cyclomatic.complexity.problem.descriptor=Overly complex method <code>#ref()</code> (cyclomatic complexity = {0}) #loc
method.coupling.limit.option=Method coupling limit:
method.coupling.problem.descriptor=<code>#ref</code> is overly coupled (# referenced classes = {0}) #loc
method.with.multiple.loops.problem.descriptor=<code>#ref</code> contains {0} loops #loc
return.point.limit.option=&Return point limit:
multiple.return.points.per.method.problem.descriptor=<code>#ref</code> has {0} return points #loc
nesting.depth.limit.option=Nesting depth limit:
nesting.depth.problem.descriptor=<code>#ref</code> is overly nested (maximum nesting depth = {0}) #loc
non.comment.source.statements.limit.option=Non-comment source statements limit:
non.comment.source.statements.problem.descriptor=<code>#ref</code> is too long (# Non-comment source statements = {0}) #loc
parameters.per.method.problem.descriptor=<code>#ref()</code> has too many parameters (num parameters = {0}) #loc
parameters.per.constructor.problem.descriptor=<code>#ref()</code> has too many parameters (num parameters = {0}) #loc
parameter.limit.option=Parameter limit:
constructor.visibility.option=Ignore constructors with visibility:
three.negations.per.method.ignore.option=Ignore negations in 'equals()' methods
three.negations.per.method.ignore.assert.option=Ignore negations in 'assert' statements
three.negations.per.method.problem.descriptor=<code>#ref</code> contains {0} negations #loc
thrown.exceptions.per.method.problem.descriptor=<code>#ref</code> has too many exceptions declared (num exceptions = {0}) #loc
thrown.exceptions.per.method.limit.option=Exceptions thrown limit:
call.to.simple.getter.in.class.ignore.option=Ignore getter calls on other objects
call.to.private.simple.getter.in.class.option=Only report getter is 'private'
call.to.simple.getter.in.class.inline.quickfix=Inline call to getter
call.to.simple.setter.in.class.ignore.option=Ignore setter calls on other objects
call.to.private.setter.in.class.option=Only report when setter is 'private'
call.to.simple.setter.in.class.inline.quickfix=Inline call to setter
make.static.quickfix=Make 'static'
length.one.strings.in.concatenation.replace.quickfix=Replace with character
multiply.or.divide.by.power.of.two.replace.quickfix=Replace with shift
boolean.expression.can.be.simplified.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
trivial.string.concatenation.problem.descriptor=Empty string used in concatenation
string.replace.quickfix=Replace concatenation with ''{0}''
instantiating.object.to.get.class.object.replace.quickfix=Replace with direct class object access
manual.array.copy.replace.quickfix=Replace with 'System.arraycopy()'
manual.array.to.collection.copy.replace.quickfix=Replace with 'Collections.addAll(...,...)'
method.may.be.static.only.option=Only check 'private' or 'final' methods
method.may.be.static.empty.option=Ignore empty methods
random.double.for.random.integer.replace.quickfix=Replace with 'nextInt()'
string.buffer.replaceable.by.string.builder.replace.quickfix=Replace with 'StringBuilder'
string.buffer.to.string.in.concatenation.remove.quickfix=Remove 'toString()'
string.concatenation.in.loops.only.option=Only warn if string is repeatedly appended
string.concatenation.inside.string.buffer.append.replace.quickfix=Replace with chained 'append()' calls
string.equals.empty.string.quickfix=Replace with 'length()==0'
string.equals.empty.string.isempty.quickfix=Replace with 'isEmpty()'
tail.recursion.replace.quickfix=Replace tail recursion with iteration
if.statement.with.too.many.branches.max.option=Maximum number of branches:
if.statement.with.too.many.branches.problem.descriptor=<code>#ref</code> has too many branches ({0}) #loc
negated.conditional.ignore.option=Ignore '!= null' comparisons
negated.conditional.invert.quickfix=Invert condition
negated.if.else.ignore.negated.null.option=Ignore '!= null' comparisons
negated.if.else.ignore.negated.zero.option=Ignore '!= 0' comparisons
negated.if.else.invert.quickfix=Invert 'if' condition
overly.complex.boolean.expression.max.terms.option=Maximum number of terms:
pointless.boolean.expression.ignore.option=Ignore named constants in determining pointless expressions
simplifiable.conditional.expression.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
simplifiable.if.statement.problem.descriptor=<code>#ref</code> statement can be replaced with ''{0}'' #loc
switch.statement.density.min.option=Minimum density of branches: %
switch.statement.density.problem.descriptor=<code>#ref</code> has too low of a branch density ({0}%) #loc
switch.statement.with.too.few.branches.min.option=Minimum number of branches:
switch.statement.with.too.few.branches.problem.descriptor=<code>#ref</code> has too few branches ({0}), and should probably be replaced with an ''if'' statement #loc
switch.statement.without.default.ignore.option=Ignore if all cases of an enumerated type are covered
unnecessary.label.remove.quickfix=Remove label
unnecessary.return.problem.descriptor=<code>#ref</code> is unnecessary as the last statement in a 'void' method #loc
unnecessary.return.constructor.problem.descriptor=<code>#ref</code> is unnecessary as the last statement in a constructor #loc
unused.label.remove.quickfix=Remove unused label
unnecessarily.qualified.static.usage.problem.descriptor=Unnecessarily qualified static method call <code>{0}()</code> #loc
unnecessarily.qualified.static.usage.problem.descriptor1=Unnecessarily qualified static access <code>{0}</code> #loc
unnecessarily.qualified.static.usage.ignore.field.option=Ignore unnecessarily qualified field accesses
unnecessarily.qualified.static.usage.ignore.method.option=Ignore unnecessarily qualified method calls
unnecessary.interface.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for interfaces #loc
unnecessary.interface.modifier.inner.interface.of.interface.problem.descriptor=Modifier <code>#ref</code> is redundant for inner interfaces #loc
unnecessary.interface.modifier.problem.descriptor2=Modifier <code>#ref</code> is redundant for interface methods #loc
unnecessary.interface.modifier.problem.descriptor3=Modifier <code>#ref</code> is redundant for inner classes of interfaces #loc
unnecessary.interface.modifier.problem.descriptor4=Modifier <code>#ref</code> is redundant for interface fields #loc
smth.unnecessary.remove.quickfix=Remove unnecessary ''{0}''
unqualified.static.usage.problem.descriptor=Unqualified static method call <code>#ref()</code> #loc
unqualified.static.usage.problem.descriptor1=Unqualified static field access <code>#ref</code> #loc
unqualified.static.usage.ignore.field.option=Ignore unqualified field accesses
unqualified.static.usage.ignore.method.option=Ignore unqualified method calls
unqualified.static.usage.qualify.field.quickfix=Qualify static field access
unqualified.static.usage.qualify.method.quickfix=Qualify static method call
too.broad.scope.allow.option=<html>Report variables with a new expression as initializer<br>(Potentially unsafe: quick fix may modify semantics if the constructor has non-local side-effects)</html>
too.broad.scope.only.blocks.option=Only report variables that can be moved into inner blocks
too.broad.scope.narrow.quickfix=Move declaration of ''{0}'' closer to usages
press.escape.to.remove.highlighting.message=Press Escape to remove the highlighting
unnecessary.enum.modifier.problem.descriptor=Modifier <code>#ref</code> is redundant for enum constructors #loc
unnecessary.enum.modifier.problem.descriptor1=Modifier <code>#ref</code> is redundant for inner enums #loc
literal.as.arg.to.string.equals.problem.descriptor=<code>#ref</code> is argument of ''{0}()'', instead of its target #loc
literal.as.arg.to.string.equals.flip.quickfix=Flip 'equals()'
c.style.array.declaration.replace.quickfix=Replace with Java-style array declaration
chained.method.call.ignore.option=Ignore chained method calls in field initializers
chained.method.call.ignore.this.super.option=Ignore chained method calls in 'this()' and 'super()' calls
introduce.variable.quickfix=Introduce variable
introduce.variable.may.change.semantics.quickfix=Introduce variable (may change semantics)
flip.comparison.quickfix=Flip comparison
control.flow.statement.without.braces.add.quickfix=Add braces to statement
control.flow.statement.without.braces.message=Add braces to ''{0}'' statement
extends.object.remove.quickfix=Remove redundant 'extends Object'
implicit.call.to.super.ignore.option=Ignore for direct subclasses of 'java.lang.Object'
implicit.call.to.super.make.explicit.quickfix=Make call to 'super()' explicit
missorted.modifiers.require.option=Require annotations to be sorted before keywords
missorted.modifiers.sort.quickfix=Sort modifiers
nested.method.call.ignore.option=Ignore nested method calls in field initializers
ignore.calls.to.static.methods=Ignore calls to static methods
ignore.calls.to.property.getters=Ignore calls to property getters
redundant.field.initialization.remove.quickfix=Remove initializer
redundant.implements.remove.quickfix=Remove redundant interface declaration
unnecessary.constructor.remove.quickfix=Remove redundant constructor
unnecessary.fully.qualified.name.replace.quickfix=Replace qualified name with import
unnecessary.fully.qualified.name.remove.quickfix=Remove unnecessary qualification
unnecessary.fully.qualified.name.status.bar.escape.highlighting.message={0} fully qualified {0, choice, 1#name|2#names} replaced with import (press Escape to remove highlighting)
unnecessary.parentheses.remove.quickfix=Remove unnecessary parentheses
unnecessary.qualifier.for.this.remove.quickfix=Remove unnecessary qualifier
unnecessary.semicolon.remove.quickfix=Remove unnecessary semicolon
unnecessary.super.constructor.remove.quickfix=Remove unnecessary 'super()'
unnecessary.this.remove.quickfix=Remove unnecessary 'this' qualifier
overly.strong.type.cast.problem.descriptor=Cast to <code>#ref</code> can be weakened to ''{0}'' #loc
field.count.inspection.include.constant.fields.in.count.checkbox=Include constant fields in count
field.count.inspection.static.final.fields.count.as.constant.checkbox='static final' fields count as constant
field.count.inspection.include.enum.constants.in.count=Include enum constants in count
make.method.final.fix.name=Make method ''{0}()'' ''final''
make.class.final.fix.name=Make class ''{0}'' ''final''
non.boolean.method.name.must.not.start.with.question.display.name=Non-boolean method name must not start with question word
non.boolean.method.name.must.not.start.with.question.problem.descriptor=Non-boolean method name <code>#ref</code> starts with a question word #loc
boolean.constructor.simplify.quickfix=Simplify
unnecessary.temporary.on.conversion.from.string.problem.descriptor=<code>#ref</code> #loc can be simplified to ''{0}''
unnecessary.temporary.on.conversion.from.string.fix.name=Replace with ''{0}''
only.report.qualified.static.usages.option=Only report qualified static access from a static context
unqualified,static.usage.only.report.static.usages.option=Only report static access from a non-static context
assignment.to.catch.block.parameter.problem.descriptor=Assignment to 'catch' block parameter <code>#ref</code> #loc
assignment.to.method.parameter.problem.descriptor=Assignment to method parameter <code>#ref</code> #loc
value.of.post.increment.problem.descriptor=Value of post-increment expression <code>#ref</code> is used #loc
value.of.post.decrement.problem.descriptor=Value of post-decrement expression <code>#ref</code> is used #loc
value.of.pre.increment.problem.descriptor=Value of pre-increment expression <code>#ref</code> is used #loc
value.of.pre.decrement.problem.descriptor=Value of pre-decrement expression <code>#ref</code> is used #loc
assignment.replaceable.with.operator.assignment.problem.descriptor=<code>#ref</code> could be simplified to ''{0}'' #loc
assignment.replaceable.with.operator.assignment.ignore.conditional.operators.option=Ignore conditional operators
assignment.replaceable.with.operator.assignment.ignore.obscure.operators.option=Ignore the obscure ^ and % operators
assignment.replaceable.with.operator.replace.quickfix=Replace ''='' with ''{0}=''
object.equality.ignore.between.objects.of.a.type.with.only.private.constructors.option=Ignore '==' between objects of a type with only 'private' constructors
redundant.method.override.display.name=Method is identical to its super method
redundant.method.override.problem.descriptor=Method <code>#ref()</code> is identical to its super method #loc
redundant.method.override.quickfix=Remove redundant method
refused.bequest.problem.descriptor=Method <code>#ref()</code> does not call 'super.#ref()' #loc
refused.bequest.ignore.empty.super.methods.option=Ignore empty super methods
overly.complex.boolean.expression.ignore.option=Ignore pure conjunctions and disjunctions
pointless.indexof.comparison.display.name=Pointless 'indexOf()' comparison
pointless.indexof.comparison.always.true.problem.descriptor=<code>#ref</code> is always true #loc
pointless.indexof.comparison.always.false.problem.descriptor=<code>#ref</code> is always false #loc
reuse.of.local.variable.problem.descriptor=Reuse of local variable <code>#ref</code> #loc
single.character.startswith.display.name=Single character 'startsWith()' or 'endsWith()'
single.character.startswith.problem.descriptor=Single character <code>#ref()</code> could be replaced with 'charAt()' expression #loc
indexof.replaceable.by.contains.display.name='indexOf()' expression is replaceable with 'contains()'
replace.indexof.with.contains.quickfix=Replace 'indexOf()' with 'contains()'
overloaded.methods.with.same.number.parameters.problem.descriptor=Multiple methods named <code>#ref</code> with the same number of parameters #loc
overloaded.vararg.method.problem.descriptor=Overloaded varargs method <code>#ref()</code> #loc
overloaded.vararg.constructor.problem.descriptor=Overloaded varargs constructor <code>#ref()</code> #loc
cached.number.constructor.call.display.name=Number constructor call with primitive argument
cached.number.constructor.call.problem.descriptor=Number constructor call with primitive argument #loc
cached.number.constructor.call.quickfix=Replace with ''{0}.valueOf()'' call
cached.number.constructor.call.ignore.string.arguments.option=Ignore new number expressions with a String argument
cached.number.constructor.call.report.only.deprecated=Report only when constructor is @Deprecated
chained.equality.comparisons.problem.descriptor=Chained equality comparison <code>#ref</code> #loc
confusing.octal.escape.sequence.problem.descriptor=Octal escape sequence <code>#ref</code> immediately followed by digit #loc
field.accessed.synchronized.and.unsynchronized.option=Simple getters and setters are considered field accesses too
method.overrides.inaccessible.method.display.name=Method overrides inaccessible method of superclass
method.overrides.package.local.method.problem.descriptor=Method <code>#ref()</code> overrides a package-private method of a superclass located in another package #loc
suspicious.to.array.call.display.name=Suspicious 'Collection.toArray()' call
suspicious.to.array.call.problem.descriptor=Array of type ''{0}[]'' expected #loc
suspicious.system.arraycopy.display.name=Suspicious 'System.arraycopy()' call
suspicious.system.arraycopy.problem.descriptor1=Parameter 'srcPos' may not be negative #loc
suspicious.system.arraycopy.problem.descriptor2=Parameter 'destPos' may not be negative #loc
suspicious.system.arraycopy.problem.descriptor3=Parameter 'length' may not be negative #loc
suspicious.system.arraycopy.problem.descriptor4=<code>#ref</code> is not of an array type #loc
suspicious.system.arraycopy.problem.descriptor5=<code>#ref</code> is not of an array type #loc
suspicious.system.arraycopy.problem.descriptor6=Source parameter type ''{0}'' is not assignable to destination parameter <code>#ref</code> of type ''{1}'' #loc
raw.use.of.parameterized.type.ignore.new.objects.option=Ignore construction of new objects
raw.use.of.parameterized.type.ignore.type.casts.option=Ignore type casts
raw.use.of.parameterized.type.ignore.uncompilable.option=Ignore where a type parameter would not compile
raw.use.of.parameterized.type.ignore.overridden.parameter.option=Ignore parameter types of overriding methods
method.only.used.from.inner.class.display.name=Private method only used from inner class
method.only.used.from.inner.class.problem.descriptor.anonymous.extending=Method <code>#ref()</code>#loc is only used from an anonymous class extending ''{0}'' #loc
method.only.used.from.inner.class.problem.descriptor.anonymous.implementing=Method <code>#ref()</code>#loc is only used from an anonymous class implementing ''{0}'' #loc
method.only.used.from.inner.class.problem.descriptor=Method <code>#ref()</code>#loc is only used from inner class ''{0}'' #loc
method.only.used.from.inner.class.ignore.option=Ignore methods accessed from an &anonymous class
ignore.static.methods.accessed.from.a.non.static.inner.class=Ignore '&static' methods accessed from a non-'static' inner class
only.report.static.methods=&Only report 'static' methods
format.decode.error.requires.both.0.and.1=requires both {0} and {1}
format.decode.any=any
format.decode.date.time=Date/Time
format.decode.char=char
format.decode.integer.type=integer type
format.decode.floating.point=floating point
single.character.startswith.quickfix=Replace with 'charAt()'
interface.never.implemented.option=Ignore interfaces which only declare constants
size.replaceable.by.isempty.display.name='size() == 0' replaceable with 'isEmpty()'
size.replaceable.by.isempty.quickfix=Replace with 'isEmpty()'
size.replaceable.by.isempty.negation.ignore.option=Ignore expressions which would be replaced with '!isEmpty()'
ignored.classes.table=Ignored classes
choose.class.type.to.ignore=Choose class type to ignore
loop.condition.not.updated.inside.loop.display.name=Loop variable not updated inside loop
loop.variable.not.updated.inside.loop.problem.descriptor=Variable '#ref' is not updated inside loop #loc
loop.condition.not.updated.inside.loop.problem.descriptor=Condition '#ref' is not updated inside loop #loc
utility.class.without.private.constructor.option=Ignore classes with only a main method
super.class.logger.option=Ignore classes with an accessible logger declared in a superclass
static.method.only.used.in.one.class.display.name='static' method only used from one other class
static.method.only.used.in.one.class.problem.descriptor='static' method <code>#ref()</code> is only used from class ''{0}'' #loc
static.method.only.used.in.one.class.problem.descriptor.anonymous.implementing='static' method <code>#ref()</code> is only used from an anonymous class implementing ''{0}'' #loc
static.method.only.used.in.one.class.problem.descriptor.anonymous.extending='static' method <code>#ref()</code> is only used from an anonymous class extending ''{0}'' #loc
static.method.only.used.in.one.class.quickfix=Move method
static.method.only.used.in.one.class.ignore.test.option=Ignore when only used from a test class
static.method.only.used.in.one.class.ignore.anonymous.option=Ignore when only used from an anonymous class
static.method.only.used.in.one.class.ignore.on.conflicts=Ignore when the method cannot be moved without conflicts
unary.plus.display.name=Unary plus
unary.plus.problem.descriptor=Unary <code>#ref</code> operator #loc
await.without.corresponding.signal.display.name='await()' without corresponding 'signal()'
await.without.corresponding.signal.problem.descriptor=Call to <code>#ref</code> without corresponding <code>signal()</code> or <code>signalAll()</code> #loc
signal.without.corresponding.await.display.name='signal()' without corresponding 'await()'
signal.without.corresponding.await.problem.descriptor=Call to <code>#ref</code> without corresponding <code>await()</code> #loc
wait.without.corresponding.notify.display.name='wait()' without corresponding 'notify()'
wait.without.corresponding.notify.problem.descriptor=Call to <code>#ref</code> without corresponding <code>notify()</code> or <code>notifyAll()</code> #loc
notify.without.corresponding.wait.display.name='notify()' without corresponding 'wait()'
notify.without.corresponding.wait.problem.descriptor=Call to <code>#ref</code> without corresponding <code>wait()</code> #loc
integer.multiplication.implicit.cast.to.long.display.name=Integer multiplication or shift implicitly cast to long
integer.multiplication.implicit.cast.to.long.problem.descriptor=#ref: integer multiplication implicitly cast to long #loc
integer.shift.implicit.cast.to.long.problem.descriptor=#ref: integer shift implicitly cast to long #loc
integer.multiplication.implicit.cast.to.long.option=<html>Ignore compile time constant expressions which do not overflow</html>
wait.or.await.without.timeout.display.name='wait()' or 'await()' without timeout
wait.or.await.without.timeout.problem.descriptor=<code>#ref</code> without timeout #loc
method.return.always.constant.display.name=Method returns per-class constant
method.return.always.constant.problem.descriptor=Method <code>#ref()</code> and all it's derivables always return constants
class.with.too.many.dependencies.display.name=Class with too many dependencies
class.with.too.many.dependencies.problem.descriptor=Class ''{0}'' has too many dependencies ({1} > {2})
class.with.too.many.transitive.dependencies.display.name=Class with too many transitive dependencies
class.with.too.many.transitive.dependencies.problem.descriptor=Class ''{0}'' has too many transitive dependencies ({1} > {2})
class.with.too.many.dependents.display.name=Class with too many dependents
class.with.too.many.dependents.problem.descriptor=Class ''{0}'' has too many dependents ({1} > {2})
class.with.too.many.transitive.dependents.display.name=Class with too many transitive dependents
class.with.too.many.transitive.dependents.problem.descriptor=Class ''{0}'' has too many transitive dependencies ({1} > {2})
class.with.too.many.dependencies.max.option=Maximum number of dependencies
class.with.too.many.dependents.max.option=Maximum number of dependents
class.with.too.many.transitive.dependencies.max.option=Maximum number of transitive dependencies
class.with.too.many.transitive.dependents.max.option=Maximum number of transitive dependents
cyclic.class.dependency.display.name=Cyclic class dependency
cyclic.class.dependency.problem.descriptor=Class ''{0}'' is cyclically dependent on {1} other classes
cyclic.class.dependency.1.problem.descriptor=Class ''{0}'' is cyclically dependent on class ''{1}''
cyclic.class.dependency.2.problem.descriptor=Class ''{0}'' is cyclically dependent on classes ''{1}'' and ''{2}''
cyclic.package.dependency.display.name=Cyclic package dependency
cyclic.package.dependency.problem.descriptor=Package ''{0}'' is cyclically dependent on {1} other packages
cyclic.package.dependency.1.problem.descriptor=Package ''{0}'' is cyclically dependent on package ''{1}''
cyclic.package.dependency.2.problem.descriptor=Package ''{0}'' is cyclically dependent on packages ''{1}'' and ''{2}''
class.unconnected.to.package.display.name=Class independent of its package
class.unconnected.to.package.problem.descriptor=Class <code>#ref</code> has no dependencies or dependents in its package
exception.package.display.name=Exception package
exception.package.problem.descriptor=Package ''{0}'' contains only exception classes
package.with.too.many.classes.display.name=Package with too many classes
package.with.too.many.classes.problem.descriptor=Package ''{0}'' contains too many classes ({1} > {2})
package.with.too.many.classes.max.option=Maximum number of classes:
package.with.too.few.classes.display.name=Package with too few classes
package.with.too.few.classes.problem.descriptor=Package ''{0}'' contains too few classes ({1} < {2})
package.with.too.few.classes.min.option=Minimum number of classes:
module.with.too.many.classes.display.name=Module with too many classes
module.with.too.many.classes.problem.descriptor=Module ''{0}'' contains too many classes ({1} > {2})
module.with.too.many.classes.max.option=Maximum number of classes:
module.with.too.few.classes.display.name=Module with too few classes
module.with.too.few.classes.problem.descriptor=Module ''{0}'' contains too few classes ({1} < {2})
module.with.too.few.classes.min.option=Minimum number of classes:
package.in.multiple.modules.display.name=Package with classes in multiple modules
package.in.multiple.modules.problem.descriptor=Package ''{0}'' has classes in multiple modules
disjoint.package.display.name=Package with disjoint dependency graph
disjoint.package.problem.descriptor=Package {0} can be decomposed into {1} independent packages
package.naming.convention.display.name=Package naming convention
package.naming.convention.problem.descriptor.short=Package name <code>{0}</code> is too short
package.naming.convention.problem.descriptor.long=Package name <code>{0}</code> is too long
package.naming.convention.problem.descriptor.regex.mismatch=Package name <code>{0}</code> doesn''t match regex ''{1}''
cyclic.class.initialization.display.name=Cyclic class initialization dependency
cyclic.class.initialization.problem.descriptor=Initialization of class ''{0}'' is cyclically dependent on {1} other classes
before.or.after.is.public.void.no.arg.display.name=Malformed @Before or @After method
before.or.after.is.public.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature for a @Before or @After method #loc
before.class.or.after.class.is.public.static.void.no.arg.display.name=Malformed @BeforeClass/@BeforeAll or @AfterClass/@AfterAll method
before.class.or.after.class.is.public.static.void.no.arg.problem.descriptor=<code>#ref()</code> has incorrect signature for a @{0} method #loc
string.constructor.display.name=Redundant String constructor call
string.constructor.problem.descriptor=<code>#ref</code> is redundant #loc
string.constructor.replace.arg.quickfix=Replace with arg
string.constructor.replace.empty.quickfix=Replace with empty string
string.constructor.substring.parameter.option=Ignore string constructor calls with a 'substring()' call argument
design.for.extension.display.name=Design for extension
design.for.extension.problem.descriptor=Method <code>#ref()</code> may be overridden and its functionality ignored #loc
bad.oddness.display.name=Suspicious test for oddness
bad.oddness.problem.descriptor=Test for oddness <code>#ref</code> will fail on negative values #loc
comparator.not.serializable.display.name=Comparator class not declared Serializable
comparator.not.serializable.problem.descriptor=Comparator class <code>#ref</code> is not declared as Serializable #loc
non.serializable.field.in.serializable.class.display.name=Non-serializable field in a Serializable class
non.serializable.field.in.serializable.class.problem.descriptor=Non-serializable field '#ref' in a Serializable class #loc
non.serializable.object.passed.to.object.stream.display.name=Non-serializable object passed to ObjectOutputStream
non.serializable.object.passed.to.object.stream.problem.descriptor=Non-serializable object passed to ObjectOutputStream #loc
non.serializable.object.bound.to.http.session.display.name=Non-serializable object bound to HttpSession
non.serializable.object.bound.to.http.session.problem.descriptor=Non-serializable object bound to HttpSession #loc
reflection.for.unavailable.annotation.display.name=Reflective access to a source-only annotation
reflection.for.unavailable.annotation.problem.descriptor=Annotation '#ref' is not retained for reflective access #loc
access.to.static.field.locked.on.instance.display.name=Access to static field locked on instance data
access.to.static.field.locked.on.instance.problem.descriptor=Access to static field <code>#ref</code> locked on instance data #loc
make.method.ctr.quickfix=Make method constructor
replace.all.dot.display.name=Call to String.replaceAll(".", ...)
replace.all.dot.problem.descriptor=Call to <code>String.#ref(".", ...)</code> #loc
constant.string.intern.display.name=Call to 'intern()' on String constant
constant.string.intern.problem.descriptor=<code>.#ref()</code> on compile-time constant is unnecessary #loc
constant.string.intern.quickfix=Remove 'intern()' call
class.extends.utility.class.display.name=Class extends utility class
class.extends.utility.class.problem.descriptor=Class <code>#ref</code> extends utility class ''{0}'' #loc
class.extends.utility.class.ignore.utility.class.option=Ignore if overriding class is a utility class
public.constructor.in.non.public.class.quickfix=Make constructor ''{0}''
assignment.to.method.parameter.ignore.transformation.option=<html>Ignore if assignment is a transformation of the original parameter</html>
type.parameter.extends.final.class.display.name=Type parameter extends final class
type.parameter.extends.final.class.problem.descriptor1=Type parameter <code>#ref</code> extends ''final'' class ''{0}'' #loc
type.parameter.extends.final.class.problem.descriptor2=Wildcard type argument <code>#ref</code> extends ''final'' class ''{0}'' #loc
type.parameter.extends.final.class.quickfix=Replace type parameter with actual class
double.negation.display.name=Double negation
double.negation.problem.descriptor=Double negation in <code>#ref</code> #loc
double.negation.quickfix=Remove double negation
exception.from.catch.which.doesntwrap.ignore.option=Ignore if result of exception method call is used
exception.from.catch.which.doesntwrap.ignore.cant.wrap.option=Ignore if thrown exception cannot wrap an exception
comparable.implemented.but.equals.not.overridden.display.name=Comparable implemented but 'equals()' not overridden
comparable.implemented.but.equals.not.overridden.problem.descriptor=Class <code>#ref</code> implements 'java.lang.Comparable' but does not override 'equals()' #loc
unqualified.field.access.display.name=Instance field access not qualified with 'this'
unqualified.field.access.problem.descriptor=Instance field access <code>#ref</code> is not qualified with 'this' #loc
unqualified.method.access.display.name=Instance method call not qualified with 'this'
unqualified.method.access.problem.descriptor=Instance method call <code>#ref</code> is not qualified with 'this' #loc
add.this.qualifier.quickfix=Add 'this' qualifier
while.loop.spins.on.field.ignore.non.empty.loops.option=Only warn if the loop is empty
method.may.be.synchronized.problem.descriptor=Method <code>#ref()</code> with synchronized block could be synchronized method #loc
method.may.be.synchronized.display.name=Method with synchronized block could be synchronized method
method.may.be.synchronized.quickfix=Make method synchronized and remove synchronized block
fallthru.in.switch.statement.quickfix=Add 'break'
law.of.demeter.display.name=Method call violates Law of Demeter
law.of.demeter.problem.descriptor=<code>#ref()</code> call violates Law of Demeter #loc
law.of.demeter.ignore.library.calls.option=Ignore calls on library methods
assertequals.between.inconvertible.types.display.name='assertEquals()' between objects of inconvertible types
assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
enumeration.can.be.iteration.display.name=Enumeration can be iteration
enumeration.can.be.iteration.problem.descriptor=<code>#ref()</code> can be replaced with ''{0}'' construct #loc
enumeration.can.be.iteration.quickfix=Replace with 'Iterator' construct
equals.hashcode.called.on.url.display.name='equals()' or 'hashCode()' called on 'java.net.URL' object
equals.hashcode.called.on.url.problem.descriptor=Call to <code>#ref()</code> on URL object #loc
collection.contains.url.problem.decriptor={0} <code>#ref</code> may contain URL objects #loc
collection.contains.url.display.name=Map or Set may contain 'java.net.URL' objects
implicit.array.to.string.problem.descriptor=Implicit call to 'toString()' on array <code>#ref</code> #loc
explicit.array.to.string.problem.descriptor=Call to '#ref()' on array #loc
implicit.array.to.string.method.call.problem.descriptor=Implicit call to 'toString()' on array returned by call to <code>#ref</code> #loc
implicit.array.to.string.display.name=Call to 'toString()' on array
implicit.array.to.string.quickfix=Wrap with ''{0}'' expression
suspicious.indent.after.control.statement.problem.descriptor=<code>#ref</code> statement has suspicious indentation #loc
suspicious.indent.after.control.statement.display.name=Suspicious indentation after control statement without braces
unpredictable.big.decimal.constructor.call.display.name=Unpredictable BigDecimal constructor call
unpredictable.big.decimal.constructor.call.problem.descriptor=Unpredictable <code>new #ref()</code> call #loc
unpredictable.big.decimal.constructor.call.ignore.references.option=Ignore constructor calls with variable or method call arguments
unpredictable.big.decimal.constructor.call.ignore.complex.literals.option=Ignore constructor calls with multiple literals (e.g. 0.1 + 0.2)
unpredictable.big.decimal.constructor.call.quickfix=Replace with ''{0}''
unnecessary.unary.minus.display.name=Unnecessary unary minus
unnecessary.unary.minus.problem.descriptor=Unnecessary unary minus #loc
unnecessary.unary.minus.quickfix=Remove unary minus and invert parent operation sign
make.field.final.quickfix=Make ''{0}'' ''final''
increment.decrement.used.as.expression.quickfix=Extract ''{0}'' to separate statement
ignore.classes.in.hierarchy.column.name=Ignore subclasses of
overly.strong.type.cast.ignore.in.matching.instanceof.option=Ignore casts with a matching instanceof expression
return.of.collection.field.quickfix=Replace with ''{0}''
access.to.non.thread.safe.static.field.from.instance.display.name=Non thread-safe static field access
access.to.non.thread.safe.static.field.from.instance.field.problem.descriptor=Access to non thread-safe static field <code>#ref</code> of type ''{0}'' #loc
access.to.non.thread.safe.static.field.from.instance.option.title=Non thread-safe classes
access.to.non.thread.safe.static.field.from.instance.class.chooser.title=Choose non thread-safe class
transient.field.not.initialized.display.name=Transient field is not initialized on deserialization
transient.field.not.initialized.problem.descriptor=Transient field <code>#ref</code> not initialized on deserialization #loc
call.to.string.concat.can.be.replaced.by.operator.display.name=Call to 'String.concat()' can be replaced with '+'
call.to.string.concat.can.be.replaced.by.operator.problem.descriptor=Call to <code>#ref()</code> can be replaced with '+' expression #loc
call.to.string.concat.can.be.replaced.by.operator.quickfix=Replace 'concat()' call with '+'
new.string.buffer.with.char.argument.display.name=StringBuilder constructor call with 'char' argument
new.string.buffer.with.char.argument.problem.descriptor=<code>new #ref()</code> with argument of type 'char' #loc
new.string.buffer.with.char.argument.quickfix=Replace char argument with String literal
suspicious.comparator.compare.display.name=Suspicious 'Comparator.compare()' implementation
suspicious.comparator.compare.descriptor.parameter.not.used='compare()' parameter <code>#ref</code> is not used #loc
suspicious.comparator.compare.descriptor.non.reflexive=Comparator does not return 0 for equal elements
to.array.call.with.zero.length.array.argument.display.name=Call to 'Collection.toArray()' with zero-length array argument
to.array.call.with.zero.length.array.argument.problem.descriptor=Call to <code>#ref()</code> with zero-length array argument ''{0}'' #loc
to.array.call.with.zero.length.array.argument.quickfix=Replace argument with correctly sized array
throwable.instance.never.thrown.runtime.exception.problem.descriptor=Runtime exception instance <code>#ref</code> is not thrown #loc
throwable.instance.never.thrown.checked.exception.problem.descriptor=Checked exception instance <code>#ref</code> is not thrown #loc
throwable.instance.never.thrown.error.problem.descriptor=Error instance <code>#ref</code> is not thrown #loc
throwable.instance.never.thrown.problem.descriptor=Throwable instance <code>#ref</code> is not thrown #loc
type.may.be.weakened.display.name=Type may be weakened
type.may.be.weakened.problem.descriptor=Type of variable <code>#ref</code> may be weakened to {0} #loc
type.may.be.weakened.method.problem.descriptor=Return type of method <code>#ref()</code> may be weakened to {0} #loc
type.may.be.weakened.parameter.problem.descriptor=Type of parameter <code>#ref</code> may be weakened to {0} #loc
type.may.be.weakened.field.problem.descriptor=Type of field <code>#ref</code> may be weakened to {0} #loc
type.may.be.weakened.quickfix=Weaken type to ''{0}''
type.may.be.weakened.ignore.option=Use &righthand type as weakest type in assignments
type.may.be.weakened.collection.method.option=Use &parameterized type of collection for method call arguments
type.may.be.weakened.do.not.weaken.to.object.option=Do not &weaken to 'java.lang.Object'
ignore.guard.clauses.option=Ignore &guard clauses
ignore.for.equals.methods.option=Ignore for '&equals()' methods
caught.exception.immediately.rethrown.display.name=Caught exception is immediately rethrown
caught.exception.immediately.rethrown.problem.descriptor=Caught exception <code>#ref</code> is immediately rethrown #loc
delete.catch.section.quickfix=Delete 'catch' section
remove.try.catch.quickfix=Remove 'try catch' statement
loop.with.implicit.termination.condition.display.name=Loop with implicit termination condition
loop.with.implicit.termination.condition.dowhile.problem.descriptor=<code>#ref-while</code> loop with implicit termination condition #loc
loop.with.implicit.termination.condition.problem.descriptor=<code>#ref</code> loop with implicit termination condition #loc
loop.with.implicit.termination.condition.quickfix=Make condition explicit
ignore.iterator.loop.variables=Ignore 'java.util.Iterator' loop variables
rename.catch.parameter.to.ignored=Rename 'catch' parameter to 'ignored'
unnecessary.super.qualifier.display.name=Unnecessary 'super' qualifier
unnecessary.super.qualifier.problem.descriptor=Qualifier <code>#ref</code> is unnecessary in this context #loc
unnecessary.super.qualifier.quickfix=Remove unnecessary 'super' qualifier
collections.field.access.replaceable.by.method.call.display.name=Collections.EMPTY_* field access replaceable with 'Collections.empty*()' method call
collections.field.access.replaceable.by.method.call.problem.descriptor=<code>#ref</code> replaceable with ''Collections.{0}'' #loc
collections.field.access.replaceable.by.method.call.quickfix=Replace with ''{0}''
synchronization.on.local.variable.or.method.parameter.display.name=Synchronization on local variable or method parameter
synchronization.on.local.variable.problem.descriptor=Synchronization on local variable <code>#ref</code> #loc
synchronization.on.method.parameter.problem.descriptor=Synchronization on method parameter <code>#ref</code> #loc
too.broad.catch.quickfix=Add ''catch'' clause for ''{0}''
replace.with.catch.clause.for.runtime.exception.quickfix=Replace with 'catch' clause for 'RuntimeException'
too.broad.catch.option=&Only warn on RuntimeException, Exception, Error or Throwable
unnecessary.call.to.string.valueof.display.name=Unnecessary call to 'String.valueOf()'
unnecessary.tostring.call.display.name=Unnecessary call to 'toString()'
unnecessary.call.to.string.valueof.problem.descriptor=<code>#ref</code> can be simplified to ''{0}'' #loc
unnecessary.tostring.call.problem.descriptor=Unnecessary <code>#ref()</code> call #loc
unnecessary.call.to.string.valueof.quickfix=Replace with ''{0}''
throwable.not.thrown.display.name=Throwable not thrown
throwable.result.of.method.call.ignored.problem.descriptor=Result of <code>#ref()</code> not thrown #loc
char.used.in.arithmetic.context.display.name=Char expression used in arithmetic context
char.used.in.arithmetic.context.problem.descriptor='char' <code>#ref</code> used in arithmetic context #loc
char.used.in.arithmetic.context.quickfix=Convert to String literal
char.used.in.arithmetic.context.cast.quickfix=Insert cast to {0}
unnecessary.constant.array.creation.expression.display.name=Redundant 'new' expression in constant array creation
unnecessary.constant.array.creation.expression.problem.descriptor=<code>#ref</code> can be replaced with array initializer expression #loc
unnecessary.constant.array.creation.expression.quickfix=Remove ''new {0}''
unnecessary.constant.array.creation.expression.family.quickfix=Replace with array initializer expression
ambiguous.method.call.display.name=Call to inherited method looks like call to local method
ambiguous.method.call.problem.descriptor=Call to method <code>#ref()</code> from superclass ''{0}'' looks like call to method from class ''{1}'' #loc
ambiguous.method.call.quickfix=Add 'super' qualifier to method call
change.modifier.quickfix=Make ''{0}''
the.whole.project=the whole project
this.class=this class
assertequals.may.be.assertsame.display.name='assertEquals()' may be 'assertSame()'
assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> may be 'assertSame()' #loc
logger.initialized.with.foreign.class.quickfix=Replace with ''{0}.class''
logger.initialized.with.foreign.class.problem.descriptor=Logger initialized with foreign class <code>#ref</code> #loc
logger.initialized.with.foreign.class.display.name=Logger initialized with foreign class
logger.factory.method.name=Logger factory method name
logger.factory.class.name=Logger factory class name
make.static.final.quickfix=Make ''{0}'' static final
logging.condition.disagrees.with.log.statement.display.name=Log condition does not match logging call
logging.condition.disagrees.with.log.statement.problem.descriptor=Log condition <code>#ref()</code> does not match ''{0}()'' logging call #loc
log.statement.guarded.by.log.condition.display.name=Logging call not guarded by log condition
log.statement.guarded.by.log.condition.problem.descriptor=<code>#ref()</code> logging calls not guarded by log condition #loc
log.statement.guarded.by.log.condition.quickfix=Surround with log condition
log.statement.guarded.by.log.condition.flag.all.unguarded.option=Flag all unguarded logging calls
key.set.iteration.may.use.entry.set.display.name=Iteration over 'keySet()' may be replaced with 'entrySet()' iteration
key.set.iteration.may.use.entry.set.problem.descriptor=Iteration over <code>#ref</code> may be replaced with 'entrySet()' iteration #loc
key.set.iteration.may.use.entry.set.quickfix=Replace with 'entrySet()' iteration
string.replaceable.by.string.buffer.in.loop.option=Only warn when appending in a loop
declare.collection.as.interface.quickfix=Weaken to ''{0}''
non.exception.name.ends.with.exception.quickfix=Make ''{0}'' extend ''java.lang.Exception''
constant.value.variable.use.display.name=Use of variable whose value is known to be constant
constant.value.variable.use.problem.descriptor=Value of <code>#ref</code> is known to be constant #loc
replace.reference.with.expression.quickfix=Replace with ''{0}''
unnecessary.parentheses.option=Ignore clarifying parentheses
unnecessary.parentheses.conditional.option=Ignore parentheses around the condition of conditional expressions
field.may.be.final.display.name=Field may be 'final'
field.may.be.final.problem.descriptor=Field <code>#ref</code> may be 'final' #loc
cast.that.loses.precision.option=Ignore casts from int to char
ignore.overflowing.byte.casts.option=Ignore casts from int 128-255 to byte
variable.not.used.inside.if.display.name=Reference checked for 'null' is not used inside 'if'
variable.not.used.inside.if.problem.descriptor=<code>#ref</code> checked for 'null' is not used inside 'if' #loc
variable.not.used.inside.conditional.problem.descriptor=<code>#ref</code> checked for 'null' is not used inside conditional #loc
boolean.expression.may.be.conditional.display.name=Boolean expression could be replaced with conditional expression
if.may.be.conditional.display.name='if' statement could be replaced with conditional expression
if.may.be.conditional.problem.descriptor=<code>#ref</code> could be replaced with conditional expression #loc
if.may.be.conditional.quickfix=Replace with conditional expression
if.may.be.conditional.report.method.calls.option=Report if statements containing method calls
redundant.string.format.call.display.name=Redundant call to 'String.format()'
redundant.string.format.call.problem.descriptor=Redundant call to <code>#ref()</code> #loc
redundant.string.format.call.quickfix=Remove redundant call to 'String.format()'
replace.printf.with.print.quickfix=Replace 'printf()' with 'print()'
junit4.test.method.in.class.extending.junit3.testcase.display.name=JUnit 4 test method in class extending JUnit 3 TestCase
junit4.test.method.in.class.extending.junit3.testcase.problem.descriptor=Method <code>#ref()</code> annotated with '@Test' inside class extending JUnit 3 TestCase #loc
ignore.test.method.in.class.extending.junit3.testcase.problem.descriptor=JUnit 3 test method <code>#ref()</code> annotated with '@Ignore' won't be ignored #loc
ignore.test.method.in.class.extending.junit3.testcase.quickfix=Remove ''@Ignore'' and rename method to ''{0}''
convert.junit3.test.class.quickfix=Convert JUnit 3 class ''{0}'' to JUnit 4
remove.junit4.test.annotation.quickfix=Remove '@Test' annotation
remove.junit4.test.annotation.and.rename.quickfix=Remove ''@Test'' annotation and rename to ''{0}''
equals.called.on.enum.constant.display.name='equals()' called on Enum value
equals.called.on.enum.constant.problem.descriptor=<code>#ref()</code> called on Enum value #loc
equals.called.on.enum.constant.quickfix=Replace 'equals()' with '=='
int.literal.may.be.long.literal.display.name='int' literal cast to 'long' could be 'long' literal
int.literal.may.be.long.literal.problem.descriptor=<code>#ref</code> could be replaced with ''{0}'' #loc
int.literal.may.be.long.literal.quickfix=Replace with ''{0}''
constant.assert.condition.display.name='assert' statement condition is constant
constant.assert.condition.problem.descriptor=Assert condition <code>#ref</code> is constant #loc
assert.with.side.effects.display.name='assert' statement with side effects
assert.with.side.effects.problem.descriptor=<code>#ref</code> has side effects #loc
method.count.ignore.getters.setters.option=&Ignore simple getter and setter methods
class.new.instance.display.name=Unsafe call to 'Class.newInstance()'
class.new.instance.problem.descriptor=Call to <code>#ref()</code> may throw undeclared checked exceptions #loc
class.new.instance.quickfix=Replace with 'Class.getConstructor().newInstance()' call
dynamic.regex.replaceable.by.compiled.pattern.display.name=Dynamic regular expression could be replaced by compiled Pattern
dynamic.regex.replaceable.by.compiled.pattern.problem.descriptor=<code>#ref()</code> could be replaced with compiled 'java.util.regex.Pattern' construct #loc
dynamic.regex.replaceable.by.compiled.pattern.quickfix=Replace with call to method of compiled 'Pattern' constant
ignore.serializable.option=Ignore 'java.io.Serializable'
ignore.cloneable.option=Ignore 'java.lang.Cloneable'
listener.may.use.adapter.display.name=Class may extend adapter instead of implementing listener
listener.may.use.adapter.problem.descriptor=Class ''{0}'' may extend ''{1}'' instead of implementing <code>#ref</code> #loc
listener.may.use.adapter.quickfix=Replace with ''extends {0}''
listener.may.use.adapter.emtpy.methods.option=&Only warn when empty implementing methods are found
unnecessary.inherit.doc.display.name=Unnecessary {@inheritDoc} Javadoc comment
unnecessary.inherit.doc.problem.descriptor=Javadoc comment containing only <code>#ref</code> is unnecessary #loc
unnecessary.inherit.doc.field.invalid.problem.descriptor=<code>#ref</code> is not valid on fields #loc
unnecessary.inherit.doc.constructor.invalid.problem.descriptor=<code>#ref</code> is not valid on constructors #loc
unnecessary.inherit.doc.class.invalid.problem.descriptor=<code>#ref</code> is not valid on classes #loc
unnecessary.inherit.doc.module.invalid.problem.descriptor=<code>#ref</code> is not valid on module declarations #loc
unnecessary.inherit.doc.constructor.no.super.problem.descriptor=No super method found to inherit Javadoc from #loc
unnecessary.inherit.doc.quickfix=Remove unnecessary {@inheritDoc}
multiple.exceptions.declared.on.test.method.display.name=Multiple exceptions declared on test method
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> could be replaced with 'throws Exception' #loc
multiple.exceptions.declared.on.test.method.quickfix=Replace with 'throws Exception'
unnecessary.javadoc.link.display.name=Unnecessary Javadoc link
unnecessary.javadoc.link.super.method.problem.descriptor=<code>#ref</code> pointing to super method is unnecessary #loc
unnecessary.javadoc.link.this.method.problem.descriptor=<code>#ref</code> pointing to this method is unnecessary #loc
unnecessary.javadoc.link.this.class.problem.descriptor=<code>#ref</code> pointing to containing class is unnecessary #loc
unnecessary.javadoc.link.quickfix=Remove unnecessary ''{0}''
thread.local.not.static.final.display.name=ThreadLocal field not declared static final
thread.local.not.static.final.problem.descriptor=ThreadLocal <code>#ref</code> is not declared 'static final' #loc
remove.try.finally.block.quickfix=Remove 'try-finally' block
remove.finally.block.quickfix=Remove 'finally' block
remove.leading.zero.to.make.decimal.quickfix=Remove leading zero to make decimal
convert.octal.literal.to.decimal.literal.quickfix=Convert octal literal to decimal literal
ignore.single.field.static.imports.option=Ignore single &field static imports
ignore.single.method.static.imports.option=Ignore single &method static imports
ignore.methods.with.boolean.return.type.option=Ignore methods with 'java.lang.&Boolean' return type
ignore.boolean.methods.in.an.interface.option=Ignore boolean methods in an @&interface
ignore.methods.overriding.super.method=Ignore methods &overriding/implementing a super method
ignore.nullable.parameters.option=Ignore @Nullable parameters
ignored.io.resource.types=Ignored I/O resource types
choose.io.resource.type.to.ignore=Choose I/O resource type to ignore
ignore.accesses.from.the.same.class=Ignore accesses from the same class
ignore.accesses.from.equals.method=Ignore accesses from 'equals()' method
ignore.branches.of.switch.statements=Ignore branches of 'switch' statements
ignore.equals.hashcode.and.tostring=Ignore 'equals()', 'hashCode()' and 'toString()' methods
ignore.methods.in.anonymous.classes=Ignore methods in anonymous classes
class.name=Class name
method.name.regex=Method name regex
choose.class=Choose class
query.column.name=Query names start with
update.column.name=Update names start with
assert.keyword.is.considered.an.assertion='assert' keyword is considered an assertion
expected.exception.never.thrown.display.name=Expected exception never thrown in test method body
expected.exception.never.thrown.problem.descriptor=Expected <code>#ref</code> never thrown in body of ''{0}()'' #loc
choose.logger.class=Choose logger class
logger.class.name=Logger class name
ignore.exceptions.declared.on.library.override.option=Ignore exceptions declared on methods overriding a &library method
allow.resource.to.be.opened.inside.a.try.block=Allow resource to be opened inside a 'try' block
any.method.may.close.resource.argument=Any method may close resource argument
log.method.name=Logging method name
log.condition.text=Log condition text
ignore.if.annotated.by=Ignore if annotated by
ignore.parameter.if.annotated.by=Ignore parameter if it is annotated by
only.weaken.to.an.interface=Only weaken to an interface
unqualified.inner.class.access.display.name=Unqualified inner class access
unqualified.inner.class.access.problem.descriptor=<code>#ref</code> is not qualified with outer class #loc
unqualified.inner.class.access.quickfix=Qualify with outer class
unnecessarily.qualified.inner.class.access.problem.descriptor=''{0}'' is unnecessarily qualified with <code>#ref</code> #loc
unnecessarily.qualified.inner.class.access.display.name=Unnecessarily qualified inner class access
unnecessarily.qualified.inner.class.access.quickfix=Remove qualifier
synchronization.on.static.field.display.name=Synchronization on 'static' field
synchronization.on.static.field.problem.descriptor=Synchronization on 'static' field <code>#ref</code> #loc
assertequals.called.on.arrays.display.name='assertEquals()' called on array
assertequals.called.on.arrays.problem.descriptor=<code>#ref()</code> called on array #loc
overly.broad.throws.clause.display.name=Overly broad 'throws' clause
overly.broad.throws.clause.problem.descriptor1=<code>throws #ref</code> is too broad, masking exception ''{0}'' #loc
overly.broad.throws.clause.problem.descriptor2=<code>throws #ref</code> is too broad, masking exceptions ''{0}'' and ''{1}'' #loc
overly.broad.throws.clause.quickfix1=Add specific exceptions
overly.broad.throws.clause.quickfix2=Replace with specific exceptions
overly.broad.throws.clause.ignore.thrown.option=Ignore exceptions which &hide others but are themselves thrown
unnecessarily.qualified.statically.imported.element.display.name=Unnecessarily qualified statically imported element
unnecessarily.qualified.statically.imported.element.problem.descriptor=Statically imported element ''{0}'' is unnecessarily qualified with <code>#ref</code> #loc
unnecessarily.qualified.statically.imported.element.quickfix=Remove unnecessary qualifier
ignore.instanceof.on.library.classes=Ignore instanceof on library classes
replace.assertequals.quickfix=Replace with ''{0}''
for.can.be.foreach.option=Report indexed 'java.util.List' loops
for.can.be.foreach.option2=Do not report iterations over untyped collections
cast.conflicts.with.instanceof.quickfix1=Replace ''{0}'' with ''{1}'' in cast
cast.conflicts.with.instanceof.quickfix2=Replace ''{0}'' with ''{1}'' in instanceof
double.checked.locking.quickfix=Make ''{0}'' volatile
double.literal.may.be.float.literal.display.name='double' literal cast to 'float' could be 'float' literal
double.literal.may.be.float.literal.problem.descriptor=<code>#ref</code> could be replaced with ''{0}'' #loc
double.literal.may.be.float.literal.quickfix=Replace with ''{0}''
multiple.declaration.option=Ignore 'for' loop declarations
simplifiable.annotation.display.name=Simplifiable annotation
simplifiable.annotation.problem.descriptor=Unnecessary <code>#ref</code> in annotation #loc
simplifiable.annotation.whitespace.problem.descriptor=Unnecessary whitespace in annotation #loc
simplifiable.annotation.quickfix=Simplify annotation
overloaded.methods.with.same.number.parameters.option=<html>Ignore overloaded methods whose parameter types are definitely incompatible</html>
string.concatenation.in.format.call.display.name=String concatenation as argument to 'format()' call
string.concatenation.in.format.call.problem.descriptor=<code>#ref()</code> call has a String concatenation argument #loc
string.concatenation.in.format.call.quickfix=Replace concatenation with separate argument
string.concatenation.in.message.format.call.display.name=String concatenation as argument to 'MessageFormat.format()' call
string.concatenation.in.message.format.call.problem.descriptor=String concatenation as argument to 'MessageFormat.format()' call #loc
shift.out.of.range.quickfix=Replace ''{0}'' with ''{1}''
boxing.boxed.value.display.name=Boxing of already boxed value
boxing.boxed.value.problem.descriptor=Boxing of already boxed <code>#ref</code> #loc
boxing.boxed.value.quickfix=Remove unnecessary boxing
unnecessary.javadoc.link.option=Ignore inline links to super methods
constant.junit.assert.argument.display.name=Constant JUnit assert argument
constant.junit.assert.argument.problem.descriptor=Argument <code>#ref</code> is constant #loc
test.case.with.no.test.methods.option=Ignore test cases which have superclasses with test methods
package.dot.html.may.be.package.info.display.name='package.html' may be converted to 'package-info.java'
package.dot.html.may.be.package.info.exists.problem.descriptor=<code>package.html</code> is ignored because <code>package-info.java</code> exists
package.dot.html.may.be.package.info.problem.descriptor=<code>package.html</code> may be converted to <code>package-info.java</code>
package.dot.html.may.be.package.info.delete.quickfix=Delete 'package.html'
package.dot.html.may.be.package.info.convert.quickfix=Convert to 'package-info.java'
choose.super.class.to.ignore=Choose class
ignore.anonymous.inner.classes=Ignore anonymous inner classes
try.with.identical.catches.display.name=Identical 'catch' branches in 'try' statement
try.with.identical.catches.problem.descriptor=''catch'' branch identical to ''{0}'' branch #loc
if.can.be.switch.display.name='if' replaceable with 'switch'
if.can.be.switch.problem.descriptor=<code>#ref</code> statement replaceable with 'switch' statement #loc
if.can.be.switch.quickfix=Replace 'if' with 'switch'
if.can.be.switch.minimum.branch.option=Minimum number of branches:
if.can.be.switch.int.option=Suggest switch on numbers
if.can.be.switch.enum.option=Suggest switch on enums
if.can.be.switch.null.safe.option=Only suggest on null-safe expressions
unnecessarily.qualified.inner.class.access.option=Ignore references for which an import is needed
unqualified.inner.class.access.option=Ignore references to local inner classes
try.with.identical.catches.quickfix=Collapse 'catch' blocks
confusing.else.option=Report when there are no more statements after the 'if' statement
html.tag.can.be.javadoc.tag.display.name=<code>...</code> can be replaced with {@code ...}
html.tag.can.be.javadoc.tag.problem.descriptor=<code>#ref...\\&lt;/code\\&gt;</code> can be replaced with '{@code ...}' #loc
html.tag.can.be.javadoc.tag.quickfix=Replace with '{@code ...}'
try.finally.can.be.try.with.resources.display.name='try finally' replaceable with 'try' with resources
try.finally.can.be.try.with.resources.problem.descriptor=<code>#ref</code> can use automatic resource management #loc
try.finally.can.be.try.with.resources.quickfix=Replace with 'try' with resources
array.comparison.display.name=Array comparison using '==', instead of 'Arrays.equals()'
array.comparison.problem.descriptor=Array objects are compared using <code>#ref</code>, not 'Arrays.equals()' #loc
array.hash.code.display.name='hashCode()' called on array
array.hash.code.problem.descriptor=<code>#ref()</code> called on array should probably be 'Arrays.hashCode()' #loc
arrays.deep.hash.code.quickfix=Replace with 'Arrays.deepHashCode()'
arrays.hash.code.quickfix=Replace with 'Arrays.hashCode()'
method.can.be.variable.arity.method.display.name=Method can be varargs method
method.can.be.variable.arity.method.problem.descriptor=<code>#ref()</code> can be converted to varargs method #loc
method.can.be.variable.arity.method.ignore.byte.short.option=Ignore parameters with type byte[] or short[]
method.can.be.variable.arity.method.ignore.all.primitive.arrays.option=Ignore all primitive array types
method.can.be.variable.arity.method.ignore.multiple.arrays.option=Ignore methods with multiple array parameters
method.can.be.variable.arity.method.ignore.multidimensional.arrays.option=Ignore multidimensional array parameters
convert.to.variable.arity.method.quickfix=Convert to varargs method
mismatched.string.builder.query.update.display.name=Mismatched query and update of StringBuilder
mismatched.string.builder.updated.problem.descriptor=Contents of {0} <code>#ref</code> are updated, but never queried #loc
mismatched.string.builder.queried.problem.descriptor=Contents of {0} <code>#ref</code> are queried, but never updated #loc
math.random.cast.to.int.display.name='Math.random()' cast to 'int'
math.random.cast.to.int.problem.descriptor=<code>#ref</code> cast to ''{0}'' is always rounded down to ''0'' #loc
math.random.cast.to.int.quickfix=Add parentheses to perform multiplication before cast
boolean.variable.always.inverted.display.name=Boolean variable is always inverted
boolean.field.always.inverted.problem.descriptor=Boolean field <code>#ref</code> is always inverted #loc
boolean.variable.always.inverted.problem.descriptor=Boolean variable <code>#ref</code> is always inverted #loc
unnecessary.explicit.numeric.cast.display.name=Unnecessary explicit numeric cast
unnecessary.explicit.numeric.cast.problem.descriptor=''{0}'' unnecessarily cast to <code>#ref</code> #loc
unnecessary.explicit.numeric.cast.quickfix=Remove cast
null.thrown.display.name='null' thrown
null.thrown.problem.descriptor=<code>#ref</code> thrown #loc
null.thrown.quickfix=Replace with 'new NullPointerException()'
unnecessary.final.on.local.variable.or.parameter.display.name=Unnecessary 'final' on local variable or parameter
unnecessary.final.on.local.variable.problem.descriptor=Unnecessary <code>#ref</code> on variable ''{0}'' #loc
unnecessary.final.on.parameter.problem.descriptor=Unnecessary <code>#ref</code> on parameter ''{0}'' #loc
unnecessary.final.report.local.variables.option=Report local variables
unnecessary.final.report.parameters.option=Report parameters
unnecessary.final.on.parameter.only.interface.option=Only warn on abstract or interface methods
choose.exception.class=Choose Exception class
class.independent.of.module.display.name=Class independent of its module
class.independent.of.module.problem.descriptor=Class <code>#ref</code> has no dependencies or dependents in its module #loc
class.only.used.in.one.module.display.name=Class only used from one other module
class.only.used.in.one.module.problem.descriptor=Class <code>#ref</code> has only dependencies on and/or dependents in module ''{0}'' #loc
empty.directory.display.name=Empty directory
empty.directories.problem.descriptor=Empty directory <code>{0}</code>
empty.directories.only.under.source.roots.option=Only report empty directories located under a source folder
empty.directories.delete.quickfix=Delete empty directory ''{0}''
simplifiable.equals.expression.display.name=Unnecessary 'null' check before 'equals()' call
simplifiable.equals.expression.problem.descriptor=Unnecessary ''null'' check before ''{0}()'' call #loc
simplifiable.equals.expression.quickfix=Flip ''.{0}()'' and remove unnecessary ''null'' check
cast.to.concrete.class.option=Ignore casts to an abstract class type
cast.to.concrete.class.ignore.equals.option=Ignore in equals()
instanceof.interfaces.option=Ignore instanceof abstract class
instance.variable.of.concrete.class.option=Ignore instance fields whose type is an abstract class
local.variable.of.concrete.class.option=Ignore local variables whose type is an abstract class
method.return.of.concrete.class.option=Ignore methods whose return type is an abstract class
parameter.of.concrete.class.option=Ignore parameters whose type is abstract class
static.variable.of.concrete.class.option=Ignore static fields whose type is an abstract class
class.only.used.in.one.package.display.name=Class only used from one other package
class.only.used.in.one.package.problem.descriptor=Class <code>#ref</code> has only dependencies on and/or dependents in package ''{0}'' #loc
unnecessary.return.option=Ignore in then branch of 'if' statement with 'else' branch
usage.of.obsolete.assert.display.name=Usage of obsolete 'junit.framework.Assert' method
use.of.obsolete.assert.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with call to method from ''org.junit.Assert'' #loc
use.of.obsolete.assert.quickfix=Replace with 'org.junit.Assert' method call
junit5.assertions.converter.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with call to method from ''{1}'' #loc
junit5.assertions.converter.quickfix=Replace with ''{0}'' method call
junit5.assertions.converter.familyName=Replace with JUnit 5 compatible call
properties.object.as.hashtable.set.quickfix=Replace with call to 'setProperty()'
properties.object.as.hashtable.get.quickfix=Replace with call to 'getProperty()'
ignored.junit.test.display.name=JUnit test annotated with '@Ignore'/'@Disabled'
ignored.junit.test.classproblem.descriptor=Test class ''{0}'' annotated with <code>#ref</code> #loc
ignored.junit.test.method.problem.descriptor=Test method ''{0}()'' annotated with <code>#ref</code> #loc
unclear.binary.expression.display.name=Unclear expression
unclear.binary.expression.problem.descriptor=Expression could use clarifying parentheses #loc
unclear.binary.expression.quickfix=Add clarifying parentheses
new.exception.without.arguments.display.name=Exception constructor called without arguments
new.exception.without.arguments.problem.descriptor=<code>new #ref()</code> without arguments #loc
new.exception.without.arguments.ignore.option=Ignore for exceptions that have no constructors with parameters
absolute.alignment.in.user.interface.display.name=Absolute alignment used in AWT/Swing code
absolute.alignment.in.user.interface.problem.descriptor=Absolute alignment constant <code>{0}.#ref</code> used #loc
absolute.alignment.in.user.interface.quickfix=Replace with ''{0}.{1}''
throws.runtime.exception.display.name=Unchecked exception declared in 'throws' clause
throws.runtime.exception.problem.descriptor=Unchecked exception <code>#ref</code> declared in 'throws' clause #loc
throws.runtime.exception.quickfix=Remove ''{0}'' from ''throws'' clause
throws.runtime.exception.move.quickfix=Move ''{0}'' to Javadoc ''@throws'' tag
empty.class.ignore.parameterization.option=Ignore class if it is a parameterization of a super type
ambiguous.field.access.display.name=Access of inherited field looks like access of element in surrounding code
ambiguous.field.access.hides.local.variable.problem.descriptor=Access of field <code>#ref</code> from superclass ''{0}'' looks like access of local variable #loc
ambiguous.field.access.hides.parameter.problem.descriptor=Access of field <code>#ref</code> from superclass ''{0}'' looks like access of parameter #loc
ambiguous.field.access.hides.field.problem.descriptor=Access of field <code>#ref</code> from superclass ''{0}'' looks like access of field from surrounding class #loc
ambiguous.field.access.quickfix=Add 'super' qualifier to field access
string.builder.replaceable.by.string.quickfix=Replace 'StringBuilder' with 'String'
string.buffer.replaceable.by.string.quickfix=Replace 'StringBuffer' with 'String'
add.0.to.ignore.if.annotated.by.list.quickfix=Add ''{0}'' to ''Ignore if annotated by'' list
non.final.field.in.enum.display.name=Non-'final' field in enum
non.final.field.in.enum.problem.descriptor=non-''final'' field <code>#ref</code> in enum ''{0}'' #loc
externalizable.without.public.no.arg.constructor.display.name=Externalizable class without 'public' no-arg constructor
externalizable.without.public.no.arg.constructor.problem.descriptor=Externalizable class <code>#ref</code> has no 'public' no-arg constructor #loc
make.constructor.public=Make constructor 'public'
string.concatenation.missing.whitespace.display.name=String literal concatenation missing whitespace
string.concatenation.missing.whitespace.problem.descriptor=String literal concatenation missing whitespace #loc
string.concatenation.missing.whitespace.option=Ignore when one or both sides are not literals
negated.equality.expression.display.name=Negated equality expression
negated.equality.expression.problem.descriptor=Negating ''{0}'' #loc
negated.equality.expression.quickfix=Remove negation
negated.conditional.expression.display.name=Negated conditional expression
negated.conditional.expression.problem.descriptor=Negating conditional expression #loc
negated.conditional.expression.quickfix=Remove negation
suspicious.array.cast.display.name=Suspicious array cast
suspicious.array.cast.problem.descriptor=Suspicious cast to <code>#ref</code> #loc
public.constructor.display.name='public' constructor
public.default.constructor.problem.descriptor=Class <code>#ref</code> has 'public' default constructor
public.constructor.problem.descriptor=Public constructor <code>#ref()</code> #loc
public.constructor.quickfix=Replace constructor with factory method
junit3.style.test.method.in.junit4.class.display.name=Old style JUnit test method in JUnit 4 class
junit3.style.test.method.in.junit4.class.problem.descriptor=Old style JUnit test method <code>#ref()</code> in JUnit 4 class #loc
none=none
private=private
package.local.private=package-private \\& private
protected.package.local.private=protected, package-private \\& private
non.final.utility.class.display.name=Utility class is not 'final'
non.final.utility.class.problem.descriptor=Utility class <code>#ref</code> is not 'final' #loc
0.will.no.longer.be.overridable.by.1={0} will no longer be overridable by {1}
0.will.have.incompatible.access.privileges.with.super.1={0} will have incompatible access privileges with super {1}
0.will.no.longer.be.visible.from.overriding.1={0} will no longer be visible from overriding {1}
make.private.quickfix=Make 'private'
arrays.as.list.with.zero.or.one.argument.display.name=Call to 'Arrays.asList()' with too few arguments
arrays.as.list.with.one.argument.problem.descriptor=Call to <code>#ref</code> with only one argument #loc
arrays.as.list.with.zero.arguments.problem.descriptor=Call to <code>#ref</code> with zero arguments #loc
arrays.as.list.with.one.argument.quickfix=Replace with call to 'Collections.singletonList()'
arrays.as.list.with.zero.arguments.quickfix=Replace with call to 'Collections.emptyList()'
ignore.classes.extending.throwable.option=Ignore classes extending 'Throwable'
string.concatenation.argument.to.log.call.display.name=Non-constant string concatenation as argument to logging call
string.concatenation.argument.to.log.call.problem.descriptor=Non-constant string concatenation as argument to <code>#ref()</code> logging call #loc
string.concatenation.argument.to.log.call.quickfix=Replace concatenation with parameterized log message
placeholder.count.matches.argument.count.display.name=Number of placeholders does not match number of arguments in logging call
placeholder.count.matches.argument.count.more.problem.descriptor=More arguments provided ({0}) than placeholders specified ({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=Fewer arguments provided ({0}) than placeholders specified ({1}) #loc
assignment.to.superclass.field.display.name=Constructor assigns value to field defined in superclass
assignment.to.superclass.field.problem.descriptor=Assignment to field ''{0}'' defined in superclass ''{1}'' #loc
junit.rule.display.name=Malformed @Rule/@ClassRule field
junit.rule.problem.descriptor=Fields annotated with ''@{0}'' should be {1}
junit.rule.type.problem.descriptor=Field type should be subtype of 'org.junit.rules.TestRule'
junit.datapoint.display.name=Malformed @DataPoint field
junit.datapoint.problem.descriptor={1}s annotated with @DataPoint should be {0}
inner.class.referenced.via.subclass.display.name=Inner class referenced via subclass
inner.class.referenced.via.subclass.problem.descriptor=Inner class <code>#ref</code> declared in class ''{0}'' but referenced via subclass ''{1}'' #loc
inner.class.referenced.via.subclass.quickfix=Rationalize inner class access
boolean.parameter.display.name='public' method with 'boolean' parameter
boolean.parameter.problem.descriptor='public' method <code>#ref()</code> with 'boolean' parameter #loc
boolean.parameters.problem.descriptor='public' method <code>#ref()</code> with 'boolean' parameters #loc
boolean.parameter.constructor.problem.descriptor='public' constructor <code>#ref()</code> with 'boolean' parameter #loc
boolean.parameters.constructor.problem.descriptor='public' constructor <code>#ref()</code> with 'boolean' parameters #loc
boolean.parameter.only.report.multiple.option=Only report methods with multiple boolean parameters
unnecessary.unicode.escape.display.name=Unnecessary unicode escape sequence
unnecessary.unicode.escape.problem.descriptor=Unicode escape sequence <code>#ref</code> can be replaced with ''{0}'' #loc
missing.package.info.display.name=Missing 'package-info.java'
missing.package.info.problem.descriptor=Package ''{0}'' is missing a <code>package-info.java</code> file
missing.package.html.problem.descriptor=Package ''{0}'' is missing a <code>package.html</code> file
package.info.java.without.package.display.name='package-info.java' without 'package' statement
package.info.without.package.problem.descriptor='package-info.java' does not have a 'package' statement
package.info.without.package.quickfix=Add ''package {0};''
package.info.without.package.family.quickfix=Add package statement
auto.closeable.resource.display.name=AutoCloseable used without 'try'-with-resources
auto.closeable.resource.problem.descriptor=''{0}'' used without ''try''-with-resources statement #loc
auto.closeable.resource.quickfix=Ignore 'AutoCloseable' returned by this method
auto.closeable.resource.returned.option=Ignore AutoCloseable instances returned from all method calls
problematic.varargs.method.display.name=Non-varargs method overrides varargs method
problematic.varargs.method.override.problem.descriptor=Non-varargs method <code>#ref()</code> overrides varargs method #loc
negatively.named.boolean.variable.problem.descriptor=Boolean variable <code>#ref</code> is negatively named #loc
negatively.named.boolean.variable.display.name=Negatively named boolean variable
invert.quickfix.family.name=Invert boolean
invert.method.quickfix=Invert method
invert.quickfix=Invert ''{0}''
throwable.printed.to.system.out.display.name='Throwable' printed to 'System.out'
throwable.printed.to.system.out.problem.descriptor='Throwable' argument <code>#ref</code> to ''System.{0}.{1}()'' call
suppress.for.tests.scope.quickfix=Suppress for 'Tests' scope
implicit.default.charset.usage.display.name=Implicit usage of platform's default charset
implicit.default.charset.usage.problem.descriptor=Call to <code>#ref()</code> uses the platform's default charset
implicit.default.charset.usage.constructor.problem.descriptor=<code>new #ref()</code> call uses the platform's default charset
interface.may.be.annotated.functional.display.name=Interface may be annotated @FunctionalInterface
interface.may.be.annotated.functional.problem.descriptor=Interface <code>#ref</code> may be annotated with @FunctionalInterface
only.report.public.methods.option=Only report 'public' methods
lambda.parameter.hides.member.variable.display.name=Lambda parameter hides field
static.initializer.references.subclass.display.name=Static initializer references subclass
lambda.parameter.hides.member.variable.problem.descriptor=Lambda parameter <code>#ref</code> hides field in class ''{0}'' #loc
lambda.parameter.hides.member.variable.ignore.invisible.option=Ignore fields not actually visible from the lambda
shared.thread.local.random.display.name='ThreadLocalRandom' instance might be shared
shared.thread.local.random.problem.descriptor='ThreadLocalRandom' instance might be shared between threads
native.method.naming.convention.display.name='native' method naming convention
native.method.naming.convention.element.description='native' method
use.of.obsolete.date.time.api.display.name=Use of obsolete date-time API
use.of.obsolete.date.time.api.problem.descriptor=Obsolete date-time type <code>#ref</code> used #loc
warn.on.label=Warn on:
all.levels.option=all log levels
warn.level.and.lower.option=warn level and lower
info.level.and.lower.option=info level and lower
debug.level.and.lower.option=debug level and lower
trace.level.option=trace level
ignored.autocloseable.types.column.label=Ignored AutoCloseable resource types
choose.autocloseable.type.to.ignore.title=Choose AutoCloseable resource type to ignore
big.decimal.method.without.rounding.called.display.name=Call to 'BigDecimal' method without a rounding mode argument
big.decimal.method.without.rounding.called.problem.descriptor='BigDecimal.#ref()' called without a rounding mode argument
bigdecimal.legacy.method.display.name='BigDecimal' legacy method called
bigdecimal.legacy.method.problem.descriptor=Call to 'BigDecimal.#ref()' can use 'RoundingMode' enum constant
bigdecimal.legacy.method.quickfix=Use 'RoundingMode' enum constant
serializable.stores.non.serializable.display.name=Serializable object implicitly stores non-Serializable object
serializable.lambda.stores.non.serializable.problem.descriptor=Serializable lambda implicitly stores non-Serializable object of type ''{0}''
serializable.local.class.stores.non.serializable.problem.descriptor=Serializable local class ''{1}'' implicitly stores non-Serializable object of type ''{0}''
serializable.anonymous.class.stores.non.serializable.problem.descriptor=Serializable anonymous class implicitly stores non-Serializable object of type ''{0}''
assignment.to.lambda.parameter.display.name=Assignment to lambda parameter
assignment.to.lambda.parameter.problem.descriptor=Assignment to lambda parameter <code>#ref</code> #loc
class.with.only.private.constructors.display.name=Class with only 'private' constructors should be declared 'final'
class.with.only.private.constructors.problem.descriptor=Class <code>#ref</code> with only 'private' constructors should be declared 'final'
property.value.set.to.itself.display.name=Property value set to itself
equals.with.itself.display.name='equals()' called on itself
equals.with.itself.problem.descriptor=<code>#ref()</code> called on itself
junit4.method.naming.convention.display.name=JUnit 4+ test method naming convention
junit4.method.naming.convention.element.description=JUnit 4+ test method
junit3.method.naming.convention.display.name=JUnit 3 test method naming convention
junit3.method.naming.convention.element.description=JUnit 3 test method
introduce.holder.class.quickfix=Introduce holder class
double.brace.initialization.display.name=Double brace initialization
double.brace.initialization.quickfix=Replace with regular initialization
return.of.inner.class.display.name=Return of instance of anonymous, local or inner class
return.of.anonymous.class.problem.descriptor=Return of instance of anonymous class #loc
return.of.local.class.problem.descriptor=Return of instance of local class <code>{0}</code> #loc
return.of.inner.class.problem.descriptor=Return of instance of non-static inner class <code>{0}</code> #loc
return.of.inner.class.ignore.non.public.option=Ignore returns from non-public methods
parameter.type.prevents.overriding.display.name=Parameter type prevents overriding
parameter.type.prevents.overriding.problem.descriptor=Parameter type <code>#ref</code> is located in ''{0}'' while super method parameter type is located in ''{1}'' preventing overriding #loc
parameter.type.prevents.overriding.quickfix=Change type of parameter to ''{0}''
parameter.type.prevents.overriding.family.quickfix=Change type of parameter
suspicious.getter.setter.display.name=Suspicious getter/setter
suspicious.setter.problem.descriptor=Setter <code>#ref()</code> assigns field ''{0}'' #loc
suspicious.getter.problem.descriptor=Getter <code>#ref()</code> returns field ''{0}'' #loc
unnecessary.break.display.name=Unnecessary 'break' statement
unnecessary.break.problem.descriptor=<code>#ref</code> statement is unnecessary #loc
utility.class.can.be.enum.display.name=Utility class can be 'enum'
utility.class.code.can.be.enum.problem.descriptor=Utility class <code>\#ref</code> can be 'enum' #loc
utility.class.code.can.be.enum.quickfix=Convert to 'enum'
non.public.clone.display.name='clone()' method not 'public'
non.public.clone.problem.descriptor=<code>#ref()</code> method not 'public' #loc
only.warn.on.public.clone.methods=Only warn on 'public' clone methods
only.warn.on.protected.clone.methods=Only warn on 'protected' clone methods
clone.returns.class.type.display.name='clone()' should have return type equal to the class it contains
clone.returns.class.type.problem.descriptor=''clone()'' should have return type ''{0}'' #loc
clone.returns.class.type.quickfix=Change return type to ''{0}''
clone.returns.class.type.family.quickfix=Change return type to class type
use.of.clone.display.name=Use of 'clone()' or 'Cloneable'
use.of.clone.call.problem.descriptor=Call to <code>#ref()</code>
use.of.clone.call.method.problem.descriptor=Implementation of <code>#ref()</code>
use.of.clone.reference.problem.descriptor=Use of <code>#ref</code>
dangling.javadoc.display.name=Dangling Javadoc comment
dangling.javadoc.problem.descriptor=Dangling Javadoc comment #loc
dangling.javadoc.convert.quickfix=Replace with block comment
dangling.javadoc.delete.quickfix=Remove dangling comment
equals.replaceable.by.objects.call.display.name='equals()' expression replaceable by 'Objects.equals()' expression
equals.replaceable.by.objects.call.problem.descriptor=<code>#ref</code> replaceable by 'Objects.equals()' expression #loc
equals.replaceable.by.objects.call.quickfix=Replace with 'Objects.equals()' expression
equals.replaceable.by.objects.check.not.null.option=Report only null safe 'equals' calls
array.objects.equals.display.name='Objects.equals()' called on arrays
array.objects.equals.problem.descriptor=<code>Objects.#ref()</code> on arrays should probably be 'Arrays.equals()' #loc
array.objects.deep.equals.problem.descriptor=<code>Objects.#ref()</code> on arrays should probably be 'Arrays.deepEquals()' #loc
extends.throwable.display.name=Class directly extends 'java.lang.Throwable'
anonymous.extends.throwable.problem.descriptor=Anonymous class directly extends 'java.lang.Throwable' #loc
extends.throwable.problem.descriptor=class <code>#ref</code> directly extends 'java.lang.Throwable' #loc
lambda.parameter.naming.convention.display.name=Lambda parameter naming convention
lambda.parameter.naming.convention.element.description=Lambda parameter
assert.message.not.string.display.name='assert' message is not a String
assert.message.of.type.boolean.problem.descriptor=''assert'' message of type ''{0}'' #loc
assert.message.not.string.only.warn.boolean.option=Only warn when 'assert' message is 'boolean' or 'java.lang.Boolean'
suspicious.literal.underscore.display.name=Suspicious underscore in number literal
suspicious.literal.underscore.problem.descriptor=Group in number literal with underscores does not have length 3 #loc
unary.plus.quickfix=Remove unary '+'
super.tear.down.in.finally.display.name='super.tearDown()' not called from 'finally' block
super.tear.down.in.finally.problem.descriptor=<code>#ref()</code> not called from 'finally' block #loc
confusing.floating.point.literal.option=Ignore floating point literals in scientific notation
class.may.be.interface.java8.option=Report classes containing non-abstract methods when using Java 8
simplifiable.boolean.expression.display.name=Simplifiable boolean expression
unnecessary.initcause.display.name=Unnecessary call to 'Throwable.initCause()'
unnecessary.initcause.problem.descriptor=Unnecessary <code>Throwable.#ref()</code> call
unnecessary.initcause.quickfix=Remove 'Throwable.initCause()' call
consider.static.final.fields.constant.option=Consider 'static final' fields constant
atomic.field.updater.not.static.final.display.name=AtomicFieldUpdater field not declared 'static final'
atomic.field.updater.not.static.final.problem.descriptor={0} field <code>#ref</code> is not declared ''static final'' #loc
atomic.field.updater.issues.display.name=AtomicFieldUpdater issues
field.not.found.in.class.problem.descriptor=No field named ''{0}'' found in class ''{1}''
field.incorrect.type.problem.descriptor=Field ''{0}'' does not have type ''{1}''
field.missing.volatile.modifier.problem.descriptor=Field ''{0}'' does not have ''volatile'' modifier
field.has.static.modifier.problem.descriptor=Field ''{0}'' has ''static'' modifier
private.field.not.accessible.problem.descriptor=''private'' field ''{0}'' is not accessible from here
package.local.field.not.accessible=package-private field ''{0}'' is not accessible from here
protected.field.not.accessible.problem.descriptor=''protected'' field ''{0}'' is not accessible from here
interface.clashes.with.object.class.display.name=Interface method clashes with method in 'java.lang.Object'
interface.clashes.with.object.class.problem.descriptor=<code>#ref()</code> clashes with method in 'java.lang.Object'
optional.used.as.field.or.parameter.type.display.name='Optional' used as field or parameter type
optional.used.as.field.type.problem.descriptor=<code>#ref</code> used as type for field ''{0}''
optional.used.as.parameter.type.problem.descriptor=<code>#ref</code> used as type for parameter ''{0}''
lambda.unfriendly.method.overload.display.name=Lambda unfriendly method overload
lambda.unfriendly.method.overload.problem.descriptor=Lambda unfriendly overload of method <code>#ref()</code>
lambda.unfriendly.constructor.overload.problem.descriptor=Lambda unfriendly overload of constructor <code>#ref()</code>
optional.contains.collection.display.name='Optional' contains array or collection
optional.contains.collection.problem.descriptor='Optional' contains collection <code>#ref</code>
optional.contains.array.problem.descriptor='Optional' contains array <code>#ref</code>
synchronization.on.get.class.display.name=Synchronization on 'getClass()'
synchronization.on.get.class.problem.descriptor=Synchronization on <code>#ref()</code> #loc
object.instantiation.inside.equals.or.hashcode.display.name=Object instantiation inside 'equals()' or 'hashCode()'
object.instantiation.inside.equals.or.hashcode.problem.descriptor=Object instantiation inside ''{0}()'' #loc
object.instantiation.inside.equals.or.hashcode.problem.descriptor2=Object instantiation inside ''{0}()'' ({1})#loc
lambda.body.can.be.code.block.name=Lambda body can be code block
lambda.body.can.be.code.block.quickfix=Expand lambda body to {...}
lambda.parameter.type.can.be.specified.name=Lambda parameter type can be specified
lambda.parameter.type.can.be.specified.descriptor=Lambda can be expanded to {0} -> '{'...'}'
lambda.parameter.type.can.be.specified.quickfix=Expand lambda to {0} -> '{'...'}'
lambda.parameter.type.can.be.specified.family.quickfix=Specify lambda parameter type
diamond.can.be.replaced.with.explicit.type.arguments.name=Diamond can be replaced with explicit type arguments
diamond.can.be.replaced.with.explicit.type.arguments.quickfix=Replace '<>' with explicit type arguments
lambda.can.be.replaced.with.anonymous.name=Lambda can be replaced with anonymous class
lambda.can.be.replaced.with.anonymous.quickfix=Replace lambda with anonymous class
method.ref.can.be.replaced.with.lambda.name=Method reference can be replaced with lambda
method.ref.can.be.replaced.with.lambda.quickfix=Replace method reference with lambda
try.statement.with.multiple.resources.name=Try statement with multiple resources can be split
try.statement.with.multiple.resources.quickfix=Split 'try' statement with multiple resources
multi.catch.can.be.split.name=Multi-catch can be split into separate catch blocks
multi.catch.can.be.split.quickfix=Split multi-catch into separate 'catch' blocks
assertion.can.be.if.name=Assertion can be replaced with if statement
assert.can.be.if.quickfix=Replace 'assert' with 'if' statement
if.can.be.assertion.name=Statement can be replaced with 'assert' or 'Objects.requireNonNull'
if.can.be.assertion.replace.with.assertion.quickfix=Replace statement with 'assert' statement
if.can.be.assertion.replace.with.objects.requirenonnull.quickfix=Replace statement with 'Objects.requireNonNull()'
single.statement.in.block.name=Code block contains single statement
single.statement.in.block.descriptor=''{0}'' contains single statement
single.statement.in.block.quickfix=Remove braces from ''{0}'' statement
single.statement.in.block.family.quickfix=Remove braces from statement
single.element.annotation.name=Single-element annotation
single.element.annotation.quickfix=Add 'value='
single.element.annotation.family.quickfix=Expand annotation to normal form
array.creation.without.new.keyword.name=Array creation without 'new' expression
array.creation.without.new.keyword.quickfix=Add ''new {0}''
array.creation.without.new.keyword.family.quickfix=Add 'new' expression
malformed.set.up.tear.down.display.name=Malformed 'setUp()' or 'tearDown()' method
malformed.set.up.tear.down.problem.descriptor='#ref()' has incorrect signature #loc
method.missing.return.statement.display.name=Method contains logic but is missing a 'return' statement
method.missing.return.statement.problem.descriptor=Method <code>#ref</code> contains logic but is missing a 'return' statement
overly.long.lambda.display.name=Overly long lambda expression
overly.long.lambda.problem.descriptor=Lambda expression is too long (# Non-comment source statements = {0}) #loc
wait.notify.not.in.synchronized.context.display.name='wait()' or 'notify()' while not synchronized
wait.notify.while.not.synchronized.on.problem.descriptor=Call to <code>#ref</code> while not synchronized on ''{0}'' #loc
junit5.assertions.converter.display.name=Obsolete assertions in JUnit 5 tests
junit5.converter.display.name=JUnit 4 test can be JUnit 5
junit5.converter.fix.name=Migrate to JUnit 5
call.to.suspicious.string.method.display.name=Call to suspicious String method
call.to.suspicious.string.method.problem.descriptor=<code>String.#ref()</code> called in internationalized context #loc

string.concatenation.replace.fix=Replace with StringBuilder
string.concatenation.replace.fix.name=Convert variable ''{0}'' from String to {1}
string.concatenation.introduce.fix=Introduce StringBuilder
string.concatenation.introduce.fix.name=Introduce new {1} to update variable ''{0}''

ignored.class.names=Ignore classes (including subclasses)
junit5.platform.runner.display.name=@RunWith(JUnitPlatform.class) without test methods
junit5.valid.parameterized.configuration.display.name=JUnit 5 malformed parameterized test
junit5.malformed.repeated.test.display.name=JUnit 5 malformed repeated test
meta.annotation.without.runtime.retention=Non-runtime annotation to be used by reflection
string.equals.char.sequence.display.name='String.equals()' called with 'CharSequence' argument
string.equals.char.sequence.problem.descriptor=<code>String.#ref()</code> called with ''{0}'' argument #loc
string.equals.char.sequence.quickfix=Replace with call to 'contentEquals()'
equals.to.equality.quickfix=Replace 'equals()' with '=='
not.equals.to.equality.quickfix=Replace '!equals()' with '!='
object.equals.can.be.equality.display.name='equals()' call can be replaced with '=='
object.equals.can.be.equality.problem.descriptor=<code>#ref()</code> can be replaced with '=='
not.object.equals.can.be.equality.problem.descriptor=<code>!#ref()</code> can be replaced with '!='
