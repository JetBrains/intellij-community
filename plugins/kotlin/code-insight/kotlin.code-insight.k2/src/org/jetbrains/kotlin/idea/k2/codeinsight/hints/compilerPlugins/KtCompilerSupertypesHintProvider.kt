// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package org.jetbrains.kotlin.idea.k2.codeinsight.hints.compilerPlugins

import com.intellij.codeInsight.hints.declarative.HintFormat
import com.intellij.codeInsight.hints.declarative.InlayTreeSink
import com.intellij.codeInsight.hints.declarative.InlineInlayPosition
import com.intellij.psi.PsiElement
import com.intellij.psi.util.endOffset
import org.jetbrains.kotlin.analysis.api.KaSession
import org.jetbrains.kotlin.analysis.api.analyze
import org.jetbrains.kotlin.analysis.api.components.isAnyType
import org.jetbrains.kotlin.analysis.api.components.isClassType
import org.jetbrains.kotlin.analysis.api.symbols.KaClassKind
import org.jetbrains.kotlin.analysis.api.symbols.KaClassSymbol
import org.jetbrains.kotlin.analysis.api.types.KaClassType
import org.jetbrains.kotlin.analysis.api.types.KaType
import org.jetbrains.kotlin.idea.base.resources.KotlinBundle
import org.jetbrains.kotlin.idea.k2.codeinsight.hints.printKtType
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.psi.KtClassOrObject

internal class KtCompilerSupertypesHintProvider : AbstractKtCompilerPluginDeclarativeHintProvider() {
    override fun collectFromElement(element: PsiElement, sink: InlayTreeSink) {
        if (element is KtClassOrObject) {
            collectGeneratedSuperTypes(element, sink)
        }
    }

    private fun collectGeneratedSuperTypes(declaration: KtClassOrObject, sink: InlayTreeSink) {
        if (!declaration.declarationCanBeModifiedByCompilerPlugins()) return

        analyze(declaration) {
            val classSymbol = declaration.classSymbol ?: return
            val byPsiSuperTypes = declaration.superTypeListEntries.mapNotNullTo(mutableSetOf()) { it.typeReference?.type }
            // non-explicitly defined super types are generated by compiler plugins
            // except for the ones generated by Kotlin compiler by default, see `isImplicitSuperType`
            val compilerGeneratedSuperTypes = classSymbol.getNonImplicitSuperTypes() - byPsiSuperTypes
            collectGeneratedSuperTypes(compilerGeneratedSuperTypes, declaration, sink)
        }
    }

    context(_: KaSession)
    private fun collectGeneratedSuperTypes(
        compilerGeneratedSuperTypes: List<KaType>,
        owner: KtClassOrObject,
        sink: InlayTreeSink,
    ) {
        if (compilerGeneratedSuperTypes.isEmpty()) return

        var printColon = owner.superTypeListEntries.isEmpty()
        sink.addPresentation(
            InlineInlayPosition(owner.placeGeneratedSuperTypesAfterOffset(), relatedToPrevious = true),
            tooltip = KotlinBundle.message("hints.tooltip.compiler.plugins.supertypes"),
            hintFormat = HintFormat.Companion.default
        ) {
            for (superType in compilerGeneratedSuperTypes) {
                if (printColon) {
                    text(" : ")
                    printColon = false
                } else {
                    text(", ")
                }
                printKtType(superType)
            }
        }
    }

    private fun KtClassOrObject.placeGeneratedSuperTypesAfterOffset(): Int {
        // all possible elements in class declaration from right to left
        getSuperTypeList()?.let { return it.endOffset }
        primaryConstructor?.let { return it.endOffset }
        typeParameterList?.let { return it.endOffset }
        nameIdentifier?.let { return it.endOffset }
        getDeclarationKeyword()?.let { return it.endOffset }
        return endOffset
    }

    context(_: KaSession)
    private fun KaClassSymbol.getNonImplicitSuperTypes(): List<KaType> {
        return superTypes.filterNot { it.isImplicitSuperType(this) }
    }

    /**
     * Some class kinds may have implicit super types generated for them. We should not consider these as generated by compiler plugins.
     */
    context(_: KaSession)
    private fun KaType.isImplicitSuperType(owner: KaClassSymbol): Boolean {
        if (this !is KaClassType) return false
        return when (owner.classKind) {
            KaClassKind.ENUM_CLASS -> isClassType(StandardClassIds.Enum)
            KaClassKind.ANNOTATION_CLASS -> isClassType(StandardClassIds.Annotation)
            else -> isAnyType
        }
    }
}