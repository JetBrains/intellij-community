// Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

package org.jetbrains.kotlin.idea.fir.fe10

import com.intellij.openapi.project.Project
import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.analysis.providers.createProjectWideOutOfBlockModificationTracker
import org.jetbrains.kotlin.builtins.DefaultBuiltIns
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.idea.caches.project.IdeaModuleInfo
import org.jetbrains.kotlin.idea.fir.fe10.*
import org.jetbrains.kotlin.analysis.api.*
import org.jetbrains.kotlin.analysis.api.fir.utils.EntityWasGarbageCollectedException
import org.jetbrains.kotlin.analysis.api.fir.utils.KtAnalysisSessionFe10BindingHolder
import org.jetbrains.kotlin.analysis.api.symbols.*
import org.jetbrains.kotlin.analysis.api.tokens.HackToForceAllowRunningAnalyzeOnEDT
import org.jetbrains.kotlin.analysis.api.tokens.ValidityToken
import org.jetbrains.kotlin.analysis.api.tokens.ValidityTokenFactory
import org.jetbrains.kotlin.analysis.api.tokens.assertIsValidAndAccessible
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.getResolveState
import org.jetbrains.kotlin.analysis.project.structure.KtModule
import org.jetbrains.kotlin.analysis.project.structure.getKtModule
import org.jetbrains.kotlin.idea.fir.analysis.project.structure.FE10ApiUsage
import org.jetbrains.kotlin.idea.fir.analysis.project.structure.moduleInfo
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.psi.KtElement
import java.lang.ref.WeakReference
import kotlin.reflect.KClass

interface FE10BindingContext {
    val builtIns: KotlinBuiltIns
    val ktAnalysisSessionFacade: KtAnalysisSessionFe10BindingHolder
    val moduleDescriptor: ModuleDescriptor

    /**
     * Legend:
     *  - where was decided, that KtSymbolBased descriptor is not support method, noImplementation() method is called.
     *  - where the implementation planned, but not yet here: implementationPlanned()
     *  - if there is no simple implementation and it isn't clear if it really needed -- implementationPostponed()
     *  - if there were no investigation -- autogenerated TODO("not implemented") called
     *  - if we could implement it right now, but not entirely correct -- wrap it into incorrect implementation
     */
    fun noImplementation(additionalInfo: String = ""): Nothing
    fun implementationPostponed(additionalInfo: String = ""): Nothing
    fun implementationPlanned(additionalInfo: String = ""): Nothing

    fun <R> incorrectImplementation(block: () -> R) = block()
}

fun KtSymbol.toDeclarationDescriptor(context: FE10BindingContext): DeclarationDescriptor =
    when (this) {
        is KtNamedClassOrObjectSymbol -> KtSymbolBasedClassDescriptor(this, context)
        is KtFunctionLikeSymbol -> toDeclarationDescriptor(context)
        is KtValueParameterSymbol -> {
            val containingSymbol = context.withAnalysisSession { this@toDeclarationDescriptor.getContainingSymbol() }
            check(containingSymbol is KtFunctionLikeSymbol) {
                "Unexpected containing symbol = $containingSymbol"
            }
            KtSymbolBasedValueParameterDescriptor(this, context, containingSymbol.toDeclarationDescriptor(context))
        }
        else -> context.implementationPlanned()
    }

fun KtFunctionLikeSymbol.toDeclarationDescriptor(context: FE10BindingContext): KtSymbolBasedFunctionLikeDescriptor =
    when (this) {
        is KtFunctionSymbol -> KtSymbolBasedFunctionDescriptor(this, context)
        is KtAnonymousFunctionSymbol -> KtSymbolBasedAnonymousFunctionDescriptor(this, context)
        is KtConstructorSymbol -> {
            val ktConstructorSymbol = this
            val ktClassOrObject = context.withAnalysisSession { ktConstructorSymbol.getContainingSymbol() as KtNamedClassOrObjectSymbol }
            KtSymbolBasedConstructorDescriptor(ktConstructorSymbol, KtSymbolBasedClassDescriptor(ktClassOrObject, context))
        }
        else -> error("Unexpected kind of KtFunctionLikeSymbol: ${this.javaClass}")
    }

inline fun <R> FE10BindingContext.withAnalysisSession(f: KtAnalysisSession.() -> R): R = f(ktAnalysisSessionFacade.analysisSession)

class FE10BindingContextImpl(
    val project: Project,
    val ktElement: KtElement
) : FE10BindingContext {
    private val token: ValidityToken = ValidityTokenForKtSymbolBasedWrappers(project)

    private val module: KtModule = ktElement.getKtModule(project)

    @OptIn(InvalidWayOfUsingAnalysisSession::class)
    override val ktAnalysisSessionFacade = KtAnalysisSessionFe10BindingHolder.create(module.getResolveState(project), token, ktElement)

    override val moduleDescriptor: ModuleDescriptor = KtSymbolBasedModuleDescriptorImpl(this, module)

    override val builtIns: KotlinBuiltIns
        get() = incorrectImplementation { DefaultBuiltIns.Instance }

    override fun noImplementation(additionalInfo: String): Nothing =
        error("This method should not be called for wrappers. $additionalInfo")

    override fun implementationPostponed(additionalInfo: String): Nothing =
        TODO("InvestigateLater and implement if needed. $additionalInfo")

    override fun implementationPlanned(additionalInfo: String): Nothing =
        TODO("SE_to_implement. $additionalInfo")
}

private class ValidityTokenForKtSymbolBasedWrappers(val project: Project) : ValidityToken() {
    private val modificationTracker = project.createProjectWideOutOfBlockModificationTracker()
    private val onCreatedTimeStamp = modificationTracker.modificationCount

    override fun isValid(): Boolean {
        return true
    }

    override fun getInvalidationReason(): String {
        if (onCreatedTimeStamp != modificationTracker.modificationCount) return "PSI has changed since creation"
        error("Getting invalidation reason for valid validity token")
    }

    override fun isAccessible(): Boolean = true

    @OptIn(HackToForceAllowRunningAnalyzeOnEDT::class)
    override fun getInaccessibilityReason(): String = error("Getting inaccessibility reason for validity token when it is accessible")

    override val factory: ValidityTokenFactory = ValidityTokenForKtSymbolBasedWrappersFactory
}

private object ValidityTokenForKtSymbolBasedWrappersFactory : ValidityTokenFactory() {
    override val identifier: KClass<out ValidityToken> = ValidityTokenForKtSymbolBasedWrappers::class

    override fun create(project: Project): ValidityToken =
        ValidityTokenForKtSymbolBasedWrappers(project)
}

// This class supposed to be used for non-declaration resolved fir elements, because of that we don't case about FIR phases.
// TODO: review FIR access -- by common IDEA FIR design access FIR should be under read lock
internal class FirWeakReference<out T : FirElement>(firElement: T, private val token: ValidityToken) {
    private val firWeakRef = WeakReference(firElement)

    inline fun <R> withFir(action: (T) -> R): R {
        return action(getFir())
    }

    fun getFir(): T {
        token.assertIsValidAndAccessible()
        return firWeakRef.get() ?: throw EntityWasGarbageCollectedException("FirElement")
    }
}

private class KtSymbolBasedModuleDescriptorImpl(
    val context: FE10BindingContext,
    val module: KtModule,
) : ModuleDescriptor {
    override val builtIns: KotlinBuiltIns
        get() = context.builtIns

    override val stableName: Name?
        get() = context.noImplementation()
    override val platform: TargetPlatform?
        get() = module.platform

    override fun shouldSeeInternalsOf(targetModule: ModuleDescriptor): Boolean = context.noImplementation()
    override fun getPackage(fqName: FqName): PackageViewDescriptor = context.noImplementation()
    override fun getSubPackagesOf(fqName: FqName, nameFilter: (Name) -> Boolean): Collection<FqName> = context.noImplementation()

    override val allDependencyModules: List<ModuleDescriptor>
        get() = context.implementationPostponed()
    override val expectedByModules: List<ModuleDescriptor>
        get() = context.implementationPostponed()
    override val allExpectedByModules: Set<ModuleDescriptor>
        get() = context.implementationPostponed()

    override fun <T> getCapability(capability: ModuleCapability<T>): T? = null

    override val isValid: Boolean
        get() = context.ktAnalysisSessionFacade.analysisSession.token.isValid()

    override fun assertValid() {
        assert(context.ktAnalysisSessionFacade.analysisSession.token.isValid())
    }

    @OptIn(FE10ApiUsage::class)
    override fun getName(): Name = module.moduleInfo.name

    override fun getOriginal(): DeclarationDescriptor = this

    override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?) = context.noImplementation()

    override val annotations: Annotations
        get() = context.incorrectImplementation { Annotations.EMPTY }

}