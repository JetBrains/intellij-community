// COMPILER_ARGUMENTS: -Xplugin=$TEST_DIR$/dataframe_fake_plugin.jar
// FILE: main.kt
// CHECK_SYMBOL_NAMES
// ALLOW_ERRORS
// HIGHLIGHTER_ATTRIBUTES_KEY
package test

<!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_KEYWORD'")!>import<!> org.jetbrains.kotlinx.dataframe.annotations.<!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_ANNOTATION'")!>DataSchema<!>
<!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_KEYWORD'")!>import<!> org.jetbrains.kotlinx.dataframe.api.cast
<!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_KEYWORD'")!>import<!> org.jetbrains.kotlinx.dataframe.api.dataFrameOf

fun <!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_FUNCTION_DECLARATION'")!>testCast<!>() {
    val <!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_LOCAL_VARIABLE'")!>df<!> = <!HIGHLIGHTING("descr='[FUNCTION_CALL_SCHEMA]  firstName: String'; highlightingTextAttributesKey='INFORMATION_ATTRIBUTES'")!><!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_PACKAGE_FUNCTION_CALL'")!>dataFrameOf<!>("firstName")<!>(
        "Alice"
    ).<!HIGHLIGHTING("severity='ERROR'; descr='[NONE_APPLICABLE] None of the following candidates is applicable:  fun <T> DataFrame<*>.cast(): DataFrame<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <T> DataFrame<*>.cast(): DataFrame<T>  fun <reified T> DataFrame<*>.cast(verify: Boolean = ...): DataFrame<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <reified T> DataFrame<*>.cast(verify: Boolean = ...): DataFrame<T>  fun <T> DataRow<*>.cast(): DataRow<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <T> DataRow<*>.cast(): DataRow<T>  fun <reified T> DataRow<*>.cast(verify: Boolean = ...): DataRow<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <reified T> DataRow<*>.cast(verify: Boolean = ...): DataRow<T>  fun <T> DataColumn<*>.cast(): DataColumn<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <T> DataColumn<*>.cast(): DataColumn<T>  fun <T> ValueColumn<*>.cast(): ValueColumn<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <T> ValueColumn<*>.cast(): ValueColumn<T>  fun <T> ColumnGroup<*>.cast(): ColumnGroup<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <T> ColumnGroup<*>.cast(): ColumnGroup<T>  fun <T> ColumnWithPath<*>.cast(): ColumnWithPath<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <T> ColumnWithPath<*>.cast(): ColumnWithPath<T>  fun <T> ColumnAccessor<*>.cast(): ColumnAccessor<T>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <T> ColumnAccessor<*>.cast(): ColumnAccessor<T>  fun <C> ColumnSet<*>.cast(): ColumnSet<C>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <C> ColumnSet<*>.cast(): ColumnSet<C>  fun <C> ColumnsResolver<*>.cast(): ColumnsResolver<C>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <C> ColumnsResolver<*>.cast(): ColumnsResolver<C>  fun <C> SingleColumn<*>.cast(): SingleColumn<C>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <C> SingleColumn<*>.cast(): SingleColumn<C>  fun <C> TransformableColumnSet<*>.cast(): TransformableColumnSet<C>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <C> TransformableColumnSet<*>.cast(): TransformableColumnSet<C>  fun <C> TransformableSingleColumn<*>.cast(): TransformableSingleColumn<C>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <C> TransformableSingleColumn<*>.cast(): TransformableSingleColumn<C>  fun <C> ColumnReference<*>.cast(): ColumnReference<C>:   Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch: fun <C> ColumnReference<*>.cast(): ColumnReference<C>'; highlightingTextAttributesKey='ERRORS_ATTRIBUTES'")!>cast<!><<!HIGHLIGHTING("severity='ERROR'; descr='[UNRESOLVED_REFERENCE] Unresolved reference 'Person'.'; highlightingTextAttributesKey='WRONG_REFERENCES_ATTRIBUTES'")!>Person<!>>()
// } // commented on purpose to make Person class "accidentally" local

<!HIGHLIGHTING("severity='ERROR'; descr='[LOCAL_INTERFACE_NOT_ALLOWED] Interface 'Person' cannot be local. Try to use an anonymous object or abstract class instead.'; highlightingTextAttributesKey='ERRORS_ATTRIBUTES'")!><!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_ANNOTATION'")!>@DataSchema<!>
interface <!HIGHLIGHTING("severity='ERROR'; descr='[DATA_SCHEMA_DECLARATION_VISIBILITY] To allow plugin-generated declarations to refer to this declaration, it must be declared as either of [public, internal]'; highlightingTextAttributesKey='ERRORS_ATTRIBUTES'"), HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_TRAIT'")!>Person<!><!> {
    val <!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_INSTANCE_PROPERTY'")!>firstName<!>: <!HIGHLIGHTING("severity='SYMBOL_TYPE_SEVERITY'; highlightingTextAttributesKey='KOTLIN_CLASS'")!>String<!>
}<!HIGHLIGHTING("severity='ERROR'; descr='Expecting '}''; highlightingTextAttributesKey='ERRORS_ATTRIBUTES'")!><!>
