// Copyright 2000-2022 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.

package org.jetbrains.kotlin.idea.fir.fe10

import com.intellij.openapi.project.Project
import org.jetbrains.kotlin.analysis.api.KtAnalysisSession
import org.jetbrains.kotlin.analysis.api.analyze
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeTokenFactory
import org.jetbrains.kotlin.analysis.api.symbols.*
import org.jetbrains.kotlin.analysis.project.structure.KtModule
import org.jetbrains.kotlin.analysis.project.structure.KtSourceModule
import org.jetbrains.kotlin.analysis.project.structure.getKtModule
import org.jetbrains.kotlin.builtins.DefaultBuiltIns
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.config.LanguageVersionSettings
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.idea.base.projectStructure.moduleInfo
import org.jetbrains.kotlin.idea.base.util.Frontend10ApiUsage
import org.jetbrains.kotlin.idea.fir.fe10.binding.Fe10BindingSpecialConstructionsWrappers
import org.jetbrains.kotlin.idea.fir.fe10.binding.KtSymbolBasedBindingContext
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.psi.KtElement
import org.jetbrains.kotlin.resolve.BindingContext

interface Fe10WrapperContext {
    val builtIns: KotlinBuiltIns
    val moduleDescriptor: ModuleDescriptor
    val languageVersionSettings: LanguageVersionSettings
    val bindingContext: BindingContext
    val fe10BindingSpecialConstructionFunctions: Fe10BindingSpecialConstructionsWrappers

    // This property used to disable some logic used locally for debug purposes
    val enableLogging: Boolean get() = false

    fun <R> withAnalysisSession(f: KtAnalysisSession.() -> R): R

    /**
     * Legend:
     *  - where was decided, that KtSymbolBased descriptor is not support method, noImplementation() method is called.
     *  - where the implementation planned, but not yet here: implementationPlanned()
     *  - if there is no simple implementation and it isn't clear if it really needed -- implementationPostponed()
     *  - if there were no investigation -- autogenerated TODO("not implemented") called
     *  - if we could implement it right now, but not entirely correct -- wrap it into incorrect implementation
     *  - if some error situation should be handled later -- use errorHandling
     */
    fun noImplementation(additionalInfo: String = ""): Nothing
    fun implementationPostponed(additionalInfo: String = ""): Nothing
    fun implementationPlanned(additionalInfo: String = ""): Nothing
    fun errorHandling(additionalInfo: String = ""): Nothing

    fun <R> incorrectImplementation(block: () -> R) = block()
}

fun KtSymbol.toDeclarationDescriptor(context: Fe10WrapperContext): DeclarationDescriptor =
    when (this) {
        is KtNamedClassOrObjectSymbol -> toDeclarationDescriptor(context)
        is KtFunctionLikeSymbol -> toDeclarationDescriptor(context)
        is KtVariableLikeSymbol -> toDeclarationDescriptor(context)
        is KtReceiverParameterSymbol -> toDeclarationDescriptor(context)
        is KtTypeAliasSymbol -> toDeclarationDescriptor(context)
        else -> context.implementationPlanned(this::class.qualifiedName ?: "")
    }

fun KtReceiverParameterSymbol.toDeclarationDescriptor(context: Fe10WrapperContext): DeclarationDescriptor {
    val owner = owningCallableSymbol.toDeclarationDescriptor(context)
    return when (owner) {
        is CallableDescriptor -> owner.extensionReceiverParameter ?: context.errorHandling("no receiver for $owner but expected")
        else -> context.errorHandling("Unexpected type of owner: $owner")
    }
}

fun KtClassOrObjectSymbol.toDeclarationDescriptor(context: Fe10WrapperContext): ClassDescriptor =
    when (this) {
        is KtNamedClassOrObjectSymbol -> KtSymbolBasedClassDescriptor(this, context)
        is KtAnonymousObjectSymbol -> context.implementationPlanned("KtAnonymousObjectSymbol")
    }

fun KtFunctionLikeSymbol.toDeclarationDescriptor(context: Fe10WrapperContext): KtSymbolBasedFunctionLikeDescriptor =
    when (this) {
        is KtFunctionSymbol -> KtSymbolBasedFunctionDescriptor(this, context)
        is KtAnonymousFunctionSymbol -> KtSymbolBasedAnonymousFunctionDescriptor(this, context)
        is KtConstructorSymbol -> {
            val ktConstructorSymbol = this
            val ktClassOrObject = context.withAnalysisSession { ktConstructorSymbol.getContainingSymbol() as KtNamedClassOrObjectSymbol }
            KtSymbolBasedConstructorDescriptor(ktConstructorSymbol, KtSymbolBasedClassDescriptor(ktClassOrObject, context))
        }
        else -> error("Unexpected kind of KtFunctionLikeSymbol: ${this.javaClass}")
    }

fun KtValueParameterSymbol.toDeclarationDescriptor(context: Fe10WrapperContext): KtSymbolBasedValueParameterDescriptor {
    val containingSymbol = context.withAnalysisSession { this@toDeclarationDescriptor.getContainingSymbol() }
    check(containingSymbol is KtFunctionLikeSymbol) {
        "Unexpected containing symbol = $containingSymbol"
    }
    return KtSymbolBasedValueParameterDescriptor(this, context, containingSymbol.toDeclarationDescriptor(context))
}


fun KtVariableLikeSymbol.toDeclarationDescriptor(context: Fe10WrapperContext): VariableDescriptor =
    when (this) {
        is KtValueParameterSymbol -> toDeclarationDescriptor(context)
        is KtPropertySymbol -> KtSymbolBasedPropertyDescriptor(this, context)
        is KtJavaFieldSymbol -> KtSymbolBasedJavaPropertyDescriptor(this, context)
        is KtLocalVariableSymbol ->  KtSymbolBasedLocalVariableDescriptor(this, context)
        else -> context.implementationPlanned(this::class.toString())
    }

fun KtTypeAliasSymbol.toDeclarationDescriptor(context: Fe10WrapperContext) = KtSymbolBasedTypeAliasDescriptor(this, context)

class Fe10WrapperContextImpl(
    private val project: Project,
    private val ktElement: KtElement
) : Fe10WrapperContext {
    private val token: KtLifetimeToken = KtLifetimeTokenForKtSymbolBasedWrappers(project, ktElement)

    private val module: KtModule = ktElement.getKtModule(project)

    override fun <R> withAnalysisSession(f: KtAnalysisSession.() -> R): R {
        return analyze(ktElement, token.factory, f)
    }

    override val moduleDescriptor: ModuleDescriptor = KtSymbolBasedModuleDescriptorImpl(this, module, token)

    override val builtIns: KotlinBuiltIns
        get() = incorrectImplementation { DefaultBuiltIns.Instance }

    override val languageVersionSettings: LanguageVersionSettings
        get() = withAnalysisSession { (useSiteModule as KtSourceModule).languageVersionSettings  }

    override val bindingContext: BindingContext = KtSymbolBasedBindingContext(this)

    override val fe10BindingSpecialConstructionFunctions = Fe10BindingSpecialConstructionsWrappers(this)

    override fun noImplementation(additionalInfo: String): Nothing =
        error("This method should not be called for wrappers. $additionalInfo")

    override fun implementationPostponed(additionalInfo: String): Nothing =
        TODO("InvestigateLater and implement if needed. $additionalInfo")

    override fun implementationPlanned(additionalInfo: String): Nothing =
        TODO("SE_to_implement. $additionalInfo")

    override fun errorHandling(additionalInfo: String): Nothing =
        TODO("Some incorrect situation/parser error/resolution error. $additionalInfo")

}

// I hope we'll find a way to use project and element later
@Suppress("unused")
private class KtLifetimeTokenForKtSymbolBasedWrappers(
    private val project: Project,
    private val element: KtElement
) : KtLifetimeToken() {

    /**
     *  This is quite strange code, isn't it?
     *  Well... Unfortunately in old FE we don't do any checks regarding of the validity of the descriptors.
     *  Moreover, it was a common practice to ask BindingContext for something and do modification of the PSI at the same time.
     *  Yes, that is not great at all, and it is unclear what will happen in that case.
     *  See [org.jetbrains.kotlin.idea.intentions.ConvertSecondaryConstructorToPrimaryIntention.applyTo] as an example.
     *
     *  One potential solution will be -- disable Fe10Wrapper for the Intentions/inspections that do this
     */
    override fun isValid(): Boolean = true
    override fun getInvalidationReason(): String = error("Getting invalidation reason for valid validity token")

    override fun isAccessible(): Boolean = true
    override fun getInaccessibilityReason(): String = error("Getting inaccessibility reason for validity token when it is accessible")

    override val factory = KtLifetimeTokenForKtSymbolBasedWrappersFactory(this)
}

private class KtLifetimeTokenForKtSymbolBasedWrappersFactory(
    private val token: KtLifetimeTokenForKtSymbolBasedWrappers
) : KtLifetimeTokenFactory() {
    override val identifier = KtLifetimeTokenForKtSymbolBasedWrappers::class

    override fun create(project: Project): KtLifetimeTokenForKtSymbolBasedWrappers = token
}

private class KtSymbolBasedModuleDescriptorImpl(
    val context: Fe10WrapperContext,
    val module: KtModule,
    val token: KtLifetimeToken
) : ModuleDescriptor {
    override val builtIns: KotlinBuiltIns
        get() = context.builtIns

    override val stableName: Name
        get() = context.noImplementation()
    override val platform: TargetPlatform
        get() = module.platform

    override fun shouldSeeInternalsOf(targetModule: ModuleDescriptor): Boolean = context.noImplementation()
    override fun getPackage(fqName: FqName): PackageViewDescriptor = context.noImplementation()
    override fun getSubPackagesOf(fqName: FqName, nameFilter: (Name) -> Boolean): Collection<FqName> = context.noImplementation()

    override val allDependencyModules: List<ModuleDescriptor>
        get() = context.implementationPostponed()
    override val expectedByModules: List<ModuleDescriptor>
        get() = context.implementationPostponed()
    override val allExpectedByModules: Set<ModuleDescriptor>
        get() = context.implementationPostponed()

    override fun <T> getCapability(capability: ModuleCapability<T>): T? = null

    override val isValid: Boolean
        get() = token.isValid()

    override fun assertValid() {
        assert(token.isValid())
    }

    @OptIn(Frontend10ApiUsage::class)
    override fun getName(): Name = module.moduleInfo.name

    override fun getOriginal(): DeclarationDescriptor = this

    override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?) = context.noImplementation()

    override val annotations: Annotations
        get() = context.incorrectImplementation { Annotations.EMPTY }

}