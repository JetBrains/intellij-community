group.names.gradle=Gradle
group.path.kotlin.migration=Kotlin,Migration
group.names.java.interop.issues=Java interop issues
group.names.kotlin=Kotlin
group.names.logging=Logging
group.names.naming.conventions=Naming conventions
group.names.maven=Maven
group.names.migration=Migration
group.names.other.problems=Other problems
group.names.probable.bugs=Probable bugs
group.names.redundant.constructs=Redundant constructs
group.names.style.issues=Style issues
group.names.code.migration=Code migration
fix.insert.delegation.call=Insert ''{0}()'' call
fix.introduce.non.null.assertion=Add non-null asserted ({0}!!) call
fix.remove.non.null.assertion=Remove unnecessary non-null assertion (!!)
fix.add.annotation.target=Add annotation target
progress.looking.up.add.annotation.usage=Looking up annotation usage\u2026
fix.add.constructor.parameter=Add constructor parameter ''{0}''
fix.make.data.class=Make ''{0}'' data class
fix.add.default.constructor=Add default constructor to 'expect' class
fix.add.explicit.import=Add explicit import
fix.add.function.body=Add function body
fix.use.fully.qualified.call=Use fully qualified call
wrap.argument.with.parentheses=Wrap argument with parentheses
fix.add.is.to.when=Add ''is'' before ''{0}''
fix.add.new.line.after.annotations=Add new line after annotations
fix.make.type.parameter.reified=Make {0} reified and {1} inline
fix.add.return.last.expression=Add 'return' to last expression
fix.add.return.before.expression=Add 'return' before the expression
fix.add.return.before.lambda.expression=Add 'run' before the lambda expression
fix.add.semicolon.lambda.expression=Terminate preceding call with semicolon
fix.add.spread.operator.after.sam=Add a spread operator before an array passing as 'vararg'
fix.add.else.branch.when=Add else branch
fix.replace.with.assign.function.call=Replace with ''{0}'' call
fix.assign.to.property=Assign to property
fix.change.mutability.change.to.val=Change ''{0}'' to val
fix.change.type.argument=Change type argument to {0}
fix.change.to.function.invocation=Change to function invocation

fix.change.to.mutable.type.family=Change type to mutable
fix.change.to.mutable.type.text=Change type to {0}

fix.change.to.property.access.family.remove=Remove invocation
fix.change.to.property.access.family.change=Change to property access

fix.change.to.labeled.return.family=Change to return with label
fix.change.to.labeled.return.text=Change to ''{0}''

fix.change.suspend.hierarchy.add=Add 'suspend' modifier to all functions in hierarchy
fix.change.suspend.hierarchy.remove=Remove 'suspend' modifier from all functions in hierarchy
fix.change.progress.looking.inheritors=Looking for class {0} inheritors\u2026
fix.change.progress.analyzing.class.hierarchy=Analyzing class hierarchy\u2026

fix.change.return.type.family=Change type
fix.change.return.type.text.primary.constructor=Change parameter ''{0}'' type of primary constructor of class ''{1}'' to ''{2}''
fix.change.return.type.text.function=Change parameter ''{0}'' type of function ''{1}'' to ''{2}''
fix.change.return.type.command.primary.constructor=Change Parameter ''{0}'' Type Of Primary Constructor Of Class ''{1}'' To ''{2}''
fix.change.return.type.command.function=Change Parameter ''{0}'' Type Of Function ''{1}'' To ''{2}''

fix.change.return.type.lambda=Change lambda expression return type to {0}
fix.change.return.type.remove.explicit.return.type=Remove explicitly specified return type
fix.change.return.type.remove.explicit.return.type.of=Remove explicitly specified return type of {0}
fix.change.return.type.return.type.text=Change return type to ''{0}''
fix.change.return.type.return.type.text.of=Change return type of {0} to ''{1}''
fix.change.return.type.type.text=Change type to ''{0}''
fix.change.return.type.type.text.of=Change type of {0} to ''{1}''
fix.change.return.type.presentation.property=property {0}
fix.change.return.type.presentation.function=function {0}
fix.change.return.type.presentation.enclosing.function=enclosing function
fix.change.return.type.presentation.enclosing=enclosing {0}
fix.change.return.type.presentation.called.function=called function
fix.change.return.type.presentation.accessed=accessed {0}
fix.change.return.type.presentation.called=called {0}
fix.change.return.type.presentation.base=base {0}

fix.cast.expression.family=Cast expression
fix.cast.expression.text=Cast expression ''{0}'' to ''{1}''

fix.change.accessor.family=Change accessor type
fix.change.accessor.getter=Change getter type to {0}
fix.change.accessor.setter.parameter=Change setter parameter type to {0}

fix.create.from.usage.dialog.title=Create From Usage

fix.add.remaining.branches=Add remaining branches
fix.add.remaining.branches.with.star.import=Add remaining branches with * import

fix.add.type.annotation.family=Add type annotation
fix.add.type.annotation.text=Add type ''{0}'' to parameter ''{1}''

fix.add.tostring.call.family=Add 'toString()' call
fix.add.tostring.call.text=Add 'toString()' call
fix.add.tostring.call.text.safe=Add safe '?.toString()' call

fix.add.star.projection.family=Add star projections
fix.add.star.projection.text=Add ''{0}''

fix.change.to.star.projection.family=Change to star projection
fix.change.to.star.projection.text=Change type arguments to {0}

fix.change.to.use.spread.operator.family=Change to use spread operator
fix.change.to.use.spread.operator.text=Change ''{0}'' to ''{1}''

fix.change.type.family=Change type
fix.change.type.text=Change type from ''{0}'' to ''{1}''

fix.add.suspend.modifier.function=Make {0} suspend
fix.add.suspend.modifier.function.generic=Make containing function suspend
fix.add.suspend.modifier.receiver=Make {0} type suspend
fix.add.suspend.modifier.receiver.generic=Make receiver type suspend

fix.add.function.parameters.change.signature.constructor=Change the signature of constructor ''{0}''
fix.add.function.parameters.change.signature.function=Change the signature of function ''{0}''
fix.add.function.parameters.add.parameter.constructor=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters} to constructor ''{2}''
fix.add.function.parameters.add.parameter.function=Add {0,number,ordinal} {1,choice,1#parameter|2#parameters} to function ''{2}''
fix.add.function.parameters.add.parameter.generic.constructor=Add {0,choice,1#parameter|2#parameters} to constructor ''{1}''
fix.add.function.parameters.add.parameter.generic.function=Add {0,choice,1#parameter|2#parameters} to function ''{1}''

fix.change.signature.family=Change signature of function/constructor
fix.change.signature.function.family=Change function signature
fix.change.signature.function.text=Change function signature to ''{0}''
fix.change.signature.function.text.generic=Change function signature\u2026
fix.change.signature.function.popup.title=Choose Signature
fix.change.signature.lambda=Change the signature of lambda expression
fix.change.signature.lambda.command=Change The Signature Of Lambda Expression
fix.change.signature.remove.parameter=Remove parameter ''{0}''
fix.change.signature.remove.parameter.command=Remove Parameter ''{0}''
fix.change.signature.unavailable=<not available>
fix.change.signature.error=<error>
fix.change.signature.unnamed.parameter=parameter
fix.change.signature.prepare=Prepare\u2026

fix.change.object.to.class=Change 'object' to 'class'

fix.add.member.supertype.family=Add {0} to supertype
fix.add.member.supertype.text=Add {0} to supertype\u2026
fix.add.member.supertype.progress=Add {0} to Type
fix.add.member.supertype.choose.type=Choose Type
fix.add.member.supertype.add.to=Add ''{0}'' to ''{1}''

fix.add.generic.upperbound.text=Add ''{0}'' as upper bound for {1}
fix.add.generic.upperbound.family=Add generic upper bound

fix.make.upperbound.not.nullable.any.text=Add ''Any'' as upper bound for {0} to make it non-nullable
fix.make.upperbound.not.nullable.remove.nullability.text=Change the upper bound of {0} to ''{1}'' to make {0} non-nullable
fix.make.upperbound.not.nullable.family=Make generic type parameter non-nullable

fix.add.modifier.inline.parameter.family=Add ''{0}'' to parameter
fix.add.modifier.inline.parameter.text=Add ''{0}'' to parameter ''{1}''

fix.add.modifier.inline.function.family=Add 'inline' to function
fix.add.modifier.inline.function.text=Add ''inline'' to function ''{0}''

fix.add.array.of.type.text=Add {0} wrapper
fix.add.array.of.type.family=Add 'arrayOf' wrapper

fix.add.loop.label.text.generic=Add label to the loop
fix.add.loop.label.text=Add ''{0}'' to {1}

fix.add.modifier.family=Add modifier
fix.add.modifier.text=Make {0} ''{1}''
fix.add.modifier.text.generic=Add ''{0}'' modifier
fix.potentially.broken.inheritance.title=Potentially Broken Inheritance
fix.potentially.broken.inheritance.message=This change could potentially break the inheritors.\nDo you want to continue?

fix.make.field.public=Make field ''{0}'' public

fix.add.argument.name.family=Add name to argument
fix.add.argument.name.text.generic=Add name to argument\u2026
fix.add.argument.name.text=Add name to argument: ''{0}''
fix.add.argument.name.step.choose.parameter.title=Choose Parameter Name

fix.create.expect.actual=Create expect / actual declaration
fix.create.missing.actual.members=Add missing actual members
fix.create.missing.actual.declarations=Add missing actual declarations
fix.create.missing.actual.declarations.title=Add Missing Actual Declarations
fix.remove.mismatched.annotation.from.expect.declaration.may.change.semantics=Remove mismatched annotation ''{0}'' from ''expect'' declaration (may change semantics)
fix.copy.mismatched.annotation.to.actual.declaration.may.change.semantics=Copy mismatched annotation ''{0}'' from ''expect'' to ''actual'' declaration (may change semantics)
fix.replace.mismatched.annotation.args.on.actual.declaration.may.change.semantics=Replace arguments of mismatched annotation ''{0}'' on ''actual'' declaration (may change semantics)
fix.replace.mismatched.annotation.args.on.expect.declaration.may.change.semantics=Replace arguments of mismatched annotation ''{0}'' on ''expect'' declaration (may change semantics)

fix.create.declaration.error=Cannot generate {0}: {1}
fix.create.declaration.error.inaccessible.type=Inaccessible Type
fix.create.declaration.error.some.types.inaccessible=Some types are not accessible:

fix.add.annotation.family=Add annotation
fix.add.annotation.text.self=Add ''@{0}'' annotation
fix.add.annotation.text.declaration=Add ''@{0}'' annotation to ''{1}''
fix.add.annotation.text.containing.class=Add ''@{0}'' annotation to containing class ''{1}''
fix.add.annotation.text.containing.file=Add ''@{0}'' annotation to containing file ''{1}''
fix.add.annotation.text.constructor=Add ''@{0}'' annotation to constructor

fix.opt_in.annotation.family=Annotate opt-in feature usage
fix.opt_in.text.use.statement=Opt in for ''{0}'' on statement
fix.opt_in.text.use.declaration=Opt in for ''{0}'' on ''{1}''
fix.opt_in.text.use.constructor=Opt in for ''{0}'' on constructor
fix.opt_in.text.use.containing.class=Opt in for ''{0}'' on containing class ''{1}''
fix.opt_in.text.use.containing.object=Opt in for ''{0}'' on containing object ''{1}''
fix.opt_in.text.use.containing.anonymous.object=Opt in for ''{0}'' on containing object
fix.opt_in.text.use.containing.file=Opt in for ''{0}'' in containing file ''{1}''
fix.opt_in.text.use.module=Opt in for ''{0}'' in module ''{1}''
fix.opt_in.text.propagate.declaration=Propagate ''{0}'' opt-in requirement to ''{1}''
fix.opt_in.text.propagate.constructor=Propagate ''{0}'' opt-in requirement to constructor
fix.opt_in.text.propagate.containing.class=Propagate ''{0}'' opt-in requirement to containing class ''{1}''
fix.opt_in.text.propagate.containing.object=Propagate ''{0}'' opt-in requirement to containing object ''{1}''

fix.opt_in.remove.all.forbidden.targets=Remove forbidden opt-in annotation targets
fix.opt_in.remove.forbidden.retention=Remove forbidden opt-in annotation retention

fix.opt_in.move.requirement.from.value.parameter.to.property=Move ''{0}'' opt-in requirement from value parameter to property
fix.opt_in.move.requirement.from.getter.to.property=Move ''{0}'' opt-in requirement from getter to property

fix.opt_in.migrate.experimental.annotation.replace=Replace deprecated '@Experimental' annotation with '@RequiresOptIn'
fix.opt_in.migrate.experimental.annotation.remove=Remove deprecated '@Experimental' annotation

fix.replace.annotation.family=Replace annotation
fix.replace.annotation.text=Replace annotation with ''@{0}''

fix.import=Import
fix.import.kind.0.name.1.and.name.2=Import {0} ''{1}'', ''{2}''
fix.import.kind.0.name.1.2=Import {0} ''{1}''{2,choice,0#|1# and {2} more}
fix.import.question=Import {0}?
fix.import.kind.delegate.accessors=Delegate accessors
fix.import.kind.component.functions=Component functions
fix.import.exclude=Exclude ''{0}'' from auto-import

fix.move.file.to.package.family=Move file to package-matching directory
fix.move.file.to.package.text=Move file to {0}

fix.change.package.family=Change file's package to match directory
fix.change.package.text=Change file''s package to {0}

fix.move.to.sealed.family=Move hierarchy member to the package/module of its sealed parent
fix.move.to.sealed.text=Move {0} to the package/module of {1}

fix.add.annotation.with.arguments.text.copy=Copy ''@{0}'' annotation from ''{1}'' to ''{2}''

action.add.import.chooser.title=Imports

goto.super.chooser.function.title=Choose Super Function
goto.super.chooser.property.title=Choose Super Property
goto.super.chooser.class.title=Choose Super Class or Interface

action.GotoSuperProperty.text=Go to S_uper Property
action.GotoSuperProperty.MainMenu.text=S_uper Property
action.GotoSuperProperty.description=Navigate to the declaration of a property that the current property overrides or implements

action.GotoSuperClass.text=Go to S_uper Class
action.GotoSuperClass.MainMenu.text=S_uper Class

action.GotoSuperInterface.text=Go to S_uper Interface
action.GotoSuperInterface.MainMenu.text=S_uper Interface

inspection.unused.receiver.parameter=Receiver parameter is never used
fix.unused.receiver.parameter.remove=Remove redundant receiver parameter

fix.create.from.usage.family=Create from usage
fix.create.from.usage.local.variable=Create local variable ''{0}''

fix.replace.with.declaring.java.class=Replace with 'declaringJavaClass'

overridden.marker.implementations.multiple=Has implementations
overridden.marker.implementation=Is implemented in
overridden.marker.overrides.multiple=Is overridden in subclasses
overridden.marker.overrides=Is overridden in
notification.navigation.to.overriding.classes=Navigation to overriding classes is not possible during index update
tooltip.implements.function=Implements function in
tooltip.overrides.function=Overrides function in
tooltip.implements.property=Implements property in
tooltip.overrides.property=Overrides property in
searching.for.overriding.methods=Searching for overriding methods
tooltip.is.subclassed.by=Is subclassed by
tooltip.is.implemented.by=Is implemented by

overridden.marker.implementations.choose.implementation.title=Choose Implementation of {0}
overridden.marker.implementations.choose.implementation.find.usages=Overriding Properties of {0}
overridden.marker.overrides.choose.implementation.title=Choose Super Implementation of {0}
overridden.marker.overrides.choose.implementation.find.usages=Super Implementations of {0}

remove.expression=Remove ''{0}''
unwrap.expression=Unwrap ''{0}''
unwrap.parameter=Unwrap ''{0}'' arg ''{1}''
remove.else=Remove else in ''{0}''
unwrap.else=Unwrap else in ''{0}''

override.declaration.x.in.y={0} in {1}
override.declaration.x.implements.y={0} implements {1}.
override.declaration.x.overrides.y.in.class.list={0} overrides declarations in the following classes/interfaces: {1} Do you want to {2} the base declarations?

override.declaration.unused.overriding.methods.title=Unused Overriding Members
override.declaration.unused.overriding.methods.description=There are unused members that override methods you delete.
override.declaration.choose.to.delete=Choose the ones you want to be deleted.
override.declaration.member=Member
override.declaration.delete.multiple.parameters={0} is a part of method hierarchy. Do you want to delete multiple parameters?

hierarchy.legend.member.is.defined.in.class=Member is defined in the class
hierarchy.legend.member.defined.in.superclass=Member is not defined in the class but defined in superclass
hierarchy.legend.member.should.be.defined=Member should be defined since the class is not abstract

intention.change.package.text=Change package

intention.extract.declarations.from.file.text=Extract declaration from current file
intention.extract.declarations.from.file.text.details=Extract ''{0}'' {1, choice, 0#|1#and subclasses }from current file
intention.wrap.in.with.context=Wrap call in 'withContext'
intention.flow.on.dispatchers.io=Flow on 'Dispatchers.IO'
intention.switch.context.to.dispatchers.io=Switch to 'Dispatchers.IO' context

# Code insight
copy.paste.select.imports.to.remove.dialog=Select Imports to Remove
copy.paste.select.imports.to.remove.text=<html>The code fragment which you have pasted uses elements that are not accessible in the new context. Necessary imports have been added.<br/>Select which of the added imports you want to remove from the file.</html>
copy.paste.reference.notification={0} {0, choice, 1#import was|2#imports were} added<p><span><a href=''show''>Review Added Imports...</a></span>

kotlin.external.compiler.updates.notification.group.name=Kotlin external compiler updates available

code.insight.workspace.settings.title=Kotlin

quick.doc.text.enum.ordinal=Enum constant ordinal: {0}
quick.doc.text.tailrec='tailrec' marks a function as <a href="https://kotlinlang.org/docs/reference/functions.html#tail-recursive-functions">tail-recursive</a> (allowing the compiler to replace recursion with iteration)
quick.doc.text.lateinit='lateinit' allows initializing a <a href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables">not-null property outside of a constructor</a>
quick.doc.no.documentation=No documentation available
quick.doc.section.deprecated=Deprecated:
quick.doc.section.replace.with=Replace with:
quick.doc.section.java.declaration=Java declaration:

action.j2k.name=Convert Java to Kotlin
action.j2k.task.name=Convert Files from Java to Kotlin
action.j2k.correction.investigate=Investigate Errors
action.j2k.correction.proceed=Proceed with Conversion
action.j2k.correction.required=Some code in the rest of your project may require corrections after performing this conversion. Do you want to find such code and correct it too?
action.j2k.correction.errors.single=''{0}'' contains syntax errors, the conversion result may be incorrect
action.j2k.correction.errors.multiple=''{0}'' and {1} other Java files contain syntax errors, the conversion result may be incorrect
action.j2k.error.cant.save.result=Failed to save conversion result: {0}
action.j2k.error.cant.find.document=couldn''t find document for ''{0}''
action.j2k.error.read.only=file ''{0}'' is read-only
action.j2k.error.nothing.to.convert=Nothing to convert:<br>No writable Java files found

formatter.settings.title=Kotlin Formatter Settings

action.generate.functions.already.defined=Functions {0} are already defined for class {1}. Do you want to delete them and proceed?

action.generate.equals.choose.equals=Choose Properties To Be Included In 'equals()'
action.generate.equals.choose.hashcode=Choose Properties To Be Included In 'hashCode()'

action.generate.secondary.constructor.choose.properties=Choose Properties to Initialize by Constructor
action.generate.secondary.constructor.error.already.exists=Constructor already exists

action.generate.test.support.choose.framework=Choose Framework
command.generate.test.support.generate.test.function=Generate Test Function
action.generate.test.support.choose.test.name=Choose test name:
action.generate.test.support.edit.template=Edit Template
action.generate.test.support.error.no.template.found=No template found for {0}:{1}
action.generate.test.support.error.cant.convert.java.template=Couldn't convert Java template to Kotlin
action.generate.test.support.error.cant.generate.method=Cannot generate method: {0}

action.generate.tostring.name=Generate 'toString()'
action.generate.super.type=Specify super type explicitly
action.generate.tostring.template.single=Single template
action.generate.tostring.template.single.with.super=Single template with super call
action.generate.tostring.template.multiple=Multiple templates with concatenation
action.generate.tostring.template.multiple.with.super=Multiple templates with concatenation and super call
action.generate.tostring.choose.implementation=Choose implementation:
action.generate.tostring.choose.implementation.mnemonic=i
action.generate.tostring.generate.super.call=Generate call to super.toString()
action.generate.tostring.generate.super.call.mnemonic=s

action.Kotlin.NewFile.text=Kotlin Class/File
action.Kotlin.NewFile.description=Creates new Kotlin class or file

action.Kotlin.NewScript.text=Kotlin Script
action.Kotlin.NewScript.description=Creates new Kotlin script or worksheet

action.new.file.dialog.title=New Kotlin Class/File
action.new.script.dialog.title=New Kotlin File

action.new.file.dialog.file.title=File
action.new.file.dialog.class.title=Class
action.new.file.dialog.data.class.title=Data class
action.new.file.dialog.sealed.class.title=Sealed class
action.new.file.dialog.annotation.title=Annotation
action.new.file.dialog.interface.title=Interface
action.new.file.dialog.sealed.interface.title=Sealed interface
action.new.file.dialog.enum.title=Enum class
action.new.file.dialog.object.title=Object
action.new.file.error.empty.name=Name can't be empty
action.new.file.error.empty.name.part=Name can't have empty parts

action.new.script.name=Kotlin script

breadcrumbs.tooltip.indexing=Indexing\u2026

copy.paste.resolve.pasted.references=Resolve pasted references
copy.paste.restore.pasted.references=Restore pasted references
copy.paste.restore.pasted.references.capitalized=Restore Pasted References

type.provider.anonymous.object=anonymous object
type.provider.unknown.type=Type is unknown
type.provider.smart.cast.from=(smart cast from {0})
type.provider.no.expression.found=No expression found

optimize.imports.collect.unused.imports=Collecting Unused Imports
optimize.imports.task.removing.redundant.imports=Removing Redundant Imports

kdoc.section.title.receiver=Receiver
kdoc.section.title.parameters=Params
kdoc.section.title.returns=Returns
kdoc.section.title.throws=Throws
kdoc.section.title.author=Authors
kdoc.section.title.properties=Properties
kdoc.section.title.constructor=Constructor
kdoc.section.title.since=Since
kdoc.section.title.suppress=Suppress
kdoc.section.title.samples=Samples
kdoc.section.title.see.also=See Also
kdoc.comment.unresolved=Unresolved

livetemplate.description.main=main() function
livetemplate.description.maina=main(args) function
livetemplate.description.soutp=Prints function parameter names and values to System.out
livetemplate.description.iter=Iterate over elements of iterable (for-in loop)
livetemplate.description.ifn=Inserts 'if null' expression
livetemplate.description.inn=Inserts 'if not null' expression
livetemplate.description.void=Function returning nothing
livetemplate.description.fun0=Function with no parameters
livetemplate.description.fun1=Function with one parameter
livetemplate.description.fun2=Function with two parameters
livetemplate.description.interface=Interface
livetemplate.description.singleton=Singleton
livetemplate.description.closure=Closure (function without name)
livetemplate.description.anonymous=Anonymous class
livetemplate.description.exfun=Extension function
livetemplate.description.exval=Extension read-only property
livetemplate.description.exvar=Extension read-write property


inlay.kotlin.references.types.hints=Show inlay hints for types
inlay.kotlin.references.types.hints.hints.type.function.parameter=Show inlay hints for function parameter types
inlay.kotlin.references.types.hints.hints.type.function.return=Show inlay hints for function return types
inlay.kotlin.references.types.hints.hints.type.variable=Show inlay hints for local variable types
inlay.kotlin.references.types.hints.hints.type.property=Show inlay hints for property types
inlay.kotlin.lambdas.hints=Show inlay hints for lambdas
inlay.kotlin.call.chains.hints=Show inlay hints for call chains
inlay.kotlin.lambdas.hints.hints.lambda.receivers.parameters=Show inlay hints for implicit receivers and parameters
inlay.kotlin.lambdas.hints.hints.lambda.return=Show inlay hints for return expressions
inlay.kotlin.values.hints=Show inlay hints for values
inlay.kotlin.values.hints.kotlin.values.ranges=Show inlay hints for ranges

hints.settings.parameters=Parameters
inlay.kotlin.parameters.hints=Shows parameter names at function call sites.
hints.settings.excluded.parameters=Excluded parameter names
inlay.kotlin.parameters.hints.excluded=Show excluded parameter names

parameter.hints.old=Kotlin: Show inlay hints for parameters
kotlin.references.types.hints=Kotlin: Show inlay hints for types
kotlin.references.types.hints.hints.type.function.parameter=Kotlin: Show inlay hints for function parameter types
kotlin.references.types.hints.hints.type.function.return=Kotlin: Show inlay hints for function return types
kotlin.references.types.hints.hints.type.variable=Kotlin: Show inlay hints for local variable types
kotlin.references.types.hints.hints.type.property=Kotlin: Show inlay hints for property types
kotlin.lambdas.hints=Kotlin: Show inlay hints for lambdas
kotlin.call.chains.hints=Kotlin: Show inlay hints for call chains
kotlin.lambdas.hints.hints.lambda.receivers.parameters=Kotlin: Show inlay hints for implicit receivers and parameters
kotlin.lambdas.hints.hints.lambda.return=Kotlin: Show inlay hints for return expressions
kotlin.values.hints=Show inlay hints for values
kotlin.values.hints.kotlin.values.ranges=Kotlin: Show inlay hints for ranges
microservices.url.path.inlay.hints=Kotlin: Show inlay hints for URL path
vcs.code.author=Kotlin: Show inlay hints with code author
spring.secured.urls.inlay.hints=Kotlin: Show inlay hints for secured spring URLs

hints.settings.common.items=Show hints for:
hints.settings.types=Types
hints.types=Type hints
hints.settings.types.property=Property types
hints.settings.types.variable=Local variable types
hints.settings.types.return=Function return types
hints.settings.types.parameter=Function parameter types
hints.settings.values.ranges=Ranges

hints.settings.show.types.property=Show property type hints
hints.settings.dont.show.types.property=Do not show property type hints
hints.settings.show.types.variable=Show local variable type hints
hints.settings.dont.show.types.variable=Do not show local variable type hints
hints.settings.show.types.return=Show function return type hints
hints.title.show.argument.name.enabled=Show argument name hints
hints.title.dont.show.argument.name.enabled=Do not show argument name hints
hints.settings.dont.show.types.return=Do not show function return type hints
hints.settings.show.types.parameter=Show function parameter type hints
hints.settings.dont.show.types.parameter=Do not show function parameter type hints
hints.settings.show.lambda.return=Show return expression hints
hints.settings.dont.show.lambda.return=Do not show return expression hints
hints.settings.show.lambda.receivers.parameters=Show implicit receiver and parameter hints
hints.settings.dont.show.lambda.receivers.parameters=Do not show implicit receiver and parameter hints
hints.settings.show.suspending=Show suspending call hints
hints.settings.dont.show.suspending=Do not show suspending call hints
hints.settings.show.ranges=Show range hints
hints.settings.dont.show.ranges=Do not show range hints

hints.settings.lambdas=Lambdas
hints.settings.lambda.return=Return expressions
hints.settings.lambda.receivers.parameters=Implicit receivers and parameters

hints.settings.ranges=Ranges
hints.ranges.lessOrEqual=\u2264
hints.ranges.less=<
hints.ranges.greaterOrEqual=\u2265

hints.settings.suspending=Suspending calls

hints.title.argument.name.enabled=Argument name

presentation.text.paren=({0})
presentation.text.paren.no.brackets={0}
presentation.text.in.container.paren=(in {0})
presentation.text.in.container.paren.no.brackets=in {0}
presentation.text.in.container={0} in {1}
presentation.text.for.receiver.in.container.paren=(for {0} in {1})
presentation.text.for.receiver.in.container.paren.no.brackets=for {0} in {1}
presentation.text.object.in.container=object in {0}

project.view.class.initializer=class initializer
project.view.expression=expression
project.view.class.error.name=no name provided

copy.text.adding.imports=Adding imports\u2026
copy.text.clipboard.content.seems.to.be.java.code.do.you.want.to.convert.it.to.kotlin=Clipboard content seems to be Java code. Do you want to convert it to Kotlin?
copy.text.convert.java.to.kotlin.title=Convert Java to Kotlin
copy.text.copied.kotlin.code=Copied Kotlin code
copy.text.resolving.references=Resolving references\u2026
copy.title.convert.code.from.java=Convert Code From Java

editor.checkbox.title.auto.add.val.keyword.to.data.value.class.constructor.parameters=Auto add 'val' keyword to data/value class constructor parameters
editor.checkbox.title.convert.pasted.java.code.to.kotlin=Convert pasted Java code to Kotlin
editor.checkbox.title.don.t.show.java.to.kotlin.conversion.dialog.on.paste=Don't show Java to Kotlin conversion dialog on paste
editor.title.kotlin=Kotlin

find.usages.progress.text.declaration.superMethods=Resolving super methods\u2026

formatter.button.text.use.import.with.when.at.least=Use import with '*' when at least
formatter.button.text.use.import.with=Use import with '*'
formatter.button.text.use.single.name.import=Use single name import
formatter.checkbox.text.insert.imports.for.nested.classes=Insert imports for nested classes
formatter.checkbox.text.use.trailing.comma=Use trailing comma
formatter.text.names.used=\ names used
formatter.text.use.defaults.from=Use defaults from:
formatter.title.after.colon.before.declaration.type=After colon, before declaration type
formatter.title.after.colon.in.new.type.definition=After colon in new type definition
formatter.title.align.when.branches.in.columns=Align 'when' branches in columns
formatter.title.line.break.after.multiline.when.entry=New line after multiline entry
formatter.title.indent.before.arrow.on.new.line=Indent before '->' on new line
formatter.title.around.arrow.in.function.types=Around arrow in function types
formatter.title.around.arrow.in=Around arrow in "when" clause
formatter.title.around.when.branches.with=Around 'when' branches with {}
formatter.title.before.declaration.with.comment.or.annotation=Before declaration with comment or annotation
formatter.title.before.colon.after.declaration.name=Before colon, after declaration name
formatter.title.before.colon.in.new.type.definition=Before colon in new type definition
formatter.title.before.lambda.arrow=Before lambda arrow
formatter.title.chained.function.calls=Chained function calls
formatter.title.elvis.expressions=Elvis expressions
formatter.title.expression.body.functions=Expression body functions
formatter.title.function.annotations=Function annotations
formatter.title.function.call.arguments=Function call arguments
formatter.title.function.declaration.parameters=Function declaration parameters
formatter.title.function.parentheses=Function parentheses
formatter.title.in.simple.one.line.methods=In simple one line methods
formatter.title.java.statics.and.enum.members=Java Statics and Enum Members
formatter.title.load.save=Load/Save
formatter.title.other=Other
formatter.title.trailing.comma=Trailing Comma
formatter.title.property.annotations=Property annotations
formatter.title.put.left.brace.on.new.line=Put left brace on new line
formatter.title.range.operator=Range operators (.., ..<)
formatter.title.elvis.operator=Elvis operator (?:)
formatter.title.top.level.symbols=Top-Level Symbols
formatter.title.use.continuation.indent.in.conditions=Use continuation indent in conditions
formatter.title.use.continuation.indent=Use continuation indent
formatter.title.when.parentheses='when' parentheses
formatter.title.when.statements='when' statements

ambiguous.non.local.break.or.continue.display.name=Ambiguous non-local 'break' or 'continue'
ambiguous.non.local.break.or.continue=Ambiguous non-local ''{0}'' (''{1}'' vs ''{2}''). Use clarifying labels or add ''callsInPlace'' contract.

hierarchy.text.anonymous=[anonymous]
hierarchy.text.in=\ in {0}

highlighter.action.text.go.to.actual.declarations=Go To Actual Declarations
highlighter.action.text.go.to.expected.declaration=Go To Expected Declaration
highlighter.action.text.go.to.implementations=Go To Implementations
highlighter.action.text.go.to.overridden.methods=Go To Overridden Methods
highlighter.action.text.go.to.overridden.properties=Go To Overridden Properties
highlighter.action.text.go.to.subclasses=Go To Subclasses
highlighter.action.text.go.to.super.method=Go To Super Method
highlighter.action.text.go.to.super.property=Go To Super Property
highlighter.descriptor.text.android.extensions.property=Properties and Variables//Android Extensions synthetic properties
highlighter.descriptor.text.annotation=Annotation//Annotation name
highlighter.descriptor.text.annotation.attribute.name=Annotation//Annotation attribute name
highlighter.descriptor.text.arrow=Braces and Operators//Arrow
highlighter.descriptor.text.builtin.annotation=Keywords//Modifier
highlighter.descriptor.text.builtin.keyword.val=Keywords//'val'
highlighter.descriptor.text.builtin.keyword.var=Keywords//'var'
highlighter.descriptor.text.builtin.keyword=Keywords//Keyword
highlighter.descriptor.text.captured.variable=Properties and Variables//Variables and values captured in a closure
highlighter.descriptor.text.closure.braces=Braces and Operators//Lambda expression braces and arrow
highlighter.descriptor.text.colon=Braces and Operators//Colon
highlighter.descriptor.text.constructor.call=Functions//Constructor call
highlighter.descriptor.text.double.colon=Braces and Operators//Double colon
highlighter.descriptor.text.dynamic.fun.call=Functions//Dynamic function call
highlighter.descriptor.text.dynamic.property=Properties and Variables//Dynamic property
highlighter.descriptor.text.enumEntry=Classes and Interfaces//Enum entry
highlighter.descriptor.text.exclexcl=Braces and Operators//Non-null assertion
highlighter.descriptor.text.extension.fun.call=Functions//Extension function call
highlighter.descriptor.text.extension.property=Properties and Variables//Extension property
highlighter.descriptor.text.field=Properties and Variables//Backing field variable
highlighter.descriptor.text.fun.call=Functions//Function call
highlighter.descriptor.text.fun=Functions//Function declaration
highlighter.descriptor.text.instance.property.custom.property.declaration=Properties and Variables//Instance property with custom property declarations
highlighter.descriptor.text.instance.property=Properties and Variables//Instance property
highlighter.descriptor.text.it=Parameters//Lambda expression default parameter
highlighter.descriptor.text.kdoc.comment=Comments//KDoc//KDoc comment
highlighter.descriptor.text.kdoc.tag=Comments//KDoc//KDoc tag
highlighter.descriptor.text.kdoc.value=Comments//KDoc//Link in KDoc tag
highlighter.descriptor.text.label=Label
highlighter.descriptor.text.local.variable=Properties and Variables//Local variable or value
highlighter.descriptor.text.named.argument=Named argument
highlighter.descriptor.text.object=Classes and Interfaces//Object
highlighter.descriptor.text.enum=Classes and Interfaces//Enum
highlighter.descriptor.text.package.fun.call=Functions//Package-level function call
highlighter.descriptor.text.package.property.custom.property.declaration=Properties and Variables//Package-level property with custom property declarations
highlighter.descriptor.text.package.property=Properties and Variables//Package-level property
highlighter.descriptor.text.quest=Braces and Operators//Type nullability marker
highlighter.descriptor.text.safe.access=Braces and Operators//Safe access dot
highlighter.descriptor.text.smart.cast.receiver=Smart-casts//Smart-cast implicit receiver
highlighter.descriptor.text.smart.cast=Smart-casts//Smart-cast value
highlighter.descriptor.text.smart.constant=Smart-casts//Smart constant
highlighter.descriptor.text.string.escape=String//Escape in string and template braces
highlighter.descriptor.text.suspend.fun.call=Functions//Suspend function call
highlighter.descriptor.text.synthetic.extension.property=Properties and Variables//Synthetic extension property
highlighter.descriptor.text.typeAlias=Classes and Interfaces//Type alias
highlighter.descriptor.text.var=Properties and Variables//Var (mutable variable, parameter or property)
highlighter.descriptor.text.variable.as.function.call=Properties and Variables//Variable as function call
highlighter.descriptor.text.variable.as.function.like.call=Properties and Variables//Variable as function-like call
highlighter.message.suspend.function.call=Suspend function call
highlighter.message.suspending.iteration=Suspending iteration
highlighter.name.expect.actual.line.markers=Kotlin ''expect''//''actual'' line markers
highlighter.name.dsl.markers=DSL markers
highlighter.name.implemented.declaration=Implemented declaration
highlighter.name.implementing.declaration=Implementing declaration
highlighter.name.kotlin.line.markers=Kotlin line markers
highlighter.name.multiplatform.actual.declaration=Multiplatform actual declaration
highlighter.name.multiplatform.expect.declaration=Multiplatform expect declaration
highlighter.name.overridden.declaration=Overridden declaration
highlighter.name.overriding.declaration=Overriding declaration
highlighter.notification.text.navigation.to.overriding.classes.is.not.possible.during.index.update=Navigation to overriding classes is not possible during index update
highlighter.prefix.text.has.actuals.in=Has actuals in {0} {1, choice, 0#module|1#modules}
highlighter.text.click.for.navigate=Click {0} to navigate
highlighter.text.has.functional.implementations=Has functional implementations
highlighter.text.implements=Implements
highlighter.text.in={0} in ''{1}''
highlighter.text.or.press=\ or press {0}
highlighter.text.overrides=Overrides
highlighter.title.overriding.declarations.of=Overriding Declarations Of {0}
highlighter.title.searching.for.overriding.declarations=Searching for overriding declarations
highlighter.title.searching.for.overriding.methods=Searching for overriding methods
highlighter.tool.tip.has.expect.declaration.in=Has expects in {0} {1, choice, 0#module|1#modules}
highlighter.tool.tip.marker.annotation.for.dsl=Marker annotation for DSL
highlighter.tool.tip.text.function=function
highlighter.tool.tip.text.property=property
highlighter.tool.tip.text.recursive.call=Recursive call

import.optimizer.notification.text.unused.imports.not.found=Unused imports not found
import.optimizer.progress.indicator.text.collect.imports.for=Collect imports for {0}
import.optimizer.text.import={0, choice, 0#import|2#imports}
import.optimizer.text.non.zero=Removed {0} {1}{2, choice, 0#|1#, added {2} {3}}
import.optimizer.text.zero=Rearranged imports
import.progress.text.resolve.imports=Find all imports\u2026

test.integration.button.text.cancel=Cancel
test.integration.button.text.rewrite=Rewrite
test.integration.message.text.create.test.in.the.same.source.root=Create test in the same source root?
test.integration.message.text.kotlin.class=Kotlin class ''{0}'' already exists. Do you want to update it?
test.integration.title.no.test.roots.found=No Test Roots Found

slicer.text.in=in
slicer.text.tracking.enclosing.lambda=\ (Tracking enclosing lambda)
slicer.text.tracking.lambda.calls=\ (Tracking lambda calls)
slicer.text.tracking.lambda.argument=\ (Tracking lambda parameter)
slicer.text.tracking.lambda.receiver=\ (Tracking lambda receiver)
slicer.title.dataflow.from.here=Dataflow from Here
slicer.title.dataflow.to.here=Dataflow to Here
slicer.tool.tip.text.variable.dereferenced=Variable dereferenced

script.action.text.ignore=Ignore
script.action.text.open.settings=Open Settings
script.action.text.show.all=Show all
script.name.kotlin.scripting=Kotlin Scripting
text.first.definition.that.matches.script.pattern.extension.applied.starting.from.top=The first definition that matches script pattern/extension is applied, starting from the top
status.text.no.definitions=No definitions

script.text.multiple.script.definitions.are.applicable.for.this.script=Multiple script definitions are applicable for this script. {0} is used

roots.description.text.update.source.roots.for.non.jvm.modules.in.kotlin.project=Update source roots for non-JVM modules in Kotlin project

configuration.maven.group.name=Kotlin Maven project import
configuration.message.enter.fully.qualified.method.name=Enter a fully qualified method name:
configuration.migration.group.name=Kotlin: Migrations to a newer version available
kotlin.jps.plugin.group.name=Kotlin JPS plugin
configuration.name.method=Method
configuration.status.text.installing=Installing\u2026
configuration.title.add.exclusion=Add Exclusion
configuration.title.edit.exclusion=Edit Exclusion
configuration.kotlin.code.style.group.name=Kotlin official code style available
kotlin.dist.downloading.failed.group.name=Kotlin dist downloading failed

#Refactoring
0.1.is.never.used={0} ''{1}'' is never used
0.has.detected.1.code.fragments.in.2.that.can.be.replaced.with.3={0} has detected {1} code {1,choice,1#fragment|2#fragments} in {2} that can be replaced with {3}. Would you like to review and replace {1,choice,1#it|2#them}?
0.will.become.invisible.after.extraction={0} will become invisible after extraction
0.will.no.longer.be.accessible.after.extraction={0} will no longer be accessible after extraction
action.text.append=Append
action.text.cancel=Cancel
action.text.overwrite=Overwrite
button.text.move.nested.class.0.to.upper.level=Move &nested class {0} to upper level
button.text.move.nested.class.0.to.another.class=&Move nested class {0} to another class
cannot.extract.super.call=Cannot extract super-call
cannot.inline.property.with.accessor.s.and.backing.field=Cannot inline property with accessor(s) and backing field
cannot.introduce.parameter.of.0.type=Cannot introduce parameter of type ''{0}''
cannot.refactor.expression.has.unit.type=Cannot introduce expression of unit type
cannot.refactor.no.container=Cannot refactor in this place
cannot.refactor.no.expression=Cannot perform refactoring without an expression
cannot.refactor.no.type=Cannot perform refactoring without a type
cannot.refactor.not.expression=Cannot find an expression to introduce
cannot.refactor.package.expression=Cannot introduce package reference
cannot.refactor.syntax.errors=Cannot refactor due to erroneous code
cannot.refactor.synthesized.function=Cannot refactor synthesized function
checkbox.text.declare.with.var=Declare with &var
checkbox.text.delete.empty.source.files=&Delete empty source files
checkbox.text.extension.property=E&xtension property:
checkbox.text.introduce.default.value=Introduce &default value
checkbox.text.open.moved.files.in.editor=Open moved member in editor
checkbox.text.replace.all.occurrences.0=&Replace all occurrences ({0})
checkbox.text.search.references=Search &references
checkbox.text.specify.type.explicitly=Specify &type explicitly
checkbox.text.update.package.directive=Update package directive (Kotlin files)
column.name.receiver=Receiver:
column.name.default.parameter=Default Parameter:
column.name.val.var=Val/Var
declarations.are.used.outside.of.selected.code.fragment=Following declarations are used outside of selected code fragment:
declarations.will.move.out.of.scope=Following declarations won't be available outside of extracted function body:
description.a.reference.to.extracted.type.parameter=a reference to extracted type parameter
error.cant.refactor.vararg.functions=Can't refactor the function with variable arguments
error.hint.text.cannot.inline.0.from.a.decompiled.file=Cannot inline ''{0}'' from a decompiled file
error.text.can.t.change.signature.of.method=Can''t change signature of {0} method
error.text.can.t.copy.class.to.the.containing.file=Can't copy class to the containing file
error.text.can.t.generate.0.1=Can''t generate {0}: {1}
error.text.can.t.introduce.lambda.parameter.for.this.expression=Can't introduce lambda parameter for this expression
error.text.can.t.introduce.property.for.this.expression=Can't introduce property for this expression
error.text.can.t.introduce.constant.for.this.expression.because.not.constant=Can't introduce constant for non constant expression
error.text.can.t.introduce.constant.for.this.expression=Can't introduce constant for this expression
error.text.different.name.expected=Different name expected
error.text.expression.has.no.type=Expression has no type
error.text.extraction.from.expect.class.is.not.yet.supported=Extraction from expect class is not yet supported
error.text.extraction.from.non.jvm.class.is.not.yet.supported=Extraction from non-JVM class is not yet supported
error.text.inline.function.is.not.supported.for.functions.with.multiple.return.statements=Inline Function is not supported for functions with multiple return statements.
error.text.inline.function.is.not.supported.for.functions.with.return.statements.not.at.the.end.of.the.body=Inline Function is not supported for functions with return statements not at the end of the body.
error.text.interface.cannot.be.extracted.from.an.annotation.class=Interface cannot be extracted from an annotation class
error.text.introduce.parameter.is.not.available.for.default.value=Introduce Parameter is not available for default value
error.text.introduce.parameter.is.not.available.inside.of.annotation.entries=Introduce Parameter is not available inside of annotation entries
error.text.invalid.name=Invalid name
error.text.invalid.parameter.name=Invalid parameter name
error.text.invalid.parameter.type=Invalid parameter type
error.text.invalid.receiver.type=Invalid receiver type
error.text.invalid.return.type=Invalid return type
error.text.no.type.to.refactor=No type to refactor
error.text.refactoring.is.not.applicable.in.the.current.context=Refactoring is not applicable in the current context
error.text.superclass.cannot.be.extracted.from.an.annotation.class=Superclass cannot be extracted from an annotation class
error.text.type.reference.is.expected=Type reference is expected
error.types.in.generated.function=Cannot generate function with erroneous return type
error.wrong.caret.position.function.or.constructor.name=The caret should be positioned at the name of the function or constructor to be refactored.
extract.function=Extract Function
family.name.update.usages.on.declarations.cut.paste=Update usages on declarations cut/paste
function.name.is.invalid=Function name is invalid
introduce.property=Introduce Property
introduce.type.parameter.to.declaration=Introduce type parameter to declaration
introduce.type.parameter=Introduce Type Parameter
introduce.variable=Introduce Variable
introduce.constant=Introduce Constant
label.text.default.receiver.value=&Default receiver value:
label.text.destination.directory=&Destination directory:
label.text.file.name=File &name:
label.text.introduce.as=&Introduce as:\u0020
label.text.name=&Name:
label.text.package.name=Packa&ge name:
label.text.source.sets=Source sets:
label.text.receiver.type=Receiver &type:
label.text.target.file.name=Target file name:
label.text.to.file=To &file:
label.text.to.package=To p&ackage:
label.text.to.class=To class:
label.text.to.object=To object:
label.text.package=P&ackage:
label.text.destination=&Destination:
label.text.file=&File:
class.name.prompt=Class &name:
search.for.text.occurrences=Search for &text occurrences
search.in.comments.and.strings=Search in &comments and strings
parameter.name.prompt=Parameter na&me:
pass.outer.class.instance.as.parameter=Pass &outer class' instance as a parameter
label.text.type=&Type:
label.text.move.expect.actual.counterparts=&Move expect/actual counterparts
label.text.visibility=&Visibility:
member.info.abstract.0=abstract {0}
member.info.companion.0=companion {0}
message.change.signature.is.not.applicable.to.dynamically.invoked.functions=Change signature is not applicable to dynamically invoked functions
error.hint.library.declarations.cannot.be.changed=Library declarations cannot be changed
error.hint.cannot.modify.0.declaration.from.1.file=Cannot modify ''{0}'' declaration from ''{1}'' file
message.do.not.show.for.local.variables.in.future=Do not show for local variables in future
message.text.return.type.cannot.be.resolved=Return type ''{0}'' cannot be resolved.\nContinue?
message.text.property.type.cannot.be.resolved=Property type ''{0}'' cannot be resolved.\nContinue?
message.text.property.receiver.type.cannot.be.resolved=Property receiver type ''{0}'' cannot be resolved.\nContinue?
message.type.for.cannot.be.resolved=Type ''{0}'' for {1} cannot be resolved.\nContinue?
name.extract.interface=Extract Interface
name.introduce.import.alias=Introduce Import Alias
name.introduce.lambda.parameter=Introduce Lambda Parameter
name.introduce.parameter1=Introduce Parameter
name.introduce.type.alias=Introduce Type Alias
title.kdoc.for.abstracts=KDoc For Abstracts
naming.convention.will.be.violated.after.rename=Naming conventions will be violated after rename
parameter.name.is.invalid=Parameter name ''{0}'' is invalid
parameter.type.is.invalid=Parameter type ''{0}'' is invalid
parameter.types.are.not.denotable=Cannot extract method since following types are not denotable in the target scope:
refactoring.move.non.kotlin.file=Target must be a Kotlin file
return.type.is.invalid=Return type is invalid
searching.usages.of.0.parameter=Searching usages of ''{0}''parameter
selected.code.fragment.has.multiple.exit.points=Selected code fragment has multiple exit points
selected.code.fragment.has.multiple.output.values=Selected code fragment has more than 3 output values:
selected.code.fragment.has.output.values.and.exit.points=Selected code fragment has output values as well as alternative exit points
setter.of.0.will.become.invisible.after.extraction=Setter of {0} will become invisible after extraction
text.0.already.contains.1={0} already contains {1}
text.0.already.contains.nested.class.1={0} already contains nested class named {1}
text.0.already.declared.in.1={0} is already declared in {1}
text.0.have.no.inheritors.warning={0} doesn''t have inheritors\nPushing members down will result in them being deleted. Would you like to proceed?
text.0.in.1.will.override.corresponding.member.of.2.after.refactoring={0} in {1} will override corresponding member of {2} after refactoring
text.0.inherits.from.1.it.will.not.be.affected.by.refactoring={0} inherits from {1}.\nIt won''t be affected by the refactoring
text.0.is.invalid.destination.package=''{0}'' is invalid destination package name
text.0.is.not.allowed.in.the.target.context=''{0}'' is not allowed in the target context
text.0.is.not.valid.package.name={0} is not a valid package name
text.0.to.inline={0} to inline
text.0.uses.1.which.is.not.accessible.from.2={0} uses {1}, which is not accessible from the {2}
text.0.uses.1.which.will.be.inaccessible.after.move={0} uses {1} which will be inaccessible after move
text.0.uses.1.which.will.not.be.accessible.from.subclass={0} uses {1} which won''t be accessible from the subclass.
text.0.uses.internal.1.which.will.be.inaccessible.after.move={0} uses internal {1} which will be inaccessible after move
text.0.will.be.shadowed.by.1={0} will be shadowed by {1}
text.0.will.clash.with.existing.1.in.2={0} after rename will clash with existing {1} in {2}
text.0.will.no.longer.be.accessible.after.signature.change={0} will no longer be accessible after signature change
text.all.declarations.must.belong.to.the.same.directory.or.class=All declarations must belong to the same directory or class
text.anonymous=[Anonymous]
text.at.least.one.file.must.be.selected=At least one member must be selected
text.callee.text.would.be.shown.here=Callee text would be shown here
text.caller.text.with.highlighted.callee.call.would.be.shown.here=Caller text\nwith highlighted callee call would be shown here
text.cannot.create.target.directory.0=Cannot create target directory {0}
text.cannot.determine.source.directory=Can't determine sources directory
text.cannot.find.package.corresponding.to.0=Could not find package corresponding to {0}
text.cannot.find.target.package.name=Cannot find target package name
text.cannot.move.for.current.project=Can't move for current project
text.cannot.move.inner.class.0.into.itself=Cannot move nested class {0} to itself
text.cannot.move.to.original.file=Can't move to the original file
text.cannot.move.expect.actual.declaration.to.file=Couldn't move expect/actual declaration to file
text.change.file.package.to.0=Change File''s Package To ''{0}''
text.choose.containing.file=Choose Containing File
text.class.0.already.contains.member.1={0} already contains {1}
text.class.0.already.exists.in.package.1=Class {0} already exists in package {1}
text.class.0.already.exists.in.the.target.scope=Class {0} already exists in the target scope
text.class.0.is.final={0} is final
text.constructor=constructor
text.convert._it_.to.explicit.lambda.parameter=Convert 'it' to explicit lambda parameter
text.create.destructuring.declaration=Create destructuring declaration
text.create.single.variable=Create single variable
text.declaration=declaration
text.declarations.clash.move.0.destination.1.declared.in.scope.2=Following declarations would clash: to move {0} and destination {1} declared in scope {2}
text.default.value=\ // default value = {0}
text.destination.class.should.be.kotlin.class=Destination class must be a Kotlin class
text.do.you.want.to.rename.0.as.well=Do you want to rename {0}() as well?
text.do.you.want.to.rename.base.property.from.0=Do you want to rename base property from \n{0}
text.do.you.want.to.rename.base.property=Do you want to rename base property
text.duplicating.local.variable=Duplicating local variable ''{0}''
text.duplicating.parameter=Duplicating parameter ''{0}''
text.duplicating.property=Duplicating property ''{0}''
change.signature.conflict.text.kotlin.default.value.in.non.kotlin.files=The default Kotlin call value may lead to incorrect code in other languages
change.signature.conflict.text.kotlin.default.parameter.in.non.kotlin.files=The default parameter may not be supported in other languages
text.explicit.receiver.is.already.present.in.call.element.0=Explicit receiver is already present in call element: {0}
text.extract.superclass=Extract Superclass
text.file.0.already.exists.in.1=File {0} already exists in {1}
text.file.name.cannot.be.empty=File name may not be empty
text.function.already.exists=Function already exists: ''{0}''
text.function.in.ticks.0=function ''{0}''
text.function=function
text.function.0={0,choice,1#function|2#functions}
text.anonymous.function=anonymous function
text.implicit.companion.object.will.be.inaccessible.0=Implicit companion object will be inaccessible: {0}
text.incorrect.target.path.directory.0.does.not.belong.to.current.project=Incorrect target path. Directory {0} does not belong to current project.
text.indirect.outer.instances.will.not.be.extracted.0=Indirect outer instances won''t be extracted: {0}
text.inline.0=Inline {0}
text.inline.all.references.and.verb.0.the.kind.1.occurrences.2=Inline all references and {0} the {1} {2}
text.inline.recursive.function.is.supported.only.on.references=Inline recursive function is supported only on references
text.inline.function.not.supported=Inline function is not supported yet
text.inline.this.reference.and.keep.the.0=Inline this reference and keep the {0}
text.inlining.0.1=Inlining {0} {1}
text.inlined.0.overrides.0.1=Inlined {0} overrides {0} {1}
text.inner.class.0.cannot.be.moved.to.interface={0} is an inner class. It can not be moved to the interface
text.introduce.default.value=Intro&duce default value
text.invalid.target.path.0=Invalid target path {0}
text.invalid.target.specified=Invalid target specified
text.keep=keep
text.lambda.parameter=lambda parameter
text.lambda.parameters=Lambda &parameters:\u0020
text.lambda.return.type=Lambda return &type
text.lazy.property=lazy property
text.local.property=property
text.local.variable=local variable
text.looking.for.usages=Looking for Usages
text.member.0.in.super.class.will.clash.with.existing.member.of.1={0} in super class would clash with existing member of {1}
text.member.extension.call.will.not.be.processed.0=Member extension call won''t be processed: {0}
text.move.declaration.no.support.for.companion.objects=Move declaration is not supported for companion objects
text.move.declaration.no.support.for.enums=Move declaration is not supported for enum entries
text.move.file.no.support.for.file.target=Move files is not supported for non-directory target
text.move.declaration.no.support.for.nested.declarations=Move declaration is not supported for nested declarations
text.move.declaration.no.support.for.multi.file=Moving declarations from different files is not supported
text.move.declaration.supports.only.top.levels.and.nested.classes=Move declaration is only supported for top-level declarations and nested classes
text.move.declaration.proceed.move.without.mpp.counterparts.text=This refactoring will move selected declaration without its expect/actual counterparts that may lead to compilation errors.\nDo you wish to proceed?
text.move.declaration.proceed.move.without.mpp.counterparts.title=Cannot Perform Refactoring. MPP Declarations Are Not Supported By This Refactoring.
text.move.declarations=Move declarations
command.move.declarations=Move Declarations
preparing.move.descriptor=Preparing move descriptor
text.no.destination.object.specified=No destination object specified
title.select.a.name.for.this.parameter=Select A Name For ''this@{0}'' Parameter
text.move.method.is.not.supported.for.non.project.methods=Move method is not supported for non-project methods
text.move.method.is.not.supported.for.generic.classes=Move method is not supported for generic classes
text.move.method.is.not.supported.when.method.is.a.part.of.inheritance.hierarchy=Move method is not supported when method is a part of inheritance hierarchy
text.references.to.outer.classes.have.to.be.added.manually=References to outer classes will have to be added manually after move
action.move.method=Move Method\u2026
text.move.file.0=Move {0}
text.move.refactoring.not.available.during.indexing=Move refactoring is not available while indexing is in progress
text.moving.multiple.nested.classes.to.top.level.not.supported=Moving multiple nested classes to top-level is not supported
text.Name=Name
text.nested.classes.to.upper.level=Nested Classes to Upper Level
text.no.elements.to.move.are.selected=No elements to move are selected
text.no.files.to.move=There are no given files to move
text.no.name.provided.for.type.alias=No name provided for type alias
text.no.package.corresponds.to.directory=No package corresponds to this directory
text.non.kotlin.0.will.not.be.affected.by.refactoring=Non-Kotlin {0} won''t be affected by the refactoring
text.overload=Overload
text.package.directive.dont.match.file.location=Package directive does not match the file location
text.parameter.0=parameter ''{0}''
text.parameter.name=Parameter &name:\u0020
text.parameter.reference.can.t.be.safely.replaced.with.0.since.1.is.ambiguous.in.this.context=Parameter reference can''t be safely replaced with {0} since {1} is ambiguous in this context
text.parameter.reference.can.t.be.safely.replaced.with.0.since.target.function.can.t.be.referenced.in.this.context=Parameter reference can''t be safely replaced with {0} since target function can''t be referenced in this context
text.parameter.type=Parameter &type:\u0020
text.parameter=Parameter
text.parameters=&Parameters
text.proceed.with.extraction=Proceed with extraction anyway
text.process.duplicates=Process Duplicates
text.processing.file.0=Processing {0}
text.property.in.ticks.0=property ''{0}''
text.property.with.getter=property with getter
text.property.with.initializer=property with initializer
text.property=property
text.property.0={0,choice,1#property|2#properties}
text.pushed.member.will.not.be.available.in.0=Pushed member won''t be available in ''{0}''
text.qualified.call.will.not.be.processed.0=Qualified call won''t be processed: {0}
text.receiver.can.t.be.safely.transformed.to.value.argument=Receiver can''t be safely transformed to value argument: {0}
text.receiver=receiver
text.refactoring.can.t.be.performed.on.the.selected.code.element=Refactoring can't be performed on the selected code element
text.refactoring.is.not.applicable.to.this.code.fragment=Refactoring is not applicable to this code fragment
text.references.in.code.to.0.1.and.its.declarations=References in code to {0} {1} and its declarations
text.remove.0.no.longer.used=Remove {0} no longer used
text.remove.question=Remove '?'
text.remove=remove
text.rename.as.part.of.phrase=rename
text.rename.is.not.applicable.to.secondary.constructors=Rename is not applicable to secondary constructors
text.rename.is.not.applicable.to.synthetic.declarations=Rename is not applicable to synthetic declaration
text.rename.is.not.applicable.to.compiler.plugin.generated.declarations=Rename is not applicable to compiler plugin-generated declaration
text.rename.not.applicable.to.backing.field.reference=Rename is not applicable to backing field reference
text.rename.not.applicable.to.dynamically.invoked.methods=Rename is not applicable to dynamically invoked members
text.rename.overloads.title=Rename Overloads
title.rename.overloads.to=Rename Overloads To:
text.rename.parameters.title=Rename Parameters
title.rename.warning=Rename Warning

text.0.1.must.be.moved.with.sealed.parent.class.and.all.its.subclasses={0} ''{1}'' must be moved with sealed parent class and all its subclasses
text.sealed.class.0.must.be.moved.with.all.its.subclasses=Sealed class ''{0}'' must be moved with all its subclasses

text.sealed.broken.hierarchy.none.in.target=Sealed hierarchy of ''{0}'' would be split. None of its members reside in the package ''{1}'' of module ''{2}'': {3}.
text.sealed.broken.hierarchy.still.in.source=Sealed hierarchy of ''{0}'' would be split. Package ''{1}'' of module ''{2}'' would still contain its members: {3}.

text.expected.moved.to.platform.modules.target=Expected declaration ''{0}'' would be moved to a platform module.
text.actual.moved.to.common.modules.target=Actual declaration ''{0}'' would be moved to a common module.

text.select.target.code.block.file=Select target code block / file
text.select.target.code.block=Select target code block
text.select.target.file=Select target file
text.there.is.already.a.parameter=There is already a parameter ''{0}'' in {1}. It will conflict with the new parameter.
text.there.is.already.a.variable.0.in.1.it.will.conflict.with.the.new.parameter=There is already a variable ''{0}'' in {1}. It will conflict with the new parameter.
text.type.alias.cannot.refer.to.types.which.aren.t.accessible.in.the.scope.where.it.s.defined=Type alias cannot refer to types which aren't accessible in the scope where it's defined
text.type.alias.name.must.be.a.valid.identifier.0=Type alias name must be a valid identifier: {0}
text.type.alias=type alias
text.type.alias.0=type {0,choice,1#alias|2#aliases}
text.type.already.exists.in.the.target.scope=Type {0} already exists in the target scope
text.type.parameter.names.must.be.distinct=Type parameter names must be distinct
text.type.parameters=Type &Parameters
text.type=Type
text.unexpected.element.type.0=Unexpected element type: {0}
text.update.usages.to.reflect.declaration.0.move=Update usages to reflect {0, choice, 0#declaration|1#declarations} move
text.updating.usages.progress=Updating usages\u2026
text.cannot.inline.reference.from.0.to.1=Cannot inline reference from {0} to {1}
title.inline.function=Inline Function
title.inline.property=Inline Property
title.inline.type.alias=Inline Type Alias
refactoring.cannot.be.applied.no.sources.attached={0} refactoring cannot be applied: no sources attached
refactoring.cannot.be.applied.to.abstract.declaration={0} refactoring cannot be applied to abstract declaration
refactoring.cannot.be.applied.to.expect.declaration={0} refactoring cannot be applied to expect declaration
refactoring.cannot.be.applied.to.anonymous.function.without.invocation={0} refactoring cannot be applied to anonymous function without invocation
refactoring.the.function.not.found=The function not found
refactoring.the.function.cannot.be.converted.to.anonymous.function=The function cannot be converted to an anonymous function
refactoring.the.invocation.cannot.be.resolved=The invocation call cannot be resolved
refactoring.cannot.be.applied.to.lambda.expression.without.invocation={0} refactoring cannot be applied to lambda expression without invocation
text.reference.cannot.be.converted.to.a.lambda=The reference cannot be converted to a lambda
title.introduce.parameter.to.declaration=Introduce parameter to declaration
title.move.nested.classes.to.upper.level=Move Nested Classes to Upper Level
title.move.method=Move Method
title.choose.destination.object=Choose Destination Object
title.select.target.code.block=Select Target Code Block
unsupported.usage.0=Unsupported usage: {0}
parameter.used.in.declaration.body.warning=''{0}'' is used in declaration body

do.you.want.to.delete.this.parameter.in.expected.declaration.and.all.related.actual.ones=Do you want to delete this parameter in expected declaration and all related actual ones?
do.you.want.to.delete.expected.declaration.together.with.all.related.actual.ones=Do you want to delete expected declaration together with all related actual ones?
delete.with.usage.search=delete (with usage search)

destination.not.found.for.package.0=Destination not found for package ''{0}''
premature.end.of.template=Premature end of template
choose.target.class.or.interface=Choose target class or interface
text.abstract=abstract
text.secondary.constructor=secondary constructor
text.create=Create
text.member=member
text.extension=extension
text.extension.function=extension function
text.extension.function.0=extension {0,choice,1#function|2#functions}
text.extension.property=extension property
text.extension.property.0=extension {0,choice,1#property|2#properties}
text.operator.0={0,choice,1#operator|2#operators}
text.object=object
text.object.0={0,choice,1#object|2#objects}
text.interface=interface
text.enum.constant=enum constant
text.enum=enum
text.annotation=annotation
create.0.1=Create {0} ''{1}''
choose.class.container=Choose class container
create.0=Create {0}
create.package.0=Create package ''{0}''
text.type.parameter=type {0, choice, 0#parameter|2#parameters}
create.0.in.1=Create {0} in {1}
searching.0=Searching {0}\u2026
create.property.0.as.constructor.parameter=Create property ''{0}'' as constructor parameter
create.parameter.0=Create parameter ''{0}''
quickfix.add.property.familyName=Add property
quickFix.add.property.text=Add ''{0}{1}'' property ''{2}'' to ''{3}''
add.method=Add method
add.0.constructor.to.1=Add {0} constructor to ''{1}''
text.secondary=secondary
text.primary=primary
add.method.0.to.1=Add method ''{0}'' to ''{1}''
create.actual.0.for.module.1.2=Create actual {0} for module {1} ({2})
create.expected.0.in.common.module.1=Create expected {0} in common module {1}
repair.actual.members=Repair actual members
these.declarations.cannot.be.transformed=These declarations cannot be transformed:
unknown.types.title=Unknown Types
choose.actual.members.title=Choose Actual Members
text.annotation.class=annotation class
text.enum.class=enum class
text.class=class
text.class.0={0,choice,1#class|2#classes}
type.0.1.is.not.accessible.from.target.module={0, choice, 0#Type|2#Types} {1} is not accessible from target module
the.function.declaration.shouldn.t.have.a.default.implementation=The function declaration shouldn't have a default implementation
some.types.are.not.accessible.from.0.1=Some types are not accessible from {0}:\n{1}
the.declaration.has.0.modifier=The declaration has ''{0}'' modifier
inaccessible.declaration=Inaccessible Declaration
fix.with.asdynamic=Fix with 'asDynamic'
migrate.type.parameter.list.syntax=Migrate type parameter list syntax
replace.deprecated.symbol.usage=Replace deprecated symbol usage
replace.with.0=Replace with ''{0}''
there.is.own.replacewith.on.0.that.is.used.through.this.alias.please.replace.usages.first=There is own ''ReplaceWith'' on ''{0}'' that is used through this alias. Please replace usages first.
replace.deprecated.symbol.usage.in.whole.project=Replace deprecated symbol usage in whole project
applying.0=Applying ''{0}''
replace.usages.of.0.in.whole.project=Replace usages of ''{0}'' in whole project
replace.with.publishedapi.bridge.call=Replace with @PublishedApi bridge call
replace.with.generated.publishedapi.bridge.call.0=Replace with generated @PublishedApi bridge call ''{0}''
convert.sealed.subclass.to.object.fix.family.name=Convert sealed subclass to object
progress.looking.up.sealed.subclass.usage=Looking up sealed subclass usage\u2026
generate.identity.equals.fix.family.name=Generate equals \\& hashCode by identity
change.type.of.0.to.1=Change type of {0} to ''{1}''
change.type.to.0=Change type to ''{0}''
base.property.0=base property {0}
make.0=Make {0}
make.0.1.explicitly=Make ''{0}'' {1} explicitly
make.0.explicitly=Make {0} explicitly
use.inherited.visibility=Use inherited visibility
replace.with.in.when=Replace ',' with '||' in when
remove.0=Remove ''.{0}''
remove.conversion.from.kclass.to.class=Remove conversion from 'KClass' to 'Class'
convert.from.class.to.kclass=Convert 'KClass' to 'Class'
convert.to.0=Convert to {0}
replace.with.arrayof=Replace with 'arrayOf'
convert.expression.to.0.by.inserting.1=Convert expression to ''{0}'' by inserting ''.{1}''
convert.extension.property.initializer.to.getter=Convert extension property initializer to getter
convert.supertype.to.0=Convert supertype to ''{0}''
convert.extension.function.type.to.regular.function.type=Convert extension function type to regular function type
convert.to.notnull.delegate=Convert to notNull delegate
convert.to.anonymous.object=Convert to anonymous object
select.loop.statement.to.label=Select loop statement to label
select.lambda.to.label=Select lambda to label
create.label=Create label
create.label.0=Create label {0}@
convert.member.to.extension=Convert member to extension
replace.annotation=Replace annotation
replace.annotation.with.0=Replace annotation with {0}
add.initializer=Add initializer
move.to.constructor.parameters=Move to constructor parameters
initialize.with.constructor.parameter=Initialize with constructor parameter
initialize.with.constructor.parameter.analyzing.existing.variables=Analyzing Existing Variables\u2026
inline.type.parameter=Inline type parameter
insert.explicit.delegation.call=Insert explicit delegation call
the.anonymous.object=the anonymous object
text.implement=implement
text.extend=extend
let.0.1=Let {0} {1}
let.type.implement.interface=Let type implement interface
0.interface.1={0} interface ''{1}''
lift.assignment.out.of.try.expression=Lift assignment out of 'try' expression
make.class.an.annotation.class=Make class an annotation class
make.0.an.annotation.class=Make ''{0}'' an annotation class
make.constructor.parameter.a.property.0=Make constructor parameter a property{0}
in.class.0=\ in class ''{0}''
add.an.opt.in.requirement.marker.compiler.argument=Add an opt-in requirement marker compiler argument
make.0.in.1.open=Make ''{0}'' in {1} open
add.modifier=Add modifier
make.private.and.0.1=Make private and {0} ''{1}''
text.overrides=overrides
text.implements=implements
make.type.parameter.reified.and.function.inline=Make type parameter reified and function inline
change.all.usages.of.0.in.this.file.to.1=Change all usages of ''{0}'' in this file to ''{1}''
change.all.usages.of.0.in.this.file.to.a.kotlin.class=Change all usages of ''{0}'' in this file to a Kotlin class
change.to.kotlin.class=Change to Kotlin class
choose.an.appropriate.kotlin.class=Choose an appropriate Kotlin class
add.empty.brackets.after.primary.constructor=Add empty brackets after primary constructor
add.constructor.keyword=Add 'constructor' keyword
move.annotation.to.receiver.type=Move annotation to receiver type
move.type.parameter.constraint.to.where.clause=Move type parameter constraint to 'where' clause
move.else.branch.to.the.end=Move else branch to the end
insert.number.conversion=Insert number conversion
convert.expression.to.0=Convert expression to ''{0}''
remove.from.annotation.argument=Remove @ from annotation argument
remove.default.parameter.value=Remove default parameter value
remove.final.upper.bound=Remove final upper bound
remove.function.body=Remove function body
make.0.not.1=Make {0} not {1}
remove.modifier.fix=Make ''{0}'' not {1}
remove.modifier.fix.family=Make not {0}
remove.0.modifier=Remove ''{0}'' modifier
remove.modifier=Remove modifier
remove.identifier.from.anonymous.function=Remove identifier from anonymous function
remove.constructor.call=Remove constructor call
make.not.nullable=Make not-nullable
remove.useless=Remove useless '?'
remove.redundant=Remove redundant '?'
remove.0.from.property=Remove {0} from property
remove.parts.from.property=Remove parts from property
text.initializer=initializer
text.setter=setter
text.getter=getter
remove.element=Remove element
for.0=for ''{0}''
remove.conflicting.import.0=Remove conflicting import {0}
remove.type.parameters=Remove type parameters
remove.type.arguments=Remove type arguments
remove.star=Remove '*'
remove.variable=Remove variable
remove.variable.0=Remove variable ''{0}''
remove.redundant.initializer=Remove redundant initializer
remove.redundant.label=Remove redundant label
remove.single.lambda.parameter.declaration=Remove single lambda parameter declaration
remove.supertype=Remove supertype
remove.0.variance.from.1=Remove ''{0}'' variance from ''{1}''
remove.parameter.0=Remove parameter ''{0}''
remove.redundant.assignment=Remove redundant assignment
there.are.possible.side.effects.found.in.expressions.assigned.to.the.variable.0=There are possible side effects found in expressions assigned to the variable ''{0}''<br>You can:<br>-\\&nbsp;<b>Remove</b> the entire assignment, or<br>-\\&nbsp;<b>Transform</b> assignment right-hand side into the statement on its own.<br>
remove.useless.cast=Remove useless cast
remove.useless.elvis.operator=Remove useless elvis operator
remove.useless.is.check=Remove useless is check
remove.val.or.var.from.parameter=Remove 'val' or 'var' from parameter
remove.0.from.parameter=Remove ''{0}'' from parameter
remove.else.branch=Remove else branch
remove.branch=Remove branch
remove.condition=Remove condition
rename.identifier.fix.text=Rename
rename.to.0=Rename to ''{0}''
rename.parameter.to.match.overridden.method=Rename parameter to match overridden method
rename.to.underscore=Rename to _
replace.with.safe.this.call=Replace with safe (this?.) call
replace.with.safe.call=Replace with safe (?.) call
replace.scope.function.with.safe.call=Replace scope function with safe (?.) call
replace.with.dot.call=Replace with dot call
replace.invalid.positioned.arguments.for.annotation=Replace invalid positioned arguments for annotation
replace.jvmfield.with.const=Replace '@JvmField' with 'const'
replace.modifier=Replace modifier
update.obsolete.label.syntax=Update obsolete label syntax
replace.with.label.0.at=Replace with label {0}@
replace.cast.with.call.to.to.0=Replace cast with call to ''to{0}()''
replace.cast.with.primitive.conversion.method=Replace cast with primitive conversion method
replace.with.array.call=Replace with array call
remove.expression.target=Remove EXPRESSION target
change.existent.retention.to.source=Change existing retention to SOURCE
add.source.retention=Add SOURCE retention
round.using.0=Round using {0}()
simplify.0.to.1=Simplify ''{0}'' to ''{1}''
simplify.comparison=Simplify comparison
specify.override.for.0.explicitly=Specify override for ''{0}'' explicitly
specify.override.explicitly=Specify override explicitly
specify.return.type.explicitly=Specify return type explicitly
specify.type.explicitly=Specify type explicitly
add.constructor.parameters.from.0.1=Add constructor parameters from {0}{1}
change.to.constructor.invocation=Change to constructor invocation
add.constructor.parameters.from.superclass=Add constructor parameters from superclass
surround.with.array.of=Surround with arrayOf(...)
surround.with.star.0=Surround with *{0}(...)
surround.with.0=Surround with {0}(...)
surround.with.lambda=Surround with lambda
surround.with.null.check=Surround with null check
convert.too.long.character.literal.to.string=Convert too long character literal to string
replace.array.of.boxed.with.array.of.primitive=Replace array of boxed with array of primitive
migrate.unsupported.yield.syntax=Migrate unsupported yield syntax
wrap.with=Wrap with []
wrap.with.array.literal=Wrap with array literal
wrap.with.collection.literal.call=Wrap with collection literal call
wrap.element.with.0.call=Wrap element with ''{0}()'' call
replace.with.0.call=Replace with ''{0}()'' call
wrap.with.let.call=Wrap with '?.let { ... }' call
change.to.0=Change to ''{0}''
change.to.correct.long.suffix.l=Change to correct long suffix 'L'
change.to.correct.primitive.type=Change to correct primitive type
0.from.1={0} from {1}
checking.data.classes=Checking data classes
checking.data.class.0.of.1=Checking data class {0} of {1}\u2026
difference.found.for.data.class.0.found.1.2=Difference found for data class {0}. Found {1} usage(s) but {2} expected
title.error=Error
analyzed.0.classes.no.difference.found=Analyzed {0} classes. No difference found.
title.success=Success
can.t.finish.while.indexing.is.in.progress=Can't finish while indexing is in progress
progress.finding.implicit.nothing.s=Finding implicit nothing's
scanning.files.0.fo.1.file.2.occurrences.found=Scanning files: {0} of {1} file. {2} occurrences found
implicit.nothing.s=Implicit Nothing's
not.found.in.0.files=Not found in {0} file(s)
titile.not.found=Not Found
search.for.not.property.candidates=Search For Not Property Candidates
enter.package.fqname=Enter package FqName
searching.for.not.property.candidates=Searching for Not Property candidates
step.1.collecting.0.1.2=Step 1: Collecting {0}:{1}:{2}
step.2.0.of.1=Step 2: {0} of {1}
step.3.0.of.1=Step 3: {0} of {1}
title.done=Done
revert.applied.imports.command=Revert Applied Imports
delete.0=delete {0}
replace.if.expression.with.elvis.expression=Replace 'if' expression with elvis expression
report.also.on.statement=Report also on statement
if.then.foldable.to=If-Then foldable to '?:'
replace.if.expression.with.safe.access.expression=Replace 'if' expression with safe access expression
remove.redundant.if.expression=Remove redundant 'if' expression
replace.if.expression.with.safe.cast.expression=Replace 'if' expression with safe cast expression
simplify.foldable.if.then=Simplify foldable if-then
foldable.if.then=Foldable if-then
introduce.when.subject=Introduce 'when' subject
when.with.subject.should.be.used='when' with subject should be used
introduce.0.as.subject.0.when=Introduce ''{0}'' as subject of ''when''
convert.call.chain.into.sequence.fix.text=Convert call chain into 'Sequence'
call.chain.length.to.transform=Call chain length to transform:
call.chain.on.collection.could.be.converted.into.sequence.to.improve.performance=Call chain on a collection could be converted into 'Sequence' to improve performance
remove.redundant.call.fix.text=Remove redundant call
rename.useless.call.fix.text=Change call to ''{0}''
call.chain.on.collection.type.may.be.simplified=Call chain on a collection type may be simplified
0.call.could.be.simplified.to.1={0} call could be simplified to {1}
simplify.call.fix.text=Convert ''{0}'' call to ''{1}''
simplify.call.chain.fix.text=Merge call chain to ''{0}''
call.on.collection.type.may.be.reduced=Call on collection type may be reduced
useless.call.on.collection.type=Useless call on collection type
this.call.is.useless.with=This call is useless with ?.
useless.call.on.not.null.type=Useless call on not-null type
call.on.not.null.type.may.be.reduced=Call on not-null type may be reduced
replace.total.order.equality.with.ieee.754.equality=Replace total order equality with IEEE 754 equality
replace.with.binary.operator=Replace with binary operator
call.replaceable.with.binary.operator=Call can be replaced with binary operator
replace.get.or.set.call.with.indexing.operator=Replace get or set call with indexing operator
should.be.replaced.with.indexing=Should be replaced with indexing
explicit.0.call=Explicit ''{0}'' call
replace.0.call.with.indexing.operator=Replace ''{0}'' call with indexing operator
function.returning.0.with.a.name.that.does.not.end.with.1=Function returning {0} with a name that does not end with {1}
add.call.or.unwrap.type.fix.text=Add ''.{0}()'' to function result (breaks use-sites!)
add.call.or.unwrap.type.fix.text1=Unwrap ''{0}'' return type (breaks use-sites!)
reports.only.function.calls.from.kotlinx.coroutines=Report only function calls from 'kotlinx.coroutines'
deferred.result.is.never.used='Deferred' result is unused
function.0.returning.1.without.the.corresponding=Function ''{0}'' returning ''{1}'' without the corresponding function ''{2}'' returning ''{3}''
redundant.async.call.may.be.reduced.to.0=Redundant ''async'' call may be reduced to ''{0}''
redundant.runcatching.call.may.be.reduced.to.0=Redundant ''runCatching'' call may be reduced to ''{0}''
rename.to.fix.text=Rename to ''{0}''
rename.only.current.0=Rename only current {0,choice,1#function|2#property}
rename.base.0=Rename base {0,choice,1#function|2#property|3#member|4#method|11#functions|12#properties|13#members|14#methods}
rename.declaration.title.0.implements.1.2.of.3={0} {1,choice,1#implements|2#overrides} {2} of {3}
rename.searching.for.all.overrides=Searching for all overrides
rename.searching.for.super.declaration=Searching for the deepest super declaration
title.rename.file=Rename File
file.entity=File
rename.file=Rename file
rename.file.0=Rename File to ''{0}''
title.rename.file.to=Rename File To:
wrap.with.coroutine.scope.fix.text=Wrap function body with 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text2=Wrap call with 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.text3=Remove receiver \\& wrap with 'coroutineScope { ... }'
wrap.with.coroutine.scope.fix.family.name=Wrap with coroutineScope
ambiguous.coroutinecontext.due.to.coroutinescope.receiver.of.suspend.function=Ambiguous coroutineContext due to CoroutineScope receiver of suspend function
replace.with.kotlin.analog.function.family.name=Replace with Kotlin analog
should.be.replaced.with.kotlin.function=Should be replaced with Kotlin function
quickfix.text.suffix.may.change.semantics=\ (may change semantics)
replace.with.kotlin.analog.function.text=Replace with ''{0}'' function
add.documentation.fix.text=Add documentation
missing.documentation=Missing documentation
0.is.missing.documentation={0} is missing documentation
it.s.prohibited.to.call.0.with.min.value.step.since.1.3=It''s prohibited to call {0} with MIN_VALUE step since 1.3
obsolete.coroutine.usage.in.whole.fix.family.name=Fix experimental coroutines usages in the project
obsolete.kotlin.js.packages.usage.in.whole.fix.family.name=Fix 'kotlin.dom' and 'kotlin.browser' packages usages in the project
apply.in.the.project.0=Apply in the project: {0}
obsolete.coroutine.usage.fix.family.name=Fix experimental coroutines usage
obsolete.package.usage.fix.family.name=Fix ''{0}'' package usage
0.is.expected.to.be.used.since.kotlin.1.3=''{0}'' is expected to be used since Kotlin 1.3
methods.are.absent.in.coroutines.class.since.1.3=Methods are absent in coroutines class since 1.3
experimental.coroutines.usages.are.obsolete.since.1.3=Experimental coroutines usages are obsolete since 1.3
package.usages.are.obsolete.since.1.4=''{0}'' package usages are obsolete since 1.4
replace.substring.call.with.droplast.call=Replace 'substring' call with 'dropLast' call
replace.substring.call.with.indexing.operation.call=Replace 'substring' call with indexing operation call
replace.substring.call.with.substringbefore.call=Replace 'substring' call with 'substringBefore' call
replace.substring.call.with.substringafter.call=Replace 'substring' call with 'substringAfter' call
replace.substring.call.with.take.call=Replace 'substring' call with 'take' call
add.operator.modifier=Add 'operator' modifier
function.should.have.operator.modifier=Function should have 'operator' modifier
type.parameter.can.have.0.variance=Type parameter can have ''{0}'' variance
add.variance.fix.text=Add ''{0}'' variance
add.variance.fix.family.name=Add variance
interface.member.dependency.required.by.interfaces=required by {0,choice,1#interface|2#interfaces}
generate.equals.and.hashcode.fix.text=Generate equals() and hashCode()
array.property.in.data.class.it.s.recommended.to.override.equals.hashcode=Property with 'Array' type in a 'data' class: it is recommended to override 'equals()' and 'hashCode()'
report.also.on.call.with.single.boolean.literal.argument=Report also on call with single boolean literal argument
boolean.literal.argument.without.parameter.name=Boolean literal argument without a parameter name
constructor.parameter.is.never.used.as.a.property=Constructor parameter is never used as a property
property.is.explicitly.assigned.to.parameter.0.can=Property is explicitly assigned to parameter {0}, so it can be declared directly in the constructor
variable.is.never.modified.and.can.be.declared.immutable.using.val=Variable is never modified, so it can be declared using 'val'
sealed.sub.class.has.no.state.and.no.overridden.equals='sealed' subclass has no state and no overridden 'equals()'
cascade.if.should.be.replaced.with.when=Cascade 'if' should be replaced with 'when'
mark.as.deprecated.level.deprecationlevel.hidden=Mark as '@Deprecated(..., level = DeprecationLevel.HIDDEN)'
searching.for.imports.to.delete.title=Searching For Imports To Delete
delete.redundant.extension.property=Delete redundant extension property
this.property.conflicts.with.synthetic.extension.and.should.be.removed.or.renamed.to.avoid.breaking.code.by.future.changes.in.the.compiler=Property conflicts with a synthetic extension and should be removed or renamed to avoid breaking code by future versions of the Kotlin compiler
condition.is.always.0=Condition is always ''{0}''
remove.fix.text=Delete expression
simplify.fix.text=Simplify expression
0.has.empty.body=''{0}'' has empty body
convert.na.n.equality.quick.fix.text=Replace with 'isNaN()'
equality.check.with.nan.should.be.replaced.with.isnan=Equality check with NaN should be replaced with 'isNaN()'
convert.pair.constructor.to.to.fix.text=Replace with infix 'to'
can.be.converted.to.to=Explicit 'Pair' initiation can be replaced with an infix 'to()' call
convert.to.a.range.check=Convert to a range check
two.comparisons.should.be.converted.to.a.range.check=Two comparisons should be converted to a range check
copy.method.of.data.class.is.called.without.named.arguments=Parameter names should be specified explicitly for the 'copy()' method call
private.data.class.constructor.is.exposed.via.the.generated.copy.method=Private primary constructor is exposed via the generated 'copy()' method of a 'data' class.
remove.var.keyword.text=Remove 'var'
delegating.to.var.property.does.not.take.its.changes.into.account=Delegating to 'var' property does not take its changes into account
add.replacewith.argument.to.specify.replacement.pattern=Add 'replaceWith' argument to specify the replacement pattern
deprecated.annotation.without.replacewith.argument='@Deprecated' annotation without a 'replaceWith' argument
variable.name.0.matches.the.name.of.a.different.component=Variable name ''{0}'' matches the name of a different component
this.range.is.empty.did.you.mean.to.use.0=This range is empty. Did you mean to use ''{0}''?
this.range.is.empty=This range is empty.
until.can.be.replaced.with.rangeUntil.operator='until' can be replaced with '..<' operator
equals.hashcode.in.object.declaration='equals()'/'hashCode()' in object declaration
hash.code.text=Generate 'hashCode()'
equals.text=Generate 'equals()'
specify.super.type=Specify super type ''{0}'' explicitly
delete.equals.and.hash.code.fix.text=Delete equals()/hashCode()
redundant.explicit.this=Redundant explicit this
explicit.this.expression.fix.family.name=Remove redundant ''{0}''
use.of.non.const.kotlin.property.as.java.constant.is.incorrect.will.be.forbidden.in.1.4=Use of non-const Kotlin property as Java constant is incorrect. Will be forbidden in 1.4
replace.if.with.elvis.operator=Replace 'if' with elvis operator
if.null.return.break.foldable.to=If-Null return/break/... foldable to '?:'
loop.parameter.0.is.unused=Loop parameter ''{0}'' is unused
replace.with.repeat.fix.family.name=Replace with 'repeat()'
introduce.anonymous.parameter.fix.family.name=Introduce anonymous parameter
wrap.run.fix.text=Convert to run { ... }
remove.braces.fix.text=Remove braces
report.for.types.with.platform.arguments=Report for types with platform arguments
apply.only.to.public.or.protected.members=Apply only to public or protected members
declaration.has.type.inferred.from.a.platform.call.which.can.lead.to.unchecked.nullability.issues=Declaration has type inferred from a platform call, which can lead to unchecked nullability issues. Specify type explicitly as nullable or non-nullable.
callable.reference.fix.family.name=Add explicit ''{0}''
java.collections.static.method.call.should.be.replaced.with.kotlin.stdlib=Java Collections static method call should be replaced with Kotlin stdlib
replace.with.std.lib.fix.text=Replace with {0}.{1}
call.of.java.mutator.0.on.immutable.kotlin.collection.1=Call of Java mutator ''{0}'' on immutable Kotlin collection ''{1}''
replace.with.kotlin.s.foreach=Replace with Kotlin's forEach
java.map.foreach.method.call.should.be.replaced.with.kotlin.s.foreach=Java Map.forEach method call should be replaced with Kotlin's forEach
remove.deprecated.symbol.import=Remove deprecated symbol import
usage.of.redundant.or.deprecated.syntax.or.deprecated.symbols=Usage of redundant or deprecated syntax or deprecated symbols
equals.should.take.any.as.its.argument='equals' should take 'Any?' as its argument
double.negation.fix.text=Remove redundant negations
redundant.double.negation=Redundant double negation
equals.between.objects.of.inconvertible.types='equals()' between objects of inconvertible types
usage.of.kotlin.internal.declaration.from.different.module=Usage of Kotlin internal declaration from different module
inheritance.of.kotlin.sealed=Java {0,choice,0#interface|1#class} cannot be a part of Kotlin sealed hierarchy
junit.static.methods=JUnit static methods
redundant.override.fix.text=Remove redundant overriding method
redundant.overriding.method=Redundant overriding method
throwable.instance.0.is.not.thrown=Throwable instance ''{0}'' is not thrown
result.of.0.call.is.not.thrown=Result of ''{0}'' call is not thrown
optimize.imports=Optimize imports
unused.import.directive=Unused import directive
title.lateinit.var.overrides.lateinit.var='lateinit var' overrides super 'lateinit var'
leaking.this.in.constructor.of.non.final.class.0=Leaking ''this'' in constructor of non-final class {0}
leaking.this.in.constructor.of.enum.class.0.with.overridable.members=Leaking ''this'' in constructor of enum class {0} (with overridable members)
accessing.non.final.property.0.in.constructor=Accessing non-final property {0} in constructor
calling.non.final.function.0.in.constructor=Calling non-final function {0} in constructor
text.can=can
text.should=should
text.Assignment=Assignment
text.Return=Return
text.return=return
0.1.be.lifted.out.of.2=''{0}'' can be lifted out of ''{1}''
lift.assignment.out.fix.text.0=Lift assignment out of ''{0}''
lift.return.out.fix.text.0=Lift return out of ''{0}''
change.main.function.return.type.to.unit.fix.text=Add explicit Unit return type
change.main.function.return.type.to.unit.fix.text2=Change return type to Unit
0.should.return.unit={0} should return Unit
map.get.with.not.null.assertion.operator='map.get()' with not-null assertion operator '(!!)'
replace.with.get.or.else.fix.text=Replace with 'getOrElse' call
replace.with.get.value.call.fix.text=Replace with 'getValue' call
replace.with.elvis.error.fix.text=Replace with '?: error("")'
might.be.const=Might be 'const'
const.might.be.used.instead.of.jvmfield='const' might be used instead of '@JvmField'
text.Function=Function
text.Property=Property
0.1.could.be.private={0} ''{1}'' could be private
diagnostic.name.should.be.replaced.by.the.new.one=Diagnostic name should be replaced by the new one
replace.diagnostic.name.fix.text={0} with {1}
replace.diagnostic.name.fix.family.name=Replace diagnostic name
lambda.argument.0.be.moved.out=Lambda argument {0,choice,0#can|1#should} be moved out of parentheses
move.lambda.argument.out.of.parentheses=Move lambda argument out of parentheses
suspicious.callable.reference.as.the.only.lambda.element=Suspicious callable reference as the only lambda element
inline.variable=Inline variable
move.variable.declaration.into.when=Move variable declaration into 'when'
nothing.to.do=Nothing to do
variable.declaration.could.be.inlined=Variable declaration could be inlined
variable.declaration.could.be.moved.into.when=Variable declaration could be moved into 'when'
may.contain.only.letters.digits.or.underscores=may contain only letters, digits or underscores
may.contain.only.letters.and.digits=may contain only letters and digits
should.not.contain.underscores.in.the.middle.or.the.end=should not contain underscores in the middle or the end
should.not.contain.underscores.with.camel.case=should not contain underscores when camel case is used
should.not.start.with.an.underscore=should not start with an underscore
should.not.start.with.an.uppercase.letter=should not start with an uppercase letter
should.not.contain.underscores=should not contain underscores
should.start.with.a.lowercase.letter=should start with a lowercase letter
should.start.with.an.uppercase.letter=should start with an uppercase letter
should.not.contain.lowercase.letter=should not contain lowercase letters
doesn.t.match.regex.0=doesn''t match regex ''{0}''
text.pattern=Pattern:
package.name=Package name
text.part=part
text.name=name
text.Package=Package
add.explicit.parameter.to.outer.lambda.fix.text=Add explicit parameter name to outer lambda
implicit.parameter.it.of.enclosing.lambda.is.shadowed=Implicit parameter 'it' of enclosing lambda is shadowed
equality.check.0.be.used.instead.of.elvis.for.nullable.boolean.check=Equality check {0} be used instead of elvis for nullable boolean check
replace.with.equality.check.fix.text=Replace with equality check
null.checks.to.safe.call.check.fix.text=Replace chained null-checks with safe-calls
null.checks.replaceable.with.safe.calls=Null-checks can be replaced with safe-calls
optionally.expected.annotation.has.no.actual.annotation.in.module.0.for.platform.1=Optionally expected annotation has no actual annotation in module {0} for platform {1}
call.of.inline.function.with.nullable.extension.receiver.can.cause.npe.in.kotlin.1.2=Call of 'inline fun' with nullable receiver can cause 'NPE' until Kotlin 1.2
make.open.fix.text=Make class open
make.private.fix.text=Make private
protected.visibility.is.effectively.private.in.a.final.class='protected' visibility is effectively 'private' in a final class
apply.also.to.private.members=Apply also to private members
apply.also.to.internal.members=Apply also to internal members
for.api.stability.it.s.recommended.to.specify.explicitly.declaration.types=For API stability, it's recommended to specify explicitly declaration types
for.api.stability.it.s.recommended.to.specify.explicitly.public.protected.declaration.types=For API stability, it's recommended to specify explicitly public \\& protected declaration types
recursive.equals.call=Recursive equals call
replace.with.field.fix.text=Replace with 'field'
recursive.synthetic.property.accessor=Recursive synthetic property accessor
recursive.property.accessor=Recursive property accessor
remove.redundant.companion.reference.fix.text=Remove redundant Companion reference
redundant.companion.reference=Redundant Companion reference
remove.redundant.else.fix.text=Remove redundant 'else'
redundant.else=Redundant 'else'
print.should.be.replaced.with.logging.display.name=Call to 'print()' or 'println()'
uses.of.should.be.replaced.with.logging=Uses of <code>{0}</code> should probably be replaced with more robust logging
remove.initializer.block.fix.text=Remove initializer block
redundant.empty.initializer.block=Redundant empty initializer block
remove.enum.constructor.invocation.fix.text=Remove enum constructor invocation
redundant.enum.constructor.invocation=Redundant enum constructor invocation
explicitly.given.type.is.redundant.here=Explicitly given type is redundant here
remove.redundant.getter.fix.text=Remove redundant getter
remove.redundant.getter.body.fix.text=Remove redundant getter body
redundant.getter=Redundant getter
redundant.getter.body=Redundant getter body
remove.redundant.constructor.keyword.fix.text=Remove redundant 'constructor' keyword
redundant.constructor.keyword=Redundant 'constructor' keyword
remove.redundant.if.text=Remove redundant 'if' statement
remove.redundant.if.may.change.semantics.with.floating.point.types=Remove redundant 'if' statement (may change semantics with floating-point types)
redundant.if.statement=Redundant 'if' statement
redundant.if.option.ignore.chained=Ignore chained 'if' statements
redundant.if.statement.analyzing.type=Analyzing condition type\u2026
convert.to.concatenated.string.statement.analyzing.entry.type=Analyzing entry type\u2026
delete.fix.family.name=Remove arrow
redundant.lambda.arrow=Redundant lambda arrow
remove.let.call=Remove 'let' call
redundant.let.call.could.be.removed=Redundant 'let' call could be removed
redundant.modality.modifier=Redundant modality modifier
this.type.probably.can.be.changed.to.nullable=This type probably can be changed to nullable
redundant.type.checks.for.object=Redundant type checks for object
replace.with.equality.fix.text=Replace ''{0}'' with ''{1}''
redundant.0.call=Redundant ''{0}'' call
remove.require.not.null.call.fix.text=Remove ''{0}'' call
remove.return.label.fix.text=Remove redundant ''@{0}''
remove.return.label.fix.family=Remove redundant label
redundant.0=Redundant ''@{0}''
remove.redundant.sam.constructors=Remove redundant SAM constructors
remove.redundant.sam.constructor=Remove redundant SAM constructor
redundant.sam.constructors=Redundant SAM constructors
redundant.sam.constructor=Redundant SAM constructor
fix.text=Remove redundant semicolon
redundant.semicolon=Redundant semicolon
remove.redundant.setter.fix.text=Remove redundant setter
remove.redundant.setter.body.fix.text=Remove redundant setter body
redundant.setter=Redundant setter
redundant.setter.body=Redundant setter body
redundant.suspend.modifier=Redundant 'suspend' modifier
redundant.unit.return.type=Redundant 'Unit' return type
redundant.visibility.modifier=Redundant visibility modifier
remove.redundant.unit.fix.text=Remove redundant 'Unit'
redundant.unit=Redundant 'Unit'
remove.redundant.with.fix.text=Remove redundant 'with' call
remove.jvmoverloads.annotation=Remove @JvmOverloads annotation
remove.jvmfield.annotation=Remove @JvmField annotation
remove.extension.function.type.annotation=Remove inapplicable @ExtensionFunctionType annotation
remove.annotation.doesnt.have.any.effect=Remove annotation, since it has no effect. See: https://youtrack.jetbrains.com/issue/KT-48141
remove.use.site.get.target=Remove 'get:' to make the annotation effective. (changes semantics. See: https://youtrack.jetbrains.com/issue/KT-48141)
report.also.for.a.variables.without.a.whitespace.around=Report also for a variables without a whitespace around
remove.curly.braces=Remove curly braces
redundant.curly.braces.in.string.template=Redundant curly braces in string template
remove.empty.parentheses.from.annotation.entry.fix.text=Remove unnecessary parentheses
parentheses.should.be.removed=Parentheses should be removed
remove.redundant.qualifier.name.quick.fix.text=Remove redundant qualifier name
redundant.qualifier.name=Redundant qualifier name
remove.redundant.backticks.quick.fix.text=Remove redundant backticks
remove.redundant.spread.operator.quickfix.text=Remove redundant spread operator
remove.to.string.fix.text=Remove 'toString()' call
redundant.tostring.call.in.string.template=Redundant 'toString()' call in string template
redundant.setter.parameter.type=Redundant setter parameter type
replace.with.contentequals=Replace '!=' with 'contentEquals'
replace.with.contentequals2=Replace '==' with 'contentEquals'
replace.with.contentequals3=Replace with 'contentEquals'
dangerous.array.comparison=Dangerous array comparison
replace.with.array.literal.fix.family.name=Replace with [...]
0.call.should.be.replaced.with.array.literal=''{0}'' call should be replaced with array literal [...]
replace.assert.boolean.with.assert.equality=Replace assert boolean with assert equality
replace.0.with.1=Replace ''{0}'' with ''{1}''
replace.collection.count.with.size.quick.fix.text=Replace 'count' with 'size'
could.be.replaced.with.size=Could be replaced with 'size'
replace.with.kotlin.s.function.call=Replace with Kotlin function call
replace.guard.clause.with.kotlin.s.function.call=Replace guard clause with Kotlin function call
replace.index.loop.with.collection.loop.quick.fix.text=Replace with loop over elements
replace.manual.range.with.indices.call.quick.fix.text=Replace with indices
range.could.be.replaced.with.indices.call=Range could be replaced with '.indices' call
for.loop.over.indices.could.be.replaced.with.loop.over.elements=For loop over indices could be replaced with loop over elements
replace.negated.0.with.1=Replace negated ''{0}'' with ''{1}''
replace.with.elvis.return.fix.text=Replace with ''?: return{0}''
replace.with.return=Replace '!!' with '?: return'
convert.put.to.assignment=Convert put to assignment
map.put.should.be.converted.to.assignment=map.put() should be converted to assignment
replace.int.range.end.inclusive.with.last.quick.fix.text=Replace 'endInclusive' with 'last'
replace.int.range.start.with.first.quick.fix.text=Replace 'start' with 'first'
could.be.replaced.with.unboxed.last=Could be replaced with unboxed 'last'
could.be.replaced.with.unboxed.first=Could be replaced with unboxed 'first'
replace.with.until.quick.fix.text=Replace with 'until'
replace.with.rangeUntil.quick.fix.text=Replace with '..<'
replace.with.string.literal.fix.family.name=Replace with string templates
replace.tostring.with.string.template=Replace 'toString' with string template
replace.to.with.infix.form.quickfix.text=Replace 'to' with infix form
replace.with.enum.map.fix.text=Replace with 'EnumMap'
replaceable.with.enummap=Can be replaced with 'EnumMap'
replace.with.operator.assignment=Replace with operator-assignment
replaceable.with.operator.assignment=Replaceable with operator-assignment
replace.with.if.fix.text=Replace with 'if' type check
should.be.replaced.with.if.type.check=Should be replaced with 'if' type check
call.is.replaceable.with.another.scope.function=Call can be replaced with another scope function
convert.scope.function.fix.family.name=Convert to ''{0}''
variable.0.is.assigned.to.itself=Variable ''{0}'' is assigned to itself
remove.self.assignment.fix.text=Remove self assignment
convert.to.nullable.type.fix.text=Convert to nullable type
constructor.has.non.null.self.reference.parameter=Constructor has non-null self reference parameter
assign.backing.field.fix.text=Assign backing field
existing.backing.field.is.not.assigned.by.the.setter=Existing backing field is not assigned by the setter
replace.with.error=Replace with '?: error(...)'
replace.assert.with.operator=Replace assert with operator
assert.should.be.replaced.with.operator=assert should be replaced with operator
simplify.negated.operation=Simplify negated operation
negated.operation.can.be.simplified=Negated operation can be simplified
replace.negated.0.operation.with.1=Replace negated ''{0}'' operation with ''{1}''
replace.negated.0.operation.with.1.may.change.semantics.with.floating.point.types=Replace negated ''{0}'' operation with ''{1}'' (may change semantics with floating-point types)
simplify.when.fix.text=Simplify 'when'
this.when.is.simplifiable=This 'when' is simplifiable
sort.modifiers=Sort modifiers
non.canonical.modifiers.order=Non-canonical modifiers order
modifiers.should.follow.annotations=Modifiers should follow annotations
remove.as.dynamic.call.fix.text=Remove 'asDynamic' invocation
suspicious.asdynamic.member.invocation=Suspicious 'asDynamic' member invocation
0.on.a.readonly.1.creates.a.new.1.under.the.hood=''{0}'' on a read-only {1} creates a new {1} under the hood
replace.with.filter.fix.text=Replace with filter
change.type.to.mutable.fix.text=Change type to mutable
replace.with.assignment.fix.text=Replace with assignment (original is empty)
join.with.initializer.fix.text=Join with initializer
suspicious.combination.of.and=Suspicious combination of == and ===
unlabeled.return.inside.lambda=Unlabeled return inside lambda
suspicious.var.property.its.setter.does.not.influence.its.getter.result=Suspicious 'var' property: its setter does not influence its getter result
variable.used.only.in.following.return.and.should.be.inlined=Variable used only in following return and can be inlined
variable.is.same.as.0.and.should.be.inlined=Variable is same as ''{0}'' and can be inlined
implicit.unsafe.cast.from.dynamic.to.0=Implicit (unsafe) cast from dynamic to {0}
cast.explicitly.fix.text=Cast explicitly
unused.equals.expression=Unused equals expression
since.kotlin.1.3.main.parameter.is.not.necessary=Since Kotlin 1.3 main parameter is not necessary
remove.token.from.function.declaration=Remove '=' token from function declaration
unused.return.value.of.a.function.with.lambda.expression.body=Unused return value of a function with lambda expression body
safe.delete.constructor=Safe delete constructor
remove.unary.operator.fix.text=Remove unused unary operator
move.unary.operator.to.previous.line.fix.text=Move unary operator to previous line
unused.unary.operator=Unused unary operator
one.line.return=one-line return
return.when='return when'
block.body=block body
use.expression.body.instead.of.0=Use expression body instead of {0}
convert.to.expression.body.fix.text=Convert to expression body
when.has.only.else.branch.and.should.be.simplified='when' has only 'else' branch and should be simplified
wrap.unary.operator.quickfix.text=Wrap unary operator and value with ()
make.0.1=Make ''{0}'' {1}
replace.with.0.operator=Replace with ''{0}'' operator
do.you.want.to.make.new.extension.an.expected.declaration=Do you want to make new extension an expected declaration?
loop.to.call.fix.family.name=Replace with stdlib operations
loop.to.call.fix.family.name2=Replace with stdlib operations with use of 'asSequence()'
loop.can.be.replaced.with.stdlib.operations=Loop can be replaced with stdlib operations
text.add.setter=Add setter
text.add.getter=Add getter
text.add.getter.and.setter=Add getter and setter
text.add.use.site.target.0=Add use-site target ''{0}''
title.choose.use.site.target=Choose Use-Site Target
add.use.site.target=Add use-site target
add.full.qualifier=Add full qualifier
add.braces.to.0.statement=Add braces to ''{0}'' statement
add.braces.to.when.entry=Add braces to 'when' entry
add.braces.to.all.branches=Add braces to all branches
add.braces.to.if.all.statements=Add braces to all 'if' statements
add.braces.to.when.all.entries=Add braces to all 'when' entries
add.jvmoverloads.annotation.to.0=Add ''@JvmOverloads'' annotation to {0}
text.primary.constructor=primary constructor
function.0=function ''{0}''
looking.for.usages.in.java.files=Looking for usages in Java files\u2026
add.return.at.0=Add ''return@{0}''
add.0.to.argument=Add ''{0} ='' to argument
add.val.var.to.parameter.0=Add ''val'' or ''var'' to parameter ''{0}''
add.val.to.parameter.0=Add ''val'' to parameter ''{0}''
add.val.var.to.primary.constructor.parameter=Add 'val' or 'var' to a primary constructor parameter
make.primary.constructor.0=Make primary constructor {0}
change.visibility=Change visibility
change.visibility.popup=Change Visibility
change.visibility.modifier=Change visibility modifier
0.may.break.code={0} (may break code)
convert.to.vararg.parameter=Convert to vararg parameter
replace.||.with.&&=Replace '||' with '\\&\\&'
replace.&&.with.||=Replace '\\&\\&' with '||'
can.t.modify.0=Can''t modify {0}
0.already.exists={0} already exists
type.arguments.will.be.lost.after.conversion.0=Type arguments will be lost after conversion: {0}
call.with.arguments.will.be.skipped.0=Call with arguments will be skipped: {0}
looking.for.usages.and.conflicts=Looking for usages and conflicts\u2026
following.expression.won.t.be.processed.since.refactoring.can.t.preserve.its.semantics.0=Following expression won''t be processed since refactoring can''t preserve its semantics: {0}
callable.reference.transformation.is.not.supported.0=Callable reference transformation is not supported: {0}
can.t.replace.non.kotlin.reference.with.call.expression.0=Can''t replace non-Kotlin reference with call expression: {0}
convert.0.to.1=Convert ''{0}'' to ''{1}''
convert.lambda.to.reference.before.text=Lambda can be converted to a reference
convert.lambda.to.reference=Convert lambda to reference
select.target.code.block.file=Select target code block / file
select.target.file=Select target file
replace.expression.with.if.expression=Replace '!!' expression with 'if' expression
inline.when.argument=Inline 'when' argument
replace.elvis.expression.with.if.expression=Replace elvis expression with 'if' expression
flatten.when.expression=Flatten 'when' expression
replace.if.expression.with.return=Replace 'if' expression with return
lift.return.out.of.if.expression=Lift return out of 'if' expression
replace.if.with.when=Replace 'if' with 'when'
replace.safe.access.expression.with.if.expression=Replace safe access expression with 'if' expression
replace.assignment.with.if.expression=Replace assignment with 'if' expression
replace.assignment.with.when.expression=Replace assignment with 'when' expression
replace.property.initializer.with.if.expression=Replace property initializer with 'if' expression
replace.property.initializer.with.when.expression=Replace property initializer with 'when' expression
replace.return.with.if.expression=Replace return with 'if' expression
replace.return.with.when.expression=Replace return with 'when' expression
replace.when.with.if=Replace 'when' with 'if'
replace.call.with.unary.operator=Replace call with unary operator
replace.contains.call.with.in.operator=Replace 'contains' call with 'in' operator
replace.invoke.with.direct.call=Replace 'invoke' with direct call
copy.concatenation.text.to.clipboard=Copy concatenation text to clipboard
split.property.declaration=Split property declaration
replace.with.stdlib.operations.with.use.of.assequence=Replace with stdlib operations with use of 'asSequence()'
replace.with.stdlib.operations=Replace with stdlib operations
use.withindex.instead.of.manual.index.increment=Use withIndex() instead of manual index increment
add.braces=Add braces
add.indices.to.for.loop=Add indices to 'for' loop
add.jvmoverloads.annotation=Add '@JvmOverloads' annotation
add.jvmstatic.annotation=Add '@JvmStatic' annotation
make.member.static.quickfix=Make ''{0}'' static
making.member.static=Making member static\u2026
add.jvminline.annotation=Add '@JvmInline' annotation
add.labeled.return.to.last.expression.in.a.lambda=Add labeled return to the last expression in a lambda
add.missing.component=Add missing destructuring component
add.names.to.call.arguments=Add names to call arguments
add.names.in.comment.to.call.arguments=Add names in comment to call arguments
add.names.to.this.argument.and.following.arguments=Add names to this argument and all following arguments
add.name.to.argument=Add name to the argument
make.open=Make 'open'
add.throws.annotation=Add '@Throws' annotation
add.remaining.branches=Add remaining branches
convert.anonymous.function.to.lambda.expression=Convert anonymous function to a lambda expression
convert.to.lambda.expression=Convert to a lambda expression
put.arguments.on.separate.lines=Put arguments on separate lines
put.parameters.on.separate.lines=Put parameters on separate lines
put.expressions.on.separate.lines=Put expressions on separate lines
put.calls.on.separate.lines=Put calls on separate lines
add.kotlin.coroutines=Add Kotlin coroutines library
add.kotlin.coroutines.description=Add Kotlin Coroutines Library
demorgan.law=DeMorgan Law
replace.with.end.of.line.comment=Replace with end of line comment
convert.collection.constructor.to.function=Convert Collection constructor to function
convert.to.sealed.class=Convert to sealed class
replace.with.a.for.loop=Replace with a 'for' loop
convert.function.to.property=Convert function to property
convert.function.type.parameter.to.receiver=Convert function type parameter to receiver
convert.function.type.receiver.to.parameter=Convert function type receiver to parameter
convert.to.nullable.var=Convert to nullable var
convert.to.ordinary.property=Convert to ordinary property
replace.with.block.comment=Replace with block comment
convert.to.lateinit.var=Convert to lateinit var
convert.object.literal.to.class=Convert object literal to class
convert.to.lazy.property=Convert to lazy property
convert.parameter.to.receiver=Convert parameter to receiver
convert.to.secondary.constructor=Convert to secondary constructor
convert.property.getter.to.initializer=Convert property getter to initializer
convert.property.initializer.to.getter=Convert property initializer to getter
convert.property.to.function=Convert property to function
can.t.replace.foreign.reference.with.call.expression.0=Can''t replace foreign reference with call expression: {0}
unrecognized.reference.will.be.skipped.0=Unrecognized reference will be skipped: {0}
property.overloaded.in.child.class.constructor=Property overloaded in child class constructor
property.has.an.actual.declaration.in.the.class.constructor=Property has an actual declaration in the class constructor
convert.to.comparisons=Convert to comparisons
convert.receiver.to.parameter=Convert receiver to parameter
highlight.usages.of.receiver=Highlight usages of receiver
convert.reference.to.lambda.before.text=Reference can be converted to a lambda
convert.reference.to.lambda=Convert reference to lambda
following.problems.are.found=Following problems are found:\n
all.expected.and.actual.classes.must.be.sealed.classes=All expected and actual classes must be sealed classes.\n
all.inheritors.must.be.nested.objects.of.the.class.itself.and.may.not.inherit.from.other.classes.or.interfaces=All inheritors must be nested objects of the class itself and may not inherit from other classes or interfaces.\n
searching.inheritors=Searching inheritors\u2026
convert.to.enum.class=Convert to enum class
convert.to.primary.constructor=Convert to primary constructor
convert.to.primary.constructor.before.text=Secondary constructor should be converted to a primary one
rename.to.01=Rename to {0}
replace.0.name.with.spaces=Replace {0} name with spaces
convert.to.block.body=Convert to block body
convert.body.to.expression = Convert body to expression
convert.template.to.concatenated.string=Convert template to concatenated string
replace.with.a.foreach.function.call=Replace with a ''{0}'' function call
convert.concatenation.to.raw.string=Convert concatenation to raw string
convert.concatenation.to.template.before.text='String' concatenation can be converted to a template
convert.concatenation.to.template=Convert concatenation to template
convert.try.finally.to.use.before.text=try-finally can be replaced with 'use()'
convert.try.finally.to.use=Replace 'try-finally' with 'use()'
convert.to.unsafe.cast=Convert to unsafe cast
convert.to.0.as.1=Convert to ''{0} as {1}''
convert.to.0.unsafecast.1=Convert to ''{0}.unsafeCast<{1}>()''
convert.to.unsafecast.call=Convert to unsafeCast() call
convert.to.array.parameter=Convert to array parameter
convert.to.assignment.expression=Converts the assignment statement to an expression
convert.to.trim.indent=Convert to 'trimIndent()' call
convert.to.trim.margin=Convert to 'trimMargin()' call
create.kotlin.subclass=Create Kotlin subclass
use.destructuring.declaration=Use destructuring declaration
implement.as.constructor.parameter=Implement as constructor parameter
implement.abstract.member=Implement abstract member
import.members.from.0=Import members from ''{0}''
import.members.with=Import members with '*'
add.import.for.0=Add import for ''{0}''
add.import.for.member=Add import for member
indent.raw.string=Indent raw string
replace.infix.call.with.ordinary.call=Replace infix call with ordinary call
infix.call.may.be.dot.call=Infix call may be dot call
insert.curly.braces.around.variable=Insert curly braces around variable
add.explicit.type.arguments=Add explicit type arguments
introduce.backing.property=Introduce backing property
introduce.import.alias=Introduce import alias
invert.if.condition=Invert 'if' condition
iterate.over.0=Iterate over ''{0}''
iterate.over.collection=Iterate over collection
join.declaration.and.assignment=Join declaration and assignment
can.be.joined.with.assignment=Can be joined with assignment
put.arguments.on.one.line=Put arguments on one line
put.parameters.on.one.line=Put parameters on one line
convert.lambda.expression.to.anonymous.function=Convert lambda expression to anonymous function
convert.to.anonymous.function=Convert to anonymous function
merge.else.if=Merge 'else if'
merge.if.s=Merge 'if's
move.lambda.argument.into.parentheses=Move lambda argument into parentheses
class.0.already.contains.1=Class ''{0}'' already contains {1}
0.in.1.will.require.class.instance=''{0}'' in {1} will require class instance
searching.for.0=Searching for {0}
move.out.of.companion.object=Move out of companion object
calls.with.explicit.extension.receiver.won.t.be.processed.0=Calls with explicit extension receiver won''t be processed: {0}
usages.of.outer.class.instance.inside.of.property.0.won.t.be.processed=Usages of outer class instance inside of property ''{0}'' won''t be processed
companion.object.already.contains.0=Companion object already contains {0}
0.references.type.parameters.of.the.containing.class={0} references type parameters of the containing class
0.is.overridden.by.declaration.s.in.a.subclass={0} is overridden by declaration(s) in a subclass
move.to.companion.object=Move to companion object
move.to.companion.object.command=Move To Companion Object
moving.to.companion.object=Moving to companion object\u2026
move.to.top.level=Move to top level
package.0.already.contains.1=Package ''{0}'' already contains {1}
move.to.class.body=Move to class body
move.to.constructor=Move to constructor
convert.boolean.const.to.elvis=Convert Boolean? == const to elvis
convert.object.literal.to.lambda=Convert object literal to lambda
convert.to.lambda=Convert to lambda
replace.by.0=Replace by ''{0}''
replace.by.reconstructed.type=Replace by reconstructed type
remove.argument.name=Remove argument name
remove.all.argument.names=Remove all argument names
remove.braces.from.when.entry=Remove braces from 'when' entry
remove.braces.from.0.statement=Remove braces from ''{0}'' statement
remove.braces=Remove braces
remove.braces.from.all.branches=Remove braces from all branches
remove.braces.from.if.all.statements=Remove braces from all 'if' statements
remove.braces.from.when.all.entries=Remove braces from all 'when' entries
redundant.empty.class.body=Redundant empty class body
remove.redundant.empty.class.body=Remove redundant empty class body
remove.unnecessary.parentheses.from.function.call.with.lambda=Remove unnecessary parentheses from function call with lambda
remove.empty.primary.constructor=Remove empty primary constructor
remove.empty.constructor.body=Remove empty constructor body
remove.explicit.lambda.parameter.types.may.break.code=Remove explicit lambda parameter types (may break code)
remove.explicit.supertype.qualification=Remove explicit supertype qualification
remove.explicit.type.arguments=Remove explicit type arguments
remove.explicit.type.specification=Remove explicit type specification
remove.explicit.type.specification.from.0=Remove explicit type specification from ''{0}''
remove.indices.in.for.loop=Remove indices in 'for' loop
index.is.not.used.in.the.loop.body=Index is not used in the loop body
remove.return.0=Remove return@{0}
remove.labeled.return.from.last.expression.in.a.lambda=Remove labeled return from last expression in a lambda
remove.redundant.calls.of.the.conversion.method=Remove redundant calls of the conversion method
remove.single.expression.string.template=Remove single-expression string template
redundant.string.template=Redundant string template
remove.unnecessary.parentheses=Remove unnecessary parentheses
rename.class.to.0=Rename class to {0}
rename.class.to.containing.file.name=Rename class to containing file name
rename.file.to.0.1=Rename file to {0}.{1}
rename.file.to.match.top.level.class.name=Rename file to match top-level class name
replace.0.with=Replace ''{0}()'' with ''+=''
replace.with1=Replace with '+='
replace.explicit.parameter.0.with.it=Replace explicit parameter ''{0}'' with ''it''
replace.it.with.explicit.parameter=Replace 'it' with explicit parameter
replace.with.0.1.2=Replace with {0}[{1}] ?: {2}
replace.with.indexing.and.elvis.operator=Replace with indexing and elvis operator
replace.size.check.with.isnotempty=Replace size check with 'isNotEmpty'
replace.size.check.with.0=Replace size check with ''{0}''
replace.size.zero.check.with.isempty=Replace size zero check with 'isEmpty'
replace.with.parameter.name=Replace '_' with parameter name
replace.with.ordinary.assignment=Replace with ordinary assignment
replace.with.explicit.type=Replace '_' with explicit type
replace.with.underscore=Replace explicit type with '_'
simplify.boolean.expression=Simplify boolean expression
specify.all.remaining.arguments.by.name=Specify all remaining arguments by name
specify.remaining.required.arguments.by.name=Specify remaining required arguments by name
specify.explicit.lambda.signature=Specify explicit lambda signature
specify.all.types.explicitly.in.destructuring.declaration=Specify all types explicitly in destructuring declaration
cannot.infer.type.for.this.declaration=Cannot infer type for this declaration
split.if.into.two=Split 'if' into two
flip.0=Flip ''{0}''
flip.binary.expression=Flip binary expression
flip.equals=Flip 'equals'
replace.with.infix.function.call=Replace with infix function call
convert.to.ordinary.string.literal=Convert to ordinary string literal
convert.to.raw.string.literal=Convert to raw string literal
remove.underscores=Remove underscores
add.underscores=Add underscores
excluded.methods=Excluded methods:
use.of.getter.method.instead.of.property.access.syntax=Use of getter method instead of property access syntax
use.of.setter.method.instead.of.property.access.syntax=Use of setter method instead of property access syntax
use.property.access.syntax=Use property access syntax
use.property.access.syntax.option.report.non.trivial.accessors=Report non-trivial accessors
convert.to.object.declaration=Convert to object declaration
comment=Comment
expression=Expression
statement=Statement
class=Class
top.level=Top-level
rethrow.stored.pce.as.a.new.runtime.exception=Rethrow stored PCE as a new runtime exception
internal.toggle.throwing.cached.pce.title=Internal: Toggle Throwing Cached PCE
minimal.line.count=Minimal line count
files.to.visit=Files to visit
random.seed=Random seed
number.of.attempts.then.files.in.project.0=Number of attempts > then files in project, {0}
text.done=Done
file.lines=File lines
max.functions.to.visit=Max functions to visit
move.refactoring.testing=Move refactoring testing
compiling.project=Compiling project\u2026
saving.files=Saving files\u2026
perform.refactoring=Perform refactoring\u2026
update.indices=Update indices\u2026
reset.files=Reset files\u2026
cannot.get.or.create.results.file=Cannot get or create results file
cannot.get.project.root.directory=Cannot get project root directory
0.try.1.with.2.fails.and.3.verifications={0} [Try {1} with {2} fails and {3} verifications]
test.result.log.file.will.be.placed.here=Test result log file will be placed here
maximum.count.of.applied.refactoring.before.validity.check=Maximum count of applied refactoring before validity check
move.refactoring.test=Move refactoring test
resolve.pasted.references=resolve pasted references
create.kotlin.file=Create Kotlin file
type.alias.0=Type alias "{0}"
type.parameter.0=Type parameter "{0}"
parameter.0=Parameter "{0}"
property.0=Property "{0}"
function.01=Function "{0}"
object.0=Object "{0}"
interface=Interface
constructor=Constructor
move.reference.into.parentheses=Move reference into parentheses
local.variable=Local variable
const.property=Const property
private.property=Private property
object.or.top.level.property=Object or top-level property
object.private.property=Object private property
property=Property
test.function=Test function
function=Function
enum.entry=Enum entry
create.subclass=Create subclass
implement.sealed.class=Implement sealed class
implement.abstract.class=Implement abstract class
implement.interface=Implement interface
implement.abstract.function=Implement abstract function
implement.abstract.property=Implement abstract property
replace.explicit.lambda.parameter.with.it=Replace explicit lambda parameter with 'it'
create.test=Create test
convert.class.0.to.kotlin=Convert class ''{0}'' to Kotlin
status=(status)
action.text.install=Install
version={version}
don.t.show.this.dialog.next.time=&Don't show this dialog next time
clipboard.content.copied.from.java.file.do.you.want.to.convert.it.to.kotlin.code=Clipboard content copied from Java file. Do you want to convert it to Kotlin code?
name=&Name:
return.type=&Return type:
visibility=&Visibility:
title.parameters=Parameters
signature.preview=Signature Preview
move.members.from=Move members from:
open.moved.members.in.editor=Open moved members in editor
open.moved.method.in.editor=Open moved method in editor
to.fully.qualified.name=To (fully qualified name):
incomplete.destructuring.declaration.text=Incomplete destructuring declaration
incomplete.destructuring.fix.family.name=Add missing variables to destructuring declaration
no.actual.for.expect.declaration=No actual for expect declaration in module(s): {0}

#Structural Search
category.class=Kotlin/Class-based
category.comments=Kotlin/Comments, KDoc and Metadata
category.expressions=Kotlin/Expressions
category.declaration=Kotlin/Declarations
category.interesting=Kotlin/Interesting
category.operators=Kotlin/Operators

context.default=Default
context.property.getter.or.setter=Property With Explicit Getter/Setter

error.context.getter.or.setter=This context is only for properties with explicit getter/setter. (set file type to Kotlin)
error.expected.an.expression=Expecting an expression
error.expected.catch.or.finally=Expecting 'catch' or 'finally'
error.param.can.t.be.null.at.index.0.in.1=Param can''t be null at index {0} in {1}.

ssr.modifier.match.val=Match val
ssr.modifier.match.var=Match var
ssr.modifier.match.companion.object=Match companion object
ssr.modifier.match.call.semantically=Match call semantically

predefined.configuration.all.methods.of.the.class=All methods of a class
predefined.configuration.all.vars.of.the.class=All vars of a class
predefined.configuration.all.vars.of.the.object=All vars of an object
predefined.configuration.annotations=Annotations
predefined.configuration.anonymous.class=Anonymous class
predefined.configuration.array.access=Array access
predefined.configuration.assert.not.null=Not-null assertion operators
predefined.configuration.assignments=Assignments
predefined.configuration.casts=Casts
predefined.configuration.class.annotation=Annotated classes
predefined.configuration.object.companion.object=Object and companion object
predefined.configuration.comments.containing.word=Comments containing a given word
predefined.configuration.do.while=Do...while loops
predefined.configuration.elvis=Elvis operators
predefined.configuration.for=For loops
predefined.configuration.function.annotation=Annotated functions
predefined.configuration.function.signature=Function signature
predefined.configuration.function.explicit.inferred.type=Explicit and inferred type
predefined.configuration.ifs=If's
predefined.configuration.instance=Instances
predefined.configuration.kdoc.tag=KDoc tags
predefined.configuration.lambda=Lambda expressions
predefined.configuration.method.calls=Method calls
predefined.configuration.companion.object.method.calls=Method calls from companion object
predefined.configuration.properties.getter=Properties with explicit getter
predefined.configuration.safe.call.operator=Safe call operators
predefined.configuration.string.literals=String literals
predefined.configuration.strings=Strings
predefined.configuration.strings.with.long.template=Strings containing a long template
predefined.configuration.trys=Try's
predefined.configuration.vars.of.given.type=Vars of given type
predefined.configuration.also.match.vals=Match both vars and vals
predefined.configuration.when=When expressions
predefined.configuration.while=While loops

#Actions
action.Kotlin.StopScratch.text=Stop Scratch Execution
action.Kotlin.StopScratch.description=Stop scratch execution
action.Kotlin.ClearScratch.text=Clear Kotlin Scratch
action.Kotlin.ClearScratch.description=Clear Kotlin scratch
action.Kotlin.RunScratch.text=Run Kotlin Scratch
action.Kotlin.RunScratch.description=Run Kotlin scratch
action.KotlinGenerateToString.text=toString()
action.KotlinGenerateEqualsAndHashCode.text=equals() and hashCode()
action.KotlinGenerateSecondaryConstructor.text=Secondary Constructor
action.KotlinGenerateDataMethod.text=Parameters Function
action.KotlinGenerateTearDownMethod.text=TearDown Function
action.KotlinGenerateSetUpMethod.text=SetUp Function
action.KotlinGenerateTestMethod.text=Test Function
action.KotlinShellExecute.text=Execute Kotlin Code
action.KotlinShellExecute.description=Execute Kotlin code in console
action.IntroduceTypeAlias.text=Type _Alias\u2026
action.IntroduceTypeParameter.text=T_ype Parameter\u2026
action.ExtractFunctionToScope.text=Function to _Scope\u2026
action.KotlinThrowException.text=Drop an Error from Kotlin Plugin
action.KotlinFormattingSettingsStatusAction.text=Formatter Settings Info
action.CopyAsDiagnosticTest.text=Copy Current File As Diagnostic Test
action.StoredExceptionsThrowToggleAction.text=Throw Cached PCE
action.PrintOutNotPropertyMatches.text=Search Not Property Candidates
action.FindImplicitNothingAction.text=Find Implicit Nothing Calls
action.CheckComponentsUsageSearchAction.text=Check Component Functions Usage Search
action.CacheResetOnProcessCanceledToggleAction.text=Reset Caches on ProcessCanceledException
action.HighlightingBenchmarkAction.text=Benchmark Highlighting
action.LocalCompletionBenchmarkAction.text=Local Scenario
action.TopLevelCompletionBenchmarkAction.text=Top-Level Scenario
group.KotlinCompletionBenchmarkGroup.text=Benchmark Completion
group.KotlinInternalGroup.text=Kotlin
action.TestMoveRefactiringAction.text=Test Move Refactoring on Opened Project
group.KotlinRefactoringTesting.text=Kotlin Refactoring Testing
action.DumbModeTremble.text=Tremble Dumb Mode
group.InternalKotlin.text=Kotlin Internal Actions
action.IntroduceProperty.text=P_roperty\u2026
action.ExtractFunction.text=_Function\u2026
action.KotlinCodeMigrationToggle.text=Enable Migrations Detection
action.KotlinCodeMigration.text=Run Code Migrations
action.CopyKotlinProjectInformation.text=Copy Kotlin Project Overview To Clipboard
action.DecompileKotlinToJava.text=Decompile Kotlin To Java
action.KotlinConfigurePlugin.text=Configure Kotlin Plugin
group.KotlinToolsGroup.text=Kotlin
action.ConvertJavaToKotlin.text=Convert Java File to Kotlin File
action.Kotlin.XDebugger.ToggleKotlinVariableView.text=Show Kotlin Variables Only
action.InspectBreakpointApplicability.text=Inspect Breakpoint Applicability
action.Kotlin.XDebugger.CoroutinesDump.text=Get Coroutines Dump
action.ShowKotlinBytecode.text=Show Kotlin Bytecode
action.ConfigureKotlinInProject.text=Configure Kotlin in Project
action.KotlinConsoleREPL.text=Kotlin REPL (Experimental)
action.LibraryToSourceDependencySupportToggleAction.text=Toggle Library to Source Dependency Support

inspection.unused.unary.operator.display.name=Unused unary operator
inspection.incomplete.destructuring.declaration.display.name=Incomplete destructuring declaration
inspection.inconsistent.comment.for.java.parameter.display.name=Inconsistent comment for Java parameter
inspection.replace.guard.clause.with.function.call.display.name=Guard clause can be replaced with Kotlin's function call
inspection.lateinit.var.overrides.lateinit.var.display.name='lateinit var' property overrides 'lateinit var' property
inspection.kotlin.equals.between.inconvertible.types.display.name='equals()' between objects of inconvertible types
inspection.redundant.empty.initializer.block.display.name=Redundant empty initializer block
inspection.add.operator.modifier.display.name=Function should have 'operator' modifier
inspection.control.flow.with.empty.body.display.name=Control flow with empty body
inspection.replace.java.static.method.with.kotlin.analog.display.name=Java methods should be replaced with Kotlin analog
inspection.self.reference.constructor.parameter.display.name=Constructor can never be complete
inspection.replace.not.null.assertion.with.elvis.return.display.name=Not-null assertion can be replaced with 'return'
inspection.kotlin.covariant.equals.display.name=Covariant 'equals()'
inspection.replace.associate.function.display.name='associate' can be replaced with 'associateBy' or 'associateWith'
inspection.java.map.for.each.display.name=Java Map.forEach method call should be replaced with Kotlin's forEach
inspection.kotlin.throwable.not.thrown.display.name=Throwable not thrown
inspection.redundant.require.not.null.call.display.name=Redundant 'requireNotNull' or 'checkNotNull' call
inspection.replace.range.start.end.inclusive.with.first.last.display.name=Boxed properties should be replaced with unboxed
inspection.redundant.enum.constructor.invocation.display.name=Redundant enum constructor invocation
inspection.redundant.labeled.return.on.last.expression.in.lambda.display.name=Redundant labeled return on the last expression in a lambda
inspection.replace.negated.is.empty.with.is.not.empty.display.name=Negated call can be simplified
inspection.function.with.lambda.expression.body.display.name=Function with '= { ... }' and inferred return type
inspection.suspend.function.on.coroutine.scope.display.name=Ambiguous coroutineContext due to CoroutineScope receiver of suspend function
inspection.boolean.literal.argument.display.name=Boolean literal argument without parameter name
inspection.suspicious.collection.reassignment.display.name=Augmented assignment creates a new collection under the hood
inspection.redundant.else.in.if.display.name=Redundant 'else' in 'if'
inspection.deferred.is.result.display.name=Function returning Deferred directly
inspection.map.get.with.not.null.assertion.operator.display.name='map.get()' with not-null assertion operator (!!)
inspection.delegation.to.var.property.display.name=Delegating to 'var' property
inspection.unused.main.parameter.display.name=Main parameter is not necessary
inspection.suspicious.var.property.display.name=Suspicious 'var' property: its setter does not influence its getter result
inspection.setter.backing.field.assignment.display.name=Existing backing field without assignment
inspection.unlabeled.return.inside.lambda.display.name=Unlabeled return inside lambda
inspection.optional.expectation.display.name=Optionally expected annotation has no actual annotation
inspection.remove.empty.parentheses.from.annotation.entry.display.name=Remove unnecessary parentheses
inspection.safe.cast.with.return.display.name=Safe cast with 'return' should be replaced with 'if' type check
inspection.simplifiable.call.display.name=Library function call could be simplified
inspection.redundant.run.catching.display.name=Redundant 'runCatching' call
inspection.redundant.return.label.display.name=Redundant 'return' label
inspection.replace.assert.boolean.with.assert.equality.display.name=Assert boolean could be replaced with assert equality
inspection.suspicious.as.dynamic.display.name=Suspicious 'asDynamic' member invocation
inspection.convert.call.chain.into.sequence.display.name=Call chain on collection could be converted into 'Sequence' to improve performance
inspection.redundant.with.display.name=Redundant 'with' call
inspection.add.kotlin.coroutines.display.name=Add Kotlin Coroutines library
inspection.obsolete.experimental.coroutines.display.name=Experimental coroutines usages are deprecated since 1.3
inspection.obsolete.kotlin.js.packages.display.name='kotlin.browser' and 'kotlin.dom' packages are deprecated since 1.4
inspection.warning.on.main.unused.parameter.migration.display.name=Unused 'args' on 'main' since 1.4
inspection.prohibit.repeated.use.site.target.annotations.migration.display.name=Repeated annotation which is not marked as '@Repeatable'
inspection.do.not.propagate.method.deprecation.through.overrides=Do not propagate method deprecation through overrides since 1.9
inspection.this.class.does.not.have.a.constructor=Forbidden constructor call
inspection.deprecated.enum.declaring.class.property=Deprecated 'Enum.declaringClass' property
inspection.non.exhaustive.when.statement.migration.display.name=Non-exhaustive 'when' statements will be prohibited since 1.7
inspection.prohibit.use.site.target.annotations.on.super.types.migration.display.name=Meaningless annotations targets on superclass
inspection.redundant.label.migration.display.name=Redundant label
inspection.ambiguous.expression.when.branch.migration.display.name=Ambiguous logical expressions in 'when' branches since 1.7
inspection.progression.resolution.change.migration.display.name=Progression resolution change since 1.9
inspection.enum.values.method.soft.deprecate.migration.display.name='Enum.values()' is recommended to be replaced by 'Enum.entries' since 1.9
inspection.enum.values.method.soft.deprecate.in.java.display.name='Enum.values()' is recommended to be replaced by 'Enum.getEntries()' since Kotlin 1.9
inspection.add.conversion.call.display.name=Explicit conversion from `Int` needed since 1.9
inspection.deprecated.inline.classes.migration.display.name=Inline classes are deprecated since 1.5
inspection.deprecated.inline.class.text=Deprecated inline class
inspection.restrict.return.statement.target.migration.display.name=Target label does not denote a function since 1.4
inspection.prohibit.jvm.overloads.on.constructors.of.annotation.classes.migration.display.name='@JvmOverloads' annotation cannot be used on constructors of annotation classes since 1.4
inspection.prohibit.type.parameters.for.local.variables.migration.display.name=Local variable with type parameters
inspection.from.closed.range.migration.display.name=MIN_VALUE step in fromClosedRange() since 1.3
inspection.replace.to.string.with.string.template.display.name=Call of 'toString' could be replaced with string template
inspection.nested.lambda.shadowed.implicit.parameter.display.name=Nested lambda has shadowed implicit parameter
inspection.for.each.parameter.not.used.display.name=Iterated elements are not used in forEach
inspection.replace.string.format.with.literal.display.name='String.format' call can be replaced with string templates
inspection.deferred.result.unused.display.name='@Deferred' result is unused
inspection.redundant.async.display.name=Redundant 'async' call
inspection.main.function.return.unit.display.name=Main function should return 'Unit'
inspection.move.variable.declaration.into.when.display.name=Variable declaration could be moved inside 'when'
inspection.move.lambda.outside.parentheses.display.name=Lambda argument inside parentheses
inspection.no.actual.for.expect.display.name=No actual for expect declaration
inspection.can.sealed.subclass.be.object.display.name=Sealed subclass without state and overridden equals
inspection.public.api.implicit.type.display.name=Public API declaration with implicit return type
inspection.redundant.companion.reference.display.name=Redundant 'Companion' reference
inspection.convert.pair.constructor.to.to.function.display.name=Convert Pair constructor to 'to' function
inspection.redundant.not.null.extension.receiver.of.inline.display.name='inline fun' extension receiver can be explicitly nullable until Kotlin 1.2
inspection.platform.extension.receiver.of.inline.display.name='inline fun' with nullable receiver until Kotlin 1.2
inspection.scope.function.conversion.display.name=Scope function can be converted to another one
inspection.redundant.object.type.check.display.name=Non-idiomatic 'is' type check for an object
inspection.fake.jvm.field.constant.display.name=Kotlin non-const property used as Java constant
inspection.may.be.constant.display.name=Might be 'const'
inspection.sort.modifiers.display.name=Non-canonical modifier order
inspection.redundant.suspend.modifier.display.name=Redundant 'suspend' modifier
inspection.replace.put.with.assignment.display.name='map.put()' can be converted to assignment
inspection.replace.to.with.infix.form.display.name='to' call should be replaced with infix form
inspection.recursive.equals.call.display.name=Recursive equals call
inspection.java.collections.static.method.on.immutable.list.display.name=Call of Java mutator method on immutable Kotlin collection
inspection.java.collections.static.method.display.name=Java Collections static method call can be replaced with Kotlin stdlib
inspection.simplify.when.with.boolean.constant.condition.display.name=Simplifiable 'when'
inspection.implicit.nullable.nothing.type.display.name=Implicit 'Nothing?' type
inspection.self.assignment.display.name=Redundant assignment
inspection.redundant.unit.expression.display.name=Redundant 'Unit'
inspection.implicit.this.display.name=Implicit 'this'
inspection.implicit.this.action.name=Add explicit 'this'
inspection.explicit.this.display.name=Redundant explicit 'this'
inspection.migrate.diagnostic.suppression.display.name=Diagnostic name should be replaced
inspection.redundant.setter.display.name=Redundant property setter
inspection.remove.redundant.qualifier.name.display.name=Redundant qualifier name
inspection.remove.redundant.backticks.display.name=Redundant backticks
inspection.redundant.getter.display.name=Redundant property getter
inspection.suspicious.equals.combination.display.name=Suspicious combination of == and ===
inspection.kotlin.redundant.override.display.name=Redundant overriding method
inspection.kotlin.redundant.suppression.display.name=Redundant diagnostic suppression
inspection.package.name.display.name=Package naming convention
inspection.local.variable.name.display.name=Local variable naming convention
inspection.const.property.name.display.name=Const property naming convention
inspection.private.property.name.display.name=Private property naming convention
inspection.object.property.name.display.name=Object property naming convention
inspection.object.private.property.name.display.name=Object private property naming convention
inspection.property.name.display.name=Property naming convention
inspection.test.function.name.display.name=Test function naming convention
inspection.function.name.display.name=Function naming convention
inspection.enum.entry.name.display.name=Enum entry naming convention
inspection.class.name.display.name=Class naming convention
inspection.redundant.lambda.arrow.display.name=Redundant lambda arrow
inspection.redundant.lambda.or.anonymous.function.display.name=Redundant creation of lambda or anonymous function
inspection.redundant.lambda.description=Redundant lambda creation
inspection.redundant.anonymous.function.description=Redundant anonymous function creation
inspection.redundant.lambda.or.anonymous.function.fix=Inline the body
inspection.when.with.only.else.display.name='when' has only 'else' branch and can be simplified
inspection.when.with.only.else.action.name=Simplify 'when' with only an 'else' branch
inspection.kotlin.double.negation.display.name=Redundant double negation
inspection.kotlin.double.negation.action.name=Remove redundant double negation
inspection.unnecessary.variable.display.name=Unnecessary local variable
inspection.unnecessary.variable.option.report.immediately.returned.variables=Report immediately returned variables
inspection.constant.condition.if.display.name=Condition of 'if' expression is constant
inspection.null.checks.to.safe.call.display.name=Null-checks can be replaced with safe-calls
inspection.cascade.if.display.name=Cascade 'if' can be replaced with 'when'
inspection.lift.return.or.assignment.display.name=Return or assignment can be lifted out
inspection.lift.return.or.assignment.option.only.single.statement=Report only if each branch is a single statement
inspection.use.expression.body.display.name=Expression body syntax is preferable here
inspection.simplifiable.call.chain.display.name=Call chain on collection type can be simplified
inspection.useless.call.on.collection.display.name=Useless call on collection type
inspection.redundant.explicit.type.display.name=Obvious explicit type
inspection.useless.call.on.not.null.display.name=Useless call on not-null type
inspection.remove.redundant.spread.operator.display.name=Redundant spread operator
inspection.empty.range.display.name=Range with start greater than endInclusive is empty
inspection.wrap.unary.operator.display.name=Ambiguous unary operator use with number constant
inspection.nullable.boolean.elvis.display.name=Equality check can be used instead of elvis for nullable boolean check
inspection.nullable.boolean.elvis.action.name=Use equality check instead of elvis for nullable boolean check
inspection.member.visibility.can.be.private.display.name=Class member can have 'private' visibility
inspection.replace.range.to.with.until.display.name='rangeTo' or the '..' call should be replaced with 'until'
inspection.replace.range.to.with.rangeUntil.display.name='rangeTo' or the '..' call should be replaced with '..<'
inspection.recursive.property.accessor.display.name=Recursive property accessor
inspection.replace.array.of.with.literal.display.name='arrayOf' call can be replaced with array literal [...]
inspection.copy.without.named.arguments.display.name='copy' method of data class is called without named arguments
inspection.move.suspicious.callable.reference.into.parentheses.display.name=Suspicious callable reference used as lambda result
inspection.kotlin.internal.in.java.display.name=Usage of Kotlin internal declarations from Java
inspection.kotlin.sealed.in.java.display.name=Inheritance of Kotlin sealed interface/class from Java
inspection.unused.lambda.expression.body.display.name=Unused return value of a function with lambda expression body
inspection.destructuring.wrong.name.display.name=Variable in destructuring declaration uses name of a wrong data class property
inspection.data.class.private.constructor.display.name=Private data class constructor is exposed via the 'copy' method
inspection.replace.with.enum.map.display.name='HashMap' can be replaced with 'EnumMap'
inspection.unused.equals.display.name=Unused equals expression
inspection.convert.na.n.equality.display.name=Convert equality check with 'NaN' to 'isNaN' call
inspection.convert.two.comparisons.to.range.check.display.name=Two comparisons should be converted to a range check
inspection.convert.try.finally.to.use.call.display.name=Convert try / finally to use() call
inspection.join.declaration.and.assignment.display.name=Join declaration and assignment
inspection.remove.empty.secondary.constructor.body.display.name=Redundant constructor body
inspection.remove.empty.primary.constructor.display.name=Redundant empty primary constructor
inspection.remove.redundant.calls.of.conversion.methods.display.name=Redundant call of conversion method
inspection.remove.empty.class.body.display.name=Replace empty class body
inspection.replace.size.zero.check.with.is.empty.display.name=Size zero check can be replaced with 'isEmpty()'
inspection.replace.size.check.with.is.not.empty.display.name=Size check can be replaced with 'isNotEmpty()'
inspection.convert.secondary.constructor.to.primary.display.name=Convert to primary constructor
inspection.complex.redundant.let.display.name=Redundant argument-based 'let' call
inspection.simple.redundant.let.display.name=Redundant receiver-based 'let' call
inspection.replace.array.equality.op.with.arrays.equals.display.name=Arrays comparison via '==' and '!='
inspection.remove.empty.parentheses.from.lambda.call.display.name=Unnecessary parentheses in function call with lambda
inspection.remove.empty.parentheses.from.lambda.call.action.name=Remove unnecessary parentheses from function call with lambda
inspection.remove.to.string.in.string.template.display.name=Redundant call to 'toString()' in string template
inspection.remove.single.expression.string.template.display.name=Redundant string template
inspection.replace.call.with.binary.operator.display.name=Can be replaced with binary operator
inspection.remove.setter.parameter.type.display.name=Redundant setter parameter type
inspection.convert.reference.to.lambda.display.name=Can be replaced with lambda
inspection.convert.lambda.to.reference.display.name=Can be replaced with function reference
inspection.can.be.primary.constructor.property.display.name=Property is explicitly assigned to constructor parameter
inspection.has.platform.type.display.name=Function or property has platform type
inspection.leaking.this.display.name=Leaking 'this' in constructor
inspection.redundant.if.display.name=Redundant 'if' statement
inspection.redundant.unit.return.type.display.name=Redundant 'Unit' return type
inspection.redundant.unit.return.type.action.name=Remove redundant 'Unit' return type
inspection.redundant.semicolon.display.name=Redundant semicolon
inspection.redundant.modality.modifier.display.name=Redundant modality modifier
inspection.can.be.parameter.display.name=Constructor parameter is never used as a property
inspection.replace.substring.with.substring.before.display.name='substring' call should be replaced with 'substringBefore'
inspection.replace.substring.with.substring.after.display.name='substring' call should be replaced with 'substringAfter'
inspection.replace.substring.with.indexing.operation.display.name='substring' call should be replaced with indexing operator
inspection.replace.substring.with.take.display.name='substring' call should be replaced with 'take' call
inspection.replace.substring.with.drop.last.display.name='substring' call should be replaced with 'dropLast' call
inspection.add.variance.modifier.display.name=Type parameter can have 'in' or 'out' variance
inspection.protected.in.final.display.name='protected' visibility is effectively 'private' in a final class
inspection.array.in.data.class.display.name=Array property in data class
inspection.can.be.val.display.name=Local 'var' is never modified and can be declared as 'val'
inspection.destructure.display.name=Use destructuring declaration
inspection.redundant.visibility.modifier.display.name=Redundant visibility modifier
inspection.equals.or.hash.code.display.name='equals()' and 'hashCode()' not paired
inspection.conflicting.extension.property.display.name=Extension property conflicting with synthetic one
inspection.use.with.index.display.name=Manually incremented index variable can be replaced with use of 'withIndex()'
inspection.loop.to.call.chain.display.name=Loop can be replaced with stdlib operations
inspection.remove.for.loop.indices.display.name=Unused loop index
inspection.kotlin.deprecation.display.name=Usage of redundant or deprecated syntax or deprecated symbols
inspection.package.directory.mismatch.display.name=Package name does not match containing directory
inspection.k.doc.missing.documentation.display.name=Missing KDoc comments for public declarations
inspection.k.doc.unresolved.reference.display.name=Unresolved reference in KDoc
inspection.unsafe.cast.from.dynamic.display.name=Implicit (unsafe) cast from dynamic type
inspection.redundant.sam.constructor.display.name=Redundant SAM constructor
inspection.kotlin.unused.import.display.name=Unused import directive
inspection.kotlin.unused.variable.display.name=Unused variable
inspection.unused.receiver.parameter.display.name=Unused receiver parameter
inspection.unused.symbol.display.name=Unused symbol
inspection.use.property.access.syntax.display.name=Accessor call that can be replaced with property access syntax
inspection.simplify.boolean.with.constants.display.name=Boolean expression can be simplified
inspection.remove.curly.braces.from.template.display.name=Redundant curly braces in string template
inspection.introduce.when.subject.display.name='when' that can be simplified by introducing an argument
inspection.replace.with.operator.assignment.display.name=Assignment can be replaced with operator assignment
inspection.simplify.negated.binary.expression.display.name=Negated boolean expression can be simplified
inspection.remove.explicit.super.qualifier.display.name=Unnecessary supertype qualification
inspection.remove.explicit.type.arguments.display.name=Unnecessary type argument
inspection.fold.initializer.and.if.to.elvis.display.name=If-Null return/break/... foldable to '?:'
inspection.if.then.to.safe.access.display.name=If-Then foldable to '?.'
inspection.if.then.to.elvis.display.name=If-Then foldable to '?:'
inspection.replace.manual.range.with.indices.calls.display.name=Range can be converted to indices or iteration
inspection.replace.until.with.rangeUntil.operator.display.name=Replace 'until' with '..<' operator
inspection.replace.get.or.set.display.name=Explicit 'get' or 'set' call
inspection.convert.to.string.template.display.name=String concatenation that can be converted to string template
inspection.deprecated.callable.add.replace.with.display.name=@Deprecated annotation without 'replaceWith' argument
inspection.replace.collection.count.with.size.display.name=Collection count can be converted to size
inspection.simplify.assert.not.null.display.name='assert' call can be replaced with '!!' or '?:'
inspection.object.literal.to.lambda.display.name=Object literal can be converted to lambda
remove.redundant.elvis.return.null.text=Remove redundant '?: return null'
inspection.redundant.elvis.return.null.descriptor=Redundant '?: return null'
inspection.redundant.elvis.return.null.display.name=Redundant '?: return null'
inspection.redundant.inner.class.modifier.descriptor=Redundant 'inner' modifier
inspection.redundant.inner.class.modifier.display.name=Redundant 'inner' modifier
fix.remove.annotation.text=Remove annotation
inspection.trailing.comma.display.name=Trailing comma recommendations
inspection.trailing.comma.report.also.a.missing.comma=Report also a missing comma or a line break
inspection.trailing.comma.add.line.break=Add line break
inspection.trailing.comma.missing.line.break=Missing line break
inspection.trailing.comma.remove.trailing.comma=Remove trailing comma
inspection.trailing.comma.useless.trailing.comma=Useless trailing comma
inspection.trailing.comma.add.trailing.comma=Add trailing comma
inspection.trailing.comma.missing.trailing.comma=Missing trailing comma
inspection.trailing.comma.fix.comma.position=Fix comma position
inspection.trailing.comma.comma.loses.the.advantages.in.this.position=Comma loses the advantages in this position
inspection.redundant.label.text=Redundant label
intention.convert.lambda.line=Convert to {0,choice,0#single|1#multi}-line lambda
intention.trailing.comma.custom.text={0,choice,0#Enable|1#Disable} a trailing comma by default in the formatter
intention.trailing.comma.text=Enable/disable a trailing comma in the formatter
intention.name.specify.supertype=Specify supertype
name.specify.supertype.command.title=Specify Supertype
popup.title.choose.supertype=Choose Supertype
fix.remove.argument.text=Remove argument
fix.remove.redundant.star.text=Remove redundant *
refactoring.extract.to.separate.file.text=Extract to separate file
action.usage.update.command=Usage Update
progress.title.analyze.extraction.data=Analyze extraction data\u2026
fix.move.file.to.package.dir.name.text=source root
move.refactoring.error.text.cannot.perform.refactoring.since.the.following.files.already.exist=Cannot perform refactoring since the following files already exist:\n\n
kotlin.script.definitions.title=Manage script definitions:
kotlin.script.definitions.model.name.autoReloadScriptDependencies.description=Enable auto reload if you want to load script configurations automatically on file change
kotlin.script.definitions.model.name.autoReloadScriptDependencies=Auto Reload
kotlin.script.definitions.model.name.is.enabled=Is Enabled
kotlin.script.definitions.model.name.pattern.extension=Pattern/Extension
kotlin.script.definitions.model.name.name=Name
kotlin.script.lookup.definitions=Looking up Kotlin script definitions\u2026
kotlin.script.in.project.sources=<html>This script is not supposed to be inside source root. After Kotlin 1.9 it will be ignored during the module compilation.</html>
kotlin.script.in.project.sources.1.9=<html>This script is not supposed to be inside source root. Since Kotlin 1.9 it is ignored during the module compilation.</html>
kotlin.script.warning.more.info=More info
kotlin.script.in.project.sources.hide=Hide
kotlin.script.in.project.sources.later=Decide later
kotlin.script.in.project.sources.move=Move to\u2026
kotlin.script.in.project.sources.allow=Allow\u2026
kotlin.script.in.project.sources.link=https://youtrack.jetbrains.com/issue/KT-52735
kotlin.script.in.beta.stage=Kotlin Scripting is now in Beta stage
kotlin.script.in.beta.stage.link=https://kotlinlang.org/docs/components-stability.html#stability-levels-explained
kotlin.script.sources.not.yet.indexed=Source files were not indexed to reduce project startup time
kotlin.script.sources.index=Index
codestyle.name.kotlin=Kotlin
add.missing.class.keyword=Add missing 'class' keyword
fix.move.typealias.to.top.level=Move typealias to top level
fix.change.jvm.name=Change JVM name
expand.boolean.expression.to.if.else=Expand boolean expression to 'if else'
inspection.logger.initialized.with.foreign.class.display.name=Logger initialized with foreign class
logger.initialized.with.foreign.class=Logger initialized with foreign class ''{0}''
inspection.logger.placeholder.count.matches.argument.count.display.name=Number of placeholders does not match number of arguments in logging call
placeholder.count.matches.argument.count.more.problem.descriptor=More arguments provided ({0}) than placeholders specified ({1}) #loc
placeholder.count.matches.argument.count.fewer.problem.descriptor=Fewer arguments provided ({0}) than placeholders specified ({1}) #loc
title.logger.factory.method.name=Logger Factory Method Name
title.logger.factory.class.name=Logger Factory Class Name
title.choose.logger.factory.class=Choose Logger Factory Class
inspection.redundant.assequence.call=Redundant 'asSequence' call
remove.assequence.call.fix.text=Remove 'asSequence' call
codestyle.layout.import.aliases.separately=Import aliases separately
button.add.package=Add Package
listbox.import.package=Package
listbox.import.with.subpackages=With Subpackages
title.import.layout=Import Layout
title.packages.to.use.import.with=Packages to Use Import with '*'
redundant.qualifier.unnecessary.non.direct.parent.class.qualifier=Unnecessary non-direct parent classes qualifiers
fix.add.exception.to.throws=Add ''{0}''
fix.add.eq.eq.true=Add '== true'
inspection.replace.isempty.with.ifempty.display.name='if' condition can be replaced with lambda call
inspection.replace.with.ignore.case.equals.display.name=Should be replaced with 'equals(..., ignoreCase = true)'
inspection.redundant.nullable.return.type.display.name=Redundant nullable return type
0.always.returns.non.null.type=''{0}'' always returns non-null type
0.is.always.non.null.type=''{0}'' is always non-null type
inspection.simplifiable.scope.function.display.name=Scope function with nested forEach can be simplified
nested.1.call.in.0.could.be.simplified.to.2=Nested ''{1}'' call in ''{0}'' could be simplified to {2}
evaluate.compile.time.expression=Evaluate compile-time expression

reorder.parameters=Reorder parameters
reorder.parameters.command=Reorder Parameters
analyzing.functions=Analyzing functions\u2026

hints.title.codevision=Code Vision

hints.codevision.usages.format={0, choice, 1#1 Usage|2#{0,number} Usages}
hints.codevision.usages.too_many.format={0,number}+ Usages
hints.codevision.implementations.format={0, choice, 1#1 Implementation|2#{0,number} Implementations}
hints.codevision.implementations.too_many.format={0,number}+ Implementations
hints.codevision.inheritors.format={0, choice, 1#1 Inheritor|2#{0,number} Inheritors}
hints.codevision.inheritors.to_many.format={0,number}+ Inheritors
hints.codevision.overrides.format={0, choice, 1#1 Override|2#{0,number} Overrides}
hints.codevision.overrides.to_many.format={0,number}+ Overrides
hints.codevision.settings=Settings\u2026
convert.string.template.to.build.string=Convert to 'buildString' call
convert.concatenation.to.build.string=Convert concatenation to 'buildString' call
convert.to.indexed.function.call=Convert to indexed function call
inspection.kotlin.invalid.bundle.or.property.display.name=Invalid property key
inspection.gradle.kotlinx.coroutines.deprecation.display.name=Incompatible kotlinx.coroutines dependency is used with Kotlin 1.3+ in Gradle
inspection.deprecated.gradle.dependency.display.name=Deprecated library is used in Gradle
inspection.different.stdlib.gradle.version.display.name=Kotlin library and Gradle plugin versions are different
inspection.different.kotlin.gradle.version.display.name=Kotlin Gradle and IDE plugins versions are different
action.Kotlin.Gradle.ShowDslLogs.text=Show Kotlin Gradle DSL Logs
inspection.maven.coroutines.deprecation.display.name=Incompatible kotlinx.coroutines dependency is used with Kotlin 1.3+ in Maven
inspection.deprecated.maven.dependency.display.name=Deprecated library is used in Maven
inspection.different.kotlin.maven.version.display.name=Maven and IDE plugins versions are different
inspection.different.maven.stdlib.version.display.name=Library and maven plugin versions are different
inspection.kotlin.test.j.unit.display.name=kotlin-test-junit could be used
inspection.kotlin.maven.plugin.phase.display.name=Kotlin Maven Plugin misconfigured
action.KotlinGenerateMavenPluginAction.text=Kotlin plugin
action.KotlinGenerateMavenTestCompileExecutionAction.text=Kotlin test-compile execution
action.KotlinGenerateMavenCompileExecutionAction.text=Kotlin compile execution
dialog.message.incorrect.target.path.directory.not.specified=Incorrect target path. Directory is not specified.
dialog.message.none.elements.were.selected=None elements were selected
a.field.without.an.initializer.is.not.yet.supported=A field without an initializer is not yet supported
a.constructor.call.is.not.yet.supported=A constructor call is not yet supported
failed.to.create.a.wrapper.for.inlining.to.kotlin=Failed to create a wrapper for inlining to Kotlin
inspection.unused.result.of.data.class.copy=Unused result of data class copy
unclear.precedence.of.binary.expression.inspection.display.name=Multiple operators with different precedence
unclear.precedence.of.binary.expression.inspection=Expression should use clarifying parentheses
unclear.precedence.of.binary.expression.quickfix=Add clarifying parentheses
unclear.precedence.of.binary.expression.report.even.obvious.cases.checkbox=Report even obvious cases
replace.function.call.with.if=Replace function call with 'if'
lift.function.call.out.of.if=Lift function call out of 'if'
replace.function.call.with.when=Replace function call with 'when'
lift.function.call.out.of.when=Lift function call out of 'when'

replace.function.call.with.the.opposite=Replace function call with the opposite
replace.0.with.1.and.vice.versa=Replace ''{0}'' with ''{1}'' and vice versa

inspection.kotlin.constant.conditions.display.name=Constant conditions
inspection.message.value.always.true=Value of ''{0}'' is always true
inspection.message.value.always.false=Value of ''{0}'' is always false
inspection.message.condition.always.true=Condition ''{0}'' is always true
inspection.message.condition.always.false=Condition ''{0}'' is always false
inspection.message.condition.always.true.when.reached=Condition ''{0}'' is always true when reached
inspection.message.condition.always.false.when.reached=Condition ''{0}'' is always false when reached
inspection.message.value.always.zero=Value of ''{0}'' is always zero
inspection.message.value.always.null=Value of ''{0}'' is always null

inspection.message.when.condition.always.false='when' branch is never reachable
inspection.message.cast.will.always.fail=Cast will always fail
inspection.message.nonnull.cast.will.always.fail=Operation will always fail as operand is always null
inspection.message.index.out.of.bounds=Index is always out of bounds
inspection.message.for.never.visited='for' range is always empty

floating.point.literal.precision.inspection.display.name=Floating-point literal exceeds the available precision
floating.point.literal.precision.inspection=Floating-point literal cannot be represented with the required precision

inspection.replace.mapIndexed.with.list.generator.display.name=Replace 'mapIndexed' with List generator
should.be.replaced.with.list.generator=Should be replaced with List generator
replace.with.list.generator.fix.text=Replace with List generator

inspection.java.io.serializable.object.must.have.read.resolve.display.name=Serializable object must implement 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.warning=Serializable object must implement 'readResolve'
inspection.java.io.serializable.object.must.have.read.resolve.quick.fix.name=Implement 'readResolve'

inspection.replace.with.import.alias.display.name=Fully qualified name can be replaced with existing import alias
replace.with.import.alias=Replace with import alias

inspection.convert.argument.to.set.display.name=Argument could be converted to 'Set' to improve performance
can.convert.argument.to.set=The argument can be converted to 'Set' to improve performance
convert.argument.to.set.fix.text=Convert argument to 'Set'
convert.to.unicode.escape=Convert to unicode escape
popup.title.expressions=Expressions
popup.title.types=Types
popup.title.elements=Elements
action.hints.settings.text=Hints Settings\u2026
start.import.button.text.add=Add
start.import.button.text.remove=Remove
import.order.button.text.add.package=Add Package
import.order.button.text.remove=Remove
import.order.button.text.up=Up
import.order.button.text.down=Down
import.text.all.other.imports=all other imports
import.text.import=import
import.text.all.alias.imports=all alias imports
extract.new.parameter.name.receiver=<receiver>
kotlin.compiler.configurable=Kotlin Compiler
kotlin.scripting.configurable=Kotlin Scripting
hint.text.no.expression.found=No expression found
progress.title.calculating.type=Calculating type\u2026
intention.name.use.correct.parameter.name=Use correct parameter name
intention.add.import.alias.group.name=Add Import Alias
inspection.message.inconsistent.parameter.name.for.0=Inconsistent parameter name for ''{0}''
inspection.kotlin.catch.may.ignore.exception.display.name='catch' block may ignore exception
inspection.message.empty.catch.block=Empty catch block

inspection.kotlin.jvm.annotation.in.java.display.name=Kotlin JVM annotation in Java
inspection.kotlin.jvm.annotation.in.java.description=Kotlin JVM annotation ''{0}'' has no effect in Java

add.empty.argument.list=Add empty argument list

find.declaration.implementing.methods.checkbox=&Implementing functions
find.declaration.overriding.methods.checkbox=Over&riding functions
find.declaration.implementing.properties.checkbox=&Implementing properties
find.declaration.overriding.properties.checkbox=Over&riding properties
find.declaration.property.readers.checkbox=Readers
find.declaration.property.writers.checkbox=Writers
find.declaration.include.overloaded.methods.checkbox=Include o&verloaded functions and extensions
find.declaration.functions.usages.checkbox=Usages of &functions
find.declaration.properties.usages.checkbox=Usages of &properties
find.declaration.constructor.usages.checkbox=Usages of &constructor
find.declaration.derived.classes.checkbox=&Derived classes
find.declaration.derived.interfaces.checkbox=Derived &interfaces

find.usages.class=class
find.usages.companion.object=companion object
find.usages.constructor=constructor
find.usages.facade.class=facade class
find.usages.for.property={0} for property
find.usages.function=function
find.usages.getter=getter
find.usages.import.alias=import alias
find.usages.interface=interface
find.usages.label=label
find.usages.lambda=lambda
find.usages.object=object
find.usages.parameter=parameter
find.usages.property.accessor=property accessor
find.usages.property=property
find.usages.setter=setter
find.usages.type.alias=type alias
find.usages.type.parameter=type parameter
find.usages.variable=variable
find.usages.checkbox.name.expected.classes=Expected classes
find.usages.class.name.anonymous=Anonymous
find.usages.checkbox.name.expected.functions=Expected functions
find.usages.text.find.usages.for.data.class.components.and.destruction.declarations=<p>Find usages for data class components and destructuring declarations<br/>could be <a href="{0}">disabled once</a> or <a href="{1}">disabled for a project</a>.</p>
find.usages.tool.tip.text.disable.search.for.data.class.components.and.destruction.declarations.project.wide.setting=Disable search for data class components and destructuring declarations. (Project wide setting)
find.usages.checkbox.text.fast.data.class.component.search=Fast data class component search
find.usages.checkbox.name.expected.properties=Expected properties

find.usages.type.named.argument=Named argument
find.usages.type.type.alias=Type alias
find.usages.type.callable.reference=Callable reference
find.usages.type.constructor.delegation.reference=Constructor delegation reference
find.usages.type.type.constraint=Type constraint
find.usages.type.value.parameter.type=Parameter type
find.usages.type.nonLocal.property.type=Class/object property type
find.usages.type.function.return.type=Function return types
find.usages.type.superType=Supertype
find.usages.type.is=Target type of 'is' operation
find.usages.type.class.object=Nested class/object
find.usages.type.companion.object=Companion object
find.usages.type.function.call=Function call
find.usages.type.implicit.get=Implicit 'get'
find.usages.type.implicit.set=Implicit 'set'
find.usages.type.implicit.invoke=Implicit 'invoke'
find.usages.type.implicit.iteration=Implicit iteration
find.usages.type.property.delegation=Property delegation
find.usages.type.extension.receiver.type=Extension receiver type
find.usages.type.super.type.qualifier=Super type qualifier
find.usages.type.receiver=Receiver
find.usages.type.delegate=Delegate
find.usages.type.packageDirective=Package directive
find.usages.type.packageMemberAccess=Package member access

and.delete.initializer=\ and delete initializer
change.to.val=Change to 'val'
change.to.var=Change to 'var'

redundant.0.modifier=Redundant ''{0}'' modifier
remove.redundant.0.modifier=Remove redundant ''{0}'' modifier
remove.redundant.modality.modifier=Remove redundant modality modifier
remove.redundant.visibility.modifier=Remove redundant visibility modifier

usage.provider.text.property.of.0={0} of {1}
usage.provider.text.unnamed=<unnamed>

inspection.unnecessary.opt_in.annotation.display.name=Unnecessary '@OptIn' annotation
inspection.unnecessary.opt_in.redundant.marker=The opt-in marker is redundant: no experimental API marked with ''{0}'' is used
inspection.unnecessary.opt_in.redundant.annotation=The opt-in annotation is redundant: no matching experimental API is used
inspection.unnecessary.opt_in.remove.marker.fix.family.name=Remove opt-in marker
inspection.unnecessary.opt_in.remove.annotation.fix.family.name=Remove annotation

inspection.verbose.nullability.and.emptiness.display.name=Verbose nullability and emptiness check
inspection.verbose.nullability.and.emptiness.call=Replace subsequent checks with ''{0}()'' call

add.return.expression=Add 'return' expression
provide.return.value=Provide the return value


wrap.expression.in.parentheses=Wrap expression in parentheses

convert.left.hand.side.to.0=Convert left-hand side to ''{0}''
convert.right.hand.side.to.0=Convert right-hand side to ''{0}''
convert.string.to.character.literal=Convert string to character literal

inspection.replace.readline.with.readln.display.name='readLine' can be replaced with 'readln' or 'readlnOrNull'

fix.convert.to.is.array.of.call=Convert to 'isArrayOf' call

inspection.message.object.with.manual.tostring.can.be.converted.to.data.object='object' with manual 'toString' can be converted to 'data object'
inspection.message.sealed.object.can.be.converted.to.data.object='sealed' sub-object can be converted to 'data object'
convert.to.data.object=Convert to 'data object'
analyzing.members=Analyzing members\u2026
inspection.convert.object.to.data.object.display.name=Convert 'object' to 'data object'

inspection.replace.with.string.builder.append.range.display.name='StringBuilder.append(CharArray, offset, len)' call on the JVM
progress.title.collect.hierarchy=Collect ''{0}'' hierarchy \u2026

inspection.redundant.value.argument.display.name=Redundant value argument
inspection.redundant.value.argument.annotation=Value argument matches the default value of parameter ''{0}''

inspection.filter.is.instance.call.with.class.literal.argument.display.name='filterIsInstance' call with a class literal argument
inspection.filter.is.instance.call.with.class.literal.argument.quick.fix.text=Replace class literal argument with a reified type parameter

add.fun.modifier.to.0=Add ''fun'' modifier to ''{0}''

convert.to.nullable.type=Convert to nullable type
add.external.keyword=Add external keyword
interface.should.be.external=Interface should be external
class.should.be.external.interface=Class should be external interface
object.should.be.external.interface=Object should be external interface
boolean.property.in.external.interface.should.be.nullable=Boolean property in external interface should be nullable
property.in.external.interface.should.be.var=Property in external interface should be var
external.interface.contains.val.property.name=External interface contains val property
external.interface.contains.non.nullable.property.name=External interface contains non-nullable boolean property
non.external.classifier.extending.state.or.props.name=Non-external classifier extending State or Props

highlighter.name.style=Style {0}
highlighter.name.dsl=Dsl//

notification.text.kotlin.js.compiler.title=Kotlin/JS IR is stable in versions 1.8.0 and later!
notification.text.kotlin.js.compiler.body=Use the new Kotlin/JS IR compiler to reduce the bundle size of your application and auto-generate TypeScript definitions (d.ts).
notification.text.kotlin.js.compiler.learn.more=Learn more
notification.text.kotlin.js.compiler.link=https://kotl.in/jsirstable
find.usages.prepare.dialog.progress=Prepare Dialog

replace.overloaded.operator.with.function.call=Replace overloaded operator with function call
dialog.progress.collect.members.to.generate=Collect Members\u2026
progress.title.collect.members.to.generate=Collect members\u2026

group.advanced.settings.kotlin=Kotlin
advanced.setting.kotlin.mpp.experimental=Enable experimental Multiplatform IDE features
advanced.setting.kotlin.mpp.experimental.description=Requires IDE restart
dialog.title.resolving.inheritable.status=Resolving Inheritable Status\u2026

inspection.join.declaration.and.assignment.option.report.with.complex.initialization.of.member.properties=Report with complex initialization of member properties
goto.related.provider.in.module.0=(in module {0})
progress.title.searching.for.expected.actual=Searching for expect/actual\u2026

button.rename.current=Rename Current
button.rename.base=Rename Base
progress.title.calculate.occurrences=Calculate occurrences\u2026
progress.title.check.for.conflicts=Check for conflicts\u2026
checkbox.collapse.to.expression.body=Collapse to expression body

inspection.runblocking.analysis.found.runblocking=--> runBlocking
inspection.runblocking.analysis.graphbuilding.progress=Processing {0}
inspection.runblocking.presentation.text=RunBlocking builder called from coroutine
inspection.runblocking.presentation.settings.exploration.title=Explore functions with overrides
inspection.runblocking.presentation.settings.exploration.option.strict=No
inspection.runblocking.presentation.settings.exploration.option.declaration=Yes, excluding overrides
inspection.runblocking.presentation.settings.exploration.option.all=Yes, including overrides
inspection.runblocking.presentation.descriptor=Analyzing runBlocking:
inspection.runblocking.presentation.display.name=RunBlocking in coroutine
group.names.coroutine=Coroutine inspections

dialog.title.build.super.types.hierarchy=Build Super Type Hierarchy for {0}

progress.title.converting.to.if.then.else.expression=Converting to if-then-else expression\u2026
progress.title.introducing.value.for.condition=Introducing value for condition\u2026