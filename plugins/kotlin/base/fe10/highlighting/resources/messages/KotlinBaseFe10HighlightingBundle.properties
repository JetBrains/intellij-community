kotlin.compiler.error=Kotlin compiler error
kotlin.compiler.warning=Kotlin compiler warning
kotlin.compiler.warning.0.options=Compiler warning ''{0}'' options

the.following.declarations.have.the.same.jvm.signature.code.0.1.code.br.ul.2.ul=The following declarations have the same JVM signature (<code>{0}{1}</code>):<br/>\n<ul>\n{2}</ul>

unknown.receiver=Unknown receiver
always.null=Always null

smart.cast.to.0.for.1.call=Smart cast to {0} (for {1} call)

wrapped.into.a.reference.object.to.be.modified.when.captured.in.a.closure=Wrapped into a reference object to be modified when captured in a closure
value.captured.in.a.closure=Value captured in a closure

type.parameters.where=where
cannot.be.inferred=cannot be inferred
i.for.i.br.0=<i> for </i><br/>{0}
defined.in=defined in
root.package=root package

function.receiver.0=receiver: {0}
function.arguments=arguments:\u0020

html.0.has.no.corresponding.expected.declaration.1.html={0} has no corresponding expected declaration{1}
html.0.is.not.abstract.and.does.not.implement.abstract.base.class.member.br.1.html={0} is not abstract and does not implement abstract base class member<br/>{1}
html.0.is.not.abstract.and.does.not.implement.abstract.member.br.1.html={0} is not abstract and does not implement abstract member<br/>{1}
html.0.method.may.be.missing.none.of.the.following.functions.will.be.called.ul.1.ul.html=''{0}'' method may be missing. None of the following functions will be called: <ul>{1}</ul>
html.candidate.resolution.will.be.changed.soon.please.use.fully.qualified.name.to.invoke.the.following.closer.candidate.explicitly.ul.0.ul.html=Candidate resolution will be changed soon, please use fully qualified name to invoke the following closer candidate explicitly: <ul>{0}</ul>
html.expected.0.has.no.actual.declaration.in.module.1.2.html=Expected {0} has no actual declaration in module {1}{2}
html.accidental.override.0.html=Accidental override: {0}
html.method.contains.from.concurrenthashmap.may.have.unexpected.semantics.it.calls.containsvalue.instead.of.containskey.br.use.explicit.form.of.the.call.to.containskey.containsvalue.contains.or.cast.the.value.to.kotlin.collections.map.instead.br.see.https.youtrack.jetbrains.com.issue.kt.18053.for.more.details.html=Method 'contains' from ConcurrentHashMap may have unexpected semantics: it calls 'containsValue' instead of 'containsKey'.<br/>Use explicit form of the call to 'containsKey'/'containsValue'/'contains' or cast the value to kotlin.collections.Map instead.<br/>See https://youtrack.jetbrains.com/issue/KT-18053 for more details
html.javascript.0.html=JavaScript: {0}
html.platform.declaration.clash.0.html=Platform declaration clash: {0}
html.internal.error.occurred.while.analyzing.this.expression.br.0.html=<strong>Internal error occurred while analyzing this expression:</strong><br/>{0}
html.property.delegate.must.have.a.0.method.none.of.the.following.functions.are.suitable.ul.1.ul.html=Property delegate must have a ''{0}'' method. None of the following functions are suitable. <ul>{1}</ul>
html.overload.resolution.ambiguity.on.method.0.all.these.functions.match.ul.1.ul.html=Overload resolution ambiguity on method ''{0}''. All these functions match. <ul>{1}</ul>
html.unresolved.reference.br.none.of.the.following.candidates.is.applicable.because.of.receiver.type.mismatch.ul.0.ul.html=Unresolved reference. <br/> None of the following candidates is applicable because of receiver type mismatch: <ul>{0}</ul>
html.cannot.choose.among.the.following.candidates.without.completing.type.inference.ul.0.ul.html=Cannot choose among the following candidates without completing type inference: <ul>{0}</ul>
html.none.of.the.following.functions.can.be.called.with.the.arguments.supplied.ul.0.ul.html=None of the following functions can be called with the arguments supplied. <ul>{0}</ul>
html.overload.resolution.ambiguity.all.these.functions.match.ul.0.ul.html=Overload resolution ambiguity. All these functions match. <ul>{0}</ul>
html.function.return.type.mismatch.table.tr.td.expected.td.td.1.td.tr.tr.td.found.td.td.2.td.tr.table.html=Function return type mismatch.<table><tr><td>Expected:</td><td>{1}</td></tr><tr><td>Found:</td><td>{2}</td></tr></table>
html.0.must.override.1.br.because.it.inherits.many.implementations.of.it.html={0} must override {1}<br />because it inherits many implementations of it
html.types.of.inherited.var.properties.do.not.match.br.0.br.1.html=Types of inherited var-properties do not match:<br/>{0},<br/>{1}
html.types.of.inherited.properties.are.incompatible.br.0.br.1.html=Types of inherited properties are incompatible:<br/>{0},<br/>{1}
html.actual.class.0.has.no.corresponding.members.for.expected.class.members.1.html=Actual class ''{0}'' has no corresponding members for expected class members:{1}
html.val.property.cannot.override.var.property.br.1.html=Val-property cannot override var-property<br />{1}
html.var.property.type.is.0.which.is.not.a.type.of.overridden.br.1.html=Var-property type is {0}, which is not a type of overridden<br/>{1}
html.setter.parameter.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Setter parameter type must be equal to the type of the property.<table><tr><td>Expected:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table>
html.property.type.is.0.which.is.not.a.subtype.type.of.overridden.br.1.html=Property type is {0}, which is not a subtype type of overridden<br/>{1}
html.return.types.of.inherited.members.are.incompatible.br.0.br.1.html=Return types of inherited members are incompatible:<br/>{0},<br/>{1}
html.return.type.is.0.which.is.not.a.subtype.of.overridden.br.1.html=Return type is ''{0}'', which is not a subtype of overridden<br/>{1}
html.loop.parameter.type.mismatch.table.tr.td.iterated.values.td.td.0.td.tr.tr.td.parameter.td.td.1.td.tr.table.html=Loop parameter type mismatch.<table><tr><td>Iterated values:</td><td>{0}</td></tr><tr><td>Parameter:</td><td>{1}</td></tr></table>
html.type.argument.is.not.within.its.bounds.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Type argument is not within its bounds.<table><tr><td>Expected:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table>
html.method.iterator.is.ambiguous.for.this.expression.ul.0.ul.html=Method ''iterator()'' is ambiguous for this expression.<ul>{0}</ul>
html.getter.return.type.must.be.equal.to.the.type.of.the.property.table.tr.td.expected.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Getter return type must be equal to the type of the property.<table><tr><td>Expected:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table>
html.type.inference.failed.0.html=Type inference failed: {0}
html.assignment.operators.ambiguity.all.these.functions.match.ul.0.ul.table.html=Assignment operators ambiguity. All these functions match.<ul>{0}</ul></table>
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.br.projected.type.2.restricts.use.of.br.3.html=Type mismatch.<table><tr><td>Required:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table><br />\nProjected type {2} restricts use of <br />\n{3}\n
html.type.mismatch.table.tr.td.required.td.td.0.td.tr.tr.td.found.td.td.1.td.tr.table.html=Type mismatch.<table><tr><td>Required:</td><td>{0}</td></tr><tr><td>Found:</td><td>{1}</td></tr></table>

found.space=found:\u0020
required.space=required:\u0020
type.inference.failed.expected.type.mismatch=Type inference failed. Expected type mismatch:\u0020