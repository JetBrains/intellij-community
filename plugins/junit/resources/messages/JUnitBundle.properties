fork.mode.label=&Fork mode:
fork.mode.name=Fork mode

repeat.label=&Repeat:
repeat.name=Repeat
repeat.count.label=&Repeat count:

search.scope.name=Search for tests
search.scope.project=In whole project
search.scope.module=In single module
search.scope.module.deps=Across module dependencies

test.group=Tests
#possible run targets
category.label=Category
change.list.label=Change list
directory.label=Directory
pattern.label=Pattern
tag.expression.label=Tag expression
uniqueid.label=UniqueId

#actions
action.AddToISuite.text=Add to JUnit Pattern Suite
action.excludeFromSuite.text=Exclude from Suite
action.text.test.unknown.target=Unknown
action.text.test.category=Tests of {0}
action.text.test.tags=Tests of {0}

unused.declaration.junit.test.entry.point=JUnit test cases
test.discovery.by.all.changes.combo.item=All
module.does.not.exists=Module ''{0}'' does not exist in project ''{1}''
junit.configuration.description=JUnit test configuration
junit.configuration.class.label=&Class:
no.pattern.error.message=No pattern selected
junit.configuration.method.label=M&ethod:
default.junit.config.name.whole.project=Whole project
default.junit.config.name.all.in.module=All in {0}
default.junit.configuration.name=<no-name>
default.junit.config.name.all.in.package.in.module={0} in {1}
default.junit.config.name.temp.suite=Temp suite
default.junit.config.name.tags=Tags ({0})
default.junit.config.empty.category=Invalid
default.junit.config.name.category=@Category({0})
junit.configuration.in.single.module.radio=In s&ingle module
no.test.class.specified.error.text=No test class specified
directory.not.found.error.message=Directory ''{0}'' is not found

create.setup.dialog.message=Method setUp already exist but is not annotated as {0}. Annotate?
junit.configuration.display.name=JUnit
class.isnt.inheritor.of.testcase.error.message={0} isn''t inheritor of TestCase
cannot.browse.test.inheritors.dialog.title=Can't Browse TestCase Inheritors
junit.configuration.package.label=Packa&ge:
create.setup.dialog.title=Create setUp Method
junit.not.found.in.module.error.message=JUnit not found in module ''{0}''
junit.configuration.across.module.dependencies.radio=Across modu&le dependencies
method.name.not.specified.error.message=Method name not specified
junit.configuration.search.for.tests.label=Search for tests:
class.not.test.error.message=Class ''{0}'' is not a test
configuration.not.specified.message=Configuration test type not specified: {0}
package.does.not.exist.error.message=Package ''{0}'' does not exist
test.method.doesnt.exist.error.message=Test method ''{0}'' doesn''t exist
junit.configuration.in.whole.project.radio=In &whole project
junit.entry.point.suggest.package.private.visibility.junit5=Suggest package-private visibility level for junit 5 tests
category.is.not.specified.error.message=Category is not specified
directory.is.not.specified.error.message=Directory is not specified
directory.0.is.not.found.error.message=Directory ''{0}'' is not found
module.to.choose.classpath.not.specified.error.message=Module to choose classpath from is not specified
tags.are.not.specified.error.message=Tags are not specified
tag.name.0.must.be.syntactically.valid.warning=Tag name [{0}] must be syntactically valid
dialog.message.no.unique.id.specified.exception=No unique id specified
test.kind.hint=The type of resource to search for tests
test.pattern.hint=A regexp to match the names of classes that contain tests
test.class.hint=The fully qualified name of a class that contains tests
test.method.hint=The fully qualified name of a test method
test.package.hint=The name of the package that contains tests

# configuration kinds
junit.configuration.kind.all.in.package=All in package
junit.configuration.kind.all.in.directory=All in directory
junit.configuration.kind.by.pattern=Pattern
junit.configuration.kind.class=Class
junit.configuration.kind.method=Method
junit.configuration.kind.category=Category
junit.configuration.kind.by.unique.id=UniqueId
junit.configuration.kind.by.tags=Tags

# repeat modes
junit.configuration.repeat.mode.once=Once
junit.configuration.repeat.mode.n.times=N times
junit.configuration.repeat.mode.until.failure=Until failure
junit.configuration.repeat.mode.until.success=Until success
junit.configuration.repeat.mode.until.stopped=Until stopped

# fork modes
junit.configuration.fork.mode.none=None
junit.configuration.fork.mode.method=Method
junit.configuration.fork.mode.class=Class
junit.configuration.fork.mode.repeat=Repeat

combobox.changelists.all=All

no.module.selected.error.message=No module selected
category.interface.dialog.title=Category Interface
running.tests.disabled.during.index.update.error.message=Running tests is disabled during index update
dialog.message.failed.to.resolve.maven.id=Failed to resolve {0}
junit5.migration.description=For transferring the JUnit 4 test annotations to the new jupiter ones, may result in red code! Assertions won't be migrated. \
  Please see the 'Java | JUnit issues | JUnit 4 test can be JUnit 5' inspection to migrate only tests which can be converted fully automatically.
progress.title.download.additional.dependencies=Download additional dependencies\u2026
junit.config.with.parameter.0=\ with parameter "{0}"
dialog.title.preparing.test=Preparing Test

#Inspections
junit.inspections.group.name=JUnit

jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' is not called from 'finally' block
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code> is not called from 'finally' block #loc

jvm.inspections.junit.mixed.annotations.name=JUnit API usage from multiple versions in a single TestCase
jvm.inspections.junit.mixed.annotations.junit.descriptor=Method <code>#ref()</code> annotated with ''@{0}'' inside class extending JUnit {1} TestCase #loc

jvm.inspections.junit4.converter.display.name=JUnit 3 test can be JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> could be converted to JUnit4 test case
jvm.inspections.junit4.converter.quickfix.name=Convert to JUnit 4 test case
jvm.inspections.junit4.converter.quickfix.conflict.semantics=Method call {0} may change semantics when {1} is converted to JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=Migration of suite method for {0} has side effects which will be deleted
jvm.inspections.junit4.converter.quickfix.conflict.name=Method {0} will have a name collision with its super method
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=Method call {0} will not compile when {1} is converted to JUnit 4

jvm.inspections.junit4.inherited.runwith.display.name='@RunWith' annotation already exists in a parent class
jvm.inspections.junit4.inherited.runwith.problem.descriptor='@RunWith' annotation already exists in {0} class

jvm.inspections.junit5.converter.display.name=JUnit 4 test can be JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref can be JUnit 5 test
jvm.inspections.junit5.converter.quickfix=Migrate to JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=Convert Assertions
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=Class {0} can''t be converted to JUnit 5, cause there are incompatible inheritor(s): {1}

jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 obsolete assertions
jvm.inspections.junit5.assertions.converter.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with a call to a method from ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Replace with ''{0}'' method call
jvm.inspections.junit5.assertions.converter.familyName=Replace with JUnit 5 compatible call

jvm.inspections.unconstructable.test.case.not.public.descriptor=Test class <code>#ref</code> is not constructable because it is not 'public' #loc
jvm.inspections.unconstructable.test.case.junit3.descriptor=Test class <code>#ref</code> is not constructable because it does not have a 'public' no-arg or single 'String' parameter constructor #loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=Test class <code>#ref</code> is not constructable because it should have exactly one 'public' no-arg constructor #loc

jvm.inspections.junit.malformed.declaration.name=JUnit malformed declaration
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignore test parameter if it is annotated by:
jvm.inspections.junit.malformed.no.arg.descriptor=Method <code>#ref</code> should be {0}, {1}{2, choice, 0# and have no parameters|1#, have no parameters and of type void}
jvm.inspections.junit.malformed.annotated.single.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2}
jvm.inspections.junit.malformed.annotated.double.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2} and {3}
jvm.inspections.junit.malformed.annotated.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be of type ''{2}''
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2} and of type ''{3}''
jvm.inspections.junit.malformed.annotated.double.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2}, {3} and of type ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameter ''{1}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameter ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameters {1} and ''{2}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameters {2} and ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameters ''{2}'' and ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameters ''{3}'' and ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameters {3} and ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameters {4} and ''{5}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not be a suspending function
jvm.inspections.junit.malformed.suspend.function.descriptor=Method <code>#ref</code> should not be a suspending function
jvm.inspections.junit.malformed.test.combination.descriptor=Suspicious combination of {0} and ''@{1}''
jvm.inspections.junit.malformed.repetition.number.descriptor=The number of repetitions must be greater than zero
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Tests in nested class will not be executed
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} should be registered at the class level
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=Cannot resolve target method source: ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Multiple parameters have to be wrapped in 'Arguments'
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=Method source ''{0}'' must have one of the following return types: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' or ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=Method source ''{0}'' should have no parameters
jvm.inspections.junit.malformed.param.method.source.static.descriptor=Method source ''{0}'' must be static
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No implicit conversion found to convert ''{0}'' to ''{1}''
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Duplicate 'enum' constant name
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=Can't resolve 'enum' constant reference.
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No value source is defined
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Exactly one type of input must be provided
jvm.inspections.junit.malformed.param.file.source.descriptor=Cannot resolve file source: ''{0}''
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' cannot provide an argument to method because method doesn''t have parameters
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' cannot provide an argument to method because method has an unsupported parameter of ''{1}'' type
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Only a single parameter can be provided by ''@{0}''
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=No sources are provided, the suite would be empty
jvm.inspections.junit.malformed.fix.class.signature=Fix class signature
jvm.inspections.junit.malformed.fix.class.signature.multi=Fix class signatures
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Fix ''{0}'' class signature
jvm.inspections.junit.malformed.fix.method.signature=Fix method signature
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Fix ''{0}'' method signature
jvm.inspections.junit.malformed.fix.field.signature=Fix field signature
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Fix ''{0}'' field signature

jvm.inspections.junit.assertequals.on.array.display.name='assertEquals()' called on array
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code> called on array #loc

jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' may be 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> may be 'assertSame()' #loc

jvm.inspections.junit.ignored.test.display.name=JUnit test annotated with '@Ignore'/'@Disabled'
jvm.inspections.junit.ignored.test.ignore.reason.option=Only report annotations without reason
jvm.inspections.junit.ignored.test.class.problem.descriptor=Test class ''{0}'' is ignored/disabled {1, choice, 1#|2#without reason} #loc
jvm.inspections.junit.ignored.test.method.problem.descriptor=Test method ''{0}()'' is ignored/disabled {1, choice, 1#|2#without reason} #loc

jvm.inspections.migrate.assertion.name=JUnit assertion can be 'assertThat()' call
jvm.inspections.migrate.assert.to.matcher.option=Statically import matcher's methods
jvm.inspections.migrate.assert.to.matcher.description=Assert expression <code>#ref</code> can be replaced with ''{0}'' call #loc

inspection.parameterized.parameters.static.collection.display.name=Parameterized test class without data provider method
fix.data.provider.signature.fix.name=Change method signature to ''{0}''
fix.data.provider.create.method.fix.name=Create data provider method '@Parameters public static Iterable<Object> parameters()'
fix.data.provider.signature.family.name=Fix data provider method signature
fix.data.provider.signature.missing.method.problem=Parameterized test class <code>#ref</code> lacks data provider method annotated with '@Parameters'
fix.data.provider.signature.incorrect.problem=Data provider method <code>#ref()</code> has an incorrect signature
fix.data.provider.multiple.methods.problem=Multiple @Parameters data provider methods present in class <code>#ref</code>

expected.exception.never.thrown.display.name=Expected exception never thrown in test method body
expected.exception.never.thrown.problem.descriptor=Expected <code>#ref</code> never thrown in body of ''{0}()'' #loc

junit3.style.test.method.in.junit4.class.display.name=Old style JUnit test method in JUnit 4 class
junit3.style.test.method.in.junit4.class.problem.descriptor=Old style JUnit test method <code>#ref()</code> in JUnit 4 class #loc

multiple.exceptions.declared.on.test.method.display.name=Multiple exceptions declared on test method
multiple.exceptions.declared.on.test.method.problem.descriptor=<code>#ref</code> could be replaced with 'throws Exception' #loc

usage.of.obsolete.assert.display.name=Usage of obsolete 'junit.framework.Assert' method
use.of.obsolete.assert.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with call to method from ''org.junit.Assert'' #loc
use.of.obsolete.assert.quickfix=Replace with 'org.junit.Assert' method call