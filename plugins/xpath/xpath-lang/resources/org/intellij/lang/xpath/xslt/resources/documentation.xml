<!DOCTYPE x:documentation [
    <!ENTITY nbsp   "&#160;"> <!-- no-break space = non-breaking space, U+00A0 ISOnum -->
]>
<x:documentation xmlns:x="urn:xslt-documentation" xmlns="http://www.w3.org/1999/xhtml">
  <!-- http://www.w3.org/TR/1999/REC-xslt-19991116  -->
  <x:elements base="http://www.w3.org/TR/xslt" style="w3c">
    <x:element name="template" href="#element-template">
      <h3><a name="section-Defining-Template-Rules"></a>Defining Template Rules</h3>

      <p class="element-syntax"><a name="element-template"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;xsl:template<br/>
      &nbsp;&nbsp;match = <var>pattern</var> <br/>
      &nbsp;&nbsp;name = <var>qname</var> <br/>
      &nbsp;&nbsp;priority = <var>number</var> <br/>
      &nbsp;&nbsp;mode = <var>qname</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*,
      <var>template</var>) --&gt;<br/>
      &lt;/xsl:template&gt;</code></p>

      <p>A template rule is specified with the <code>xsl:template</code> element.
      The <code>match</code> attribute is a <a href="#NT-Pattern">Pattern</a> that
      identifies the source node or nodes to which the rule applies.  The
      <code>match</code> attribute is required unless the <code>xsl:template</code>
      element has a <code>name</code> attribute (see <a
      href="#named-templates">[<b>6 Named Templates</b>]</a>). It is an error for
      the value of the <code>match</code> attribute to contain a <a
      href="http://www.w3.org/TR/xpath#NT-VariableReference">VariableReference</a>.
      The content of the <code>xsl:template</code> element is the template that is
      instantiated when the template rule is applied.</p>

      <p>For example, an XML document might contain:</p>
      <pre>This is an &lt;emph&gt;important&lt;/emph&gt; point.</pre>

      <p>The following template rule matches <code>emph</code> elements and
      produces a <code>fo:inline-sequence</code> formatting object with a
      <code>font-weight</code> property of <code>bold</code>.</p>
      <pre>&lt;xsl:template match="emph"&gt;
  &lt;fo:inline-sequence font-weight="bold"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre>

      <blockquote>
        <b>NOTE:</b>Examples in this document use the <code>fo:</code> prefix for
        the namespace <code>http://www.w3.org/1999/XSL/Format</code>, which is the
        namespace of the formatting objects defined in <a
      href="#XSL">[XSL]</a>.</blockquote>

      <p>As described next, the <code>xsl:apply-templates</code> element
      recursively processes the children of the source element.</p>
    </x:element>

    <x:element name="apply-imports" href="#element-apply-imports">
      <h3><a name="apply-imports"></a>Overriding Template Rules</h3>

      <p class="element-syntax"><a name="element-apply-imports"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:apply-imports&nbsp;/&gt;</code></p>

      <p>A template rule that is being used to override a template rule in an
      imported stylesheet (see <a href="#conflict">[<b>5.5 Conflict Resolution for
      Template Rules</b>]</a>) can use the <code>xsl:apply-imports</code> element
      to invoke the overridden template rule.</p>

      <p><a name="dt-current-template-rule"></a>At any point in the processing of a
      stylesheet, there is a <b>current template rule</b>.  Whenever a template
      rule is chosen by matching a pattern, the template rule becomes the current
      template rule for the instantiation of the rule's template. When an
      <code>xsl:for-each</code> element is instantiated, the current template rule
      becomes null for the instantiation of the content of the
      <code>xsl:for-each</code> element.</p>

      <p><code>xsl:apply-imports</code> processes the current node using only
      template rules that were imported into the stylesheet element containing the
      current template rule; the node is processed in the current template rule's
      mode.  It is an error if <code>xsl:apply-imports</code> is instantiated when
      the current template rule is null.</p>

      <p>For example, suppose the stylesheet <code>doc.xsl</code> contains a
      template rule for <code>example</code> elements:</p>
      <pre>&lt;xsl:template match="example"&gt;
        &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
      &lt;/xsl:template&gt;</pre>

      <p>Another stylesheet could import <code>doc.xsl</code> and modify the
      treatment of <code>example</code> elements as follows:</p>
      <pre>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</pre>

      <p>The combined effect would be to transform an <code>example</code> into an
      element of the form:</p>
      <pre>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</pre>
    </x:element>

    <x:element name="apply-templates" href="#element-apply-templates">
      <h3><a name="section-Applying-Template-Rules"></a>Applying Template Rules </h3>

      <p class="element-syntax"><a name="element-apply-templates"></a><code>&lt;!--
        Category: instruction --&gt;<br/>
        &lt;xsl:apply-templates<br/>
        &nbsp;&nbsp;select = <var>node-set-expression</var> <br/>
        &nbsp;&nbsp;mode = <var>qname</var>&gt;<br/>
        &nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a
          href="#element-with-param">xsl:with-param</a>)* --&gt;<br/>
        &lt;/xsl:apply-templates&gt;</code></p>

      <p>This example creates a block for a <code>chapter</code> element and then
        processes its immediate children.</p>
      <pre>&lt;xsl:template match="chapter"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

      <p>In the absence of a <code>select</code> attribute, the
        <code>xsl:apply-templates</code> instruction processes all of the children of
        the current node, including text nodes.  However, text nodes that have been
        stripped as specified in <a href="#strip">[<b>3.4 Whitespace
        Stripping</b>]</a> will not be processed.  If stripping of whitespace nodes
        has not been enabled for an element, then all whitespace in the content of
        the element will be processed as text, and thus whitespace between child
        elements will count in determining the position of a child element as
        returned by the <b><a
          href="http://www.w3.org/TR/xpath#function-position">position</a></b>
        function.</p>

      <p>A <code>select</code> attribute can be used to process nodes selected by
        an expression instead of processing all children.  The value of the
        <code>select</code> attribute is an <a href="#dt-expression">expression</a>.
        The expression must evaluate to a node-set.  The selected set of nodes is
        processed in document order, unless a sorting specification is present (see
        <a href="#sorting">[<b>10 Sorting</b>]</a>).  The following example processes
        all of the <code>author</code> children of the <code>author-group</code>:</p>
      <pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre>

      <p>The following example processes all of the <code>given-name</code>s of the
        <code>author</code>s that are children of <code>author-group</code>:</p>
      <pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</pre>

      <p>This example processes all of the <code>heading</code> descendant elements
        of the <code>book</code> element.</p>
      <pre>&lt;xsl:template match="book"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates select=".//heading"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

      <p>It is also possible to process elements that are not descendants of the
        current node.  This example assumes that a <code>department</code> element
        has <code>group</code> children and <code>employee</code> descendants. It
        finds an employee's department and then processes the <code>group</code>
        children of the <code>department</code>.</p>
      <pre>&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

      <p>Multiple <code>xsl:apply-templates</code> elements can be used within a
        single template to do simple reordering.  The following example creates two
        HTML tables. The first table is filled with domestic sales while the second
        table is filled with foreign sales.</p>
      <pre>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</pre>

      <blockquote>
        <b>NOTE:</b> It is possible for there to be two matching descendants where
        one is a descendant of the other.  This case is not treated specially: both
        descendants will be processed as usual. For example, given a source document
        <pre>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</pre>
        the rule
        <pre>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</pre>
        will process both the outer <code>div</code> and inner <code>div</code>
        elements.</blockquote>

      <blockquote>
        <b>NOTE:</b>Typically, <code>xsl:apply-templates</code> is used to process
        only nodes that are descendants of the current node.  Such use of
        <code>xsl:apply-templates</code> cannot result in non-terminating
        processing loops.  However, when <code>xsl:apply-templates</code> is used
        to process elements that are not descendants of the current node, the
        possibility arises of non-terminating loops. For example,
        <pre style="color: red">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</pre>
        Implementations may be able to detect such loops in some cases, but the
        possibility exists that a stylesheet may enter a non-terminating loop that
        an implementation is unable to detect. This may present a denial of service
        security risk.</blockquote>
    </x:element>

    <x:element name="attribute" href="#element-attribute">
      <h3><a name="creating-attributes"></a>Creating Attributes with
      <code>xsl:attribute</code></h3>

      <p class="element-syntax"><a name="element-attribute"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:attribute<br/>
      &nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br/>
      &nbsp;&nbsp;namespace = { <var>uri-reference</var> }&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:attribute&gt;</code></p>

      <p>The <code>xsl:attribute</code> element can be used to add attributes to
      result elements whether created by literal result elements in the stylesheet
      or by instructions such as <code>xsl:element</code>. The <a
      href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> of the
      attribute to be created is specified by a required <code>name</code>
      attribute and an optional <code>namespace</code> attribute. Instantiating an
      <code>xsl:attribute</code> element adds an attribute node to the containing
      result element node. The content of the <code>xsl:attribute</code> element is
      a template for the value of the created attribute.</p>

      <p>The <code>name</code> attribute is interpreted as an <a
      href="#dt-attribute-value-template">attribute value template</a>. It is an
      error if the string that results from instantiating the attribute value
      template is not a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> or is the string
      <code>xmlns</code>.  An XSLT processor may signal the error; if it does not
      signal the error, it must recover by not adding the attribute to the result
      tree. If the <code>namespace</code> attribute is not present, then the <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> is expanded into
      an expanded-name using the namespace declarations in effect for the
      <code>xsl:attribute</code> element, <i>not</i> including any default
      namespace declaration.</p>

      <p>If the <code>namespace</code> attribute is present, then it also is
      interpreted as an <a href="#dt-attribute-value-template">attribute value
      template</a>. The string that results from instantiating it should be a URI
      reference.  It is not an error if the string is not a syntactically legal URI
      reference.  If the string is empty, then the expanded-name of the attribute
      has a null namespace URI.  Otherwise, the string is used as the namespace URI
      of the expanded-name of the attribute to be created. The local part of the <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> specified by the
      <code>name</code> attribute is used as the local part of the expanded-name of
      the attribute to be created.</p>

      <p>XSLT processors may make use of the prefix of the <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> specified in the
      <code>name</code> attribute when selecting the prefix used for outputting the
      created attribute as XML; however, they are not required to do so and, if the
      prefix is <code>xmlns</code>, they must not do so. Thus, although it is not
      an error to do:</p>
      <pre>&lt;xsl:attribute name="xmlns:xsl" namespace="whatever"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;</pre>

      <p>it will not result in a namespace declaration being output.</p>

      <p>Adding an attribute to an element replaces any existing attribute of that
      element with the same expanded-name.</p>

      <p>The following are all errors:</p>
      <ul>
        <li><p>Adding an attribute to an element after children have been added to
          it; implementations may either signal the error or ignore the
          attribute.</p>
        </li>
        <li><p>Adding an attribute to a node that is not an element;
          implementations may either signal the error or ignore the attribute.</p>
        </li>
        <li><p>Creating nodes other than text nodes during the instantiation of the
          content of the <code>xsl:attribute</code> element; implementations may
          either signal the error or ignore the offending nodes.</p>
        </li>
      </ul>

      <blockquote>
        <b>NOTE:</b>When an <code>xsl:attribute</code> contains a text node with a
        newline, then the XML output must contain a character reference. For
        example,
        <pre>&lt;xsl:attribute name="a"&gt;x
y&lt;/xsl:attribute&gt;</pre>
        will result in the output
        <pre>a="x&amp;#xA;y"</pre>
        (or with any equivalent character reference). The XML output cannot be
        <pre>a="x
y"</pre>
        This is because XML 1.0 requires newline characters in attribute values to
        be normalized into spaces but requires character references to newline
        characters not to be normalized.  The attribute values in the data model
        represent the attribute value after normalization.  If a newline occurring
        in an attribute value in the tree were output as a newline character rather
        than as character reference, then the attribute value in the tree created
        by reparsing the XML would contain a space not a newline, which would mean
        that the tree had not been output correctly.</blockquote>
    </x:element>

    <x:element name="attribute-set" href="#element-attribute-set">
      <h3><a name="attribute-sets"></a>Named Attribute Sets</h3>

      <p class="element-syntax"><a name="element-attribute-set"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;xsl:attribute-set<br/>
      &nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>
      &nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>*
      --&gt;<br/>
      &lt;/xsl:attribute-set&gt;</code></p>

      <p>The <code>xsl:attribute-set</code> element defines a named set of
      attributes.  The <code>name</code> attribute specifies the name of the
      attribute set.  The value of the <code>name</code> attribute is a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
      expanded as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>.
      The content of the <code>xsl:attribute-set</code> element consists of zero or
      more <code>xsl:attribute</code> elements that specify the attributes in the
      set.</p>

      <p>Attribute sets are used by specifying a <code>use-attribute-sets</code>
      attribute on <code>xsl:element</code>, <code>xsl:copy</code> (see <a
      href="#copying">[<b>7.5 Copying</b>]</a>) or <code>xsl:attribute-set</code>
      elements.  The value of the <code>use-attribute-sets</code> attribute is a
      whitespace-separated list of names of attribute sets.  Each name is specified
      as a <a href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which
      is expanded as described in <a href="#qname">[<b>2.4 Qualified
      Names</b>]</a>.  Specifying a <code>use-attribute-sets</code> attribute is
      equivalent to adding <code>xsl:attribute</code> elements for each of the
      attributes in each of the named attribute sets to the beginning of the
      content of the element with the <code>use-attribute-sets</code> attribute, in
      the same order in which the names of the attribute sets are specified in the
      <code>use-attribute-sets</code> attribute.  It is an error if use of
      <code>use-attribute-sets</code> attributes on <code>xsl:attribute-set</code>
      elements causes an attribute set to directly or indirectly use itself.</p>

      <p>Attribute sets can also be used by specifying an
      <code>xsl:use-attribute-sets</code> attribute on a literal result element.
      The value of the <code>xsl:use-attribute-sets</code> attribute is a
      whitespace-separated list of names of attribute sets. The
      <code>xsl:use-attribute-sets</code> attribute has the same effect as the
      <code>use-attribute-sets</code> attribute on <code>xsl:element</code> with
      the additional rule that attributes specified on the literal result element
      itself are treated as if they were specified by <code>xsl:attribute</code>
      elements before any actual <code>xsl:attribute</code> elements but after any
      <code>xsl:attribute</code> elements implied by the
      <code>xsl:use-attribute-sets</code> attribute.  Thus, for a literal result
      element, attributes from attribute sets named in an
      <code>xsl:use-attribute-sets</code> attribute will be added first, in the
      order listed in the attribute; next, attributes specified on the literal
      result element will be added; finally, any attributes specified by
      <code>xsl:attribute</code> elements will be added.  Since adding an attribute
      to an element replaces any existing attribute of that element with the same
      name, this means that attributes specified in attribute sets can be
      overridden by attributes specified on the literal result element itself.</p>

      <p>The template within each <code>xsl:attribute</code> element in an
      <code>xsl:attribute-set</code> element is instantiated each time the
      attribute set is used; it is instantiated using the same current node and
      current node list as is used for instantiating the element bearing the
      <code>use-attribute-sets</code> or <code>xsl:use-attribute-sets</code>
      attribute. However, it is the position in the stylesheet of the
      <code>xsl:attribute</code> element rather than of the element bearing the
      <code>use-attribute-sets</code> or <code>xsl:use-attribute-sets</code>
      attribute that determines which variable bindings are visible (see <a
      href="#variables">[<b>11 Variables and Parameters</b>]</a>); thus, only
      variables and parameters declared by <a href="#dt-top-level">top-level</a>
      <code>xsl:variable</code> and <code>xsl:param</code> elements are visible.</p>

      <p>The following example creates a named attribute set
      <code>title-style</code> and uses it in a template rule.</p>
      <pre>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block quadding="start" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</pre>

      <p>Multiple definitions of an attribute set with the same expanded-name are
      merged.  An attribute from a definition that has higher <a
      href="#dt-import-precedence">import precedence</a> takes precedence over an
      attribute from a definition that has lower <a
      href="#dt-import-precedence">import precedence</a>.  It is an error if there
      are two attribute sets that have the same expanded-name and equal import
      precedence and that both contain the same attribute, unless there is a
      definition of the attribute set with higher <a
      href="#dt-import-precedence">import precedence</a> that also contains the
      attribute.  An XSLT processor may signal the error; if it does not signal the
      error, it must recover by choosing from amongst the definitions that specify
      the attribute that have the highest import precedence the one that was
      specified last in the stylesheet.  Where the attributes in an attribute set
      were specified is relevant only in merging the attributes into the attribute
      set; it makes no difference when the attribute set is used.</p>
  </x:element>

    <x:element name="call-template" href="#element-call-template">
      <h3><a name="named-templates"></a>Named Templates</h3>

      <p class="element-syntax"><a name="element-call-template"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:call-template<br/>
      &nbsp;&nbsp;<b>name</b> = <var>qname</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <a
      href="#element-with-param">xsl:with-param</a>* --&gt;<br/>
      &lt;/xsl:call-template&gt;</code></p>

      <p>Templates can be invoked by name.  An <code>xsl:template</code> element
      with a <code>name</code> attribute specifies a named template. The value of
      the <code>name</code> attribute is a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
      expanded as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>.
      If an <code>xsl:template</code> element has a <code>name</code> attribute, it
      may, but need not, also have a <code>match</code> attribute.  An
      <code>xsl:call-template</code> element invokes a template by name; it has a
      required <code>name</code> attribute that identifies the template to be
      invoked.  Unlike <code>xsl:apply-templates</code>,
      <code>xsl:call-template</code> does not change the current node or the
      current node list.</p>

      <p>The <code>match</code>, <code>mode</code> and <code>priority</code>
      attributes on an <code>xsl:template</code> element do not affect whether the
      template is invoked by an <code>xsl:call-template</code> element.  Similarly,
      the <code>name</code> attribute on an <code>xsl:template</code> element does
      not affect whether the template is invoked by an
      <code>xsl:apply-templates</code> element.</p>

      <p>It is an error if a stylesheet contains more than one template with the
      same name and same <a href="#dt-import-precedence">import precedence</a>.</p>
    </x:element>

    <x:element name="choose" href="#element-choose">
      <h3><a name="section-Conditional-Processing-with-xsl:choose"></a>
      Conditional Processing with <code>xsl:choose</code></h3>

      <p class="element-syntax"><a name="element-choose"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:choose&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a
      href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br/>
      &lt;/xsl:choose&gt;</code></p>

      <p class="element-syntax"><a name="element-when"></a><code>&lt;xsl:when<br/>
      &nbsp;&nbsp;<b>test</b> = <var>boolean-expression</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:when&gt;</code></p>

      <p class="element-syntax"><a
      name="element-otherwise"></a><code>&lt;xsl:otherwise&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:otherwise&gt;</code></p>

      <p>The <code>xsl:choose</code> element selects one among a number of possible
      alternatives. It consists of a sequence of <code>xsl:when</code> elements
      followed by an optional <code>xsl:otherwise</code> element.  Each
      <code>xsl:when</code> element has a single attribute, <code>test</code>,
      which specifies an <a href="#dt-expression">expression</a>. The content of
      the <code>xsl:when</code> and <code>xsl:otherwise</code> elements is a
      template.  When an <code>xsl:choose</code> element is processed, each of the
      <code>xsl:when</code> elements is tested in turn, by evaluating the
      expression and converting the resulting object to a boolean as if by a call
      to the <b><a
      href="http://www.w3.org/TR/xpath#function-boolean">boolean</a></b> function.
      The content of the first, and only the first, <code>xsl:when</code> element
      whose test is true is instantiated.  If no <code>xsl:when</code> is true, the
      content of the <code>xsl:otherwise</code> element is instantiated. If no
      <code>xsl:when</code> element is true, and no <code>xsl:otherwise</code>
      element is present, nothing is created.</p>

      <p>The following example enumerates items in an ordered list using arabic
      numerals, letters, or roman numerals depending on the depth to which the
      ordered lists are nested.</p>
      <pre>&lt;xsl:template match="orderedlist/listitem"&gt;
&lt;fo:list-item indent-start='2pi'&gt;
  &lt;fo:list-item-label&gt;
    &lt;xsl:variable name="level"
                  select="count(ancestor::orderedlist) mod 3"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test='$level=1'&gt;
        &lt;xsl:number format="i"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test='$level=2'&gt;
        &lt;xsl:number format="a"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:number format="1"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
  &lt;/fo:list-item-label&gt;
  &lt;fo:list-item-body&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:list-item-body&gt;
&lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre>
    </x:element>

    <x:element name="comment" href="#element-comment">
      <h3><a name="section-Creating-Comments"></a>Creating Comments</h3>

      <p class="element-syntax"><a name="element-comment"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:comment&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:comment&gt;</code></p>

      <p>The <code>xsl:comment</code> element is instantiated to create a comment
      node in the result tree.  The content of the <code>xsl:comment</code> element
      is a template for the string-value of the comment node.</p>

      <p>For example, this</p>
      <pre>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</pre>

      <p>would create the comment</p>
      <pre>&lt;!--This file is automatically generated. Do not edit!--&gt;</pre>

      <p>It is an error if instantiating the content of <code>xsl:comment</code>
      creates nodes other than text nodes.  An XSLT processor may signal the error;
      if it does not signal the error, it must recover by ignoring the offending
      nodes together with their content.</p>

      <p>It is an error if the result of instantiating the content of the
      <code>xsl:comment</code> contains the string <code>--</code> or ends with
      <code>-</code>.  An XSLT processor may signal the error; if it does not
      signal the error, it must recover by inserting a space after any occurrence
      of <code>-</code> that is followed by another <code>-</code> or that ends the
      comment.</p>
    </x:element>

    <x:element name="copy" href="#element-copy">
      <h3><a name="copying"></a>Copying</h3>

      <p class="element-syntax"><a name="element-copy"></a><code>&lt;!-- Category:
      instruction --&gt;<br/>
      &lt;xsl:copy<br/>
      &nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:copy&gt;</code></p>

      <p>The <code>xsl:copy</code> element provides an easy way of copying the
      current node. Instantiating the <code>xsl:copy</code> element creates a copy
      of the current node.  The namespace nodes of the current node are
      automatically copied as well, but the attributes and children of the node are
      not automatically copied.  The content of the <code>xsl:copy</code> element
      is a template for the attributes and children of the created node; the
      content is instantiated only for nodes of types that can have attributes or
      children (i.e. root nodes and element nodes).</p>

      <p>The <code>xsl:copy</code> element may have a
      <code>use-attribute-sets</code> attribute (see <a
      href="#attribute-sets">[<b>7.1.4 Named Attribute Sets</b>]</a>). This is used
      only when copying element nodes.</p>

      <p>The root node is treated specially because the root node of the result
      tree is created implicitly.  When the current node is the root node,
      <code>xsl:copy</code> will not create a root node, but will just use the
      content template.</p>

      <p>For example, the identity transformation can be written using
      <code>xsl:copy</code> as follows:</p>
      <pre>&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre>

      <p>When the current node is an attribute, then if it would be an error to use
      <code>xsl:attribute</code> to create an attribute with the same name as the
      current node, then it is also an error to use <code>xsl:copy</code> (see <a
      href="#creating-attributes">[<b>7.1.3 Creating Attributes with
      <code>xsl:attribute</code></b>]</a>).</p>

      <p>The following example shows how <code>xml:lang</code> attributes can be
      easily copied through from source to result. If a stylesheet defines the
      following named template:</p>
      <pre>&lt;xsl:template name="apply-templates-copy-lang"&gt;
 &lt;xsl:for-each select="@xml:lang"&gt;
   &lt;xsl:copy/&gt;
 &lt;/xsl:for-each&gt;
 &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>

      <p>then it can simply do</p>
      <pre>&lt;xsl:call-template name="apply-templates-copy-lang"/&gt;</pre>

      <p>instead of</p>
      <pre>&lt;xsl:apply-templates/&gt;</pre>

      <p>when it wants to copy the <code>xml:lang</code> attribute.</p>
    </x:element>

    <x:element name="copy-of" href="#element-copy-of">
      <h3><a name="copy-of"></a>Using Values of Variables and Parameters with
      <code>xsl:copy-of</code></h3>

      <p class="element-syntax"><a name="element-copy-of"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:copy-of<br/>
      &nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;/&gt;</code></p>

      <p>The <code>xsl:copy-of</code> element can be used to insert a result tree
      fragment into the result tree, without first converting it to a string as
      <code>xsl:value-of</code> does (see <a href="#value-of">[<b>7.6.1 Generating
      Text with <code>xsl:value-of</code></b>]</a>).  The required
      <code>select</code> attribute contains an <a
      href="#dt-expression">expression</a>.  When the result of evaluating the
      expression is a result tree fragment, the complete fragment is copied into
      the result tree.  When the result is a node-set, all the nodes in the set are
      copied in document order into the result tree; copying an element node copies
      the attribute nodes, namespace nodes and children of the element node as well
      as the element node itself; a root node is copied by copying its children.
      When the result is neither a node-set nor a result tree fragment, the result
      is converted to a string and then inserted into the result tree, as with
      <code>xsl:value-of</code>.</p>
    </x:element>

    <x:element name="decimal-format" href="#element-number-format">
      <h3><a name="format-number"></a>Number Formatting</h3>

      <p>The <code>xsl:decimal-format</code> element declares a decimal-format,
      which controls the interpretation of a format pattern used by the <b><a
      href="#function-format-number">format-number</a></b> function.  If there is a
      <code>name</code> attribute, then the element declares a named
      decimal-format; otherwise, it declares the default decimal-format. The value
      of the <code>name</code> attribute is a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
      expanded as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>.
      It is an error to declare either the default decimal-format or a
      decimal-format with a given name more than once (even with different <a
      href="#dt-import-precedence">import precedence</a>), unless it is declared
      every time with the same value for all attributes (taking into account any
      default values).</p>

      <p class="element-syntax"><a name="element-decimal-format"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;xsl:decimal-format<br/>
      &nbsp;&nbsp;name = <var>qname</var> <br/>
      &nbsp;&nbsp;decimal-separator = <var>char</var> <br/>
      &nbsp;&nbsp;grouping-separator = <var>char</var> <br/>
      &nbsp;&nbsp;infinity = <var>string</var> <br/>
      &nbsp;&nbsp;minus-sign = <var>char</var> <br/>
      &nbsp;&nbsp;NaN = <var>string</var> <br/>
      &nbsp;&nbsp;percent = <var>char</var> <br/>
      &nbsp;&nbsp;per-mille = <var>char</var> <br/>
      &nbsp;&nbsp;zero-digit = <var>char</var> <br/>
      &nbsp;&nbsp;digit = <var>char</var> <br/>
      &nbsp;&nbsp;pattern-separator = <var>char</var>&nbsp;/&gt;</code></p>


      <p>The other attributes on <code>xsl:decimal-format</code> correspond to the
      methods on the JDK 1.1 <a
      href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html">DecimalFormatSymbols</a>
      class.  For each <code>get</code>/<code>set</code> method pair there is an
      attribute defined for the <code>xsl:decimal-format</code> element.</p>

      <p>The following attributes both control the interpretation of characters in
      the format pattern and specify characters that may appear in the result of
      formatting the number:</p>
      <ul>
        <li><p><code>decimal-separator</code> specifies the character used for the
          decimal sign; the default value is the period character
          (<code>.</code>)</p>
        </li>
        <li><p><code>grouping-separator</code> specifies the character used as a
          grouping (e.g. thousands) separator; the default value is the comma
          character (<code>,</code>)</p>
        </li>
        <li><p><code>percent</code> specifies the character used as a percent sign;
          the default value is the percent character (<code>%</code>)</p>
        </li>
        <li><p><code>per-mille</code> specifies the character used as a per mille
          sign; the default value is the Unicode per-mille character (#x2030)</p>
        </li>
        <li><p><code>zero-digit</code> specifies the character used as the digit
          zero; the default value is the digit zero (<code>0</code>)</p>
        </li>
      </ul>

      <p>The following attributes control the interpretation of characters in the
      format pattern:</p>
      <ul>
        <li><p><code>digit</code> specifies the character used for a digit in the
          format pattern; the default value is the number sign character
          (<code>#</code>)</p>
        </li>
        <li><p><code>pattern-separator</code> specifies the character used to
          separate positive and negative sub patterns in a pattern; the default
          value is the semi-colon character (<code>;</code>)</p>
        </li>
      </ul>

      <p>The following attributes specify characters or strings that may appear in
      the result of formatting the number:</p>
      <ul>
        <li><p><code>infinity</code> specifies the string used to represent
          infinity; the default value is the string <code>Infinity</code></p>
        </li>
        <li><p><code>NaN</code> specifies the string used to represent the NaN
          value; the default value is the string <code>NaN</code></p>
        </li>
        <li><p><code>minus-sign</code> specifies the character used as the default
          minus sign; the default value is the hyphen-minus character
          (<code>-</code>, #x2D)</p>
        </li>
      </ul>
    </x:element>

    <x:element name="element" href="#element-element">
      <h3><a name="section-Creating-Elements-with-xsl:element"></a>Creating
        Elements with <code>xsl:element</code></h3>

      <p class="element-syntax"><a name="element-element"></a><code>&lt;!--
        Category: instruction --&gt;<br/>
        &lt;xsl:element<br/>
        &nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br/>
        &nbsp;&nbsp;namespace = { <var>uri-reference</var> }<br/>
        &nbsp;&nbsp;use-attribute-sets = <var>qnames</var>&gt;<br/>
        &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
        &lt;/xsl:element&gt;</code></p>

      <p>The <code>xsl:element</code> element allows an element to be created with
        a computed name.  The <a
          href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> of the
        element to be created is specified by a required <code>name</code> attribute
        and an optional <code>namespace</code> attribute.  The content of the
        <code>xsl:element</code> element is a template for the attributes and
        children of the created element.</p>

      <p>The <code>name</code> attribute is interpreted as an <a
          href="#dt-attribute-value-template">attribute value template</a>. It is an
        error if the string that results from instantiating the attribute value
        template is not a <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>.  An XSLT
        processor may signal the error; if it does not signal the error, then it must
        recover by making the the result of instantiating the
        <code>xsl:element</code> element be the sequence of nodes created by
        instantiating the content of the  <code>xsl:element</code> element, excluding
        any initial attribute nodes. If the <code>namespace</code> attribute is not
        present then the <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> is expanded into
        an expanded-name using the namespace declarations in effect for the
        <code>xsl:element</code> element, including any default namespace
        declaration.</p>

      <p>If the <code>namespace</code> attribute is present, then it also is
        interpreted as an <a href="#dt-attribute-value-template">attribute value
        template</a>. The string that results from instantiating the attribute value
        template should be a URI reference.  It is not an error if the string is not
        a syntactically legal URI reference.  If the string is empty, then the
        expanded-name of the element has a null namespace URI.  Otherwise, the string
        is used as the namespace URI of the expanded-name of the element to be
        created. The local part of the <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> specified by the
        <code>name</code> attribute is used as the local part of the expanded-name of
        the element to be created.</p>

      <p>XSLT processors may make use of the prefix of the <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> specified in the
        <code>name</code> attribute when selecting the prefix used for outputting the
        created element as XML; however, they are not required to do so.</p>
    </x:element>

    <x:element name="fallback" href="#element-fallback">
      <h3><a name="fallback"></a>Fallback</h3>

      <p class="element-syntax"><a name="element-fallback"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:fallback&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:fallback&gt;</code></p>

      <p>Normally, instantiating an <code>xsl:fallback</code> element does nothing.
       However, when an XSLT processor performs fallback for an instruction
      element, if the instruction element has one or more <code>xsl:fallback</code>
      children, then the content of each of the <code>xsl:fallback</code> children
      must be instantiated in sequence; otherwise, an error must be signaled. The
      content of an <code>xsl:fallback</code> element is a template.</p>

      <p>The following functions can be used with the <code>xsl:choose</code> and
      <code>xsl:if</code> instructions to explicitly control how a stylesheet
      should behave if particular elements or functions are not available.</p>

      <p><b>Function: </b><i>boolean</i>
      <b>element-available</b>(<i>string</i>)</p>

      <p>The argument must evaluate to a string that is a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>.  The <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> is expanded into
      an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>
      using the namespace declarations in scope for the expression. The <b><a
      href="#function-element-available">element-available</a></b> function returns
      true if and only if the expanded-name is the name of an instruction.  If the
      expanded-name has a namespace URI equal to the XSLT namespace URI, then it
      refers to an element defined by XSLT.  Otherwise, it refers to an extension
      element. If the expanded-name has a null namespace URI, the <b><a
      href="#function-element-available">element-available</a></b> function will
      return false.</p>
    </x:element>

    <x:element name="for-each" href="#element-for-each">
      <h3><a name="for-each"></a>Repetition</h3>

      <p class="element-syntax"><a name="element-for-each"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:for-each<br/>
      &nbsp;&nbsp;<b>select</b> = <var>node-set-expression</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*,
      <var>template</var>) --&gt;<br/>
      &lt;/xsl:for-each&gt;</code></p>

      <p>When the result has a known regular structure, it is useful to be able to
      specify directly the template for selected nodes.  The
      <code>xsl:for-each</code> instruction contains a template, which is
      instantiated for each node selected by the <a
      href="#dt-expression">expression</a> specified by the <code>select</code>
      attribute. The <code>select</code> attribute is required.  The expression
      must evaluate to a node-set.  The template is instantiated with the selected
      node as the <a href="#dt-current-node">current node</a>, and with a list of
      all of the selected nodes as the <a href="#dt-current-node-list">current node
      list</a>.  The nodes are processed in document order, unless a sorting
      specification is present (see <a href="#sorting">[<b>10 Sorting</b>]</a>).</p>

      <p>For example, given an XML document with this structure</p>
      <pre>&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</pre>

      <p>the following would create an HTML document containing a table with a row
      for each <code>customer</code> element</p>
      <pre>&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Customers&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;xsl:for-each select="customers/customer"&gt;
          &lt;tr&gt;
            &lt;th&gt;
              &lt;xsl:apply-templates select="name"/&gt;
            &lt;/th&gt;
            &lt;xsl:for-each select="order"&gt;
              &lt;td&gt;
                &lt;xsl:apply-templates/&gt;
              &lt;/td&gt;
            &lt;/xsl:for-each&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre>
    </x:element>

    <x:element name="if" href="#element-if">
      <h3><a name="section-Conditional-Processing-with-xsl:if"></a>Conditional
      Processing with <code>xsl:if</code></h3>

      <p class="element-syntax"><a name="element-if"></a><code>&lt;!-- Category:
      instruction --&gt;<br/>
      &lt;xsl:if<br/>
      &nbsp;&nbsp;<b>test</b> = <var>boolean-expression</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:if&gt;</code></p>

      <p>The <code>xsl:if</code> element has a <code>test</code> attribute, which
      specifies an <a href="#dt-expression">expression</a>. The content is a
      template.  The expression is evaluated and the resulting object is converted
      to a boolean as if by a call to the <b><a
      href="http://www.w3.org/TR/xpath#function-boolean">boolean</a></b> function.
      If the result is true, then the content template is instantiated; otherwise,
      nothing is created. In the following example, the names in a group of names
      are formatted as a comma separated list:</p>
      <pre>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</pre>

      <p>The following colors every other table row yellow:</p>
      <pre>&lt;xsl:template match="item"&gt;
&lt;tr&gt;
  &lt;xsl:if test="position() mod 2 = 0"&gt;
     &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
  &lt;/xsl:if&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/tr&gt;
&lt;/xsl:template&gt;</pre>
    </x:element>

    <x:element name="import" href="#element-import"><h3><a name="import"></a>Stylesheet Import</h3>

      <p class="element-syntax"><a name="element-import"></a><code>&lt;xsl:import<br/>
        &nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p>

      <p>An XSLT stylesheet may import another XSLT stylesheet using an
        <code>xsl:import</code> element.  Importing a stylesheet is the same as
        including it (see <a href="#include">[<b>2.6.1 Stylesheet Inclusion</b>]</a>)
        except that definitions and template rules in the importing stylesheet take
        precedence over template rules and definitions in the imported stylesheet;
        this is described in more detail below.  The <code>xsl:import</code> element
        has an <code>href</code> attribute whose value is a URI reference identifying
        the stylesheet to be imported.  A relative URI is resolved relative to the
        base URI of the <code>xsl:import</code> element (see <a
          href="#base-uri">[<b>3.2 Base URI</b>]</a>).</p>

      <p>The <code>xsl:import</code> element is only allowed as a <a
          href="#dt-top-level">top-level</a> element.  The <code>xsl:import</code>
        element children must precede all other element children of an
        <code>xsl:stylesheet</code> element, including any <code>xsl:include</code>
        element children.  When <code>xsl:include</code> is used to include a
        stylesheet, any <code>xsl:import</code> elements in the included document are
        moved up in the including document to after any existing
        <code>xsl:import</code> elements in the including document.</p>

      <p>For example,</p>
      <pre>&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</pre>

      <p><a name="dt-import-tree"></a>The <code>xsl:stylesheet</code> elements
        encountered during processing of a stylesheet that contains
        <code>xsl:import</code> elements are treated as forming an <b>import
        tree</b>.  In the import tree, each <code>xsl:stylesheet</code> element has
        one import child for each <code>xsl:import</code> element that it contains.
        Any <code>xsl:include</code> elements are resolved before constructing the
        import tree. <a name="dt-import-precedence"></a>An
        <code>xsl:stylesheet</code> element in the import tree is defined to have
        lower <b>import precedence</b> than another <code>xsl:stylesheet</code>
        element in the import tree if it would be visited before that
        <code>xsl:stylesheet</code> element in a post-order traversal of the import
        tree (i.e. a traversal of the import tree in which an
        <code>xsl:stylesheet</code> element is visited after its import children).
        Each definition and template rule has import precedence determined by the
        <code>xsl:stylesheet</code> element that contains it.</p>

      <p>For example, suppose</p>
      <ul>
        <li><p>stylesheet <var>A</var> imports stylesheets <var>B</var> and
          <var>C</var> in that order;</p>
        </li>
        <li><p>stylesheet <var>B</var> imports stylesheet <var>D</var>;</p>
        </li>
        <li><p>stylesheet <var>C</var> imports stylesheet <var>E</var>.</p>
        </li>
      </ul>

      <p>Then the order of import precedence (lowest first) is <var>D</var>,
        <var>B</var>, <var>E</var>, <var>C</var>, <var>A</var>.</p>

      <blockquote>
        <b>NOTE:</b>Since <code>xsl:import</code> elements are required to occur
        before any definitions or template rules, an implementation that processes
        imported stylesheets at the point at which it encounters the
        <code>xsl:import</code> element will encounter definitions and template
        rules in increasing order of import precedence.</blockquote>

      <p>In general, a definition or template rule with higher import precedence
        takes precedence over a definition or template rule with lower import
        precedence.  This is defined in detail for each kind of definition and for
        template rules.</p>

      <p>It is an error if a stylesheet directly or indirectly imports itself.
        Apart from this, the case where a stylesheet with a particular URI is
        imported in multiple places is not treated specially. The <a
          href="#dt-import-tree">import tree</a> will have a separate
        <code>xsl:stylesheet</code> for each place that it is imported.</p>

      <blockquote>
        <b>NOTE:</b>If <code>xsl:apply-imports</code> is used (see <a
          href="#apply-imports">[<b>5.6 Overriding Template Rules</b>]</a>), the
        behavior may be different from the behavior if the stylesheet had been
        imported only at the place with the highest <a
          href="#dt-import-precedence">import precedence</a>.</blockquote>
    </x:element>

    <x:element name="include" href="#element-include">
      <h3><a name="include"></a>Stylesheet Inclusion</h3>

      <p class="element-syntax"><a name="element-include"></a><code>&lt;!--
        Category: top-level-element --&gt;<br/>
        &lt;xsl:include<br/>
        &nbsp;&nbsp;<b>href</b> = <var>uri-reference</var>&nbsp;/&gt;</code></p>

      <p>An XSLT stylesheet may include another XSLT stylesheet using an
        <code>xsl:include</code> element. The <code>xsl:include</code> element has an
        <code>href</code> attribute whose value is a URI reference identifying the
        stylesheet to be included.  A relative URI is resolved relative to the base
        URI of the <code>xsl:include</code> element (see <a href="#base-uri">[<b>3.2
        Base URI</b>]</a>).</p>

      <p>The <code>xsl:include</code> element is only allowed as a <a
          href="#dt-top-level">top-level</a> element.</p>

      <p>The inclusion works at the XML tree level.  The resource located by the
        <code>href</code> attribute value is parsed as an XML document, and the
        children of the <code>xsl:stylesheet</code> element in this document replace
        the <code>xsl:include</code> element in the including document.  The fact
        that template rules or definitions are included does not affect the way they
        are processed.</p>

      <p>The included stylesheet may use the simplified syntax described in <a
          href="#result-element-stylesheet">[<b>2.3 Literal Result Element as
        Stylesheet</b>]</a>.  The included stylesheet is treated the same as the
        equivalent <code>xsl:stylesheet</code> element.</p>

      <p>It is an error if a stylesheet directly or indirectly includes itself.</p>

      <blockquote>
        <b>NOTE:</b>Including a stylesheet multiple times can cause errors because
        of duplicate definitions.  Such multiple inclusions are less obvious when
        they are indirect. For example, if stylesheet <var>B</var> includes
        stylesheet <var>A</var>, stylesheet <var>C</var> includes stylesheet
        <var>A</var>, and stylesheet <var>D</var> includes both stylesheet
        <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be
        included indirectly by <var>D</var> twice.  If all of <var>B</var>,
        <var>C</var> and <var>D</var> are used as independent stylesheets, then the
        error can be avoided by separating everything in <var>B</var> other than
        the inclusion of <var>A</var> into a separate stylesheet <var>B'</var> and
        changing <var>B</var> to contain just inclusions of <var>B'</var> and
        <var>A</var>, similarly for <var>C</var>, and then changing <var>D</var> to
        include <var>A</var>, <var>B'</var>, <var>C'</var>.</blockquote>
    </x:element>

    <x:element name="key" href="#element-key">
      <p>A stylesheet declares a set of keys for each document using the
      <code>xsl:key</code> element.  When this set of keys contains a member with
      node <var>x</var>, name <var>y</var> and value <var>z</var>, we say that node
      <var>x</var> has a key with name <var>y</var> and value <var>z</var>.</p>

      <p>Thus, a key is a kind of generalized ID, which is not subject to the same
      limitations as an XML ID:</p>
      <ul>
        <li><p>Keys are declared in the stylesheet using <code>xsl:key</code>
          elements.</p>
        </li>
        <li><p>A key has a name as well as a value; each key name may be thought of
          as distinguishing a separate, independent space of identifiers.</p>
        </li>
        <li><p>The value of a named key for an element may be specified in any
          convenient place; for example, in an attribute, in a child element or in
          content.  An XPath expression is used to specify where to find the value
          for a particular named key.</p>
        </li>
        <li><p>The value of a key can be an arbitrary string; it is not constrained
          to be a name.</p>
        </li>
        <li><p>There can be multiple keys in a document with the same node, same
          key name, but different key values.</p>
        </li>
        <li><p>There can be multiple keys in a document with the same key name,
          same key value, but different nodes.</p>
        </li>
      </ul>

      <p class="element-syntax"><a name="element-key"></a><code>&lt;!-- Category:
      top-level-element --&gt;<br/>
      &lt;xsl:key<br/>
      &nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>
      &nbsp;&nbsp;<b>match</b> = <var>pattern</var> <br/>
      &nbsp;&nbsp;<b>use</b> = <var>expression</var>&nbsp;/&gt;</code></p>

      <p>The <code>xsl:key</code> element is used to declare keys.  The
      <code>name</code> attribute specifies the name of the key.  The value of the
      <code>name</code> attribute is a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
      expanded as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>.
      The <code>match</code> attribute is a <a href="#NT-Pattern">Pattern</a>; an
      <code>xsl:key</code> element gives information about the keys of any node
      that matches the pattern specified in the match attribute.  The
      <code>use</code> attribute is an <a href="#dt-expression">expression</a>
      specifying the values of the key; the expression is evaluated once for each
      node that matches the pattern.  If the result is a node-set, then for each
      node in the node-set, the node that matches the pattern has a key of the
      specified name whose value is the string-value of the node in the node-set;
      otherwise, the result is converted to a string, and the node that matches the
      pattern has a key of the specified name with value equal to that string.
      Thus, a node <var>x</var> has a key with name <var>y</var> and value
      <var>z</var> if and only if there is an <code>xsl:key</code> element such
      that:</p>
      <ul>
        <li><p><var>x</var> matches the pattern specified in the <code>match</code>
          attribute of the <code>xsl:key</code> element;</p>
        </li>
        <li><p>the value of the <code>name</code> attribute of the
          <code>xsl:key</code> element is equal to <var>y</var>; and</p>
        </li>
        <li><p>when the expression specified in the <code>use</code> attribute of
          the <code>xsl:key</code> element is evaluated with <var>x</var> as the
          current node and with a node list containing just <var>x</var> as the
          current node list resulting in an object <var>u</var>, then either
          <var>z</var> is equal to the result of converting <var>u</var> to a
          string as if by a call to the <b><a
          href="http://www.w3.org/TR/xpath#function-string">string</a></b>
          function, or <var>u</var> is a node-set and <var>z</var> is equal to the
          string-value of one or more of the nodes in <var>u</var>.</p>
        </li>
      </ul>

      <p>Note also that there may be more than one <code>xsl:key</code> element
      that matches a given node; all of the matching <code>xsl:key</code> elements
      are used, even if they do not have the same <a
      href="#dt-import-precedence">import precedence</a>.</p>

      <p>It is an error for the value of either the <code>use</code> attribute or
      the <code>match</code> attribute to contain a <a
      href="http://www.w3.org/TR/xpath#NT-VariableReference">VariableReference</a>.</p>
    </x:element>

    <x:element name="message" href="#element-message">
      <h3><a name="message"></a>Messages</h3>

      <p class="element-syntax"><a name="element-message"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:message<br/>
      &nbsp;&nbsp;terminate = "yes" | "no"&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:message&gt;</code></p>

      <p>The <code>xsl:message</code> instruction sends a message in a way that is
      dependent on the XSLT processor.  The content of the <code>xsl:message</code>
      instruction is a template.  The <code>xsl:message</code> is instantiated by
      instantiating the content to create an XML fragment.  This XML fragment is
      the content of the message.</p>

      <blockquote>
        <b>NOTE:</b>An XSLT processor might implement <code>xsl:message</code> by
        popping up an alert box or by writing to a log file.</blockquote>

      <p>If the <code>terminate</code> attribute has the value <code>yes</code>,
      then the XSLT processor should terminate processing after sending the
      message.  The default value is <code>no</code>.</p>

      <p>One convenient way to do localization is to put the localized information
      (message text, etc.) in an XML document, which becomes an additional input
      file to the stylesheet.  For example, suppose messages for a language
      <code><var>L</var></code> are stored in an XML file
      <code>resources/<var>L</var>.xml</code> in the form:</p>
      <pre>&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;</pre>

      <p>Then a stylesheet could use the following approach to localize
      messages:</p>
      <pre>&lt;xsl:param name="lang" select="en"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message&gt;
    &lt;xsl:value-of select="$messages/message[@name=$name]"/&gt;
  &lt;/xsl:message&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"/&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre>
    </x:element>

    <x:element name="namespace-alias" href="#element-namespace-alias">
      <p><a name="dt-literal-namespace-uri"></a>A namespace URI in the stylesheet
      tree that is being used to specify a namespace URI in the result tree is
      called a <b>literal namespace URI</b>. This applies to:</p>
      <ul>
        <li><p>the namespace URI in the expanded-name of a literal result element
          in the stylesheet</p>
        </li>
        <li><p>the namespace URI in the expanded-name of an attribute specified on
          a literal result element in the stylesheet</p>
        </li>
        <li><p>the string-value of a namespace node on a literal result element in
          the stylesheet</p>
        </li>
      </ul>

      <p class="element-syntax"><a name="element-namespace-alias"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;xsl:namespace-alias<br/>
      &nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | "#default"<br/>
      &nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> |
      "#default"&nbsp;/&gt;</code></p>

      <p><a name="dt-alias"></a>A stylesheet can use the
      <code>xsl:namespace-alias</code> element to declare that one namespace URI is
      an <b>alias</b> for another namespace URI. When a <a
      href="#dt-literal-namespace-uri">literal namespace URI</a> has been declared
      to be an alias for another namespace URI, then the namespace URI in the
      result tree will be the namespace URI that the literal namespace URI is an
      alias for, instead of the literal namespace URI itself.  The
      <code>xsl:namespace-alias</code> element declares that the namespace URI
      bound to the prefix specified by the <code>stylesheet-prefix</code> attribute
      is an alias for the namespace URI bound to the prefix specified by the
      <code>result-prefix</code> attribute.  Thus, the
      <code>stylesheet-prefix</code> attribute specifies the namespace URI that
      will appear in the stylesheet, and the <code>result-prefix</code> attribute
      specifies the corresponding namespace URI that will appear in the result
      tree.  The default namespace (as declared by <code>xmlns</code>) may be
      specified by using <code>#default</code> instead of a prefix.  If a namespace
      URI is declared to be an alias for multiple different namespace URIs, then
      the declaration with the highest <a href="#dt-import-precedence">import
      precedence</a> is used. It is an error if there is more than one such
      declaration.  An XSLT processor may signal the error; if it does not signal
      the error, it must recover by choosing, from amongst the declarations with
      the highest import precedence, the one that occurs last in the stylesheet.</p>

      <p>When literal result elements are being used to create element, attribute,
      or namespace nodes that use the XSLT namespace URI, the stylesheet must use
      an alias.  For example, the stylesheet</p>
      <pre>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>

      <p>will generate an XSLT stylesheet from a document of the form:</p>
      <pre>&lt;elements&gt;
  &lt;block&gt;p&lt;/block&gt;
  &lt;block&gt;h1&lt;/block&gt;
  &lt;block&gt;h2&lt;/block&gt;
  &lt;block&gt;h3&lt;/block&gt;
  &lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</pre>

      <blockquote>
        <b>NOTE:</b>It may be necessary also to use aliases for namespaces other
        than the XSLT namespace URI.  For example, literal result elements
        belonging to a namespace dealing with digital signatures might cause XSLT
        stylesheets to be mishandled by general-purpose security software; using an
        alias for the namespace would avoid the possibility of such
      mishandling.</blockquote>
    </x:element>

    <x:element name="number" href="#element-number">
      <h3><a name="number"></a>Numbering</h3>

      <p class="element-syntax"><a name="element-number"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:number<br/>
      &nbsp;&nbsp;level = "single" | "multiple" | "any"<br/>
      &nbsp;&nbsp;count = <var>pattern</var> <br/>
      &nbsp;&nbsp;from = <var>pattern</var> <br/>
      &nbsp;&nbsp;value = <var>number-expression</var> <br/>
      &nbsp;&nbsp;format = { <var>string</var> }<br/>
      &nbsp;&nbsp;lang = { <var>nmtoken</var> }<br/>
      &nbsp;&nbsp;letter-value = { "alphabetic" | "traditional" }<br/>
      &nbsp;&nbsp;grouping-separator = { <var>char</var> }<br/>
      &nbsp;&nbsp;grouping-size = { <var>number</var> }&nbsp;/&gt;</code></p>

      <p>The <code>xsl:number</code> element is used to insert a formatted number
      into the result tree.  The number to be inserted may be specified by an
      expression. The <code>value</code> attribute contains an <a
      href="#dt-expression">expression</a>.  The expression is evaluated and the
      resulting object is converted to a number as if by a call to the <b><a
      href="http://www.w3.org/TR/xpath#function-number">number</a></b> function.
      The number is rounded to an integer and then converted to a string using the
      attributes specified in <a href="#convert">[<b>7.7.1 Number to String
      Conversion Attributes</b>]</a>; in this context, the value of each of these
      attributes is interpreted as an <a
      href="#dt-attribute-value-template">attribute value template</a>.  After
      conversion, the resulting string is inserted in the result tree. For example,
      the following example numbers a sorted list:</p>
      <pre>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre>

      <p>If no <code>value</code> attribute is specified, then the
      <code>xsl:number</code> element inserts a number based on the position of the
      current node in the source tree. The following attributes control how the
      current node is to be numbered:</p>
      <ul>
        <li><p>The <code>level</code> attribute specifies what levels of the source
          tree should be considered; it has the values <code>single</code>,
          <code>multiple</code> or <code>any</code>. The default is
          <code>single</code>.</p>
        </li>
        <li><p>The <code>count</code> attribute is a pattern that specifies what
          nodes should be counted at those levels.  If <code>count</code> attribute
          is not specified, then it defaults to the pattern that matches any node
          with the same node type as the current node and, if the current node has
          an expanded-name, with the same expanded-name as the current node.</p>
        </li>
        <li><p>The <code>from</code> attribute is a pattern that specifies where
          counting starts.</p>
        </li>
      </ul>

      <p>In addition, the attributes specified in <a href="#convert">[<b>7.7.1
      Number to String Conversion Attributes</b>]</a> are used for number to string
      conversion, as in the case when the <code>value</code> attribute is
      specified.</p>

      <p>The <code>xsl:number</code> element first constructs a list of positive
      integers using the <code>level</code>, <code>count</code> and
      <code>from</code> attributes:</p>
      <ul>
        <li><p>When <code>level="single"</code>, it goes up to the first node in
          the ancestor-or-self axis that matches the <code>count</code> pattern,
          and constructs a list of length one containing one plus the number of
          preceding siblings of that ancestor that match the <code>count</code>
          pattern. If there is no such ancestor, it constructs an empty list.  If
          the <code>from</code> attribute is specified, then the only ancestors
          that are searched are those that are descendants of the nearest ancestor
          that matches the <code>from</code> pattern. Preceding siblings has the
          same meaning here as with the <code>preceding-sibling</code> axis.</p>
        </li>
        <li><p>When <code>level="multiple"</code>, it constructs a list of all
          ancestors of the current node in document order followed by the element
          itself; it then selects from the list those nodes that match the
          <code>count</code> pattern; it then maps each node in the list to one
          plus the number of preceding siblings of that node that match the
          <code>count</code> pattern.  If the <code>from</code> attribute is
          specified, then the only ancestors that are searched are those that are
          descendants of the nearest ancestor that matches the <code>from</code>
          pattern. Preceding siblings has the same meaning here as with the
          <code>preceding-sibling</code> axis.</p>
        </li>
        <li><p>When <code>level="any"</code>, it constructs a list of length one
          containing the number of nodes that match the <code>count</code> pattern
          and belong to the set containing the current node and all nodes at any
          level of the document that are before the current node in document order,
          excluding any namespace and attribute nodes (in other words the union of
          the members of the <code>preceding</code> and
          <code>ancestor-or-self</code> axes). If the <code>from</code> attribute
          is specified, then only nodes after the first node before the current
          node that match the <code>from</code> pattern are considered.</p>
        </li>
      </ul>

      <p>The list of numbers is then converted into a string using the attributes
      specified in <a href="#convert">[<b>7.7.1 Number to String Conversion
      Attributes</b>]</a>; in this context, the value of each of these attributes
      is interpreted as an <a href="#dt-attribute-value-template">attribute value
      template</a>.  After conversion, the resulting string is inserted in the
      result tree.</p>

      <p>The following would number the items in an ordered list:</p>
      <pre>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;xsl:template&gt;</pre>

      <p>The following two rules would number <code>title</code> elements. This is
      intended for a document that contains a sequence of chapters followed by a
      sequence of appendices, where both chapters and appendices contain sections,
      which in turn contain subsections. Chapters are numbered 1, 2, 3; appendices
      are numbered A, B, C; sections in chapters are numbered 1.1, 1.2, 1.3;
      sections in appendices are numbered A.1, A.2, A.3.</p>
      <pre>&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

      <p>The following example numbers notes sequentially within a chapter:</p>
      <pre>&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

      <p>The following example would number <code>H4</code> elements in HTML with a
      three-part label:</p>
      <pre>&lt;xsl:template match="H4"&gt;
 &lt;fo:block&gt;
   &lt;xsl:number level="any" from="H1" count="H2"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H2" count="H3"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H3" count="H4"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>

      <h3><a name="convert"></a>Number to String Conversion Attributes</h3>

      <p>The following attributes are used to control conversion of a list of
      numbers into a string. The numbers are integers greater than 0. The
      attributes are all optional.</p>

      <p>The main attribute is <code>format</code>.  The default value for the
      <code>format</code> attribute is <code>1</code>.  The <code>format</code>
      attribute is split into a sequence of tokens where each token is a maximal
      sequence of alphanumeric characters or a maximal sequence of non-alphanumeric
      characters.  Alphanumeric means any character that has a Unicode category of
      Nd, Nl, No, Lu, Ll, Lt, Lm or Lo.  The alphanumeric tokens (format tokens)
      specify the format to be used for each number in the list.  If the first
      token is a non-alphanumeric token, then the constructed string will start
      with that token; if the last token is non-alphanumeric token, then the
      constructed string will end with that token.  Non-alphanumeric tokens that
      occur between two format tokens are separator tokens that are used to join
      numbers in the list.  The <var>n</var>th format token will be used to format
      the <var>n</var>th number in the list.  If there are more numbers than format
      tokens, then the last format token will be used to format remaining numbers.
      If there are no format tokens, then a format token of <code>1</code> is used
      to format all numbers.  The format token specifies the string to be used to
      represent the number 1.  Each number after the first will be separated from
      the preceding number by the separator token preceding the format token used
      to format that number, or, if there are no separator tokens, then by
      <code>.</code> (a period character).</p>

      <p>Format tokens are a superset of the allowed values for the
      <code>type</code> attribute for the <code>OL</code> element in HTML 4.0 and
      are interpreted as follows:</p>
      <ul>
        <li><p>Any token where the last character has a decimal digit value of 1
          (as specified in the Unicode character property database), and the
          Unicode value of preceding characters is one less than the Unicode value
          of the last character generates a decimal representation of the number
          where each number is at least as long as the format token.  Thus, a
          format token <code>1</code> generates the sequence <code>1 2 ... 10 11 12
          ...</code>, and a format token <code>01</code> generates the sequence
          <code>01 02 ... 09 10 11 12 ... 99 100 101</code>.</p>
        </li>
        <li><p>A format token <code>A</code> generates the sequence <code>A B C ...
          Z AA AB AC...</code>.</p>
        </li>
        <li><p>A format token <code>a</code> generates the sequence <code>a b c ...
          z aa ab ac...</code>.</p>
        </li>
        <li><p>A format token <code>i</code> generates the sequence <code>i ii iii
          iv v vi vii viii ix x ...</code>.</p>
        </li>
        <li><p>A format token <code>I</code> generates the sequence <code>I II III
          IV V VI VII VIII IX X ...</code>.</p>
        </li>
        <li><p>Any other format token indicates a numbering sequence that starts
          with that token.  If an implementation does not support a numbering
          sequence that starts with that token, it must use a format token of
          <code>1</code>.</p>
        </li>
      </ul>

      <p>When numbering with an alphabetic sequence, the <code>lang</code>
      attribute specifies which language's alphabet is to be used; it has the same
      range of values as <code>xml:lang</code> <a href="#XML">[XML]</a>; if no
      <code>lang</code> value is specified, the language should be determined from
      the system environment.  Implementers should document for which languages
      they support numbering.</p>

      <blockquote>
        <b>NOTE:</b>Implementers should not make any assumptions about how
        numbering works in particular languages and should properly research the
        languages that they wish to support.  The numbering conventions of many
        languages are very different from English.</blockquote>

      <p>The <code>letter-value</code> attribute disambiguates between numbering
      sequences that use letters.  In many languages there are two commonly used
      numbering sequences that use letters.  One numbering sequence assigns numeric
      values to letters in alphabetic sequence, and the other assigns numeric
      values to each letter in some other manner traditional in that language.  In
      English, these would correspond to the numbering sequences specified by the
      format tokens <code>a</code> and <code>i</code>.  In some languages, the
      first member of each sequence is the same, and so the format token alone
      would be ambiguous.  A value of <code>alphabetic</code> specifies the
      alphabetic sequence; a value of <code>traditional</code> specifies the other
      sequence.  If the <code>letter-value</code> attribute is not specified, then
      it is implementation-dependent how any ambiguity is resolved.</p>

      <blockquote>
        <b>NOTE:</b>It is possible for two conforming XSLT processors not to
        convert a number to exactly the same string.  Some XSLT processors may not
        support some languages.  Furthermore, there may be variations possible in
        the way conversions are performed for any particular language that are not
        specifiable by the attributes on <code>xsl:number</code>. Future versions
        of XSLT may provide additional attributes to provide control over these
        variations.  Implementations may also use implementation-specific
        namespaced attributes on <code>xsl:number</code> for this.</blockquote>

      <p>The <code>grouping-separator</code> attribute gives the separator used as
      a grouping (e.g. thousands) separator in decimal numbering sequences, and the
      optional <code>grouping-size</code> specifies the size (normally 3) of the
      grouping.  For example, <code>grouping-separator=","</code> and
      <code>grouping-size="3"</code> would produce numbers of the form
      <code>1,000,000</code>.  If only one of the <code>grouping-separator</code>
      and <code>grouping-size</code> attributes is specified, then it is
      ignored.</p>

      <p>Here are some examples of conversion specifications:</p>
      <ul>
        <li><p><code>format="&amp;#x30A2;"</code> specifies Katakana numbering</p>
        </li>
        <li><p><code>format="&amp;#x30A4;"</code> specifies Katakana numbering in
          the "iroha" order</p>
        </li>
        <li><p><code>format="&amp;#x0E51;"</code> specifies numbering with Thai
          digits</p>
        </li>
        <li><p><code>format="&amp;#x05D0;" letter-value="traditional"</code>
          specifies "traditional" Hebrew numbering</p>
        </li>
        <li><p><code>format="&amp;#x10D0;" letter-value="traditional"</code>
          specifies Georgian numbering</p>
        </li>
        <li><p><code>format="&amp;#x03B1;" letter-value="traditional"</code>
          specifies "classical" Greek numbering</p>
        </li>
        <li><p><code>format="&amp;#x0430;" letter-value="traditional"</code>
          specifies Old Slavic numbering</p>
        </li>
      </ul>

    </x:element>

    <x:element name="otherwise" href="#element-otherwise"><x:ref name="choose" /></x:element>

    <x:element name="output" href="#element-output">
      <h3><a name="output"></a>Output</h3>

      <p class="element-syntax"><a name="element-output"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;xsl:output<br/>
      &nbsp;&nbsp;method = "xml" | "html" | "text" |
      <var>qname-but-not-ncname</var> <br/>
      &nbsp;&nbsp;version = <var>nmtoken</var> <br/>
      &nbsp;&nbsp;encoding = <var>string</var> <br/>
      &nbsp;&nbsp;omit-xml-declaration = "yes" | "no"<br/>
      &nbsp;&nbsp;standalone = "yes" | "no"<br/>
      &nbsp;&nbsp;doctype-public = <var>string</var> <br/>
      &nbsp;&nbsp;doctype-system = <var>string</var> <br/>
      &nbsp;&nbsp;cdata-section-elements = <var>qnames</var> <br/>
      &nbsp;&nbsp;indent = "yes" | "no"<br/>
      &nbsp;&nbsp;media-type = <var>string</var>&nbsp;/&gt;</code></p>

      <p>An XSLT processor may output the result tree as a sequence of bytes,
      although it is not required to be able to do so (see <a
      href="#conformance">[<b>17 Conformance</b>]</a>). The <code>xsl:output</code>
      element allows stylesheet authors to specify how they wish the result tree to
      be output. If an XSLT processor outputs the result tree, it should do so as
      specified by the <code>xsl:output</code> element; however, it is not required
      to do so.</p>

      <p>The <code>xsl:output</code> element is only allowed as a <a
      href="#dt-top-level">top-level</a> element.</p>

      <p>The <code>method</code> attribute on <code>xsl:output</code> identifies
      the overall method that should be used for outputting the result tree.  The
      value must be a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>.  If the <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> does not have a
      prefix, then it identifies a method specified in this document and must be
      one of <code>xml</code>, <code>html</code> or <code>text</code>.  If the <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> has a prefix,
      then the <a href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> is
      expanded into an <a
      href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a> as
      described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>; the
      expanded-name identifies the output method; the behavior in this case is not
      specified by this document.</p>

      <p>The default for the <code>method</code> attribute is chosen as follows.
      If</p>
      <ul>
        <li><p>the root node of the result tree has an element child,</p>
        </li>
        <li><p>the expanded-name of the first element child of the root node (i.e.
          the document element) of the result tree has local part <code>html</code>
          (in any combination of upper and lower case) and a null namespace URI,
          and</p>
        </li>
        <li><p>any text nodes preceding the first element child of the root node of
          the result tree contain only whitespace characters,</p>
        </li>
      </ul>

      <p>then the default output method is <code>html</code>; otherwise, the
      default output method is <code>xml</code>.  The default output method should
      be used if there are no <code>xsl:output</code> elements or if none of the
      <code>xsl:output</code> elements specifies a value for the
      <code>method</code> attribute.</p>

      <p>The other attributes on <code>xsl:output</code> provide parameters for the
      output method.  The following attributes are allowed:</p>
      <ul>
        <li><p><code>version</code> specifies the version of the output method</p>
        </li>
        <li><p><code>indent</code> specifies whether the XSLT processor may add
          additional whitespace when outputting the result tree; the value must be
          <code>yes</code> or <code>no</code></p>
        </li>
        <li><p><code>encoding</code> specifies the preferred character encoding
          that the XSLT processor should use to encode sequences of characters as
          sequences of bytes; the value of the attribute should be treated
          case-insensitively; the value must contain only characters in the range
          #x21 to #x7E (i.e. printable ASCII characters); the value should either
          be a <code>charset</code> registered with the Internet Assigned Numbers
          Authority <a href="#IANA">[IANA]</a>, <a href="#RFC2278">[RFC2278]</a> or
          start with <code>X-</code></p>
        </li>
        <li><p><code>media-type</code> specifies the media type (MIME content type)
          of the data that results from outputting the result tree; the
          <code>charset</code> parameter should not be specified explicitly;
          instead, when the top-level media type is <code>text</code>, a
          <code>charset</code> parameter should be added according to the character
          encoding actually used by the output method</p>
        </li>
        <li><p><code>doctype-system</code> specifies the system identifier to be
          used in the document type declaration</p>
        </li>
        <li><p><code>doctype-public</code> specifies the public identifier to be
          used in the document type declaration</p>
        </li>
        <li><p><code>omit-xml-declaration</code> specifies whether the XSLT
          processor should output an XML declaration; the value must be
          <code>yes</code> or <code>no</code></p>
        </li>
        <li><p><code>standalone</code> specifies whether the XSLT processor should
          output a standalone document declaration; the value must be
          <code>yes</code> or <code>no</code></p>
        </li>
        <li><p><code>cdata-section-elements</code> specifies a list of the names of
          elements whose text node children should be output using CDATA
          sections</p>
        </li>
      </ul>

      <p>The detailed semantics of each attribute will be described separately for
      each output method for which it is applicable.  If the semantics of an
      attribute are not described for an output method, then it is not applicable
      to that output method.</p>

      <p>A stylesheet may contain multiple <code>xsl:output</code> elements and may
      include or import stylesheets that also contain <code>xsl:output</code>
      elements.  All the <code>xsl:output</code> elements occurring in a stylesheet
      are merged into a single effective <code>xsl:output</code> element. For the
      <code>cdata-section-elements</code> attribute, the effective value is the
      union of the specified values.  For other attributes, the effective value is
      the specified value with the highest <a href="#dt-import-precedence">import
      precedence</a>. It is an error if there is more than one such value for an
      attribute.  An XSLT processor may signal the error; if it does not signal the
      error, if should recover by using the value that occurs last in the
      stylesheet. The values of attributes are defaulted after the
      <code>xsl:output</code> elements have been merged; different output methods
      may have different default values for an attribute.</p>
    </x:element>

    <x:element name="param" href="#element-param"><x:ref name="variable" /></x:element>

    <x:element name="preserve-space" href="#element-preserve-space">
      <h3><a name="strip"></a>Whitespace Stripping</h3>

      <p>After the tree for a source document or stylesheet document has been
      constructed, but before it is otherwise processed by XSLT, some text nodes
      are stripped.  A text node is never stripped unless it contains only
      whitespace characters.  Stripping the text node removes the text node from
      the tree.  The stripping process takes as input a set of element names for
      which whitespace must be preserved.  The stripping process is applied to both
      stylesheets and source documents, but the set of whitespace-preserving
      element names is determined differently for stylesheets and for source
      documents.</p>

      <p>A text node is preserved if any of the following apply:</p>
      <ul>
        <li><p>The element name of the parent of the text node is in the set of
          whitespace-preserving element names.</p>
        </li>
        <li><p>The text node contains at least one non-whitespace character. As in
          XML, a whitespace character is #x20, #x9, #xD or #xA.</p>
        </li>
        <li><p>An ancestor element of the text node has an <code>xml:space</code>
          attribute with a value of <code>preserve</code>, and no closer ancestor
          element has <code>xml:space</code> with a value of
          <code>default</code>.</p>
        </li>
      </ul>

      <p>Otherwise, the text node is stripped.</p>

      <p>The <code>xml:space</code> attributes are not stripped from the tree.</p>

      <blockquote>
        <b>NOTE:</b>This implies that if an <code>xml:space</code> attribute is
        specified on a literal result element, it will be included in the
      result.</blockquote>

      <p>For stylesheets, the set of whitespace-preserving element names consists
      of just <code>xsl:text</code>.</p>

      <p class="element-syntax"><a name="element-strip-space"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;xsl:strip-space<br/>
      &nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p>

      <p class="element-syntax"><a name="element-preserve-space"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;xsl:preserve-space<br/>
      &nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p>

      <p>For source documents, the set of whitespace-preserving element names is
      specified by <code>xsl:strip-space</code> and <code>xsl:preserve-space</code>
      <a href="#dt-top-level">top-level</a> elements.  These elements each have an
      <code>elements</code> attribute whose value is a whitespace-separated list of
      <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a>s.  Initially,
      the set of whitespace-preserving element names contains all element names. If
      an element name matches a <a
      href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> in an
      <code>xsl:strip-space</code> element, then it is removed from the set of
      whitespace-preserving element names.  If an element name matches a <a
      href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> in an
      <code>xsl:preserve-space</code> element, then it is added to the set of
      whitespace-preserving element names.  An element matches a <a
      href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> if and only if the
      <a href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> would be true
      for the element as an <a href="http://www.w3.org/TR/xpath#node-tests">XPath
      node test</a>.  Conflicts between matches to <code>xsl:strip-space</code> and
      <code>xsl:preserve-space</code> elements are resolved the same way as
      conflicts between template rules (see <a href="#conflict">[<b>5.5 Conflict
      Resolution for Template Rules</b>]</a>).  Thus, the applicable match for a
      particular element name is determined as follows:</p>
      <ul>
        <li><p>First, any match with lower <a href="#dt-import-precedence">import
          precedence</a> than another match is ignored.</p>
        </li>
        <li><p>Next, any match with a <a
          href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> that has a
          lower <a href="#dt-default-priority">default priority</a> than the <a
          href="#dt-default-priority">default priority</a> of the <a
          href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</a> of another
          match is ignored.</p>
        </li>
      </ul>

      <p>It is an error if this leaves more than one match.  An XSLT processor may
      signal the error; if it does not signal the error, it must recover by
      choosing, from amongst the matches that are left, the one that occurs last in
      the stylesheet.</p>
    </x:element>

    <x:element name="processing-instruction" href="#element-processing-instruction">
      <h3><a name="section-Creating-Processing-Instructions"></a>Creating
      Processing Instructions</h3>

      <p class="element-syntax"><a
      name="element-processing-instruction"></a><code>&lt;!-- Category: instruction
      --&gt;<br/>
      &lt;xsl:processing-instruction<br/>
      &nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:processing-instruction&gt;</code></p>

      <p>The <code>xsl:processing-instruction</code> element is instantiated to
      create a processing instruction node.  The content of the
      <code>xsl:processing-instruction</code> element is a template for the
      string-value of the processing instruction node.  The
      <code>xsl:processing-instruction</code> element has a required
      <code>name</code> attribute that specifies the name of the processing
      instruction node.  The value of the <code>name</code> attribute is
      interpreted as an <a href="#dt-attribute-value-template">attribute value
      template</a>.</p>

      <p>For example, this</p>
      <pre>&lt;xsl:processing-instruction name="xml-stylesheet"&gt;href="book.css" type="text/css"&lt;/xsl:processing-instruction&gt;</pre>

      <p>would create the processing instruction</p>
      <pre>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</pre>

      <p>It is an error if the string that results from instantiating the
      <code>name</code> attribute is not both an <a
      href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</a> and a <a
      href="http://www.w3.org/TR/REC-xml#NT-PITarget">PITarget</a>.  An XSLT
      processor may signal the error; if it does not signal the error, it must
      recover by not adding the processing instruction to the result tree.</p>

      <blockquote>
        <b>NOTE:</b>This means that <code>xsl:processing-instruction</code> cannot
        be used to output an XML declaration.  The <code>xsl:output</code> element
        should be used instead (see <a href="#output">[<b>16
      Output</b>]</a>).</blockquote>

      <p>It is an error if instantiating the content of
      <code>xsl:processing-instruction</code> creates nodes other than text nodes.
      An XSLT processor may signal the error; if it does not signal the error, it
      must recover by ignoring the offending nodes together with their content.</p>

      <p>It is an error if the result of instantiating the content of the
      <code>xsl:processing-instruction</code> contains the string
      <code>?&gt;</code>.  An XSLT processor may signal the error; if it does not
      signal the error, it must recover by inserting a space after any occurrence
      of <code>?</code> that is followed by a <code>&gt;</code>.</p>
    </x:element>

    <x:element name="sort" href="#element-sort">
      <h3><a name="sorting"></a>Sorting</h3>

      <p class="element-syntax"><a name="element-sort"></a><code>&lt;xsl:sort<br/>
      &nbsp;&nbsp;select = <var>string-expression</var> <br/>
      &nbsp;&nbsp;lang = { <var>nmtoken</var> }<br/>
      &nbsp;&nbsp;data-type = { "text" | "number" | <var>qname-but-not-ncname</var>
      }<br/>
      &nbsp;&nbsp;order = { "ascending" | "descending" }<br/>
      &nbsp;&nbsp;case-order = { "upper-first" | "lower-first"
      }&nbsp;/&gt;</code></p>

      <p>Sorting is specified by adding <code>xsl:sort</code> elements as children
      of an <code>xsl:apply-templates</code> or <code>xsl:for-each</code> element.
      The first <code>xsl:sort</code> child specifies the primary sort key, the
      second <code>xsl:sort</code> child specifies the secondary sort key and so
      on.  When an <code>xsl:apply-templates</code> or <code>xsl:for-each</code>
      element has one or more <code>xsl:sort</code> children, then instead of
      processing the selected nodes in document order, it sorts the nodes according
      to the specified sort keys and then processes them in sorted order.  When
      used in <code>xsl:for-each</code>, <code>xsl:sort</code> elements must occur
      first.  When a template is instantiated by <code>xsl:apply-templates</code>
      and <code>xsl:for-each</code>, the <a href="#dt-current-node-list">current
      node list</a> list consists of the complete list of nodes being processed in
      sorted order.</p>

      <p><code>xsl:sort</code> has a <code>select</code> attribute whose value is
      an <a href="#dt-expression">expression</a>. For each node to be processed,
      the expression is evaluated with that node as the current node and with the
      complete list of nodes being processed in unsorted order as the current node
      list. The resulting object is converted to a string as if by a call to the
      <b><a href="http://www.w3.org/TR/xpath#function-string">string</a></b>
      function; this string is used as the sort key for that node. The default
      value of the <code>select</code> attribute is <code>.</code>, which will
      cause the string-value of the current node to be used as the sort key.</p>

      <p>This string serves as a sort key for the node.  The following optional
      attributes on <code>xsl:sort</code> control how the list of sort keys are
      sorted; the values of all of these attributes are interpreted as <a
      href="#dt-attribute-value-template">attribute value templates</a>.</p>
      <ul>
        <li><p><code>order</code> specifies whether the strings should be sorted in
          ascending or descending order; <code>ascending</code> specifies ascending
          order; <code>descending</code> specifies descending order; the default is
          <code>ascending</code></p>
        </li>
        <li><p><code>lang</code> specifies the language of the sort keys; it has
          the same range of values as <code>xml:lang</code> <a
          href="#XML">[XML]</a>; if no <code>lang</code> value is specified, the
          language should be determined from the system environment</p>
        </li>
        <li><p><code>data-type</code> specifies the data type of the strings; the
          following values are allowed:</p>
          <ul>
            <li><p><code>text</code> specifies that the sort keys should be sorted
              lexicographically in the culturally correct manner for the language
              specified by <code>lang</code></p>
            </li>
            <li><p><code>number</code> specifies that the sort keys should be
              converted to numbers and then sorted according to the numeric value;
              the sort key is converted to a number as if by a call to the <b><a
              href="http://www.w3.org/TR/xpath#function-number">number</a></b>
              function; the <code>lang</code> attribute is ignored</p>
            </li>
            <li><p>a <a
              href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> with a
              prefix is expanded into an <a
              href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>
              as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>;
              the expanded-name identifies the data-type; the behavior in this case
              is not specified by this document</p>
            </li>
          </ul>
          <p>The default value is <code>text</code>.</p>

          <blockquote>
            <b>NOTE:</b>The XSL Working Group plans that future versions of XSLT
            will leverage XML Schemas to define further values for this
          attribute.</blockquote>
        </li>
        <li><p><code>case-order</code> has the value <code>upper-first</code> or
          <code>lower-first</code>; this applies when
          <code>data-type="text"</code>, and specifies that upper-case letters
          should sort before lower-case letters or vice-versa respectively. For
          example, if <code>lang="en"</code>, then <code>A a B b</code> are sorted
          with <code>case-order="upper-first"</code> and <code>a A b B</code> are
          sorted with <code>case-order="lower-first"</code>. The default value is
          language dependent.</p>
        </li>
      </ul>

      <blockquote>
        <b>NOTE:</b>It is possible for two conforming XSLT processors not to sort
        exactly the same.  Some XSLT processors may not support some languages.
        Furthermore, there may be variations possible in the sorting of any
        particular language that are not specified by the attributes on
        <code>xsl:sort</code>, for example, whether Hiragana or Katakana is sorted
        first in Japanese.  Future versions of XSLT may provide additional
        attributes to provide control over these variations.  Implementations may
        also use implementation-specific namespaced attributes on
        <code>xsl:sort</code> for this.</blockquote>

      <blockquote>
        <b>NOTE:</b>It is recommended that implementers consult <a
        href="#UNICODE-TR10">[UNICODE TR10]</a> for information on
        internationalized sorting.</blockquote>

      <p>The sort must be stable: in the sorted list of nodes, any sub list that
      has sort keys that all compare equal must be in document order.</p>

      <p>For example, suppose an employee database has the form</p>
      <pre>&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;</pre>

<p>Then a list of employees sorted by name could be generated using:</p>
<pre>&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</pre>
    </x:element>

    <x:element name="strip-space" href="#element-strip-space"><x:ref name="preserve-space" /></x:element>

    <x:element name="stylesheet" href="#stylesheet-element">
      <h3><a name="stylesheet-element"></a>Stylesheet Element</h3>

      <p class="element-syntax"><a
          name="element-stylesheet"></a><code>&lt;xsl:stylesheet<br/>
        &nbsp;&nbsp;id = <var>id</var> <br/>
        &nbsp;&nbsp;extension-element-prefixes = <var>tokens</var> <br/>
        &nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var> <br/>
        &nbsp;&nbsp;<b>version</b> = <var>number</var>&gt;<br/>
        &nbsp;&nbsp;&lt;!-- Content: (<a href="#element-import">xsl:import</a>*,
        <var>top-level-elements</var>) --&gt;<br/>
        &lt;/xsl:stylesheet&gt;</code></p>

      <p class="element-syntax"><a
          name="element-transform"></a><code>&lt;xsl:transform<br/>
        &nbsp;&nbsp;id = <var>id</var> <br/>
        &nbsp;&nbsp;extension-element-prefixes = <var>tokens</var> <br/>
        &nbsp;&nbsp;exclude-result-prefixes = <var>tokens</var> <br/>
        &nbsp;&nbsp;<b>version</b> = <var>number</var>&gt;<br/>
        &nbsp;&nbsp;&lt;!-- Content: (<a href="#element-import">xsl:import</a>*,
        <var>top-level-elements</var>) --&gt;<br/>
        &lt;/xsl:transform&gt;</code></p>

      <p>A stylesheet is represented by an <code>xsl:stylesheet</code> element in
        an XML document.  <code>xsl:transform</code> is allowed as a synonym for
        <code>xsl:stylesheet</code>.</p>

      <p>An <code>xsl:stylesheet</code> element must have a <code>version</code>
        attribute, indicating the version of XSLT that the stylesheet requires.  For
        this version of XSLT, the value should be <code>1.0</code>.  When the value
        is not equal to <code>1.0</code>, forwards-compatible processing mode is
        enabled (see <a href="#forwards">[<b>2.5 Forwards-Compatible
        Processing</b>]</a>).</p>

      <p>The <code>xsl:stylesheet</code> element may contain the following types of
        elements:</p>
      <ul>
        <li><p><code>xsl:import</code></p>
        </li>
        <li><p><code>xsl:include</code></p>
        </li>
        <li><p><code>xsl:strip-space</code></p>
        </li>
        <li><p><code>xsl:preserve-space</code></p>
        </li>
        <li><p><code>xsl:output</code></p>
        </li>
        <li><p><code>xsl:key</code></p>
        </li>
        <li><p><code>xsl:decimal-format</code></p>
        </li>
        <li><p><code>xsl:namespace-alias</code></p>
        </li>
        <li><p><code>xsl:attribute-set</code></p>
        </li>
        <li><p><code>xsl:variable</code></p>
        </li>
        <li><p><code>xsl:param</code></p>
        </li>
        <li><p><code>xsl:template</code></p>
        </li>
      </ul>

      <p><a name="dt-top-level"></a>An element occurring as a child of an
        <code>xsl:stylesheet</code> element is called a <b>top-level</b> element.</p>

      <p>This example shows the structure of a stylesheet.  Ellipses
        (<code>...</code>) indicate where attribute values or content have been
        omitted.  Although this example shows one of each type of allowed element,
        stylesheets may contain zero or more of each of these elements.</p>
      <pre>&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="..."/&gt;

  &lt;xsl:include href="..."/&gt;

  &lt;xsl:strip-space elements="..."/&gt;

  &lt;xsl:preserve-space elements="..."/&gt;

  &lt;xsl:output method="..."/&gt;

  &lt;xsl:key name="..." match="..." use="..."/&gt;

  &lt;xsl:decimal-format name="..."/&gt;

  &lt;xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/&gt;

  &lt;xsl:attribute-set name="..."&gt;
  ...
  &lt;/xsl:attribute-set&gt;

  &lt;xsl:variable name="..."&gt;...&lt;/xsl:variable&gt;

  &lt;xsl:param name="..."&gt;...&lt;/xsl:param&gt;

  &lt;xsl:template match="..."&gt;
  ...
  &lt;/xsl:template&gt;

  &lt;xsl:template name="..."&gt;
  ...
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>

      <p>The order in which the children of the <code>xsl:stylesheet</code> element
        occur is not significant except for <code>xsl:import</code> elements and for
        error recovery.  Users are free to order the elements as they prefer, and
        stylesheet creation tools need not provide control over the order in which
        the elements occur.</p>

      <p>In addition, the <code>xsl:stylesheet</code> element may contain any
        element not from the XSLT namespace, provided that the expanded-name of the
        element has a non-null namespace URI.  The presence of such top-level
        elements must not change the behavior of XSLT elements and functions defined
        in this document; for example, it would not be permitted for such a top-level
        element to specify that <code>xsl:apply-templates</code> was to use different
        rules to resolve conflicts. Thus, an XSLT processor is always free to ignore
        such top-level elements, and must ignore a top-level element without giving
        an error if it does not recognize the namespace URI. Such elements can
        provide, for example,</p>
      <ul>
        <li><p>information used by extension elements or extension functions (see
          <a href="#extension">[<b>14 Extensions</b>]</a>),</p>
        </li>
        <li><p>information about what to do with the result tree,</p>
        </li>
        <li><p>information about how to obtain the source tree,</p>
        </li>
        <li><p>metadata about the stylesheet,</p>
        </li>
        <li><p>structured documentation for the stylesheet.</p>
        </li>
      </ul>
    </x:element>

    <x:element name="text" href="#element-text">
      <h3><a name="section-Creating-Text"></a>Creating Text</h3>

      <p>A template can also contain text nodes.  Each text node in a template
      remaining after whitespace has been stripped as specified in <a
      href="#strip">[<b>3.4 Whitespace Stripping</b>]</a> will create a text node
      with the same string-value in the result tree.  Adjacent text nodes in the
      result tree are automatically merged.</p>

      <p>Note that text is processed at the tree level. Thus, markup of
      <code>&amp;lt;</code> in a template will be represented in the stylesheet
      tree by a text node that includes the character <code>&lt;</code>. This will
      create a text node in the result tree that contains a <code>&lt;</code>
      character, which will be represented by the markup <code>&amp;lt;</code> (or
      an equivalent character reference) when the result tree is externalized as an
      XML document (unless output escaping is disabled as described in <a
      href="#disable-output-escaping">[<b>16.4 Disabling Output
      Escaping</b>]</a>).</p>

      <p class="element-syntax"><a name="element-text"></a><code>&lt;!-- Category:
      instruction --&gt;<br/>
      &lt;xsl:text<br/>
      &nbsp;&nbsp;disable-output-escaping = "yes" | "no"&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: #PCDATA --&gt;<br/>
      &lt;/xsl:text&gt;</code></p>

      <p>Literal data characters may also be wrapped in an <code>xsl:text</code>
      element.  This wrapping may change what whitespace characters are stripped
      (see <a href="#strip">[<b>3.4 Whitespace Stripping</b>]</a>) but does not
      affect how the characters are handled by the XSLT processor thereafter.</p>

      <blockquote>
        <b>NOTE:</b>The <code>xml:lang</code> and <code>xml:space</code> attributes
        are not treated specially by XSLT. In particular,
        <ul>
          <li><p>it is the responsibility of the stylesheet author explicitly to
            generate any <code>xml:lang</code> or <code>xml:space</code> attributes
            that are needed in the result;</p>
          </li>
          <li><p>specifying an <code>xml:lang</code> or <code>xml:space</code>
            attribute on an element in the XSLT namespace will not cause any
            <code>xml:lang</code> or <code>xml:space</code> attributes to appear in
            the result.</p>
          </li>
        </ul>
      </blockquote>
    </x:element>

    <x:element name="transform"><x:ref name="stylesheet" /></x:element>

    <x:element name="value-of" href="#element-value-of">
      <h3><a name="section-Computing-Generated-Text"></a>Computing Generated
      Text</h3>

      <p>Within a template, the <code>xsl:value-of</code> element can be used to
      compute generated text, for example by extracting text from the source tree
      or by inserting the value of a variable.  The <code>xsl:value-of</code>
      element does this with an <a href="#dt-expression">expression</a> that is
      specified as the value of the <code>select</code> attribute.  Expressions can
      also be used inside attribute values of literal result elements by enclosing
      the expression in curly braces (<code>{}</code>).</p>

      <h3><a name="value-of"></a>Generating Text with <code>xsl:value-of</code></h3>

      <p class="element-syntax"><a name="element-value-of"></a><code>&lt;!--
      Category: instruction --&gt;<br/>
      &lt;xsl:value-of<br/>
      &nbsp;&nbsp;<b>select</b> = <var>string-expression</var> <br/>
      &nbsp;&nbsp;disable-output-escaping = "yes" | "no"&nbsp;/&gt;</code></p>

      <p>The <code>xsl:value-of</code> element is instantiated to create a text
      node in the result tree.  The required <code>select</code> attribute is an <a
      href="#dt-expression">expression</a>; this expression is evaluated and the
      resulting object is converted to a string as if by a call to the <b><a
      href="http://www.w3.org/TR/xpath#function-string">string</a></b> function.
      The string specifies the string-value of the created text node.  If the
      string is empty, no text node will be created.  The created text node will be
      merged with any adjacent text nodes.</p>

      <p>The <code>xsl:copy-of</code> element can be used to copy a node-set over
      to the result tree without converting it to a string. See <a
      href="#copy-of">[<b>11.3 Using Values of Variables and Parameters with
      <code>xsl:copy-of</code></b>]</a>.</p>

      <p>For example, the following creates an HTML paragraph from a
      <code>person</code> element with <code>given-name</code> and
      <code>family-name</code> attributes.  The paragraph will contain the value of
      the <code>given-name</code> attribute of the current node followed by a space
      and the value of the <code>family-name</code> attribute of the current
      node.</p>
      <pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="@given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="@family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre>

      <p>For another example, the following creates an HTML paragraph from a
      <code>person</code> element with <code>given-name</code> and
      <code>family-name</code> children elements.  The paragraph will contain the
      string-value of the first <code>given-name</code> child element of the
      current node followed by a space and the string-value of the first
      <code>family-name</code> child element of the current node.</p>
      <pre>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</pre>

      <p>The following precedes each <code>procedure</code> element with a
      paragraph containing the security level of the procedure.  It assumes that
      the security level that applies to a procedure is determined by a
      <code>security</code> attribute on the procedure element or on an ancestor
      element of the procedure. It also assumes that if more than one such element
      has a <code>security</code> attribute then the security level is determined
      by the element that is closest to the procedure.</p>
      <pre>&lt;xsl:template match="procedure"&gt;
  &lt;fo:block&gt;
    &lt;xsl:value-of select="ancestor-or-self::*[@security][1]/@security"/&gt;
  &lt;/fo:block&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
    </x:element>

    <x:element name="variable" href="#element-variable">
      <h3><a name="variables"></a>Variables and Parameters</h3>

      <p class="element-syntax"><a name="element-variable"></a><code>&lt;!--
      Category: top-level-element --&gt;<br/>
      &lt;!-- Category: instruction --&gt;<br/>
      &lt;xsl:variable<br/>
      &nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>
      &nbsp;&nbsp;select = <var>expression</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:variable&gt;</code></p>

      <p class="element-syntax"><a name="element-param"></a><code>&lt;!-- Category:
      top-level-element --&gt;<br/>
      &lt;xsl:param<br/>
      &nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>
      &nbsp;&nbsp;select = <var>expression</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:param&gt;</code></p>

      <p>A variable is a name that may be bound to a value.  The value to which a
      variable is bound (the <b>value</b> of the variable) can be an object of any
      of the types that can be returned by expressions. There are two elements that
      can be used to bind variables: <code>xsl:variable</code> and
      <code>xsl:param</code>. The difference is that the value specified on the
      <code>xsl:param</code> variable is only a default value for the binding; when
      the template or stylesheet within which the <code>xsl:param</code> element
      occurs is invoked, parameters may be passed that are used in place of the
      default values.</p>

      <p>Both <code>xsl:variable</code> and <code>xsl:param</code> have a required
      <code>name</code> attribute, which specifies the name of the variable.  The
      value of the <code>name</code> attribute is a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
      expanded as described in <a href="#qname">[<b>2.4 Qualified
      Names</b>]</a>.</p>

      <p>For any use of these variable-binding elements, there is a region of the
      stylesheet tree within which the binding is visible; within this region, any
      binding of the variable that was visible on the variable-binding element
      itself is hidden.  Thus, only the innermost binding of a variable is visible.
       The set of variable bindings in scope for an expression consists of those
      bindings that are visible at the point in the stylesheet where the expression
      occurs.</p>
    </x:element>

    <x:element name="when" href="#element-when"><x:ref name="choose" /></x:element>

    <x:element name="with-param" href="#element-with-param">
      <h3><a name="section-Passing-Parameters-to-Templates"></a>Passing
      Parameters to Templates</h3>

      <p class="element-syntax"><a
      name="element-with-param"></a><code>&lt;xsl:with-param<br/>
      &nbsp;&nbsp;<b>name</b> = <var>qname</var> <br/>
      &nbsp;&nbsp;select = <var>expression</var>&gt;<br/>
      &nbsp;&nbsp;&lt;!-- Content: <var>template</var> --&gt;<br/>
      &lt;/xsl:with-param&gt;</code></p>

      <p>Parameters are passed to templates using the <code>xsl:with-param</code>
      element.  The required <code>name</code> attribute specifies the name of the
      parameter (the variable the value of whose binding is to be replaced).  The
      value of the <code>name</code> attribute is a <a
      href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
      expanded as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>.
      <code>xsl:with-param</code> is allowed within both
      <code>xsl:call-template</code> and <code>xsl:apply-templates</code>.  The
      value of the parameter is specified in the same way as for
      <code>xsl:variable</code> and <code>xsl:param</code>.  The current node and
      current node list used for computing the value specified by
      <code>xsl:with-param</code> element is the same as that used for the
      <code>xsl:apply-templates</code> or <code>xsl:call-template</code> element
      within which it occurs.  It is not an error to pass a parameter <var>x</var>
      to a template that does not have an <code>xsl:param</code> element for
      <var>x</var>; the parameter is simply ignored.</p>

      <p>This example defines a named template for a <code>numbered-block</code>
      with an argument to control the format of the number.</p>
      <pre>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre>
    </x:element>
  </x:elements>

  <!-- http://www.w3.org/TR/1999/REC-xslt-19991116  -->
  <x:functions type="xslt" base="http://www.w3.org/TR/xslt" style="w3c">
    <x:function name="current" href="#function-current">
      <p><a name="function-current"><b>Function: </b><i>node-set</i>
        <b>current</b>()</a></p>

      <p>The <b><a href="#function-current">current</a></b> function returns a
        node-set that has the <a href="#dt-current-node">current node</a> as its only
        member.  For an outermost expression (an expression not occurring within
        another expression), the current node is always the same as the context node.
        Thus,</p>
      <pre>&lt;xsl:value-of select="current()"/&gt;</pre>

      <p>means the same as</p>
      <pre>&lt;xsl:value-of select="."/&gt;</pre>

      <p>However, within square brackets the current node is usually different from
        the context node. For example,</p>
      <pre>&lt;xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/&gt;</pre>

      <p>will process all <code>item</code> elements that have a
        <code>glossary</code> parent element and that have a <code>name</code>
        attribute with value equal to the value of the current node's
        <code>ref</code> attribute. This is different from</p>
      <pre>&lt;xsl:apply-templates select="//glossary/item[@name=./@ref]"/&gt;</pre>

      <p>which means the same as</p>
      <pre>&lt;xsl:apply-templates select="//glossary/item[@name=@ref]"/&gt;</pre>

      <p>and so would process all <code>item</code> elements that have a
        <code>glossary</code> parent element and that have a <code>name</code>
        attribute and a <code>ref</code> attribute with the same value.</p>

      <p>It is an error to use the <b><a href="#function-current">current</a></b>
        function in a <a href="#dt-pattern">pattern</a>.</p>
    </x:function>

    <x:function name="document" href="#function-document">
      <p><a name="function-document"><b>Function: </b><i>node-set</i>
        <b>document</b>(<i>object</i>, <i>node-set</i>?)</a></p>

      <p>The <b><a href="#function-document">document</a></b> function allows
        access to XML documents other than the main source document.</p>

      <p>When the <b><a href="#function-document">document</a></b> function has
        exactly one argument and the argument is a node-set, then the result is the
        union, for each node in the argument node-set, of the result of calling the
        <b><a href="#function-document">document</a></b> function with the first
        argument being the <a
          href="http://www.w3.org/TR/xpath#dt-string-value">string-value</a> of the
        node, and the second argument being a node-set with the node as its only
        member. When the <b><a href="#function-document">document</a></b> function
        has two arguments and the first argument is a node-set, then the result is
        the union, for each node in the argument node-set, of the result of calling
        the <b><a href="#function-document">document</a></b> function with the first
        argument being the <a
          href="http://www.w3.org/TR/xpath#dt-string-value">string-value</a> of the
        node, and with the second argument being the second argument passed to the
        <b><a href="#function-document">document</a></b> function.</p>

      <p>When the first argument to the <b><a
          href="#function-document">document</a></b> function is not a node-set, the
        first argument is converted to a string as if by a call to the <b><a
          href="http://www.w3.org/TR/xpath#function-string">string</a></b> function.
        This string is treated as a URI reference; the resource identified by the URI
        is retrieved. The data resulting from the retrieval action is parsed as an
        XML document and a tree is constructed in accordance with the data model (see
        <a href="#data-model">[<b>3 Data Model</b>]</a>).  If there is an error
        retrieving the resource, then the XSLT processor may signal an error; if it
        does not signal an error, it must recover by returning an empty node-set.
        One possible kind of retrieval error is that the XSLT processor does not
        support the URI scheme used by the URI.  An XSLT processor is not required to
        support any particular URI schemes.  The documentation for an XSLT processor
        should specify which URI schemes the XSLT processor supports.</p>

      <p>If the URI reference does not contain a fragment identifier, then a
        node-set containing just the root node of the document is returned. If the
        URI reference does contain a fragment identifier, the function returns a
        node-set containing the nodes in the tree identified by the fragment
        identifier of the URI reference. The semantics of the fragment identifier is
        dependent on the media type of the result of retrieving the URI.  If there is
        an error in processing the fragment identifier, the XSLT processor may signal
        the error; if it does not signal the error, it must recover by returning an
        empty node-set. Possible errors include:</p>
      <ul>
        <li><p>The fragment identifier identifies something that cannot be
          represented by an XSLT node-set (such as a range of characters within a
          text node).</p>
        </li>
        <li><p>The XSLT processor does not support fragment identifiers for the
          media-type of the retrieval result.  An XSLT processor is not required to
          support any particular media types.  The documentation for an XSLT
          processor should specify for which media types the XSLT processor
          supports fragment identifiers.</p>
        </li>
      </ul>

      <p>The data resulting from the retrieval action is parsed as an XML document
        regardless of the media type of the retrieval result; if the top-level media
        type is <code>text</code>, then it is parsed in the same way as if the media
        type were <code>text/xml</code>; otherwise, it is parsed in the same way as
        if the media type were <code>application/xml</code>.</p>

      <blockquote>
        <b>NOTE:</b>Since there is no top-level <code>xml</code> media type, data
        with a media type other than <code>text/xml</code> or
        <code>application/xml</code> may in fact be XML.</blockquote>

      <p>The URI reference may be relative. The base URI (see <a
          href="#base-uri">[<b>3.2 Base URI</b>]</a>) of the node in the second
        argument node-set that is first in document order is used as the base URI for
        resolving the relative URI into an absolute URI.  If the second argument is
        omitted, then it defaults to the node in the stylesheet that contains the
        expression that includes the call to the <b><a
          href="#function-document">document</a></b> function.  Note that a zero-length
        URI reference is a reference to the document relative to which the URI
        reference is being resolved; thus <code>document("")</code> refers to the
        root node of the stylesheet; the tree representation of the stylesheet is
        exactly the same as if the XML document containing the stylesheet was the
        initial source document.</p>

      <p>Two documents are treated as the same document if they are identified by
        the same URI. The URI used for the comparison is the absolute URI into which
        any relative URI was resolved and does not include any fragment identifier.
        One root node is treated as the same node as another root node if the two
        nodes are from the same document. Thus, the following expression will always
        be true:</p>
      <pre>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</pre>

      <p>The <b><a href="#function-document">document</a></b> function gives rise
        to the possibility that a node-set may contain nodes from more than one
        document.  With such a node-set, the relative document order of two nodes in
        the same document is the normal <a
          href="http://www.w3.org/TR/xpath#dt-document-order">document order</a>
        defined by XPath <a href="#XPATH">[XPath]</a>.  The relative document order
        of two nodes in different documents is determined by an
        implementation-dependent ordering of the documents containing the two nodes.
        There are no constraints on how the implementation orders documents other
        than that it must do so consistently: an implementation must always use the
        same order for the same set of documents.</p>
    </x:function>

    <x:function name="element-available" href="#function-element-available">
      <p><a name="function-element-available"><b>Function: </b><i>boolean</i>
        <b>element-available</b>(<i>string</i>)</a></p>

      <p>The argument must evaluate to a string that is a <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>.  The <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> is expanded into
        an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>
        using the namespace declarations in scope for the expression. The <b><a
          href="#function-element-available">element-available</a></b> function returns
        true if and only if the expanded-name is the name of an instruction.  If the
        expanded-name has a namespace URI equal to the XSLT namespace URI, then it
        refers to an element defined by XSLT.  Otherwise, it refers to an extension
        element. If the expanded-name has a null namespace URI, the <b><a
          href="#function-element-available">element-available</a></b> function will
        return false.</p>
    </x:function>

    <x:function name="format-number" href="#function-formatnumber">
      <p><a name="function-format-number"><b>Function: </b><i>string</i>
        <b>format-number</b>(<i>number</i>, <i>string</i>, <i>string</i>?)</a></p>

      <p>The <b><a href="#function-format-number">format-number</a></b> function
        converts its first argument to a string using the format pattern string
        specified by the second argument and the decimal-format named by the third
        argument, or the default decimal-format, if there is no third argument.  The
        format pattern string is in the syntax specified by the JDK 1.1 <a
          href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html">DecimalFormat</a>
        class. The format pattern string is in a localized notation: the
        decimal-format determines what characters have a special meaning in the
        pattern (with the exception of the quote character, which is not localized).
        The format pattern must not contain the currency sign (#x00A4); support for
        this feature was added after the initial release of JDK 1.1.  The
        decimal-format name must be a <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
        expanded as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>.
        It is an error if the stylesheet does not contain a declaration of the
        decimal-format with the specified <a
          href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>.</p>

      <blockquote>
        <b>NOTE:</b>Implementations are not required to use the JDK 1.1
        implementation, nor are implementations required to be implemented in
        Java.</blockquote>

      <blockquote>
        <b>NOTE:</b>Stylesheets can use other facilities in XPath to control
        rounding.</blockquote>
    </x:function>

    <x:function name="function-available" href="#function-function-available">
      <p><a name="function-function-available"><b>Function: </b><i>boolean</i>
        <b>function-available</b>(<i>string</i>)</a></p>

      <p>The argument must evaluate to a string that is a <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>.  The <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> is expanded into
        an <a href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</a>
        using the namespace declarations in scope for the expression. The <b><a
          href="#function-function-available">function-available</a></b> function
        returns true if and only if the expanded-name is the name of a function in
        the function library. If the expanded-name has a non-null namespace URI, then
        it refers to an extension function; otherwise, it refers to a function
        defined by XPath or XSLT.</p>
    </x:function>

    <x:function name="generate-id" href="#function-generate-id">
      <p><a name="function-generate-id"><b>Function: </b><i>string</i>
        <b>generate-id</b>(<i>node-set</i>?)</a></p>

      <p>The <b><a href="#function-generate-id">generate-id</a></b> function
        returns a string that uniquely identifies the node in the argument node-set
        that is first in document order.  The unique identifier must consist of ASCII
        alphanumeric characters and must start with an alphabetic character. Thus,
        the string is syntactically an XML name.  An implementation is free to
        generate an identifier in any convenient way provided that it always
        generates the same identifier for the same node and that different
        identifiers are always generated from different nodes. An implementation is
        under no obligation to generate the same identifiers each time a document is
        transformed.  There is no guarantee that a generated unique identifier will
        be distinct from any unique IDs specified in the source document.  If the
        argument node-set is empty, the empty string is returned. If the argument is
        omitted, it defaults to the context node.</p>
    </x:function>

    <x:function name="key" href="#function-key">
      <p><a name="function-key"><b>Function: </b><i>node-set</i>
        <b>key</b>(<i>string</i>, <i>object</i>)</a></p>

      <p>The <b><a href="#function-key">key</a></b> function does for keys what the
        <b><a href="http://www.w3.org/TR/xpath#function-id">id</a></b> function does
        for IDs.  The first argument specifies the name of the key. The value of the
        argument must be a <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>, which is
        expanded as described in <a href="#qname">[<b>2.4 Qualified Names</b>]</a>.
        When the second argument to the <b><a href="#function-key">key</a></b>
        function is of type node-set, then the result is the union of the result of
        applying the <b><a href="#function-key">key</a></b> function to the string <a
          href="http://www.w3.org/TR/xpath#dt-value">value</a> of each of the nodes in
        the argument node-set.  When the second argument to <b><a
          href="#function-key">key</a></b> is of any other type, the argument is
        converted to a string as if by a call to the <b><a
          href="http://www.w3.org/TR/xpath#function-string">string</a></b> function; it
        returns a node-set containing the nodes in the same document as the context
        node that have a value for the named key equal to this string.</p>

      <p>For example, given a declaration</p>
      <pre>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</pre>

      <p>an expression <code>key("idkey",@ref)</code> will return the same node-set
        as <code>id(@ref)</code>, assuming that the only ID attribute declared in the
        XML source document is:</p>
      <pre>&lt;!ATTLIST div id ID #IMPLIED&gt;</pre>

      <p>and that the <code>ref</code> attribute of the current node contains no
        whitespace.</p>

      <p>Suppose a document describing a function library uses a
        <code>prototype</code> element to define functions</p>
      <pre>&lt;prototype name="key" return-type="node-set"&gt;
&lt;arg type="string"/&gt;
&lt;arg type="object"/&gt;
&lt;/prototype&gt;</pre>

      <p>and a <code>function</code> element to refer to function names</p>
      <pre>&lt;function&gt;key&lt;/function&gt;</pre>

      <p>Then the stylesheet could generate hyperlinks between the references and
        definitions as follows:</p>
      <pre>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
&lt;a href="#{generate-id(key('func',.))}"&gt;
&lt;xsl:apply-templates/&gt;
&lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
&lt;p&gt;&lt;a name="{generate-id()}"&gt;
&lt;b&gt;Function: &lt;/b&gt;
...
&lt;/a&gt;&lt;/p&gt;
&lt;/xsl:template&gt;</pre>

      <p>The <b><a href="#function-key">key</a></b> can be used to retrieve a key
        from a document other than the document containing the context node.  For
        example, suppose a document contains bibliographic references in the form
        <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a separate XML
        document <code>bib.xml</code> containing a bibliographic database with
        entries in the form:</p>
      <pre>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</pre>

      <p>Then the stylesheet could use the following to transform the
        <code>bibref</code> elements:</p>
      <pre>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
&lt;xsl:variable name="name" select="."/&gt;
&lt;xsl:for-each select="document('bib.xml')"&gt;
&lt;xsl:apply-templates select="key('bib',$name)"/&gt;
&lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre>
    </x:function>

    <x:function name="system-property" href="#function-system-property">
      <p><a name="function-system-property"><b>Function: </b><i>object</i>
        <b>system-property</b>(<i>string</i>)</a></p>

      <p>The argument must evaluate to a string that is a <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a>.  The <a
          href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> is expanded into
        a name using the namespace declarations in scope for the expression. The
        <b><a href="#function-system-property">system-property</a></b> function
        returns an object representing the value of the system property identified by
        the name. If there is no such system property, the empty string should be
        returned.</p>

      <p>Implementations must provide the following system properties, which are
        all in the XSLT namespace:</p>
      <ul>
        <li><code>xsl:version</code>, a number giving the version of XSLT
          implemented by the processor; for XSLT processors implementing the
          version of XSLT specified by this document, this is the number 1.0</li>
        <li><code>xsl:vendor</code>, a string identifying the vendor of the XSLT
          processor</li>
        <li><code>xsl:vendor-url</code>, a string containing a URL identifying the
          vendor of the XSLT processor; typically this is the host page (home page)
          of the vendor's Web site.</li>
      </ul>
    </x:function>

    <x:function name="unparsed-entity-uri" href="#function-unparsed-entity-uri">
      <p><a name="function-unparsed-entity-uri"><b>Function: </b><i>string</i>
        <b>unparsed-entity-uri</b>(<i>string</i>)</a></p>

      <p>The <b><a href="#function-unparsed-entity-uri">unparsed-entity-uri</a></b>
        returns the URI of the unparsed entity with the specified name in the same
        document as the context node (see <a href="#unparsed-entities">[<b>3.3
        Unparsed Entities</b>]</a>).  It returns the empty string if there is no such
        entity.</p>
    </x:function>
  </x:functions>

  <!-- http://www.w3.org/TR/1999/REC-xpath-19991116 -->
  <x:functions type="core" base="http://www.w3.org/TR/xpath" style="w3c">
    <x:function name="last" href="#function-last">
      <p>
      <a name="function-last"><b>Function: </b><i>number</i> <b>last</b>()</a>
      </p>

      <p>The <b><a href="#function-last">last</a></b> function returns a number equal to
      the <a href="#dt-context-size">context size</a> from the
      expression evaluation context.</p>
    </x:function>
    <x:function name="position" href="#function-position">
      <p>
      <a name="function-position"><b>Function: </b><i>number</i> <b>position</b>()</a>
      </p>

      <p>The <b><a href="#function-position">position</a></b> function returns a number equal to
      the <a href="#dt-context-position">context position</a> from
      the expression evaluation context.</p>
    </x:function>
    <x:function name="count" href="#function-count">
      <p>
      <a name="function-count"><b>Function: </b><i>number</i> <b>count</b>(<i>node-set</i>)</a>
      </p>

      <p>The <b><a href="#function-count">count</a></b> function returns the number of nodes in the
      argument node-set.</p>
    </x:function>
    <x:function name="id" href="#function-id">
      <p>
      <a name="function-id"><b>Function: </b><i>node-set</i> <b>id</b>(<i>object</i>)</a>
      </p>

      <p>The <b><a href="#function-id">id</a></b> function selects elements by their
      unique ID (see <a href="#unique-id">[<b>5.2.1 Unique IDs</b>]</a>).  When the argument to
      <b><a href="#function-id">id</a></b> is of type node-set, then the result is the
      union of the result of applying <b><a href="#function-id">id</a></b> to the
      <a href="#dt-string-value">string-value</a> of each of the
      nodes in the argument node-set.  When the argument to
      <b><a href="#function-id">id</a></b> is of any other type, the argument is
      converted to a string as if by a call to the
      <b><a href="#function-string">string</a></b> function; the string is split into a
      whitespace-separated list of tokens (whitespace is any sequence of
      characters matching the production <a href="http://www.w3.org/TR/REC-xml#NT-S">S</a>);
      the result is a node-set containing the elements in the same document
      as the context node that have a unique ID equal to any of the tokens
      in the list.</p>

      <ul>
      <li>
      <p>
      <code>id("foo")</code> selects the element with unique ID
      <code>foo</code>
      </p>
      </li>
      <li>
      <p>
      <code>id("foo")/child::para[position()=5]</code> selects
      the fifth <code>para</code> child of the element with unique ID
      <code>foo</code>
      </p>
      </li>
      </ul>

    </x:function>
    <x:function name="local-name" href="#function-local-name">
      <p>
      <a name="function-local-name"><b>Function: </b><i>string</i> <b>local-name</b>(<i>node-set</i>?)</a>
      </p>

      <p>The <b><a href="#function-local-name">local-name</a></b> function returns the local part
      of the <a href="#dt-expanded-name">expanded-name</a> of the
      node in the argument node-set that is first in <a href="#dt-document-order">document order</a>. If the argument
      node-set is empty or the first node has no <a href="#dt-expanded-name">expanded-name</a>, an empty string is
      returned.  If the argument is omitted, it defaults to a node-set with
      the context node as its only member.</p>
    </x:function>
    <x:function name="namespace-uri" href="#function-namespace-uri">
      <p>
      <a name="function-namespace-uri"><b>Function: </b><i>string</i> <b>namespace-uri</b>(<i>node-set</i>?)</a>
      </p>

      <p>The <b><a href="#function-namespace-uri">namespace-uri</a></b> function returns the
      namespace URI of the <a href="#dt-expanded-name">expanded-name</a> of the node in the
      argument node-set that is first in <a href="#dt-document-order">document order</a>. If the argument
      node-set is empty, the first node has no <a href="#dt-expanded-name">expanded-name</a>, or the namespace URI
      of the <a href="#dt-expanded-name">expanded-name</a> is
      null, an empty string is returned.  If the argument is omitted, it
      defaults to a node-set with the context node as its only member.</p>

      <blockquote>
      <b>NOTE: </b>The string returned by the
      <b><a href="#function-namespace-uri">namespace-uri</a></b> function will be empty except for
      element nodes and attribute nodes.</blockquote>
    </x:function>
    <x:function name="name" href="#function-name">
      <p>
      <a name="function-name"><b>Function: </b><i>string</i> <b>name</b>(<i>node-set</i>?)</a>
      </p>

      <p>The <b><a href="#function-name">name</a></b> function returns a string containing
      a <a href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> representing the
      <a href="#dt-expanded-name">expanded-name</a> of the node in
      the argument node-set that is first in <a href="#dt-document-order">document order</a>. The <a href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> must represent the <a href="#dt-expanded-name">expanded-name</a> with respect to the
      namespace declarations in effect on the node whose <a href="#dt-expanded-name">expanded-name</a> is being represented.
      Typically, this will be the <a href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> that occurred in the XML
      source.  This need not be the case if there are namespace declarations
      in effect on the node that associate multiple prefixes with the same
      namespace.  However, an implementation may include information about
      the original prefix in its representation of nodes; in this case, an
      implementation can ensure that the returned string is always the same
      as the <a href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</a> used in the XML
      source. If the argument node-set is empty or the first node has no
      <a href="#dt-expanded-name">expanded-name</a>, an empty
      string is returned.  If the argument it omitted, it defaults to a
      node-set with the context node as its only member.</p>

      <blockquote>
      <b>NOTE: </b>The string returned by the <b><a href="#function-name">name</a></b> function
      will be the same as the string returned by the
      <b><a href="#function-local-name">local-name</a></b> function except for element nodes and
      attribute nodes.</blockquote>
    </x:function>
    <x:function name="string" href="#function-string">
      <p>
      <a name="function-string"><b>Function: </b><i>string</i> <b>string</b>(<i>object</i>?)</a>
      </p>

      <p>The <b><a href="#function-string">string</a></b> function converts an object to a string
      as follows:</p>

      <ul>

      <li>
      <p>A node-set is converted to a string by returning the <a href="#dt-string-value">string-value</a> of the node in the
      node-set that is first in <a href="#dt-document-order">document
      order</a>.  If the node-set is empty, an empty string is
      returned.</p>
      </li>

      <li>
      <p>A number is converted to a string as follows</p>

      <ul>

      <li>
      <p>NaN is converted to the string <code>NaN</code>
      </p>
      </li>

      <li>
      <p>positive zero is converted to the string
      <code>0</code>
      </p>
      </li>

      <li>
      <p>negative zero is converted to the string
      <code>0</code>
      </p>
      </li>

      <li>
      <p>positive infinity is converted to the string
      <code>Infinity</code>
      </p>
      </li>

      <li>
      <p>negative infinity is converted to the string
      <code>-Infinity</code>
      </p>
      </li>

      <li>
      <p>if the number is an integer, the number is represented in
      decimal form as a <a href="#NT-Number">Number</a> with no decimal
      point and no leading zeros, preceded by a minus sign (<code>-</code>)
      if the number is negative</p>
      </li>

      <li>
      <p>otherwise, the number is represented in decimal form as a <a href="#NT-Number">Number</a> including a decimal point with at least
      one digit before the decimal point and at least one digit after the
      decimal point, preceded by a minus sign (<code>-</code>) if the number
      is negative; there must be no leading zeros before the decimal point
      apart possibly from the one required digit immediately before the
      decimal point; beyond the one required digit after the decimal point
      there must be as many, but only as many, more digits as are needed to
      uniquely distinguish the number from all other IEEE 754 numeric
      values.</p>
      </li>

      </ul>

      </li>

      <li>
      <p>The boolean false value is converted to the string
      <code>false</code>.  The boolean true value is converted to the
      string <code>true</code>.</p>
      </li>

      <li>
      <p>An object of a type other than the four basic types is
      converted to a string in a way that is dependent on that
      type.</p>
      </li>

      </ul>

      <p>If the argument is omitted, it defaults to a node-set with the
      context node as its only member.</p>

      <blockquote>
      <b>NOTE: </b>The <code>string</code> function is not intended for
      converting numbers into strings for presentation to users.  The
      <code>format-number</code> function and <code>xsl:number</code>
      element in <a href="#XSLT">[XSLT]</a> provide this
      functionality.</blockquote>

    </x:function>
    <x:function name="concat" href="#function-concat">
      <p>
      <a name="function-concat"><b>Function: </b><i>string</i> <b>concat</b>(<i>string</i>, <i>string</i>, <i>string</i>*)</a>
      </p>

      <p>The <b><a href="#function-concat">concat</a></b> function returns the concatenation of its
      arguments.</p>

    </x:function>
    <x:function name="starts-with" href="#function-starts-with">
      <p>
      <a name="function-starts-with"><b>Function: </b><i>boolean</i> <b>starts-with</b>(<i>string</i>, <i>string</i>)</a>
      </p>

      <p>The <b><a href="#function-starts-with">starts-with</a></b> function returns true if the
      first argument string starts with the second argument string, and
      otherwise returns false.</p>
    </x:function>
    <x:function name="contains" href="#function-contains">
      <p>
      <a name="function-contains"><b>Function: </b><i>boolean</i> <b>contains</b>(<i>string</i>, <i>string</i>)</a>
      </p>

      <p>The <b><a href="#function-contains">contains</a></b> function returns true if the first
      argument string contains the second argument string, and otherwise
      returns false.</p>
    </x:function>
    <x:function name="substring-before" href="#function-substring-before">
      <p>
      <a name="function-substring-before"><b>Function: </b><i>string</i> <b>substring-before</b>(<i>string</i>, <i>string</i>)</a>
      </p>

      <p>The <b><a href="#function-substring-before">substring-before</a></b> function returns the substring
      of the first argument string that precedes the first occurrence of the
      second argument string in the first argument string, or the empty
      string if the first argument string does not contain the second
      argument string.  For example,
      <code>substring-before("1999/04/01","/")</code> returns
      <code>1999</code>.</p>

    </x:function>
    <x:function name="substring-after" href="#function-substring-after">
      <p>
      <a name="function-substring-after"><b>Function: </b><i>string</i> <b>substring-after</b>(<i>string</i>, <i>string</i>)</a>
      </p>

      <p>The <b><a href="#function-substring-after">substring-after</a></b> function returns the
      substring of the first argument string that follows the first
      occurrence of the second argument string in the first argument string,
      or the empty string if the first argument string does not contain the
      second argument string. For example,
      <code>substring-after("1999/04/01","/")</code> returns
      <code>04/01</code>, and
      <code>substring-after("1999/04/01","19")</code> returns
      <code>99/04/01</code>.</p>

    </x:function>
    <x:function name="substring" href="#function-substring">
      <p>
      <a name="function-substring"><b>Function: </b><i>string</i> <b>substring</b>(<i>string</i>, <i>number</i>, <i>number</i>?)</a>
      </p>

      <p>The <b><a href="#function-substring">substring</a></b> function returns the substring of the
      first argument starting at the position specified in the second
      argument with length specified in the third argument. For example,
      <code>substring("12345",2,3)</code> returns <code>"234"</code>.
      If the third argument is not specified, it returns
      the substring starting at the position specified in the second
      argument and continuing to the end of the string. For example,
      <code>substring("12345",2)</code> returns <code>"2345"</code>.</p>

      <p>More precisely, each character in the string (see <a href="#strings">[<b>3.6 Strings</b>]</a>) is considered to have a numeric position: the
      position of the first character is 1, the position of the second
      character is 2 and so on.</p>

      <blockquote>
      <b>NOTE: </b>This differs from Java and ECMAScript, in which the
      <code>String.substring</code> method treats the position of the first
      character as 0.</blockquote>

      <p>The returned substring contains those
      characters for which the position of the character is greater than or
      equal to the rounded value of the second argument and, if the third
      argument is specified, less than the sum of the rounded value of the
      second argument and the rounded value of the third argument; the
      comparisons and addition used for the above follow the standard IEEE
      754 rules; rounding is done as if by a call to the
      <b><a href="#function-round">round</a></b> function. The following examples illustrate
      various unusual cases:</p>

      <ul>

      <li>
      <p>
      <code>substring("12345", 1.5, 2.6)</code> returns
      <code>"234"</code>
      </p>
      </li>

      <li>
      <p>
      <code>substring("12345", 0, 3)</code> returns
      <code>"12"</code>
      </p>
      </li>

      <li>
      <p>
      <code>substring("12345", 0 div 0, 3)</code> returns
      <code>""</code>
      </p>
      </li>

      <li>
      <p>
      <code>substring("12345", 1, 0 div 0)</code> returns
      <code>""</code>
      </p>
      </li>

      <li>
      <p>
      <code>substring("12345", -42, 1 div 0)</code> returns
      <code>"12345"</code>
      </p>
      </li>

      <li>
      <p>
      <code>substring("12345", -1 div 0, 1 div 0)</code> returns
      <code>""</code>
      </p>
      </li>

      </ul>

    </x:function>
    <x:function name="string-length" href="#function-string-length">
      <p>
      <a name="function-string-length"><b>Function: </b><i>number</i> <b>string-length</b>(<i>string</i>?)</a>
      </p>

      <p>The <b><a href="#function-string-length">string-length</a></b> returns the number of
      characters in the string (see <a href="#strings">[<b>3.6 Strings</b>]</a>).  If the
      argument is omitted, it defaults to the context node converted to a
      string, in other words the <a href="#dt-string-value">string-value</a> of the context node.</p>

    </x:function>
    <x:function name="normalize-space" href="#function-normalize-space">
      <p>
      <a name="function-normalize-space"><b>Function: </b><i>string</i> <b>normalize-space</b>(<i>string</i>?)</a>
      </p>

      <p>The <b><a href="#function-normalize-space">normalize-space</a></b> function returns the argument
      string with whitespace normalized by stripping leading and trailing
      whitespace and replacing sequences of whitespace characters by a
      single space.  Whitespace characters are the same as those allowed by the <a href="http://www.w3.org/TR/REC-xml#NT-S">S</a> production in XML.  If the argument is
      omitted, it defaults to the context node converted to a string, in
      other words the <a href="#dt-string-value">string-value</a>
      of the context node.</p>

    </x:function>
    <x:function name="translate" href="#function-translate">
      <p>
      <a name="function-translate"><b>Function: </b><i>string</i> <b>translate</b>(<i>string</i>, <i>string</i>, <i>string</i>)</a>
      </p>

      <p>The <b><a href="#function-translate">translate</a></b> function returns the first
      argument string with occurrences of characters in the second argument
      string replaced by the character at the corresponding position in the
      third argument string.  For example,
      <code>translate("bar","abc","ABC")</code> returns the string
      <code>BAr</code>.  If there is a character in the second argument
      string with no character at a corresponding position in the third
      argument string (because the second argument string is longer than the
      third argument string), then occurrences of that character in the
      first argument string are removed.  For example,
      <code>translate("--aaa--","abc-","ABC")</code> returns
      <code>"AAA"</code>. If a character occurs more than once in the second
      argument string, then the first occurrence determines the replacement
      character.  If the third argument string is longer than the second
      argument string, then excess characters are ignored.</p>

      <blockquote>
      <b>NOTE: </b>The <b><a href="#function-translate">translate</a></b> function is not a sufficient
      solution for case conversion in all languages.  A future version of
      XPath may provide additional functions for case conversion.</blockquote>

    </x:function>
    <x:function name="boolean" href="#function-boolean">
      <p>
      <a name="function-boolean"><b>Function: </b><i>boolean</i> <b>boolean</b>(<i>object</i>)</a>
      </p>

      <p>The <b><a href="#function-boolean">boolean</a></b> function converts its argument to a
      boolean as follows:</p>

      <ul>

      <li>
      <p>a number is true if and only if it is neither positive or
      negative zero nor NaN</p>
      </li>

      <li>
      <p>a node-set is true if and only if it is non-empty</p>
      </li>

      <li>
      <p>a string is true if and only if its length is non-zero</p>
      </li>

      <li>
      <p>an object of a type other than the four basic types is
      converted to a boolean in a way that is dependent on that
      type</p>
      </li>

      </ul>

    </x:function>
    <x:function name="not" href="#function-not">
      <p>
      <a name="function-not"><b>Function: </b><i>boolean</i> <b>not</b>(<i>boolean</i>)</a>
      </p>

      <p>The <b><a href="#function-not">not</a></b> function returns true if its argument is
      false, and false otherwise.</p>
    </x:function>
    <x:function name="true" href="#function-true">
      <p>
      <a name="function-true"><b>Function: </b><i>boolean</i> <b>true</b>()</a>
      </p>

      <p>The <b><a href="#function-true">true</a></b> function returns true.</p>
    </x:function>
    <x:function name="false" href="#function-false">
      <p>
      <a name="function-false"><b>Function: </b><i>boolean</i> <b>false</b>()</a>
      </p>

      <p>The <b><a href="#function-false">false</a></b> function returns false.</p>

    </x:function>
    <x:function name="lang" href="#function-lang">
      <p>
      <a name="function-lang"><b>Function: </b><i>boolean</i> <b>lang</b>(<i>string</i>)</a>
      </p>

      <p>The <b><a href="#function-lang">lang</a></b> function returns true or false depending on
      whether the language of the context node as specified by
      <code>xml:lang</code> attributes is the same as or is a sublanguage of
      the language specified by the argument string.  The language of the
      context node is determined by the value of the <code>xml:lang</code>
      attribute on the context node, or, if the context node has no
      <code>xml:lang</code> attribute, by the value of the
      <code>xml:lang</code> attribute on the nearest ancestor of the context
      node that has an <code>xml:lang</code> attribute.  If there is no such
      attribute, then <b><a href="#function-lang">lang</a></b> returns false. If there is such an
      attribute, then <b><a href="#function-lang">lang</a></b> returns true if the attribute
      value is equal to the argument ignoring case, or if there is some
      suffix starting with <code>-</code> such that the attribute value is
      equal to the argument ignoring that suffix of the attribute value and
      ignoring case. For example, <code>lang("en")</code> would return true
      if the context node is any of these five elements:</p>

      <pre>&lt;para xml:lang="en"/&gt;
&lt;div xml:lang="en"&gt;&lt;para/&gt;&lt;/div&gt;
&lt;para xml:lang="EN"/&gt;
&lt;para xml:lang="en-us"/&gt;</pre>
    </x:function>
    <x:function name="number" href="#function-number">
      <p>
      <a name="function-number"><b>Function: </b><i>number</i> <b>number</b>(<i>object</i>?)</a>
      </p>

      <p>The <b><a href="#function-number">number</a></b> function converts its argument to a
      number as follows:</p>

      <ul>

      <li>
      <p>a string that consists of optional whitespace followed by an
      optional minus sign followed by a <a href="#NT-Number">Number</a>
      followed by whitespace is converted to the IEEE 754 number that is
      nearest (according to the IEEE 754 round-to-nearest rule)
      to the mathematical value represented by the string; any other
      string is converted to NaN</p>
      </li>

      <li>
      <p>boolean true is converted to 1; boolean false is converted to
      0</p>
      </li>

      <li>

      <p>a node-set is first converted to a string as if by a call to the
      <b><a href="#function-string">string</a></b> function and then converted in the same way as a
      string argument</p>

      </li>

      <li>
      <p>an object of a type other than the four basic types is
      converted to a number in a way that is dependent on that
      type</p>
      </li>

      </ul>

      <p>If the argument is omitted, it defaults to a node-set with the
      context node as its only member.</p>

      <blockquote>
      <b>NOTE: </b>The <b><a href="#function-number">number</a></b> function should not be used
      for conversion of numeric data occurring in an element in an XML
      document unless the element is of a type that represents numeric data
      in a language-neutral format (which would typically be transformed
      into a language-specific format for presentation to a user). In
      addition, the <b><a href="#function-number">number</a></b> function cannot be used
      unless the language-neutral format used by the element is consistent
      with the XPath syntax for a <a href="#NT-Number">Number</a>.</blockquote>

    </x:function>
    <x:function name="sum" href="#function-sum">
      <p>
      <a name="function-sum"><b>Function: </b><i>number</i> <b>sum</b>(<i>node-set</i>)</a>
      </p>

      <p>The <b><a href="#function-sum">sum</a></b> function returns the sum, for each
      node in the argument node-set, of the result of converting the
      <a href="#dt-string-value">string-value</a>s of the node to
      a number.</p>
    </x:function>
    <x:function name="floor" href="#function-floor">
      <p>
      <a name="function-floor"><b>Function: </b><i>number</i> <b>floor</b>(<i>number</i>)</a>
      </p>

      <p>The <b><a href="#function-floor">floor</a></b> function returns the largest (closest to
      positive infinity) number that is not greater than the argument and
      that is an integer.</p>

    </x:function>
    <x:function name="ceiling" href="#function-ceiling">
      <p>
      <a name="function-ceiling"><b>Function: </b><i>number</i> <b>ceiling</b>(<i>number</i>)</a>
      </p>

      <p>The <b><a href="#function-ceiling">ceiling</a></b> function returns the smallest (closest
      to negative infinity) number that is not less than the argument and
      that is an integer.</p>
    </x:function>
    <x:function name="round" href="#function-round">
      <p>
      <a name="function-round"><b>Function: </b><i>number</i> <b>round</b>(<i>number</i>)</a>
      </p>

      <p>The <b><a href="#function-round">round</a></b> function returns the number that is
      closest to the argument and that is an integer.  If there are two such
      numbers, then the one that is closest to positive infinity is
      returned. If the argument is NaN, then NaN is returned. If the
      argument is positive infinity, then positive infinity is returned.  If
      the argument is negative infinity, then negative infinity is
      returned. If the argument is positive zero, then positive zero is
      returned.  If the argument is negative zero, then negative zero is
      returned.  If the argument is less than zero, but greater than or
      equal to -0.5, then negative zero is returned.</p>

      <blockquote>
      <b>NOTE: </b>For these last two cases, the result of calling the
      <b><a href="#function-round">round</a></b> function is not the same as the result of
      adding 0.5 and then calling the <b><a href="#function-floor">floor</a></b>
      function.</blockquote>


    </x:function>
  </x:functions>

</x:documentation>