// Copyright 2000-2026 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
import {access, copyFile, mkdir, readdir, readFile, rm, writeFile} from "node:fs/promises"
import {dirname, join, relative, resolve, sep} from "node:path"
import process from "node:process"
import {fileURLToPath} from "node:url"

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const repoRoot = resolve(__dirname, "..", "..");
const templatesDir = join(repoRoot, "community", ".ai");
const partialsDir = join(templatesDir, "partials");
const sharedPartialsDir = join(repoRoot, ".ai", "partials");

const generatedGuideHeader =
  "<!-- Generated by community/.ai/render-guides.mjs; edit community/.ai/* -->\n\n";
const generatedBeadsHeader =
  "<!-- Generated by community/.ai/render-guides.mjs; edit community/build/mcp-servers/task/beads-semantics.md -->\n\n";

const validEditions = new Set(["ULTIMATE", "COMMUNITY"]);

/**
 * @typedef {Object} OutputTarget
 * @property {string} name
 * @property {string} tool
 * @property {string} [template]
 * @property {string} [templatePath]
 * @property {string} output
 * @property {string} [runContext]
 * @property {string} [forbiddenToolsSuffix]
 * @property {boolean} [usesCompilationRule]
 * @property {string} [generatedHeader]
 * @property {string} [generatedHeaderPosition]
 * @property {string} [edition]
 * @property {string} [onlyWhenEdition]
 */

/** @type {OutputTarget[]} */
const outputs = [
  {
    name: "AGENTS.md",
    tool: "CODEX",
    template: "guide.md",
    output: "AGENTS.md",
    runContext: "via terminal command tool (not JetBrains MCP terminal)",
    forbiddenToolsSuffix: "",
    usesCompilationRule: true,
    generatedHeader: generatedGuideHeader,
    generatedHeaderPosition: "after-frontmatter",
  },
  {
    name: "AGENTS.md (community)",
    tool: "CODEX",
    template: "guide.md",
    output: "community/AGENTS.md",
    runContext: "via terminal command tool (not JetBrains MCP terminal)",
    forbiddenToolsSuffix: "",
    usesCompilationRule: true,
    generatedHeader: generatedGuideHeader,
    generatedHeaderPosition: "after-frontmatter",
    edition: "COMMUNITY",
    onlyWhenEdition: "ULTIMATE",
  },
  {
    name: "CLAUDE.md (ultimate)",
    tool: "CLAUDE",
    template: "guide.md",
    output: "CLAUDE.md",
    runContext: "from the shell/CLI",
    forbiddenToolsSuffix: "",
    usesCompilationRule: true,
    generatedHeader: generatedGuideHeader,
    generatedHeaderPosition: "after-frontmatter",
    edition: "ULTIMATE",
    onlyWhenEdition: "ULTIMATE",
  },
  {
    name: "Beads rules (CLAUDE)",
    tool: "CLAUDE",
    templatePath: "community/build/mcp-servers/task/beads-semantics.md",
    output: ".claude/rules/beads.md",
    forbiddenToolsSuffix: "",
    usesCompilationRule: false,
    generatedHeader: generatedBeadsHeader,
  },
  {
    name: "Guidelines (community)",
    tool: "CODEX",
    template: "ai-topic-index.template.md",
    output: "community/.ai/ai-topic-index.md",
    forbiddenToolsSuffix: "",
    usesCompilationRule: false,
    edition: "COMMUNITY",
  },
  {
    name: "Guidelines (ultimate)",
    tool: "CODEX",
    template: "ai-topic-index.template.md",
    output: ".ai/ai-topic-index.md",
    forbiddenToolsSuffix: "",
    usesCompilationRule: false,
    edition: "ULTIMATE",
    onlyWhenEdition: "ULTIMATE",
  },
];

function normalize(text) {
  const normalized = text.replace(/\r\n/g, "\n");
  const collapsed = normalized.replace(/\n{3,}/g, "\n\n");
  return collapsed.trimEnd() + "\n";
}

function renderCompilationRule(template, runContext) {
  const rendered = template.replace("{{RUN_CONTEXT}}", runContext).trim();
  if (rendered.includes("{{RUN_CONTEXT}}")) {
    throw new Error("Compilation template still contains {{RUN_CONTEXT}} placeholder.");
  }
  return rendered;
}

function replaceAll(text, token, value) {
  return text.split(token).join(value);
}

function splitLinkTarget(target) {
  const match = target.match(/^([^?#]+)([?#].*)?$/);
  if (!match) {
    return { path: target, suffix: "" };
  }
  return { path: match[1], suffix: match[2] ?? "" };
}

function isRelativeLinkTarget(target) {
  if (target.startsWith("#")) {
    return false;
  }
  if (target.startsWith("/")) {
    return false;
  }
  if (/^[a-z][a-z0-9+.-]*:/i.test(target)) {
    return false;
  }
  return true;
}

function ensureDotSlash(value) {
  if (value === "" || value === ".") {
    return "./";
  }
  if (value.startsWith("./") || value.startsWith("../") || value.startsWith("/")) {
    return value;
  }
  return `./${value}`;
}

function toPosixPath(value) {
  return value.split(sep).join("/");
}

function rewriteLinkTarget(rawTarget, sourcePath, outputPath) {
  const { path, suffix } = splitLinkTarget(rawTarget);
  if (!path || !isRelativeLinkTarget(path)) {
    return rawTarget;
  }
  const absolutePath = resolve(dirname(sourcePath), path);
  const outputDir = dirname(outputPath);
  let relativePath = relative(outputDir, absolutePath);
  relativePath = ensureDotSlash(relativePath);
  return toPosixPath(relativePath) + suffix;
}

const inlineLinkPattern = /(!?\[[^\]]*])\(([^)\s]+)(\s+[^)]+)?\)/g;

function rewriteInlineLinks(text, sourcePath, outputPath) {
  return text.replace(inlineLinkPattern, (match, label, target, title = "") => {
    const rewrittenTarget = rewriteLinkTarget(target, sourcePath, outputPath);
    return `${label}(${rewrittenTarget}${title})`;
  });
}

const referenceLinkPattern = /^(\s*\[[^\]]+]:\s*)(\S+)(.*)$/gm;

function rewriteReferenceLinks(text, sourcePath, outputPath) {
  return text.replace(referenceLinkPattern, (match, prefix, target, suffix) => {
    const rewrittenTarget = rewriteLinkTarget(target, sourcePath, outputPath);
    return `${prefix}${rewrittenTarget}${suffix}`;
  });
}

function rewriteMarkdownLinks(text, sourcePath, outputPath) {
  const withInlineLinks = rewriteInlineLinks(text, sourcePath, outputPath);
  return rewriteReferenceLinks(withInlineLinks, sourcePath, outputPath);
}

const partialPattern = /\{\{PARTIAL:([^}]+)[}][}]/g;
const partialPatternCheck = /\{\{PARTIAL:[^}]+[}][}]/;

async function loadPartialsFromDir(dir) {
  let entries;
  try {
    entries = await readdir(dir, {withFileTypes: true});
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return new Map();
    }
    throw error;
  }
  const partials = new Map();
  for (const entry of entries) {
    if (!entry.isFile() || !entry.name.endsWith(".md")) {
      continue;
    }
    const name = entry.name.replace(/\.md$/, "");
    const path = join(dir, entry.name);
    const content = await readFile(path, "utf8");
    partials.set(name, {content: content.trimEnd(), path});
  }
  return partials;
}

async function loadPartials() {
  const partials = new Map();
  const sources = [partialsDir, sharedPartialsDir];
  for (const source of sources) {
    const next = await loadPartialsFromDir(source);
    for (const [name, partial] of next.entries()) {
      partials.set(name, partial);
    }
  }
  return partials;
}

function applyPartials(text, partials) {
  return text.replace(partialPattern, (match, name) => {
    const partial = partials.get(name);
    if (partial === undefined) {
      throw new Error(`Unknown partial: ${name}`);
    }
    return partial;
  });
}

const templateBlockPattern = /<!-- TEMPLATE:COMMENT -->[\s\S]*?<!-- \/TEMPLATE:COMMENT -->\n?/g;

function stripTemplateBlocks(text) {
  return text.replace(templateBlockPattern, "");
}

const toolBlockPattern = /<!--\s*IF_TOOL:([A-Z0-9_-]+)\s*-->([\s\S]*?)<!--\s*\/IF_TOOL:\1\s*-->/gi;

function applyToolBlocks(text, tool) {
  const normalizedTool = (tool ?? "").toUpperCase();
  return text.replace(toolBlockPattern, (match, blockTool, content) => {
    if (blockTool.toUpperCase() === normalizedTool) {
      return content;
    }
    return "";
  });
}

const editionBlockPattern = /<!--\s*IF_EDITION:([A-Z0-9_-]+)\s*-->([\s\S]*?)<!--\s*\/IF_EDITION:\1\s*-->/gi;

function applyEditionBlocks(text, edition) {
  const normalizedEdition = (edition ?? "").toUpperCase();
  return text.replace(editionBlockPattern, (match, blockEdition, content) => {
    if (blockEdition.toUpperCase() === normalizedEdition) {
      return content;
    }
    return "";
  });
}

function normalizeEdition(value) {
  const normalized = value.trim().toUpperCase();
  if (!validEditions.has(normalized)) {
    throw new Error(`Unknown edition "${value}". Use community or ultimate.`);
  }
  return normalized;
}

async function detectEdition() {
  const envEdition = process.env["AI_GUIDE_EDITION"] ?? process.env["RENDER_EDITION"];
  if (envEdition) {
    return normalizeEdition(envEdition);
  }
  try {
    await access(join(repoRoot, ".ultimate.root.marker"));
    return "ULTIMATE";
  } catch {
    return "COMMUNITY";
  }
}

const basePartials = await loadPartials();
const defaultEdition = await detectEdition();
const compilationTemplatePath = join(templatesDir, "compilation.md");
const compilationTemplate = await readFile(compilationTemplatePath, "utf8");
const mcpConfigPath = join(repoRoot, ".mcp.json");
const opencodeConfigPath = join(repoRoot, "opencode.json");
const codexSkillsDir = join(repoRoot, ".codex", "skills");
const opencodeSkillsDir = join(repoRoot, ".opencode", "skill");
const opencodeJetBrainsMcpName = "jetbrains";
const opencodeJetBrainsMcpConfig = {
  type: "remote",
  url: "http://127.0.0.1:64344/sse",
  headers: {},
  enabled: true
};

function buildPartialsForTarget(target, outputPath) {
  const partials = new Map();
  for (const [name, partial] of basePartials.entries()) {
    let content = partial.content;
    if (content) {
      content = rewriteMarkdownLinks(content, partial.path, outputPath);
    }
    partials.set(name, content);
  }
  return partials;
}

function toOpenCodeServer(name, server) {
  if (!server || typeof server !== "object") {
    throw new Error(`Invalid MCP server config for ${name}.`);
  }
  if (server.type === "stdio") {
    if (!server.command) {
      throw new Error(`MCP server ${name} is missing command.`);
    }
    const command = [server.command, ...(server.args ?? [])].filter(Boolean);
    const entry = { type: "local", command };
    if (server.env && Object.keys(server.env).length > 0) {
      entry.environment = server.env;
    }
    return entry;
  }
  if (server.type === "http") {
    if (!server.url) {
      throw new Error(`MCP server ${name} is missing url.`);
    }
    const entry = { type: "remote", url: server.url };
    if (server.headers && Object.keys(server.headers).length > 0) {
      entry.headers = server.headers;
    }
    return entry;
  }
  throw new Error(`Unsupported MCP server type for ${name}: ${server.type}`);
}

async function renderOpenCodeConfig() {
  let raw;
  try {
    raw = await readFile(mcpConfigPath, "utf8");
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return;
    }
    throw error;
  }
  let parsed;
  try {
    parsed = /** @type {{mcpServers?: Record<string, unknown>}} */ (JSON.parse(raw));
  } catch (error) {
    throw new Error(`Failed to parse ${mcpConfigPath}.`);
  }
  const mcpServers = parsed.mcpServers;
  if (!mcpServers || typeof mcpServers !== "object") {
    throw new Error(`Invalid ${mcpConfigPath}: missing mcpServers.`);
  }
  const mcp = {};
  for (const [name, server] of Object.entries(mcpServers)) {
    mcp[name] = toOpenCodeServer(name, server);
  }
  if (!mcp[opencodeJetBrainsMcpName]) {
    mcp[opencodeJetBrainsMcpName] = {...opencodeJetBrainsMcpConfig};
  }
  const opencodeConfig = {
    "$schema": "https://opencode.ai/config.json",
    model: "openai/gpt-5.2-codex",
    provider: {
      openai: {
        models: {
          "gpt-5.2-codex": {
            options: {
              reasoningEffort: "high"
            }
          }
        }
      }
    },
    mcp
  };
  const content = `${JSON.stringify(opencodeConfig, null, 2)}\n`;
  await writeFile(opencodeConfigPath, content, "utf8");
}

async function copyDirectory(sourceDir, targetDir) {
  await mkdir(targetDir, {recursive: true});
  const entries = await readdir(sourceDir, {withFileTypes: true});
  for (const entry of entries) {
    const sourcePath = join(sourceDir, entry.name);
    const targetPath = join(targetDir, entry.name);
    if (entry.isDirectory()) {
      await copyDirectory(sourcePath, targetPath);
    } else if (entry.isFile()) {
      await copyFile(sourcePath, targetPath);
    }
  }
}

async function renderOpenCodeSkills() {
  let entries;
  try {
    entries = await readdir(codexSkillsDir, {withFileTypes: true});
  } catch (error) {
    if (error && error.code === "ENOENT") {
      return;
    }
    throw error;
  }

  await mkdir(opencodeSkillsDir, {recursive: true});
  for (const entry of entries) {
    if (!entry.isDirectory()) {
      continue;
    }
    const sourcePath = join(codexSkillsDir, entry.name);
    const targetPath = join(opencodeSkillsDir, entry.name);
    await rm(targetPath, {recursive: true, force: true});
    await copyDirectory(sourcePath, targetPath);
  }
}

function shouldRenderTarget(target, edition) {
  if (!target.onlyWhenEdition) {
    return true;
  }
  return normalizeEdition(target.onlyWhenEdition) === edition;
}

function resolveEdition(target, fallbackEdition) {
  if (!target.edition) {
    return fallbackEdition;
  }
  return normalizeEdition(target.edition);
}

for (const target of outputs) {
  if (!shouldRenderTarget(target, defaultEdition)) {
    continue;
  }
  const edition = resolveEdition(target, defaultEdition);
  const outputPath = join(repoRoot, target.output);
  const templatePath = target.templatePath
    ? join(repoRoot, target.templatePath)
    : join(templatesDir, target.template);
  const templateText = await readFile(templatePath, "utf8");
  const rewrittenTemplateText = rewriteMarkdownLinks(templateText, templatePath, outputPath);
  const usesCompilationRule = target.usesCompilationRule !== false;
  if (usesCompilationRule) {
    if (!templateText.includes("{{COMPILATION_RULE}}")) {
      throw new Error(`${target.name} template is missing {{COMPILATION_RULE}} placeholder.`);
    }
  } else if (templateText.includes("{{COMPILATION_RULE}}")) {
    throw new Error(`${target.name} template includes {{COMPILATION_RULE}} but usesCompilationRule is false.`);
  }

  const partials = buildPartialsForTarget(target, outputPath);
  const withPartials = applyPartials(rewrittenTemplateText, partials);
  if (partialPatternCheck.test(withPartials)) {
    throw new Error(`${target.name} rendered output still has {{PARTIAL:...}} placeholders.`);
  }

  const withForbiddenTools = replaceAll(
    withPartials,
    "{{FORBIDDEN_TOOLS_SUFFIX}}",
    target.forbiddenToolsSuffix,
  );
  if (withForbiddenTools.includes("{{FORBIDDEN_TOOLS_SUFFIX}}")) {
    throw new Error(`${target.name} rendered output still has {{FORBIDDEN_TOOLS_SUFFIX}} placeholder.`);
  }

  let renderedText = withForbiddenTools;
  if (usesCompilationRule) {
    const compilationRule = renderCompilationRule(compilationTemplate, target.runContext);
    renderedText = replaceAll(withForbiddenTools, "{{COMPILATION_RULE}}", compilationRule);
  }

  const withToolBlocks = applyToolBlocks(renderedText, target.tool);
  const withEditionBlocks = applyEditionBlocks(withToolBlocks, edition);
  const withoutTemplateBlocks = stripTemplateBlocks(withEditionBlocks);

  if (withoutTemplateBlocks.includes("{{COMPILATION_RULE}}")) {
    throw new Error(`${target.name} rendered output still has {{COMPILATION_RULE}} placeholder.`);
  }

  let finalText = withoutTemplateBlocks;
  if (target.generatedHeader && !finalText.includes(target.generatedHeader)) {
    if (target.generatedHeaderPosition === "after-frontmatter" && finalText.startsWith("---\n")) {
      const frontmatterEnd = finalText.indexOf("\n---\n", 4);
      if (frontmatterEnd !== -1) {
        const insertAt = frontmatterEnd + "\n---\n".length;
        const remainder = finalText.slice(insertAt);
        const remainderStripped = remainder.startsWith("\n") ? remainder.slice(1) : remainder;
        finalText = finalText.slice(0, insertAt) + "\n" + target.generatedHeader + remainderStripped;
      } else {
        finalText = target.generatedHeader + finalText;
      }
    } else {
      finalText = target.generatedHeader + finalText;
    }
  }

  await writeFile(outputPath, normalize(finalText), "utf8");
}

await renderOpenCodeConfig();
await renderOpenCodeSkills();
