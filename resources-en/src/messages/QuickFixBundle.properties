add.import=Add Import
class.to.import.chooser.title=Class to Import
method.to.import.chooser.title=Method to Import
field.to.import.chooser.title=Field to Import
access.static.via.class.reference.family=Access static via class reference
access.static.via.class.reference.text=Access static ''{1}.{0}'' via class ''{2}'' reference
add.default.constructor.family=Add Default Constructor
add.default.constructor.text=Add {0} no-args constructor to {1}
add.catch.clause.family=Add exception to catch clause
add.catch.clause.text=Add 'catch' clause(s)
add.exception.to.throws.inherited.method.warning.text=Method ''{0}'' is inherited.\n\
  Do you want to add exceptions to method signatures in the whole method hierarchy?
method.is.inherited.warning.title=Method Is Inherited
add.exception.to.throws.text=Add {0, choice, 0#exception|2#exceptions} to method signature
add.exception.to.throws.family=Add exception to method signature
add.method.body.text=Add method body
add.method.family=Add Method
add.method.text=Add Method ''{0}'' to Class ''{1}''
add.new.array.family=Add missing new expression
add.new.array.text=Add ''new {0}[]''
add.return.statement.text=Add 'return' statement
add.runtime.exception.to.throws.text=Add runtime exception(s) to method signature
add.runtime.exception.to.throws.family=Add Runtime Exception to Method Signature
add.typecast.family=Add TypeCast
add.typecast.text=Cast to ''{0}''
add.docTag.to.custom.tags=Add {0} to custom tags
fix.javadoc.family=Fix Javadoc
adjust.package.family=Adjust Package Name
adjust.package.text=Set package name to ''{0}''
bring.variable.to.scope.family=Bring Variable to Scope
bring.variable.to.scope.text=Bring ''{0}'' into scope

cast.parameter.text=Cast {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} parameter to ''{1}''
cast.single.parameter.text=Cast parameter to ''{0}''

add.type.arguments.text=Add explicit type arguments to {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} argument
add.type.arguments.single.argument.text=Add explicit type arguments

change.class.signature.text=Change signature of ''{0}'' to match ''{1}''
change.class.signature.family=Change class signature

uidesigner.change.bound.field.type=Change bound field type
cannot.change.field.exception=Cannot change field ''{0}'' type.\nReason: {1}

# {0} - original keyword (extends or implements), {1} - proposed keyword (implements or extends), {2} - class name
exchange.extends.implements.keyword=Change ''{0} {2}'' to ''{1} {2}''
uidesigner.change.gui.component.type=Change GUI component type
change.method.signature.from.usage.family=Change method signature from usage

# {0} - original method signature including name, {1} - method name, {2} - proposed new parameters list
change.method.signature.from.usage.text=Change signature of ''{0}'' to ''{1}({2})''
add.parameter.from.usage.text=Add ''{0}'' as {1, choice, 1#1st|2#2nd|3#3rd|4#{1,number}th} parameter to method ''{2}''
remove.parameter.from.usage.text=Remove {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} parameter from method ''{1}''
change.parameter.from.usage.text=Change {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} parameter of method ''{1}'' from ''{2}'' to ''{3}''
searching.for.usages.progress.title=Searching For Usages...
create.class.from.new.family=Create Class from New
create.class.from.new.text=Create class ''{0}''
create.class.from.usage.family=Create Class from Usage
create.class.from.usage.text=Create {0} ''{1}''
create.inner.class.from.usage.text=Create inner {0} ''{1}''
create.constant.from.usage.family=Create Constant From Usage
create.constant.from.usage.text=Create constant field ''{0}''
create.enum.constant.from.usage.text=Create enum constant ''{0}''
create.constructor.from.new.family=Create Constructor from New
create.constructor.from.new.text=Create constructor
create.constructor.from.super.call.family=Create Constructor From super() Call
create.constructor.from.this.call.family=Create Constructor From this() Call
create.constructor.text=Create constructor in ''{0}''
create.constructor.matching.super=Create constructor matching super
super.class.constructors.chooser.title=Choose Super Class Constructors
create.field.from.usage.family=Create field from Usage
create.field.from.usage.text=Create field ''{0}''
target.class.chooser.title=Choose Target Class
create.class.title=Create {0}
create.enum=enum
create.interface=interface
create.class=class
new.method.body.template.error.text=Please Correct "New Method Body" Template
new.method.body.template.error.title=File Template Error
cannot.create.java.file.error.text=Cannot create {0}.java in {1}: {2}
cannot.create.java.file.error.title=File Creation Failed
cannot.create.java.package.error.text=Cannot create {0} in {1}: {2}
cannot.create.java.package.error.title=Package Creation Failed
create.accessor.for.unused.field.family=Create Accessor for Unused Field
create.getter.for.field=Create getter for ''{0}''
create.setter.for.field=Create setter for ''{0}''
create.getter.and.setter.for.field=Create getter and setter for ''{0}''
create.local.from.usage.family=Create Local from Usage
create.local.from.usage.text=Create local variable ''{0}''
create.local.from.instanceof.usage.family=Create Local Var from instanceof Usage
create.local.from.instanceof.usage.text=Insert ''({0}){1}'' declaration
create.method.from.usage.family=Create method from usage
create.method.from.usage.text=Create method ''{0}''
create.abstract.method.from.usage.text=Create abstract method ''{0}''
create.parameter.from.usage.family=Create parameter from Usage
create.parameter.from.usage.text=Create parameter ''{0}''
create.property.from.usage.family=Create property From Usage
create.getter=Create Getter
create.setter=Create Setter
defer.final.assignment.with.temp.family=Defer final assignment with temp
defer.final.assignment.with.temp.text=Defer assignment to ''{0}'' using temp variable
delete.catch.family=Delete Catch
delete.catch.text=Delete catch for ''{0}''
delete.body.text=Delete method body
enable.optimize.imports.on.the.fly=Enable 'Settings|Code Style|Imports|Optimize imports on the fly'
generalize.catch.family=Generalize Catch
generalize.catch.text=Generalize catch for ''{0}'' to ''{1}''
generify.family=Generify File
generify.text=Try to generify ''{0}''
implement.methods.fix=Implement methods
import.class.fix=Import class
insert.new.fix=Insert new
insert.super.constructor.call.family=Base Ctr call
insert.super.constructor.call.text=Insert ''{0}''
make.class.an.interface.family=Make Class an Interface
make.class.an.interface.text=Make ''{0}'' an interface
make.interface.an.class.text=Make ''{0}'' a class
make.vararg.parameter.last.family=Make vararg parameter last
make.vararg.parameter.last.text=Move ''{0}'' to the end of the list
fix.parameter.type.family=Fix Parameter Type
fix.parameter.type.text=Make ''{0}'' take parameter of type ''{1}'' here
fix.return.type.family=Fix return type
fix.return.type.text=Make ''{0}'' return ''{1}''
fix.throws.list.family=Fix throws list
fix.throws.list.add.exception=Add ''{0}'' to ''{1}'' throws list
fix.throws.list.remove.exception=Remove ''{0}'' from ''{1}'' throws list
fix.modifiers.family=Fix modifiers

anonymous.class.presentation=Anonymous class derived from {0}
# {0} owner class name
class.initializer.presentation={0} class initializer
add.modifier.fix=Make ''{0}'' {1}
remove.modifier.fix=Make ''{0}'' not {1}

change.inheritors.visibility.warning.text=Do you want to change inheritors' visibility to visibility of the base method?
change.inheritors.visibility.warning.title=Change Inheritors
move.class.in.extend.list.family=Move Class in Extend list
move.bound.class.to.front.fix.text=Move bound ''{0}'' to the beginning of the bounds list of type parameter ''{1}''
move.catch.up.family=Move Catch Up
move.catch.up.text=Move catch for ''{0}'' before ''{1}''
move.class.to.separate.file.family=Move Class to Separate File
move.class.to.separate.file.text=Move class ''{0}'' to ''{0}.java''
move.class.to.package.family=Move Class to Package
move.class.to.package.text=Move to package ''{0}''

# change if (!a == b) ...  =>  if (!(a == b)) ...
negation.broader.scope.family=Negation Broader Scope
negation.broader.scope.text=Change to ''!({0})''

optimize.imports.fix=Optimize imports
remove.qualifier.fix=Remove qualifier
remove.unused.parameter.family=Remove unused parameter
remove.unused.parameter.text=Remove parameter ''{0}''
remove.unused.variable.family=Remove unused variable
remove.unused.variable=Remove variable ''{0}''
remove.unused.field=Remove field ''{0}''
rename.wrong.reference.family=Rename Wrong Reference
rename.wrong.reference.text=Rename reference
reuse.variable.declaration.family=Reuse variable declaration
reuse.variable.declaration.text=Reuse previous variable ''{0}'' declaration
navigate.variable.declaration.family=Navigate to variable declaration
navigate.variable.declaration.text=Navigate to previous declared variable ''{0}''
safe.delete.family=Safe delete
safe.delete.text=Safe delete ''{0}''
setup.jdk.location.family=Setup JDK Location
setup.jdk.location.text=Setup JDK
side.effects.warning.dialog.title=Side Effects Found
simplify.boolean.expression.family=Simplify boolean expression
simplify.boolean.expression.text=Simplify ''{0}'' to {1}
fix.super.method.return.type.family=Fix Super Method Return Type
fix.super.method.return.type.text=Make ''{0}'' return ''{1}''
surround.with.try.catch.fix=Surround with try/catch
make.final.family=Make Final
make.final.text=Make {0} final
make.final.copy.to.temp=Copy ''{0}'' to {1} temp variable
make.final.transform.to.one.element.array=Transform {0} into final one element array
fix.variable.type.family=Fix Variable Type
fix.variable.type.text=Change {0} ''{1}'' type to ''{2}''

# Sample: Boolean b = "true"; -> Boolean b = Boolean.valueOf("true");
wrap.expression.using.static.accessor.family=Wrap Expression
wrap.expression.using.static.accessor.text=Wrap using ''{0}()''

# {0} - qualified class name suggested to be imported.
side.effect.action.remove=&Remove
side.effect.action.transform=&Transform
side.effect.action.cancel=&Cancel
side.effect.message1=<html><body>\
  There are possible side effects found in expressions assigned to the variable ''{0}''<br>\
  You can:<ul><li><b>Remove</b> variable usages along with all expressions involved</li>\
  </body></html>
# {0} - variable name, {1} - variable type, {2} - expression with side effect, {3} - same expression transformed to hold the effect

change.parameter.class.family=Change Parameter Class

change.extends.list.family=Extend Class from
add.class.to.extends.list=Make ''{0}'' extend ''{1}''
remove.class.from.extends.list=Make ''{0}'' not extend ''{1}''
add.interface.to.implements.list=Make ''{0}'' implement ''{1}''
remove.interface.from.implements.list=Make ''{0}'' not implement ''{1}''
convert.method.to.constructor=Make method constructor

create.class.text=Create class {0}
create.interface.text=Create interface {0}
create.package.text=Create package {0}
create.field.text=Create field {0}
create.property.text=Create property {0}
add.constructor.parameter.name=Add constructor parameter
remove.suppression.action.name=Remove ''{0}'' suppression
remove.suppression.action.family=Remove suppression
remove.qualifier.action.text=Remove qualifier
fix.argument.family=Fix Arguments
change.new.operator.type.text=Change ''{0}'' to ''new {1}{2}''
change.new.operator.type.family=Change new operator type

fix.unused.symbol.injection.family=Add to Dependency Injection Annotations
fix.unused.symbol.injection.text=Suppress for {0} annotated by ''{1}''
fix.add.special.annotation.family=Add to Special Annotations
fix.add.special.annotation.text=Add ''{0}'' to special annotations list

orderEntry.fix.add.dependency.on.module=Add dependency on module ''{0}''
orderEntry.fix.add.dependency.on.module.choose=Add dependency on module...
orderEntry.fix.choose.module.to.add.dependency.on=Choose Module to Add Dependency on
orderEntry.fix.family.add.module.dependency=Add module dependency
orderEntry.fix.add.library.to.classpath=Add library ''{0}'' to classpath
orderEntry.fix.family.add.library.to.classpath=Add library to classpath
orderEntry.fix.circular.dependency.warning=Adding dependency on module ''{0}'' will introduce circular dependency between modules ''{1}'' and ''{2}''.\nAdd dependency anyway?
orderEntry.fix.title.circular.dependency.warning=Circular Dependency Warning
static.import.method.text=Import static method
static.import.method.choose.method.to.import=Choose Method to Import
static.import.constant.text=Import static constant

add.library.title.dialog=Add ''{0}'' Library to Project
add.library.title.choose.folder=Choose Directory
add.library.description.choose.folder=Choose directory where the library will be copied
add.library.error.not.found=Library file ''{0}'' does not exist
add.library.error.cannot.copy=Cannot copy ''{0}'' to ''{1}''\n({2})
add.library.use.bundled.library.radio.button=&Use ''{0}'' from {1} distribution
add.library.copy.files.to.radio.button=&Copy ''{0}'' library files to

permute.arguments=Permute arguments
fix.single.character.string.to.char.literal.text=Change {0} to {1} (to {2} literal)
fix.single.character.string.to.char.literal.family=Fix literal type

create.readable.writable.property.with.field=Create getter, setter and field for ''{0}''
create.readable.property=Create getter for ''{0}''
create.writable.property=Create setter for ''{0}''
create.readable.property.with.field=Create getter and field for ''{0}''
create.writable.property.with.field=Create setter and field for ''{0}''

change.to.append.family=Fix StringBuilder append
change.to.append.text=Change to ''{0}''

convert.to.string.family=Fix Character Literal
convert.to.string.text=Convert to string literal

initialize.final.field.in.constructor.name=Initialize in constructor
initialize.final.field.in.constructor.choose.dialog.title=Choose constructors to add initialization to

remove.redundant.arguments.text=Remove redundant arguments to call ''{0}''
remove.redundant.arguments.family=Remove redundant arguments

replace.with.list.access.text=Replace with list access

add.qualifier=Add qualifier
add.qualifier.original.class.chooser.title=Original class

annotations.fix=Annotations
add.missing.annotation.parameters.fix=Add missing annotation parameters - {0}
add.missing.annotation.single.parameter.fix=Add missing annotation parameter ''{0}''

add.method.qualifier.fix.text=Add qualifier ''{0}'' to method
add.method.qualifier.fix.family=Add method qualifier

collection.addall.can.be.replaced.with.constructor.fix.options.title=Classes to check
collection.addall.can.be.replaced.with.constructor.fix.description=''{0}()'' method can be replaced with parametrized constructor
collection.addall.can.be.replaced.with.constructor.fix.title=Replace 'addAll/putAll' method with parametrized constructor call

add.exception.from.field.initializer.to.constructor.throws.text=Add exception to class {0, choice, 0#default constructor|1#constructor|2#constructors} signature
add.exception.from.field.initializer.to.constructor.throws.family.text=Add exception to class constructors signature
java.8.map.api.inspection.fix.text=Replace with ''{0}'' method call
java.8.map.api.inspection.description=Can be replaced with single ''Map.{0}'' method call
java.8.map.api.inspection.fix.family.name=Replace with single Map method call
java.8.collection.removeif.inspection.description=The loop could be replaced with Collection.removeIf
java.8.collection.removeif.inspection.fix.name=Replace the loop with Collection.removeIf
java.8.list.sort.inspection.description=Collections.sort could be replaced with List.sort
java.8.list.sort.inspection.fix.name=Replace with List.sort

wrap.with.optional.parameter.text=Wrap {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} parameter using ''java.util.Optional''
wrap.with.optional.single.parameter.text=Wrap using 'java.util.Optional'

move.file.to.source.root.text=Move file to a source root

delete.element.fix.text=Delete element
delete.reference.fix.text=Delete reference
delete.unreachable.statement.fix.text=Delete unreachable statement

extract.side.effects.convert.to.if=Convert to 'if' statement
extract.side.effects=Extract side {0, choice, 1#effect|2#effects}
extract.side.effects.family.name=Delete statement extracting side effects

module.info.add.requires.family.name=Add 'requires' directive to module-info.java
module.info.add.requires.name=Add ''requires {0}'' directive to module-info.java

collection.to.array.text=Apply conversion ''.toArray({0})''
collection.to.array.family.name=Apply conversion '.toArray()'

insert.sam.method.call.fix.name=Insert ''.{0}'' to call functional interface method
insert.sam.method.call.fix.family.name=Insert single abstract method call

wrap.with.adapter.call.family.name=Wrap using adapter call or object
wrap.with.adapter.text=Wrap using ''{0}''
wrap.with.adapter.parameter.single.text=Wrap parameter using ''{0}''
wrap.with.adapter.parameter.multiple.text=Wrap {0, choice, 1#1st|2#2nd|3#3rd|4#{0,number}th} parameter using ''{1}''

java.9.merge.module.statements.fix.family.name=Merge with other ''{0}'' directive
java.9.merge.module.statements.fix.name=Merge with other ''{0} {1}'' directive

model.create.constructor.quickfix.message=Create constructor ''{0}''
model.create.constructor.quickfix.message.family.name=Create constructor

adjust.method.accepting.functional.expression.fix.family.name=Adjust method accepting functional expression
adjust.method.accepting.functional.expression.fix.text=Replace ''{0}()'' with ''{1}()''