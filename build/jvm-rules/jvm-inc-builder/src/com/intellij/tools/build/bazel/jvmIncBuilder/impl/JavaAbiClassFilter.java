// Copyright 2000-2025 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license.
package com.intellij.tools.build.bazel.jvmIncBuilder.impl;

import com.intellij.tools.build.bazel.jvmIncBuilder.instrumentation.FailSafeClassReader;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.org.objectweb.asm.*;
import org.jetbrains.org.objectweb.asm.tree.FieldNode;
import org.jetbrains.org.objectweb.asm.tree.InsnNode;
import org.jetbrains.org.objectweb.asm.tree.MethodNode;

import java.util.*;

public class JavaAbiClassFilter extends ClassVisitor {
  public static final String MODULE_INFO_CLASS_NAME = "module-info";
  private boolean isAbiClass;
  private boolean isEnum;
  private boolean allowPackageLocalMethods;
  private final Set<String> myExcludedClasses = new HashSet<>();
  private final List<FieldNode> myFields = new ArrayList<>();
  private final MethodContainer myMethods;

  private JavaAbiClassFilter(ClassVisitor delegate, MethodContainer methodContainer) {
    super(Opcodes.API_VERSION, delegate);
    myMethods = methodContainer;
  }

  public static byte @Nullable [] filter(byte[] classBytes) {
    ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS) {
      @Override
      protected String getCommonSuperClass(String type1, String type2) {
        return null;
      }
    };
    ClassReader reader = new FailSafeClassReader(classBytes);
    JavaAbiClassFilter abiVisitor = new JavaAbiClassFilter(writer, MethodContainer.create(reader));
    reader.accept(
      abiVisitor, ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG
    );
    return abiVisitor.isAbiClass? writer.toByteArray() : null;
  }

  @Override
  public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
    isAbiClass = MODULE_INFO_CLASS_NAME.equals(name) || isAbiVisible(access);
    isEnum = isEnum(access);
    allowPackageLocalMethods = name.contains("/android/");   // todo: temporary condition to enable android tests compilation
    if (!isAbiClass) {
      myExcludedClasses.add(name);
    }
    super.visit(version, access, name, signature, superName, interfaces);
  }

  private static boolean isAbiVisible(int access) {
    return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED)) != 0;
  }

  private static boolean isEnum(int access) {
    return (access & Opcodes.ACC_ENUM) != 0;
  }

  private static boolean isSynthetic(int access) {
    return (access & Opcodes.ACC_SYNTHETIC) != 0;
  }

  private static boolean isPackageLocal(int access) {
    return (access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE)) == 0;
  }

  @Override
  public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
    if (isAbiVisible(access) || isEnum && isSynthetic(access)) {
      FieldNode field = new FieldNode(Opcodes.API_VERSION, access, name, descriptor, signature, value);
      myFields.add(field);
      return field;
    }
    return null;
  }

  @Override
  public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
    if (isAbiVisible(access) || (allowPackageLocalMethods && isPackageLocal(access))) {
      return myMethods.addAbiStubMethod(access, name, descriptor, signature, exceptions);
    }
    return null;
  }

  @Override
  public void visitEnd() {
    // Important: sorting members may cause generated bytecode built against ABI content
    // to be binary-different from the generated bytecode built against artifact's bytecode
    // For now, sorting is disabled to minimize bytecode differences

    //Collections.sort(myFields, Comparator.comparing(f -> f.name));
    for (FieldNode field : myFields) {
      field.accept(cv);
    }

    //Collections.sort(myMethods, Comparator.comparing(m -> m.name));
    for (MethodNode method : myMethods.getMethods()) {
      method.accept(cv);
    }
    super.visitEnd();
  }

  @Override
  public void visitNestMember(String nestMember) {
    if (nestMember == null || !myExcludedClasses.contains(nestMember)) {
      super.visitNestMember(nestMember);
    }
  }

  @Override
  public void visitPermittedSubclass(String permittedSubclass) {
    if (permittedSubclass == null || !myExcludedClasses.contains(permittedSubclass)) {
      super.visitPermittedSubclass(permittedSubclass);
    }
  }

  @Override
  public void visitInnerClass(String name, String outerName, String innerName, int access) {
    // innerName == null for anonymous classes
    if (isAbiVisible(access) && innerName != null && !myExcludedClasses.contains(name)) {
      super.visitInnerClass(name, outerName, innerName, access);
    }
  }

  private static final class AbiMethod extends MethodNode {
    private static final List<InsnNode> ourBodyInstructions = List.of(
      new InsnNode(Opcodes.ACONST_NULL),
      new InsnNode(Opcodes.ATHROW)
    );

    AbiMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
      super(Opcodes.API_VERSION, access, name, descriptor, signature, exceptions);

      if ((access & (Opcodes.ACC_ABSTRACT | Opcodes.ACC_NATIVE)) == 0) {
        // in a valid bytecode, non-abstract and non-native methods must have a code attribute
        for (InsnNode insn : ourBodyInstructions) {
          instructions.add(insn);
        }
      }
    }
  }

  private interface MethodContainer {
    @Nullable
    MethodNode addAbiStubMethod(int access, String name, String descriptor, String signature, String[] exceptions);

    Collection<MethodNode> getMethods();

    static MethodContainer create(ClassReader reader) {
      if (isEnum(reader.getAccess())) {
        // Keep enum's certain methods in ABI content. Form compiler relies on enum's valueOf() and similar methods in property value introspection.
        // Failure to read enum constants on compilation stage may lead to incorrectly generated UI setup code.
        return new EnumMethodContainer(Opcodes.API_VERSION, reader);
      }
      return new MethodContainer() {
        private final List<MethodNode> myNodes = new ArrayList<>();
        @Override
        public MethodNode addAbiStubMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
          AbiMethod node = new AbiMethod(access, name, descriptor, signature, exceptions);
          myNodes.add(node);
          return node;
        }

        @Override
        public Collection<MethodNode> getMethods() {
          return Collections.unmodifiableCollection(myNodes);
        }
      };
    }
  }

  private static class EnumMethodContainer implements MethodContainer {
    private static final Set<String> ourEnumMethodsToKeep = Set.of(
      "valueOf", "values", "$values", "name", "ordinal", "compareTo"
    );
    private final Map<String, MethodNode> myNodes = new LinkedHashMap<>(); // keep method order

    EnumMethodContainer(int api, ClassReader reader) {
      if (isAbiVisible(reader.getAccess())) {
        // collect methods to keep
        reader.accept(new ClassVisitor(api) {
          @Override
          public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
            if (shouldKeepMethod(access, name)) {
              MethodNode node = new MethodNode(api, access, name, descriptor, signature, exceptions);
              myNodes.put(getKey(name, descriptor), node);
              return node;
            }

            myNodes.put(getKey(name, descriptor), new AbiMethod(access, name, descriptor, signature, exceptions));
            return null;
          }
        }, ClassReader.SKIP_DEBUG);
      }
    }

    @Override
    @Nullable
    public MethodNode addAbiStubMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
      return shouldKeepMethod(access, name)? null : myNodes.computeIfAbsent(getKey(name, descriptor), k -> new AbiMethod(access, name, descriptor, signature, exceptions));
    }

    @Override
    public Collection<MethodNode> getMethods() {
      return Collections.unmodifiableCollection(myNodes.values());
    }

    private static @NotNull String getKey(String name, String descriptor) {
      return name + descriptor;
    }

    private static boolean shouldKeepMethod(int access, String name) {
      return isSynthetic(access) || isAbiVisible(access) && ourEnumMethodsToKeep.contains(name) || isConstructor(name);
    }

    private static boolean isConstructor(String name) {
      return "<init>".equals(name) || "<clinit>".equals(name);
    }
  }
  
}
