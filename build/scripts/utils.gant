/*
 * Copyright 2000-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



import com.intellij.openapi.util.SystemInfo
import com.intellij.openapi.util.io.FileUtil
import org.jetbrains.jps.gant.JpsGantTool
import org.jetbrains.jps.gant.TeamCityBuildInfoPrinter
import org.jetbrains.jps.model.java.JavaSourceRootType
import org.jetbrains.jps.model.java.JdkVersionDetector
import org.jetbrains.jps.model.java.JpsJavaExtensionService
import org.jetbrains.jps.model.java.JpsJavaSdkType
import org.jetbrains.jps.model.library.JpsOrderRootType
import org.jetbrains.jps.model.module.JpsModule
import org.jetbrains.jps.model.serialization.JpsModelSerializationDataService

includeTool << JpsGantTool

binding.setVariable("p", {String key, String defaultValue = null ->
  try {
    return getProperty(key) as String
  }
  catch (MissingPropertyException e) {
    if (defaultValue != null) {
      return defaultValue
    }
    throw e;
  }
})

binding.setVariable("guessJdk", {
  String javaHome = p("java.home")

  if (new File(javaHome).getName() == "jre") {
    javaHome = new File(javaHome).getParent()
  }

  return javaHome
})

binding.setVariable("includeFile", {String filePath ->
  Script s = groovyShell.parse(new File(filePath))
  s.setBinding(binding)
  s
})

binding.setVariable("isMac", {
  return System.getProperty("os.name").toLowerCase().startsWith("mac")
})

binding.setVariable("isWin", {
  return System.getProperty("os.name").toLowerCase().startsWith("windows")
})

binding.setVariable("isEap", {
  return "true" == p("component.version.eap")
})

binding.setVariable("mem32", "-server -Xms128m -Xmx512m -XX:MaxPermSize=250m -XX:ReservedCodeCacheSize=240m")
binding.setVariable("mem64", "-Xms128m -Xmx750m -XX:MaxPermSize=350m -XX:ReservedCodeCacheSize=240m")
binding.setVariable("common_vmoptions", "-XX:+UseConcMarkSweepGC -XX:SoftRefLRUPolicyMSPerMB=50 -ea " +
                                        "-Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true " +
                                        "-XX:+HeapDumpOnOutOfMemoryError")

binding.setVariable("vmOptions", { "$common_vmoptions".trim() })
binding.setVariable("vmOptions32", { "$mem32 ${vmOptions()}".trim() })
binding.setVariable("vmOptions64", { "$mem64 ${vmOptions()}".trim() })

binding.setVariable("yjpOptions", { String systemSelector, String platformSuffix = "" ->
  "-agentlib:yjpagent$platformSuffix=probe_disable=*,disablealloc,disabletracing,onlylocal,disableexceptiontelemetry,delay=10000,sessionname=$systemSelector".trim()
})
binding.setVariable("vmOptions32yjp", { String systemSelector ->
  "${vmOptions32()} ${yjpOptions(systemSelector)}".trim()
})
binding.setVariable("vmOptions64yjp", { String systemSelector ->
  "${vmOptions64()} ${yjpOptions(systemSelector, "64")}".trim()
})

binding.setVariable("isDefined", {String key ->
  try {
    this[key]
    return true
  }
  catch (MissingPropertyException ignored) {
    return false
  }
})

private String require(String key) {
  try {
    this[key]
  }
  catch (MissingPropertyException ignored) {
    projectBuilder.error("Property '$key' is required")
  }
}

private String require(String key, String defaultValue) {
  try {
    this[key]
  }
  catch (MissingPropertyException ignored) {
    projectBuilder.info("'$key' is not defined. Defaulting to '$defaultValue'")
    this[key] = defaultValue
  }
}

binding.setVariable("requireProperty", {String key, String defaultValue = null ->
  if (defaultValue == null) {
    require(key)
  }
  else {
    require(key, defaultValue)
  }
})

binding.setVariable("guessHome", {
  // current file is supposed to be at build/scripts/*.gant path
  String uri = requireProperty("gant.file")
  new File(new URI(uri).getSchemeSpecificPart()).getParentFile().getParentFile().getParent()
})

binding.setVariable("loadProject", {
  defineJdk("IDEA jdk", setupJdkPath("jdkHome", "$home/build/jdk/1.6", "JDK_16_x64"))
  defineJdk("1.8", setupJdkPath("jdk8Home", "$home/build/jdk/1.8", "JDK_18_x64"))
  def bundledKotlinPath = "$home/build/kotlinc"
  if (!new File(bundledKotlinPath, "lib/kotlin-runtime.jar").exists()) {
    bundledKotlinPath = "$home/community/build/kotlinc"
  }
  if (!new File(bundledKotlinPath, "lib/kotlin-runtime.jar").exists()) {
    projectBuilder.error("Could not find Kotlin runtime at $bundledKotlinPath/lib/kotlin-runtime.jar")
    return
  }
  setPathVariable("KOTLIN_BUNDLED", bundledKotlinPath)
  projectBuilder.buildIncrementally = Boolean.parseBoolean(p("jps.build.incrementally", "false"))
  def dataDirName = projectBuilder.buildIncrementally ? ".jps-incremental-build" : ".jps-build-data"
  projectBuilder.dataStorageRoot = new File("$home/$dataDirName")
  projectBuilder.setupAdditionalLogging(new File("${p("teamcity.build.tempDir", p("java.io.tmpdir"))}/system/build-log/build.log"),
                                        p("jps.build.debug.logging.categories", ""))
  loadProjectFromPath(home)

  def compilerOptions = JpsJavaExtensionService.instance.getOrCreateCompilerConfiguration(project).currentCompilerOptions
  compilerOptions.GENERATE_NO_WARNINGS = true
  compilerOptions.DEPRECATION = false
  compilerOptions.ADDITIONAL_OPTIONS_STRING = compilerOptions.ADDITIONAL_OPTIONS_STRING.replace("-Xlint:unchecked", "")
})

binding.setVariable("removeJdkJarFiles", { Collection<String> classpath ->
  def jdkHomePaths = project.model.global.libraryCollection.getLibraries(JpsJavaSdkType.INSTANCE).collect {
    def homeDir = new File(it.properties.homePath)
    return SystemInfo.isMac && homeDir.name == "Home" ? homeDir.parent : homeDir.absolutePath
  }
  return classpath.findAll { jarPath -> jdkHomePaths.every { !FileUtil.isAncestor(it, jarPath, false) } }
})

private String setupJdkPath(String propertyName, String defaultDir, String envVarName) {
  try {
    this[propertyName]
  }
  catch (MissingPropertyException ignored) {
    def jdk = SystemInfo.isMac ? "$defaultDir/Home" : defaultDir
    if (new File(jdk).exists()) {
      projectBuilder.info("$propertyName set to $jdk")
    }
    else {
      jdk = System.getenv(envVarName)
      if (jdk != null) {
        projectBuilder.info("'$defaultDir' doesn't exist, $propertyName set to '$envVarName' environment variable: $jdk")
      }
      else {
        jdk = guessJdk()
        def version = JdkVersionDetector.instance.detectJdkVersion(jdk)
        if (propertyName.contains("8") && !version.contains("1.8.")) {
          projectBuilder.error("JDK 1.8 is required to compile the project, but '$propertyName' property and '$envVarName' environment variable aren't defined and default JDK $jdk ($version) cannot be used as JDK 1.8")
          return null
        }
        projectBuilder.info("'$envVarName' isn't defined and '$defaultDir' doesn't exist, $propertyName set to $jdk")
      }
    }
    this[propertyName] = jdk
    return jdk
  }
}

private void defineJdk(String jdkName, jdkHomePath) {
  jdk(jdkName, jdkHomePath) {
    def toolsJar = "$jdkHomePath/lib/tools.jar"
    if (new File(toolsJar).exists()) {
      classpath toolsJar
    }
  }

  if (SystemInfo.isMac) {
    //temporary workaround for Mac: resolve symlinks manually. Previously ZipFileCache used FileUtil.toCanonicalPath method which doesn't resolve symlinks.
    def jdk = global.libraryCollection.findLibrary(jdkName, JpsJavaSdkType.INSTANCE)
    def jdkClasspath = jdk.getFiles(JpsOrderRootType.COMPILED)
    def urls = jdk.getRootUrls(JpsOrderRootType.COMPILED)
    urls.each { jdk.removeUrl(it, JpsOrderRootType.COMPILED) }
    jdkClasspath.each {
      try {
        jdk.addRoot(it.getCanonicalFile(), JpsOrderRootType.COMPILED)
      }
      catch (IOException ignored) {
      }
    }
    projectBuilder.info("JDK '$jdkName' classpath: ${jdk.getFiles(JpsOrderRootType.COMPILED)}")
  }
}

private void setPathVariable(String name, String value) {
  def pathVars = JpsModelSerializationDataService.getOrCreatePathVariablesConfiguration(global)
  pathVars.addPathVariable(name, value)
}

binding.setVariable("prepareOutputFolder", {
  def targetFolder = projectBuilder.buildIncrementally ? "$home/out/incremental-build" : out
  projectBuilder.targetFolder = targetFolder
  if (projectBuilder.buildIncrementally && Boolean.parseBoolean(p("jps.build.clear.incremental.caches", "false"))) {
    FileUtil.delete(new File(targetFolder))
    FileUtil.delete(projectBuilder.dataStorageRoot)
  }
})

boolean hasSourceRoots(JpsModule module) {
  return module.getSourceRoots(JavaSourceRootType.SOURCE).iterator().hasNext()
}

binding.setVariable("findModule", {String name ->
  project.modules.find { it.name == name }
})

binding.setVariable("allModules", {
  return project.modules
})

binding.setVariable("printUnusedModules", {Set<String> usedModules ->
  allModules().each {JpsModule m ->
    if (!usedModules.contains(m.name) && hasSourceRoots(m)) {
      projectBuilder.warning("Module $m.name is not used in project layout")
    }
  }
})

requireProperty("home", guessHome())

String readSnapshotBuild() {
  def file = new File("$home/community/build.txt")
  if (!file.exists()) {
    file = new File("$home/build.txt")
  }

  return file.readLines().get(0)
}

binding.setVariable("snapshot", readSnapshotBuild())

projectBuilder.buildInfoPrinter = new TeamCityBuildInfoPrinter()
projectBuilder.compressJars = false

binding.setVariable("notifyArtifactBuilt", { String artifactPath ->
  if (!artifactPath.startsWith(home)) {
    projectBuilder.error("Artifact path $artifactPath should start with $home")
  }
  def relativePath = artifactPath.substring(home.length())
  if (relativePath.startsWith("/")) {
    relativePath = relativePath.substring(1)
  }
  def file = new File(artifactPath)
  if (file.isDirectory()) {
    relativePath += "=>" + file.name
  }
  projectBuilder.info("##teamcity[publishArtifacts '$relativePath']")
})

def debugPort = System.getProperty("debug.port")
def debugSuspend = System.getProperty("rи") ?: "n"
if (debugSuspend == 'y') {
  println """

------------->------------- The process suspended until remote debugger connects to debug port -------------<-------------
---------------------------------------^------^------^------^------^------^------^----------------------------------------

"""
}

binding.setVariable("patchFiles", { List files, Map args, String marker = "__" ->
  files.each { file ->
    args.each { arg ->
      ant.replace(file: file, token: "${marker}${arg.key}${marker}", value:  arg.value)
    }
  }
})

binding.setVariable("copyAndPatchFile", { String file, String target, Map args, String marker = "__" ->
  ant.copy(file: file, tofile: target, overwrite: "true") {
    filterset(begintoken: marker, endtoken: marker) {
      args.each {
        filter(token: it.key, value: it.value)
      }
    }
  }
})

binding.setVariable("copyAndPatchFiles", { Closure files, String target, Map args, String marker = "__" ->
  ant.copy(todir: target, overwrite: "true") {
    files()

    filterset(begintoken: marker, endtoken: marker) {
      args.each {
        filter(token: it.key, value: it.value)
      }
    }
  }
})

binding.setVariable("wireBuildDate", { String buildNumber, String appInfoFile ->
  ant.tstamp()
  patchFiles([appInfoFile], ["BUILD_NUMBER": buildNumber, "BUILD_DATE": DSTAMP])
})

binding.setVariable("commonJvmArgsForTests", {
  def jdwp = "-Xrunjdwp:transport=dt_socket,server=y,suspend=$debugSuspend"
  if (debugPort != null) jdwp += ",address=$debugPort"

  return [
    "-ea",
    "-Dio.netty.leakDetectionLevel=PARANOID",
    "-server",
    "-Xbootclasspath/p:${projectBuilder.moduleOutput(findModule("boot"))}",
    "-XX:+HeapDumpOnOutOfMemoryError",
    "-Didea.home.path=$home",
    "-Didea.config.path=${p("teamcity.build.tempDir")}/config",
    "-Didea.system.path=${p("teamcity.build.tempDir")}/system",
    "-Xdebug",
    jdwp
  ]
})

binding.setVariable("classPathLibs", [
        "bootstrap.jar",
        "extensions.jar",
        "util.jar",
        "jdom.jar",
        "log4j.jar",
        "trove4j.jar",
        "jna.jar"
])

binding.setVariable("platformApiModules", [
  "analysis-api",
  "built-in-server-api",
  "core-api",
  "diff-api",
  "dvcs-api",
  "editor-ui-api",
  "external-system-api",
  "indexing-api",
  "jps-model-api",
  "lang-api",
  "lvcs-api",
  "platform-api",
  "projectModel-api",
  "remote-servers-agent-rt",
  "remote-servers-api",
  "structure-view-api",
  "usageView",
  "vcs-api-core",
  "vcs-api",
  "vcs-log-api",
  "vcs-log-graph-api",
  "xdebugger-api",
  "xml-analysis-api",
  "xml-openapi",
  "xml-psi-api",
  "xml-structure-view-api"
])

binding.setVariable("platformImplementationModules", [
  "analysis-impl",
  "built-in-server",
  "core-impl",
  "diff-impl",
  "dvcs-impl",
  "editor-ui-ex",
  "images",
  "indexing-impl",
  "jps-model-impl",
  "jps-model-serialization",
  "json",
  "lang-impl",
  "lvcs-impl",
  "platform-impl",
  "projectModel-impl",
  "protocol-reader-runtime",
  "RegExpSupport",
  "relaxng",
  "remote-servers-impl",
  "script-debugger-backend",
  "script-debugger-ui",
  "smRunner",
  "spellchecker",
  "structure-view-impl",
  "testRunner",
  "vcs-impl",
  "vcs-log-graph",
  "vcs-log-impl",
  "xdebugger-impl",
  "xml-analysis-impl",
  "xml-psi-impl",
  "xml-structure-view-impl",
  "xml"
])

binding.setVariable("layoutMacApp", { String path, String ch, Map args ->
  ant.copy(todir: "$path/bin") {
    fileset(dir: "$ch/bin/mac")
  }

  ant.copy(todir: path) {
    fileset(dir: "$ch/build/conf/mac/Contents")
  }

  ant.tstamp() {
    format(property: "todayYear", pattern: "yyyy")
  }

  String executable = args.executable != null ? args.executable : p("component.names.product").toLowerCase()
  String helpId = args.help_id != null ? args.help_id : "IJ"
  String icns = "idea.icns"
  String helpIcns = "$path/Resources/${helpId}.help/Contents/Resources/Shared/product.icns"
  if (args.icns != null) {
    ant.delete(file: "$path/Resources/idea.icns")
    ant.copy(file: args.icns, todir: "$path/Resources")
    ant.copy(file: args.icns, tofile: helpIcns)
    icns = new File((String)args.icns).getName();
  } else {
    ant.copy(file: "$path/Resources/idea.icns", tofile: helpIcns)
  }

  String fullName = args.fullName != null ? args.fullName : p("component.names.fullname")

  String vmOptions = "-Dfile.encoding=UTF-8 ${vmOptions()} -Xverify:none"

  String minor = p("component.version.minor")
  String version = isEap() && !minor.contains("RC") && !minor.contains("Beta") ? "EAP $args.buildNumber" : "${p("component.version.major")}.${minor}"
  String EAP = isEap() && !minor.contains("RC") && !minor.contains("Beta") ? "-EAP" : ""

  Map properties = readIdeaProperties(args)

  def coreKeys = ["idea.platform.prefix", "idea.paths.selector", "idea.executable"]

  String coreProperties = submapToXml(properties, coreKeys);

  StringBuilder effectiveProperties = new StringBuilder()
  properties.each { k, v ->
    if (!coreKeys.contains(k)) {
      effectiveProperties.append("$k=$v\n");
    }
  }

  new File("$path/bin/idea.properties").text = effectiveProperties.toString()
  String ideaVmOptions = "$mem64 -XX:+UseCompressedOops"
  if (isEap() && !args.mac_no_yjp) {
    ideaVmOptions += " ${yjpOptions(args.system_selector)}"
  }
  new File("$path/bin/${executable}.vmoptions").text = ideaVmOptions.split(" ").join("\n")

  String classPath = classPathLibs.collect {"\$APP_PACKAGE/Contents/lib/${it}" }.join(":")

  String archs = """
    <key>LSArchitecturePriority</key>
    <array>"""
  (args.archs != null ? args.archs : ["x86_64", "i386"]).each {
    archs += "<string>${it}</string>"
  }
  archs +="</array>\n"
  
  String urlSchemes = ""
  if (args.urlSchemes != null) {
    urlSchemes += """
      <key>CFBundleURLTypes</key>
      <array>
        <dict>
          <key>CFBundleTypeRole</key>
          <string>Editor</string>
          <key>CFBundleURLName</key>
          <string>Stacktrace</string>
          <key>CFBundleURLSchemes</key>
          <array>
"""
    args.urlSchemes.each { scheme ->
      urlSchemes += "            <string>${scheme}</string>"
    }
    urlSchemes += """
          </array>
        </dict>
      </array>
"""
  }

  ant.replace(file: "$path/Info.plist") {
    replacefilter(token: "@@build@@", value: args.buildNumber)
    replacefilter(token: "@@doc_types@@", value: ifNull(args.doc_types, ""))
    replacefilter(token: "@@executable@@", value: executable)
    replacefilter(token: "@@icns@@", value: icns)
    replacefilter(token: "@@bundle_name@@", value: fullName)
    replacefilter(token: "@@product_state@@", value: EAP)
    replacefilter(token: "@@bundle_identifier@@", value: args.bundleIdentifier)
    replacefilter(token: "@@year@@", value: "$todayYear")
    replacefilter(token: "@@version@@", value: version)
    replacefilter(token: "@@vmoptions@@", value: vmOptions)
    replacefilter(token: "@@idea_properties@@", value: coreProperties)
    replacefilter(token: "@@class_path@@", value: classPath)
    replacefilter(token: "@@help_id@@", value: helpId)
    replacefilter(token: "@@url_schemes@@", value: urlSchemes)
    replacefilter(token: "@@archs@@", value: archs)
    replacefilter(token: "@@min_osx@@", value: ifNull(args.min_osx, "10.6"))
  }

  if (executable != "idea") {
    ant.move(file: "$path/MacOS/idea", tofile: "$path/MacOS/$executable")
  }

  ant.replace(file: "$path/bin/inspect.sh") {
    replacefilter(token: "@@product_full@@", value: fullName)
    replacefilter(token: "@@script_name@@", value: executable)
  }
  if (args.inspect_script != null && args.inspect_script != "inspect") {
    ant.move(file: "$path/bin/inspect.sh", tofile: "$path/bin/${args.inspect_script}.sh")
  }

  ant.fixcrlf(srcdir: "$path/bin", includes: "*.sh", eol: "unix")
})

binding.setVariable("winScripts", { String target, String home, String name, Map args ->
  String fullName = args.fullName != null ? args.fullName : p("component.names.fullname")
  String product_uc = args.product_uc != null ? args.product_uc : p("component.names.product").toUpperCase()
  String vm_options = args.vm_options != null ? args.vm_options : "${p("component.names.product").toLowerCase()}.exe"
  if (vm_options.endsWith(".exe")) {
    vm_options = vm_options.replace(".exe", "%BITS%.exe")
  }
  else {
    vm_options = vm_options + "%BITS%"
  }

  String classPath = "SET CLASS_PATH=%IDE_HOME%\\lib\\${classPathLibs[0]}\n"
  classPath += classPathLibs[1..-1].collect {"SET CLASS_PATH=%CLASS_PATH%;%IDE_HOME%\\lib\\${it}"}.join("\n")
  if (args.tools_jar) classPath += "\nSET CLASS_PATH=%CLASS_PATH%;%JDK%\\lib\\tools.jar"

  ant.copy(todir: "$target/bin") {
    fileset(dir: "$home/bin/scripts/win")

    filterset(begintoken: "@@", endtoken: "@@") {
      filter(token: "product_full", value: fullName)
      filter(token: "product_uc", value: product_uc)
      filter(token: "vm_options", value: vm_options)
      filter(token: "isEap", value: isEap())
      filter(token: "system_selector", value: args.system_selector)
      filter(token: "ide_jvm_args", value: ifNull(args.ide_jvm_args, ""))
      filter(token: "class_path", value: classPath)
      filter(token: "script_name", value: name)
    }
  }

  if (name != "idea.bat") {
    ant.move(file: "$target/bin/idea.bat", tofile: "$target/bin/$name")
  }
  if (args.inspect_script != null && args.inspect_script != "inspect") {
    ant.move(file: "$target/bin/inspect.bat", tofile: "$target/bin/${args.inspect_script}.bat")
  }

  ant.fixcrlf(srcdir: "$target/bin", includes: "*.bat", eol: "dos")
})

private ifNull(v, defVal) { v != null ? v : defVal }

binding.setVariable("unixScripts", { String target, String home, String name, Map args ->
  String fullName = args.fullName != null ? args.fullName : p("component.names.fullname")
  String product_uc = args.product_uc != null ? args.product_uc : p("component.names.product").toUpperCase()
  String vm_options = args.vm_options != null ? args.vm_options : p("component.names.product").toLowerCase()

  String classPath = "CLASSPATH=\"\$IDE_HOME/lib/${classPathLibs[0]}\"\n"
  classPath += classPathLibs[1..-1].collect {"CLASSPATH=\"\$CLASSPATH:\$IDE_HOME/lib/${it}\""}.join("\n")
  if (args.tools_jar) classPath += "\nCLASSPATH=\"\$CLASSPATH:\$JDK/lib/tools.jar\""

  ant.copy(todir: "$target/bin") {
    fileset(dir: "$home/bin/scripts/unix")

    filterset(begintoken: "@@", endtoken: "@@") {
      filter(token: "product_full", value: fullName)
      filter(token: "product_uc", value: product_uc)
      filter(token: "vm_options", value: vm_options)
      filter(token: "isEap", value: isEap())
      filter(token: "system_selector", value: args.system_selector)
      filter(token: "ide_jvm_args", value: ifNull(args.ide_jvm_args, ""))
      filter(token: "class_path", value: classPath)
      filter(token: "script_name", value: name)
    }
  }

  if (name != "idea.sh") {
    ant.move(file: "$target/bin/idea.sh", tofile: "$target/bin/$name")
  }
  if (args.inspect_script != null && args.inspect_script != "inspect") {
    ant.move(file: "$target/bin/inspect.sh", tofile: "$target/bin/${args.inspect_script}.sh")
  }

  ant.fixcrlf(srcdir: "$target/bin", includes: "*.sh", eol: "unix")
})

binding.setVariable("winVMOptions", { String target, String system_selector, String name, String name64 = null ->
  if (name != null) {
    def options = isEap() && system_selector != null ? vmOptions32yjp(system_selector) : vmOptions32()
    ant.echo(file: "$target/bin/${name}.vmoptions", message: options.replace(' ', '\n'))
  }

  if (name64 != null) {
    def options = isEap() && system_selector != null ? vmOptions64yjp(system_selector) : vmOptions64()
    ant.echo(file: "$target/bin/${name64}.vmoptions", message: options.replace(' ', '\n'))
  }

  ant.fixcrlf(srcdir: "$target/bin", includes: "*.vmoptions", eol: "dos")
})

binding.setVariable("unixVMOptions", { String target, String name, String name64 = (name + "64") ->
  if (name != null) {
    ant.echo(file: "$target/bin/${name}.vmoptions", message: "${vmOptions32()} -Dawt.useSystemAAFontSettings=lcd".trim().replace(' ', '\n'))
  }
  if (name64 != null) {
    ant.echo(file: "$target/bin/${name64}.vmoptions", message: "${vmOptions64()} -Dawt.useSystemAAFontSettings=lcd".trim().replace(' ', '\n'))
  }
  ant.fixcrlf(srcdir: "$target/bin", includes: "*.vmoptions", eol: "unix")
})

binding.setVariable("unixReadme", { String target, String home, Map args ->
  String fullName = args.fullName != null ? args.fullName : p("component.names.fullname")
  String settings_dir = args.system_selector.replaceFirst("\\d+", "")
  copyAndPatchFile("$home/build/Install-Linux-tar.txt", "$target/Install-Linux-tar.txt",
                   ["product_full": fullName,
                    "product": p("component.names.product").toLowerCase(),
                    "system_selector": args.system_selector,
                    "settings_dir": settings_dir], "@@")
  ant.fixcrlf(file: "$target/bin/Install-Linux-tar.txt", eol: "unix")
})

binding.setVariable("forceDelete", { String dirPath ->
  // if wasn't deleted - retry several times
  attempt = 1
  while (attempt < 21 && (new File(dirPath).exists())) {
    if (attempt > 1) {
      ant.echo "Deleting $dirPath ... (attempt=$attempt)"

      // let's wait a bit and try again - may be help
      // in some cases on our windows 7 agents
      sleep(2000)
    }

    ant.delete(failonerror: false, dir: dirPath)

    attempt++
  }

  if (new File(dirPath).exists()) {
    ant.project.log ("Cannot delete directory: $dirPath" )
    System.exit (1)
  }
})

binding.setVariable("patchPropertiesFile", { String target, Map args = [:] ->
  String file = "$target/bin/idea.properties"

  if (args.appendices != null) {
    ant.concat(destfile: file, append:  true) {
      args.appendices.each {
        fileset(file: it)
      }
    }
  }

  String product_uc = args.product_uc != null ? args.product_uc : p("component.names.product").toUpperCase()
  String settings_dir = args.system_selector.replaceFirst("\\d+", "")
  ant.replace(file: file) {
    replacefilter(token: "@@product_uc@@", value: product_uc)
    replacefilter(token: "@@settings_dir@@", value: settings_dir)
  }

  String message = (isEap() ? """
#-----------------------------------------------------------------------
# Change to 'disabled' if you don't want to receive instant visual notifications
# about fatal errors that happen to an IDE or plugins installed.
#-----------------------------------------------------------------------
idea.fatal.error.notification=enabled
"""
                 : """
#-----------------------------------------------------------------------
# Change to 'enabled' if you want to receive instant visual notifications
# about fatal errors that happen to an IDE or plugins installed.
#-----------------------------------------------------------------------
idea.fatal.error.notification=disabled
""")
  ant.echo(file: file, append: true, message: message)
})

binding.setVariable("zipSources", { String home, String targetDir ->
  String sources = "$targetDir/sources.zip"
  projectBuilder.stage("zip sources to $sources")

  ant.mkdir(dir: targetDir)
  ant.delete(file: sources)
  ant.zip(destfile: sources) {
    fileset(dir: home) {
      ["java", "groovy", "ipr", "iml", "form", "xml", "properties"].each {
        include(name: "**/*.$it")
      }
      exclude(name: "**/testData/**")
    }
  }

  notifyArtifactBuilt(sources)
})

binding.setVariable("zipSourcesOfModules", { String home, String targetFilePath, Collection<String> modules ->
  projectBuilder.stage("zip sources of ${modules.size()} modules to $targetFilePath")

  ant.mkdir(dir: new File(targetFilePath).getParent())
  ant.delete(file: targetFilePath)
  ant.zip(destfile: targetFilePath) {
    modules.each {
      JpsModule module = findModule(it)
      module.getSourceRoots(JavaSourceRootType.SOURCE).flatten().collect {it.file}.each { File srcRoot ->
        zipfileset(prefix: module.name, dir: srcRoot.absolutePath)
      }
    }
  }

  notifyArtifactBuilt(targetFilePath)
})

/**
 * E.g.
 *
 * Load all properties from file:
 *    readIdeaProperties("idea.properties.path" : "$home/ruby/build/idea.properties")
 *
 * Load all properties except "idea.cycle.buffer.size", change "idea.max.intellisense.filesize" to 3000
 * and enable "idea.is.internal" mode:
 *    readIdeaProperties("idea.properties.path" : "$home/ruby/build/idea.properties",
 *                       "idea.properties" : ["idea.max.intellisense.filesize" : 3000,
 *                                           "idea.cycle.buffer.size" : null,
 *                                           "idea.is.internal" : true ])
 * @param args
 * @return text xml properties description in xml
 */
private Map readIdeaProperties(Map args) {
  String ideaPropertiesPath =  args == null ? null : args.get("idea.properties.path")
  if (ideaPropertiesPath == null) {
    return [:]
  }

  // read idea.properties file
  Properties ideaProperties = new Properties();
  FileInputStream ideaPropertiesFile = new FileInputStream(ideaPropertiesPath);
  ideaProperties.load(ideaPropertiesFile);
  ideaPropertiesFile.close();

  def defaultProperties = ["CVS_PASSFILE": "~/.cvspass",
                           "JVMVersion": "1.6+",
                           "com.apple.mrj.application.live-resize": "false",
                           "idea.paths.selector": args.system_selector,
                           "idea.executable": args.executable,
                           "java.endorsed.dirs": "",
                           "idea.smooth.progress": "false",
                           "apple.laf.useScreenMenuBar": "true",
                           "apple.awt.graphics.UseQuartz": "true",
                           "apple.awt.fullscreencapturealldisplays": "false"]
  if (args.platform_prefix != null) {
    defaultProperties.put("idea.platform.prefix", args.platform_prefix)
  }

  Map properties = defaultProperties
  def customProperties = args.get("idea.properties")
  if (customProperties != null) {
    properties += customProperties
  }

  properties.each {k, v ->
    if (v == null) {
      // if overridden with null - ignore property
      ideaProperties.remove(k)
    } else {
      // if property is overridden in args map - use new value
      ideaProperties.put(k, v)
    }
  }

  return ideaProperties;
}

private String submapToXml(Map properties, List keys) {
// generate properties description for Info.plist
  StringBuilder buff = new StringBuilder()

  keys.each { key ->
    String value = properties[key]
    if (value != null) {
      String string =
        """
        <key>$key</key>
        <string>$value</string>
"""
      buff.append(string)
    }
  }
  return buff.toString()
}

private List<File> getChildren(File file) {
  if (!file.isDirectory()) return []
  return file.listFiles().sort { File f -> f.name.toLowerCase() }
}

binding.setVariable("bundledJDKs"){
  requireProperty("jdk16.mac", "true")
  requireProperty("jdk.bundled.win", "1.8")
  requireProperty("jdk.bundled.linux", "false")
  requireProperty("jdk.bundled.mac", "1.8")
  requireProperty("jdk.custom.mac", "true")
  if (new File("${home}/build/jdk").exists()) {
    if (p("jdk.bundled.win") != "false") {
      setProperty("winJDK", getPathToBundledJDK(new File("${home}/build/jdk/win"), "jdk" + p("jdk.bundled.win"), "x32.zip"))
      extractRedistJre(winJDK, "${paths.sandbox}/bundled.win.jdk/jre")
    }
    if (p("jdk.bundled.linux") != "false") {
      setProperty("linuxJDK", getPathToBundledJDK(new File("${home}/build/jdk/linux"), "jdk" + p("jdk.bundled.linux"), ".tar"))
      extractRedistJre(linuxJDK, "${paths.sandbox}/bundled.linux.jdk/jre")
    }
    if (p("jdk.bundled.mac") != "false") {
      setProperty("macJDK", getPathToBundledJDK(new File("${home}/build/jdk/mac"), "jdk" + p("jdk.bundled.mac"), ".tar"))
    }
    def customJdkDir = new File("${home}/build/jdk/custom")
    if (p("jdk.custom.mac") == "true" && (customJdkDir.exists() && customJdkDir.isDirectory())) {
      setProperty("macCustomJDK", getPathToBundledJDK(customJdkDir, "openjdk.1.8", ".tar.gz"))
    }
  }
}

binding.setVariable("getPathToBundledJDK", { File jdkDir, String prefix, String ext ->
  def JdkFileName = ""
  getChildren(jdkDir).each {
    if (it.getName().startsWith(prefix) && it.getName().endsWith(ext)) {
      JdkFileName = it.getAbsolutePath()
      if (ext == ".tar.gz") {
        def OriginalJdkFileName = JdkFileName.substring(0, JdkFileName.length() - 3)
        JdkFileName = JdkFileName.substring(0, JdkFileName.length() - 7) + "_${buildNumber}.tar"
        if (new File(JdkFileName).exists()) { ant.delete(file: JdkFileName) }
        ant.gunzip(src: it.getAbsolutePath())
        ant.copy(file: OriginalJdkFileName, tofile: JdkFileName)
      }
    }
  }
  return JdkFileName.replace('\\', '/')
})

binding.setVariable("buildWinZip", { String zipPath, List paths ->
  projectBuilder.stage(".win.zip")

  fixIdeaPropertiesEol(paths, "dos")

  ant.zip(zipfile: zipPath) {
    paths.each {
      fileset(dir: it)
    }
  }

  notifyArtifactBuilt(zipPath)
})

binding.setVariable("buildCrossPlatformZip", { String zipPath, String sandbox, List commonPaths, String distWin, String distUnix, String distMac ->
  projectBuilder.stage("Building cross-platform zip")

  def zipDir = "$sandbox/cross-platform-zip"
  def ideaPropertiesFile = commonPaths.collect { new File(it, "bin/idea.properties") }.find { it.exists() }
  ["win", "linux"].each {
    ant.mkdir(dir: "$zipDir/bin/$it")
    ant.copy(file: ideaPropertiesFile.absolutePath, todir: "$zipDir/bin/$it")
  }
  ant.fixcrlf(file: "$zipDir/bin/win/idea.properties", eol: "dos")
  ant.copy(todir: "$zipDir/bin/linux") {
    fileset(dir: "$distUnix/bin") {
      include(name: "idea*.vmoptions")
    }
  }
  ant.copy(todir: "$zipDir/bin/mac") {
    fileset(dir: "$distMac/bin") {
      include(name: "idea.vmoptions")
      include(name: "idea.properties")
    }
  }
  ant.copy(file: "$distMac/bin/idea.vmoptions", tofile: "$zipDir/bin/mac/idea64.vmoptions")
  ant.copy(todir: "$zipDir/bin") {
    fileset(dir: "$distMac/bin") {
      include(name: "*.jnilib")
    }
    mapper(type: "glob", from: "*.jnilib", to: "*.dylib")
  }

  ant.zip(zipfile: zipPath, duplicate: "fail") {
    commonPaths.each {
      fileset(dir: it) {
        exclude(name: "bin/idea.properties")
      }
    }
    fileset(dir: zipDir)

    fileset(dir: distWin) {
      exclude(name: "bin/fsnotifier*.exe")
      exclude(name: "bin/idea*.exe.vmoptions")
      exclude(name: "bin/idea*.exe")
    }
    zipfileset(dir: "$distWin/bin", prefix: "bin/win") {
      include(name: "fsnotifier*.exe")
      include(name: "idea*.exe.vmoptions")
    }

    fileset(dir: distUnix) {
      exclude(name: "bin/fsnotifier*")
      exclude(name: "bin/idea*.vmoptions")
      exclude(name: "bin/*.sh")
      exclude(name: "help/**")
    }
    zipfileset(dir: "$distUnix/bin", filemode: "775", prefix: "bin") {
      include(name: "*.sh")
    }
    zipfileset(dir: "$distUnix/bin", prefix: "bin/linux", filemode: "775") {
      include(name: "fsnotifier*")
    }

    fileset(dir: distMac) {
      exclude(name: "bin/fsnotifier*")
      exclude(name: "bin/restarter*")
      exclude(name: "bin/*.sh")
      exclude(name: "bin/*.py")
      exclude(name: "bin/*.jnilib")
      exclude(name: "bin/idea.properties")
      exclude(name: "bin/idea*.vmoptions")
    }
    zipfileset(dir: "$distMac/bin", filemode: "775", prefix: "bin") {
      include(name: "restarter*")
      include(name: "*.py")
    }
    zipfileset(dir: "$distMac/bin", prefix: "bin/mac", filemode: "775") {
      include(name: "fsnotifier*")
    }
  }

  notifyArtifactBuilt(zipPath)
})

binding.setVariable("buildMacZip", { String zipRoot, String zipPath, List paths, String macPath, List extraBins = [] ->
  projectBuilder.stage(".mac.zip")

  allPaths = paths + [macPath]
  ant.zip(zipfile: zipPath) {
    allPaths.each {
      zipfileset(dir: it, prefix: zipRoot) {
        exclude(name: "bin/*.sh")
        exclude(name: "bin/*.py")
        exclude(name: "bin/fsnotifier")
        exclude(name: "bin/restarter")
        exclude(name: "MacOS/*")
        exclude(name: "build.txt")
        exclude(name: "NOTICE.txt")
        extraBins.each {
          exclude(name: it)
        }
        exclude(name: "bin/idea.properties")
      }
    }

    allPaths.each {
      zipfileset(dir: it, filemode: "755", prefix: zipRoot) {
        include(name: "bin/*.sh")
        include(name: "bin/*.py")
        include(name: "bin/fsnotifier")
        include(name: "bin/restarter")
        include(name: "MacOS/*")
        extraBins.each {
          include(name: it)
        }
      }
    }

    allPaths.each {
      zipfileset(dir: it, prefix: "$zipRoot/Resources") {
        include(name: "build.txt")
        include(name: "NOTICE.txt")
      }
    }

    zipfileset(file: "$macPath/bin/idea.properties", prefix: "$zipRoot/bin")
  }
})

binding.setVariable("buildTarGz", { String tarRoot, String tarPath, List paths, List extraBins = [] ->
  projectBuilder.stage(".tar.gz")

  fixIdeaPropertiesEol(paths, "unix")

  ant.tar(tarfile: tarPath, longfile: "gnu") {
    paths.each {
      tarfileset(dir: it, prefix: tarRoot) {
        exclude(name: "bin/*.sh")
        exclude(name: "bin/fsnotifier*")
        extraBins.each {
          exclude(name: it)
        }
        type(type: "file")
      }
    }

    paths.each {
      tarfileset(dir: it, filemode: "755", prefix: tarRoot) {
        include(name: "bin/*.sh")
        include(name: "bin/fsnotifier*")
        extraBins.each {
          include(name: it)
        }
        type(type: "file")
      }
    }
  }

  String gzPath = "${tarPath}.gz"
  ant.gzip(src: tarPath, zipfile: gzPath)
  ant.delete(file: tarPath)
  notifyArtifactBuilt(gzPath)
})

binding.setVariable("extractRedistJre", { String jdk_file_name, String destination  ->
  def jre_redist = "${destination}"
  ant.mkdir(dir: jre_redist)
  if (jdk_file_name.endsWith(".tar")) {
    ant.untar(dest: jre_redist, src: "${jdk_file_name}")
  }
  else {
    ant.unzip(dest: jre_redist, src: "${jdk_file_name}")
  }
})

private void fixIdeaPropertiesEol(List paths, String eol) {
  paths.each {
    String file = "$it/bin/idea.properties"
    if (new File(file).exists()) {
      ant.fixcrlf(file: file, eol: eol)
    }
  }
}

binding.setVariable("buildWinLauncher", { String ch, String inputPath, String outputPath, String appInfo,
                                          String launcherProperties, String pathsSelector, List resourcePaths ->
  projectBuilder.stage("winLauncher")

  if (pathsSelector != null) {
    def paths = getProperty("paths")
    def launcherPropertiesTemp = "${paths.sandbox}/launcher.properties"
    copyAndPatchFile(launcherProperties, launcherPropertiesTemp, ["PRODUCT_PATHS_SELECTOR": pathsSelector,
                                                                  "IDE-NAME": p("component.names.product").toUpperCase()])
    launcherProperties = launcherPropertiesTemp
  }

  ant.java(classname: "com.pme.launcher.LauncherGeneratorMain", fork: "true", failonerror: "true") {
    sysproperty(key: "java.awt.headless", value: "true")
    arg(value: inputPath)
    arg(value: appInfo)
    arg(value: "$ch/native/WinLauncher/WinLauncher/resource.h")
    arg(value: launcherProperties)
    arg(value: outputPath)
    classpath {
      pathelement(location: "$ch/build/lib/launcher-generator.jar")
      fileset(dir: "$ch/lib") {
        include(name: "guava*.jar")
        include(name: "jdom.jar")
        include(name: "sanselan*.jar")
      }
      resourcePaths.each {
        pathelement(location: it)
      }
    }
  }
})

binding.setVariable("collectUsedJars", { List modules, List approvedJars, List forbiddenJars, List modulesToBuild ->
  def usedJars = new HashSet();

  modules.each {
    def module = findModule(it)
    if (module != null) {
      projectBuilder.moduleRuntimeClasspath(module, false).each {
        File file = new File(it)
        if (file.exists()) {
          String path = file.canonicalPath.replace('\\', '/')
          if (path.endsWith(".jar") && approvedJars.any { path.startsWith(it) } && !forbiddenJars.any { path.contains(it) }) {
            if (usedJars.add(path)) {
              projectBuilder.info("\tADDED: $path for ${module.getName()}")
            }
          }
        }
      }
      if (modulesToBuild != null) {
        modulesToBuild << module
      }
    }
    else {
      projectBuilder.warning("$it is not a module")
    }
  }

  return usedJars
})

binding.setVariable("buildModulesAndCollectUsedJars", { List modules, List approvedJars, List forbiddenJars ->
  def modulesToBuild = []
  def usedJars = collectUsedJars(modules, approvedJars, forbiddenJars, modulesToBuild)
  projectBuilder.cleanOutput()
  projectBuilder.buildModules(modulesToBuild)

  return usedJars
})

binding.setVariable("buildSearchableOptions", { String target, List licenses, Closure cp, String jvmArgs = null,
                                                def paths = getProperty("paths") ->
  projectBuilder.stage("Building searchable options")

  String targetFile = "${target}/searchableOptions.xml"
  ant.delete(file: targetFile)

  licenses.each {
    ant.copy(file: it, todir: paths.ideaSystem)
  }

  ant.path(id: "searchable.options.classpath") { cp() }
  String classpathFile = "${paths.sandbox}/classpath.txt"
  ant.echo(file: classpathFile, append: false, message: "\${toString:searchable.options.classpath}")
  ant.replace(file: classpathFile, token: File.pathSeparator, value: "\n")

  ant.java(classname: "com.intellij.rt.execution.CommandLineWrapper", fork: true, failonerror: true) {
    jvmarg(line: "-ea -Xmx500m -XX:MaxPermSize=200m")
    jvmarg(value: "-Xbootclasspath/a:${projectBuilder.moduleOutput(findModule("boot"))}")
    jvmarg(value: "-Didea.home.path=${home}")
    jvmarg(value: "-Didea.system.path=${paths.ideaSystem}")
    jvmarg(value: "-Didea.config.path=${paths.ideaConfig}")
    if (jvmArgs != null) {
      jvmarg(line: jvmArgs)
    }

    arg(value: "${classpathFile}")
    arg(line: "com.intellij.idea.Main traverseUI")
    arg(value: "${target}/searchableOptions.xml")

    classpath() {
      pathelement(location: "${projectBuilder.moduleOutput(findModule("java-runtime"))}")
    }
  }

  ant.available(file: targetFile, property: "searchable.options.exists");
  ant.fail(unless: "searchable.options.exists", message: "Searchable options were not built.")
})

binding.setVariable("reassignAltClickToMultipleCarets", {String communityHome ->
  String defaultKeymapContent = new File("$communityHome/platform/platform-resources/src/idea/Keymap_Default.xml").text
  defaultKeymapContent = defaultKeymapContent.replace("<mouse-shortcut keystroke=\"alt button1\"/>", "")
  defaultKeymapContent = defaultKeymapContent.replace("<mouse-shortcut keystroke=\"alt shift button1\"/>",
                                                      "<mouse-shortcut keystroke=\"alt button1\"/>")
  patchedKeymapFile = new File("${paths.sandbox}/classes/production/platform-resources/idea/Keymap_Default.xml")
  patchedKeymapFile.write(defaultKeymapContent)
})

// modules used in Upsource and in Kotlin as an API to IDEA
binding.setVariable("analysisApiModules", [
    "analysis-api",
    "boot",
    "core-api",
    "duplicates-analysis",
    "editor-ui-api",
    "editor-ui-ex",
    "extensions",
    "indexing-api",
    "java-analysis-api",
    "java-indexing-api",
    "java-psi-api",
    "java-structure-view",
    "jps-model-api",
    "jps-model-serialization",
    "projectModel-api",
    "structure-view-api",
    "util",
    "util-rt",
    "xml-analysis-api",
    "xml-psi-api",
    "xml-structure-view-api",
])
binding.setVariable("analysisImplModules", [
    "analysis-impl",
    "core-impl",
    "indexing-impl",
    "java-analysis-impl",
    "java-indexing-impl",
    "java-psi-impl",
    "projectModel-impl",
    "structure-view-impl",
    "xml-analysis-impl",
    "xml-psi-impl",
    "xml-structure-view-impl",
])
