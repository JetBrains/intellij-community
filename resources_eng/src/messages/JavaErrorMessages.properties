# @interface (annotation) related messages
annotation.unknown.method=Cannot resolve method ''{0}''
annotation.missing.method=Cannot find method ''{0}''
annotation.incompatible.types=Incompatible types. Found: ''{0}'', required: ''{1}''
annotation.illegal.array.initializer=Illegal initializer for ''{0}''
annotation.duplicate.annotation=Duplicate annotation
annotation.duplicate.attribute=Duplicate attribute ''{0}''
annotation.missing.attribute={0} missing though required
annotation.not.applicable=@''{0}'' not applicable to {1}
annotation.nonconstant.attribute.value=Attribute value must be constant
annotation.invalid.annotation.member.type=Invalid type for annotation member
annotation.cyclic.element.type=Cyclic annotation element type
annotation.annotation.type.expected=Annotation type expected
annotation.members.may.not.have.throws.list=@interface members may not have throws list
annotation.may.not.have.extends.list=@interface may not have extends list

# These aren't unused.
annotation.target.ANNOTATION_TYPE=annotation type
annotation.target.TYPE=type
annotation.target.CONSTRUCTOR=constructor
annotation.target.METHOD=method
annotation.target.FIELD=field
annotation.target.PARAMETER=parameter
annotation.target.LOCAL_VARIABLE=local variable
annotation.target.PACKAGE=package

# generics related messages
generics.holder.type=Type
generics.holder.method=Method

generics.are.not.supported=Generics are not supported at this language level
generics.inferred.type.for.type.parameter.is.not.within.its.bound.extend=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should extend ''{1}''
generics.inferred.type.for.type.parameter.is.not.within.its.bound.implement=Inferred type ''{2}'' for type parameter ''{0}'' is not within its bound; should implement ''{1}''
generics.type.parameter.is.not.within.its.bound.extend=Type parameter ''{0}'' is not within its bound; should extend ''{1}''
generics.type.parameter.is.not.within.its.bound.implement=Type parameter ''{0}'' is not within its bound; should implement ''{1}''

# {0} - Type (class) or Method
generics.type.or.method.does.not.have.type.parameters={0} ''{1}'' does not have type parameters
generics.wrong.number.of.type.arguments=Wrong number of type arguments: {0}; required: {1}
generics.cannot.be.inherited.with.different.type.arguments=''{0}'' cannot be inherited with different type arguments: ''{1}'' and ''{2}''
generics.methods.have.same.erasure={0}; both methods have same erasure.
generics.methods.have.same.erasure.override={0}; both methods have same erasure, yet neither overrides the other
generics.type.parameter.cannot.be.instantiated=Type parameter ''{0}'' cannot be instantiated directly
wildcard.type.cannot.be.instantiated=Wildcard type ''{0}'' cannot be instantiated directly
generics.wildcard.not.expected=No wildcard expected
generics.wildcards.may.be.used.only.as.reference.parameters=Wildcards may be used only as reference parameters
generics.type.argument.cannot.be.of.primitive.type=Type argument cannot be of primitive type
generics.unchecked.assignment=Unchecked assignment: ''{0}'' to ''{1}''
generics.unchecked.cast=Unchecked cast: ''{0}'' to ''{1}''
generics.unchecked.call.to.member.of.raw.type=Unchecked call to ''{0}'' as a member of raw type ''{1}''
foreach.not.applicable=foreach not applicable to type ''{0}''.
illegal.to.access.static.member.from.enum.constructor.or.instance.initializer=It is illegal to access static member ''{0}'' from enum constructor or instance initializer
enum.types.cannot.be.instantiated=Enum types cannot be instantiated
generic.array.creation=Generic array creation
generics.enum.may.not.have.type.parameters=Enum may not have type parameters
generics.annotation.members.may.not.have.type.parameters=@interface members may not have type parameters
annotation.may.not.have.type.parameters=@interface may not have type parameters
generics.duplicate.type.parameter=Duplicate type parameter: ''{0}''
generics.cannot.catch.type.parameters=Cannot catch type parameters
generics.cannot.instanceof.type.parameters=Class or array expected
illegal.generic.type.for.instanceof=Illegal generic type for instanceof
cannot.select.dot.class.from.type.variable=Cannot select from a type variable
override.annotation.violated=Method does not override method from its superclass
call.to.super.is.not.allowed.in.enum.constructor=Call to super is not allowed in enum constructor
vararg.not.last.parameter=Vararg parameter must be the last in the list
modifiers.for.enum.constants=No modifiers allowed for enum constants
generics.type.arguments.on.raw.type=Type arguments given on a raw type
generics.type.arguments.on.raw.method=Type arguments given on a raw method
classes.extends.enum=Classes cannot directly extend 'java.lang.Enum'
unchecked.overriding.incompatible.return.type=Unchecked overriding: return type requires unchecked conversion. Found ''{0}'', required ''{1}''
unchecked.overriding=Unchecked overriding
local.enum=Enum must not be local

aspectj.abstract.pointcut.definition.should.not.have.pointcut.designator=Abstract pointcut definition should not have pointcut designator
aspectj.should.have.a.pointcut.designator.or.declare.abstract=Should have a pointcut designator, or declare abstract
aspectj.pointcut.overrides.final.one=Pointcut overrides final one
aspectj.verification.introduction.no.message=<no message>
aspectj.join.point.is.affected.by.around.advice=This join point is affected by around advice in {0}
aspectj.join.point.is.affected.by.after.advice=This join point is affected by after advice in {0}
aspectj.join.point.is.affected.by.before.advice=This join point is affected by before advice in {0}

interface.expected=Interface expected here
class.expected=No interface expected here
implements.after.interface=No implements clause allowed for interface
static.declaration.in.inner.class=Inner classes cannot have static declarations
class.must.be.abstract=Class ''{0}'' must either be declared abstract or implement abstract method ''{1}'' in ''{2}''
abstract.cannot.be.instantiated=''{0}'' is abstract; cannot be instantiated
duplicate.class.in.other.file=Duplicate class found in the file ''{0}''
duplicate.class=Duplicate class: ''{0}''
public.class.should.be.named.after.file=Class ''{0}'' is public, should be declared in a file named ''{0}.java''
inheritance.from.final.class=Cannot inherit from final ''{0}''
package.name.file.path.mismatch=Package name ''{0}'' does not correspond to the file path ''{1}''
missing.package.statement=Missing package statement: ''{0}''
interface.cannot.be.local=Modifier 'interface' not allowed here
cyclic.inheritance=Cyclic inheritance involving ''{0}''
class.already.imported=''{0}'' is already defined in this compilation unit
class.cannot.extend.multiple.classes=Class cannot extend multiple classes
not.allowed.in.interface=Not allowed in interface
qualified.new.of.static.class=Qualified new of static class
class.name.expected=Class name expected
no.enclosing.instance.in.scope=No enclosing instance of type ''{0}'' is in scope
externalizable.class.should.have.public.constructor=Externalizable class should have public no-args constructor
is.not.an.enclosing.class=''{0}'' is not an enclosing class
cannot.be.referenced.from.static.context=''{0}'' cannot be referenced from a static context
no.default.constructor.available=There is no default constructor available in ''{0}''
missing.return.statement=Missing return statement
unreachable.statement=Unreachable statement
variable.not.initialized=Variable ''{0}'' might not have been initialized
variable.already.assigned=Variable ''{0}'' might already have been assigned to
variable.assigned.in.loop=Variable ''{0}'' might be assigned in loop
assignment.to.final.variable=Cannot assign a value to final variable ''{0}''
variable.must.be.final=Variable ''{0}'' is accessed from within inner class. Needs to be declared final.
initializer.must.be.able.to.complete.normally=Initializer must be able to complete normally
weaker.privileges={0}; attempting to assign weaker access privileges (''{1}''); was ''{2}''
incompatible.return.type=attempting to use incompatible return type
final.method.override=''{0}'' cannot override ''{1}'' in ''{2}''; overridden method is final
overridden.method.does.not.throw={0}; overridden method does not throw ''{1}''
exception.is.never.thrown=Exception ''{0}'' is never thrown in the method
wrong.method.arguments=''{0}'' in ''{1}'' cannot be applied to ''{2}''
method.call.expected=Method call expected
ambiguous.method.call=Ambiguous method call: both ''{0}'' and ''{1}'' match
cannot.resolve.method=Cannot resolve method ''{0}''
missing.method.body=Missing method body, or declare abstract
abstract.method.in.non.abstract.class=Abstract method in non-abstract class
missing.return.type=Invalid method declaration; return type required
duplicate.method=''{0}'' is already defined in ''{1}''
constructor.call.must.be.first.statement=Call to ''{0}'' must be first statement in constructor body
direct.abstract.method.access=Abstract method ''{0}'' cannot be accessed directly
unrelated.overriding.methods.return.types=methods have unrelated return types
overrides.deprecated.method=Overrides deprecated method in ''{0}''
method.has.same.name.as.class=Method should be constructor
recursive.constructor.invocation=Recursive constructor invocation
wrong.constructor.arguments=''{0}'' cannot be applied to ''{1}''
cannot.resolve.constructor=Cannot resolve constructor ''{0}''
invalid.package.annotation.containing.file=Package annotations should be in file package-info.java
repeated.annotation.target=Repeated annotation target

clash.methods.message=''{0}'' clashes with ''{1}''
clash.methods.message.show.classes=''{0}'' in ''{2}'' clashes with ''{1}'' in ''{3}''

# {0} - colspan, {1} - method1, {2} - class1, {3} - method2, {4} - class2
ambigous.method.html.tooltip=\
  <html><body><table border=0>\
  <tr><td colspan={0}>Ambigous method call. Both</td></tr>\
  <tr>{1}<td>in <b>{2}</b>\\&nbsp;and</td></tr>\
  <tr>{3}<td>in <b>{4}</b>\\&nbsp;match.</td></tr>\
  </table></body></html>


# {0} - colspan, {1} - method name, {2} - class name, {3} - formal parameters row, {4} - arguments row
argument.mismatch.html.tooltip=\
  <html><body><table border=0>\
  <tr><td><b>{1}</b></td>{3}<td colspan={0}>in <b>{2}</b>\\&nbsp;cannot be applied</td></tr>\
  <tr><td>to</td>{4}</tr>\
  </table></body></html>

# {0} - left raw type, {1} - required row, {2} - right raw type, {3} - found row
incompatible.types.html.tooltip=\
  <html><body>Incompatible types.<table>\
  <tr><td>Required:</td><td>{0}</td>{1}</tr>\
  <tr><td>Found:</td><td>{2}</td>{3}</tr>\
  </table></body></html>

interface.methods.cannot.have.body=Interface methods cannot have body
abstract.methods.cannot.have.a.body=Abstract methods cannot have a body
native.methods.cannot.have.a.body=Native methods cannot have a body

instance.method.cannot.override.static.method=Instance method ''{0}'' in ''{1}'' cannot override static method ''{2}'' in ''{3}''
static.method.cannot.override.instance.method=Static method ''{0}'' in ''{1}'' cannot override instance method ''{2}'' in ''{3}''
inconvertible.type.cast=Inconvertible types; cannot cast ''{0}'' to ''{1}''
variable.expected=Variable expected
binary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}'',''{2}''
unary.operator.not.applicable=Operator ''{0}'' cannot be applied to ''{1}''
return.outside.method=Return outside method
return.from.void.method=Cannot return a value from a method with void result type
missing.return.value=Missing return value

#{0] - exceptions list (comma separated). {1} - exceptions count in the list
unhandled.exceptions=Unhandled {1, choice, 0#exception|2#exceptions}: {0}
variable.already.defined=Variable ''{0}'' is already defined in the scope
break.outside.switch.or.loop=Break outside switch or loop
continue.outside.loop=Continue outside of loop
not.loop.label=Not a loop label: ''{0}''
incompatible.modifiers=Illegal combination of modifiers: ''{0}'' and ''{1}''
modifier.not.allowed=Modifier ''{0}'' not allowed here
exception.never.thrown.try=Exception ''{0}'' is never thrown in the corresponding try block
not.a.statement=Not a statement
incompatible.types=Incompatible types. Found: ''{1}'', required: ''{0}''
valid.switch.selector.types=byte, char, short or int
dot.expected.after.super.or.this='.' expected

non.static.method.referenced.from.static.context=Non-static method ''{0}'' cannot be referenced from a static context
non.static.variable.referenced.from.static.context=Non-static variable ''{0}'' cannot be referenced from a static context
non.static.class.referenced.from.static.context=Non-static class ''{0}'' cannot be referenced from a static context
private.symbol=''{0}'' has private access in ''{1}''
protected.symbol=''{0}'' has protected access in ''{1}''
package.local.symbol=''{0}'' is not public in ''{1}''. Cannot be accessed from outside package
visibility.access.problem=Cannot access ''{0}'' in ''{1}''
array.type.expected=Array type expected; found: ''{0}''
expression.expected=Expression expected
case.statement.outside.switch=Case statement outside switch
qualified.enum.constant.in.switch=An enum switch case label must be the unqualified name of an enumeration constant
constant.expression.required=Constant expression required
duplicate.default.switch.label=Duplicate default label
duplicate.switch.label=Duplicate label ''{0}''
switch.colon.expected.after.case.label=':' expected

#See JLS 8.3.2.3
illegal.forward.reference=Illegal forward reference

unknown.class=Unknown class: ''{0}''
illegal.type.void=Illegal type: 'void'
member.referenced.before.constructor.called=Cannot reference ''{0}'' before supertype constructor has been called
label.without.statement=Label without statement
duplicate.label=Label ''{0}'' already in use
nonterminated.comment=Unclosed comment
assignment.to.itself=Variable is assigned to itself
exception.already.caught=Exception ''{0}'' has already been caught
statement.must.be.prepended.with.case.label=Statement must be prepended with case label
void.type.is.not.allowed='void' type is not allowed here
single.import.class.conflict=''{0}'' is already defined in a single-type import
numeric.overflow.in.expression=Numeric overflow in expression
static.member.accessed.via.instance.reference=Static member ''{0}.{1}'' accessed via instance reference
unresolved.label=Undefined label: ''{0}''
deprecated.symbol=''{0}'' is deprecated
cannot.resolve.symbol=Cannot resolve symbol ''{0}''
static.imports.prior.15=Static imports are not supported at this language level
foreach.prior.15=Foreach loops are not supported at this language level
class.is.already.defined.in.single.type.import=class ''{0}'' is already defined in a single-type import
method.is.already.defined.in.single.type.import=method ''{0}'' is already defined in a single-type import
field.is.already.defined.in.single.type.import=field ''{0}'' is already defined in a single-type import
annotation.interface.members.may.not.have.parameters=@interface members may not have parameters


#javadoc related messages
name.expected=Name expected
wrong.tag=Wrong tag
tag.is.not.allowed.here=Tag ''{0}'' is not allowed here
missing.return.value.description=Missing return value description


# {0} - declaration type (local variable, field, method etc.), {1} - declaration name.
symbol.is.never.used={0} ''{1}'' is never used
local.variable.is.never.used=Variable ''{0}'' is never used
local.variable.is.not.used.for.reading=Variable ''{0}'' is assigned but never accessed
local.variable.is.not.assigned=Variable ''{0}'' is never assigned
private.field.is.not.used=Private field ''{0}'' is never used
private.field.is.not.used.for.reading=Private field ''{0}'' is assigned but never accessed
private.field.is.not.assigned=Private field ''{0}'' is never assigned
parameter.is.not.used=Parameter ''{0}'' is never used
private.method.is.not.used=Private method ''{0}'' is never used
private.constructor.is.not.used=Private constructor ''{0}'' is never used
private.inner.class.is.not.used=Private inner class ''{0}'' is never used
private.inner.interface.is.not.used=Private inner interface ''{0}'' is never used
type.parameter.is.not.used=Type parameter ''{0}'' is never used
local.class.is.not.used=Local class ''{0}'' is never used
uidesigned.field.is.overwritten.by.generated.code=Field ''{0}'' is overwritten by generated code
uidesigner.bound.field.type.mismatch=Types of GUI component (''{0}'') and bound field (''{1}'') do not match

hexadecimal.numbers.must.contain.at.least.one.hexadecimal.digit=Hexadecimal numbers must contain at least one hexadecimal digit
integer.number.too.large=Integer number too large
long.number.too.large=Long number too large
malformed.floating.point.literal=Malformed floating point literal
illegal.line.end.in.character.literal=Illegal line end in character literal
illegal.escape.character.in.character.literal=Illegal escape character in character literal
too.many.characters.in.character.literal=Too many characters in character literal
empty.character.literal=Empty character literal
illegal.line.end.in.string.literal=Illegal line end in string literal
illegal.escape.character.in.string.literal=Illegal escape character in string literal
floating.point.number.too.large=Floating point number too large
floating.point.number.too.small=Floating point number too small

import.statement.identifier.or.asterisk.expected.=Identifier or '*' expected

javadoc.exception.tag.exception.class.expected=Exception class expected
javadoc.exception.tag.wrong.tag.value=Wrong tag value
javadoc.exception.tag.class.is.not.throwable=Class {0} is not a descendant of Throwable
javadoc.exception.tag.exception.is.not.thrown={0} is not declared to be thrown by method {1}
javadoc.param.tag.paramter.name.expected=Parameter name expected
javadoc.param.tag.type.parameter.name.expected=Type parameter name expected
javadoc.param.tag.type.parameter.gt.expected='>' expected
javadoc.value.tag.jdk15.required=@value tag may not have any arguments when JDK 1.4 or earlier is used
javadoc.value.field.required=@value tag must reference a field
javadoc.value.static.field.required=@value tag must reference a static field
javadoc.value.field.with.initializer.required=@value tag must reference a field with a constant initializer

expected.identifier=Identifier expected
expected.comma.or.semicolon=',' or ';' expected
unexpected.token=Unexpected token
expected.class.or.interface='class' or 'interface' expected
expected.identifier.or.type=Identifier or type expected
expected.rbracket=']' expected
expected.expression=Expression expected
expected.semicolon=';' expected
expected.class.reference=Class reference expected
expected.lparen='(' expected
expected.rparen=')' expected
expected.eq='=' expected
expected.value=Value expected
expected.rbrace='}' expected
expected.lbrace='{' expected
unexpected.identifier=Unexpected identifier
expected.gt='>' expected.
expected.lbrace.or.semicolon='{' or ';' expected
expected.parameter=Parameter expected
expected.type.parameter=Type parameter expected
expected.comma=',' expected
unexpected.tokens.beyond.the.end.of.expression=Unexpected token(s) beyond the end of expression
expected.colon=':' expected
expected.type=Type expected
expected.lbracket='[' expected
expected.lparen.or.lbracket='(' or '[' expected
expected.array.initializer=Array initializer expected
unexpected.tokens=Unexpected tokens
expected.gt.or.comma='>' or ',' expected.
else.without.if='else' without 'if'
catch.without.try='catch' without 'try'
finally.without.try='finally' without 'try'
expected.statement=Statement expected
expected.while='while' expected
expected.catch.or.finally='catch' or 'finally' expected
expected.boolean.expression=Boolean expression expected
error.cannot.resolve=Cannot resolve
error.cannot.resolve.default.message=Cannot resolve symbol ''{0}''
error.cannot.resolve.infix=or
expected.class.or.package=Expected class or package
suspicious.name.assignment=''{0}'' should probably not be assigned to ''{1}''
suspicious.name.parameter=''{0}'' should probably not be passed as parameter ''{1}''
