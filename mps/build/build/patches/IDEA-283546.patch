Index: platform/core-impl/src/com/intellij/ide/plugins/PluginDescriptorLoader.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/platform/core-impl/src/com/intellij/ide/plugins/PluginDescriptorLoader.kt b/platform/core-impl/src/com/intellij/ide/plugins/PluginDescriptorLoader.kt
--- a/platform/core-impl/src/com/intellij/ide/plugins/PluginDescriptorLoader.kt	(revision aa678ccd2da3557cf2315f889b7f098e37591215)
+++ b/platform/core-impl/src/com/intellij/ide/plugins/PluginDescriptorLoader.kt	(date 1638530448155)
@@ -1,5 +1,5 @@
 // Copyright 2000-2021 JetBrains s.r.o. and contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
-@file:Suppress("ReplaceNegatedIsEmptyWithIsNotEmpty")
+@file:Suppress("ReplaceNegatedIsEmptyWithIsNotEmpty", "ReplacePutWithAssignment")
 @file:JvmName("PluginDescriptorLoader")
 @file:ApiStatus.Internal
 package com.intellij.ide.plugins
@@ -20,10 +20,7 @@
 import com.intellij.util.lang.ZipFilePool
 import org.jetbrains.annotations.ApiStatus
 import org.jetbrains.annotations.TestOnly
-import java.io.Closeable
-import java.io.File
-import java.io.IOException
-import java.io.InputStream
+import java.io.*
 import java.net.URL
 import java.nio.charset.StandardCharsets
 import java.nio.file.Files
@@ -42,18 +39,18 @@
 
 internal fun createPluginLoadingResult(buildNumber: BuildNumber?): PluginLoadingResult {
   return PluginLoadingResult(brokenPluginVersions = PluginManagerCore.getBrokenPluginVersions(),
-                             productBuildNumber = { buildNumber ?: PluginManagerCore.getBuildNumber() })
+    productBuildNumber = { buildNumber ?: PluginManagerCore.getBuildNumber() })
 }
 
 @TestOnly
 fun loadDescriptor(file: Path, parentContext: DescriptorListLoadingContext): IdeaPluginDescriptorImpl? {
   return loadDescriptorFromFileOrDir(file = file,
-                                     context = parentContext,
-                                     pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
-                                     isBundled = false,
-                                     isEssential = false,
-                                     isDirectory = Files.isDirectory(file),
-                                     useCoreClassLoader = false)
+    context = parentContext,
+    pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
+    isBundled = false,
+    isEssential = false,
+    isDirectory = Files.isDirectory(file),
+    useCoreClassLoader = false)
 }
 
 internal fun loadForCoreEnv(pluginRoot: Path, fileName: String): IdeaPluginDescriptorImpl? {
@@ -61,23 +58,23 @@
   val parentContext = DescriptorListLoadingContext(disabledPlugins = DisabledPluginsState.disabledPlugins())
   if (Files.isDirectory(pluginRoot)) {
     return loadDescriptorFromDir(file = pluginRoot,
-                                 descriptorRelativePath = "${PluginManagerCore.META_INF}$fileName",
-                                 pluginPath = null,
-                                 context = parentContext,
-                                 isBundled = true,
-                                 isEssential = true,
-                                 pathResolver = pathResolver,
-                                 useCoreClassLoader = false)
+      descriptorRelativePath = "${PluginManagerCore.META_INF}$fileName",
+      pluginPath = null,
+      context = parentContext,
+      isBundled = true,
+      isEssential = true,
+      pathResolver = pathResolver,
+      useCoreClassLoader = false)
   }
   else {
     return loadDescriptorFromJar(file = pluginRoot,
-                                 fileName = fileName,
-                                 pathResolver = pathResolver,
-                                 parentContext = parentContext,
-                                 isBundled = true,
-                                 isEssential = true,
-                                 pluginPath = null,
-                                 useCoreClassLoader = false)
+      fileName = fileName,
+      pathResolver = pathResolver,
+      parentContext = parentContext,
+      isBundled = true,
+      isEssential = true,
+      pluginPath = null,
+      useCoreClassLoader = false)
   }
 }
 
@@ -93,14 +90,14 @@
     val input = Files.readAllBytes(file.resolve(descriptorRelativePath))
     val dataLoader = LocalFsDataLoader(file)
     val raw = readModuleDescriptor(input = input,
-                                   readContext = context,
-                                   pathResolver = pathResolver,
-                                   dataLoader = dataLoader,
-                                   includeBase = null,
-                                   readInto = null,
-                                   locationSource = file.toString())
+      readContext = context,
+      pathResolver = pathResolver,
+      dataLoader = dataLoader,
+      includeBase = null,
+      readInto = null,
+      locationSource = file.toString())
     val descriptor = IdeaPluginDescriptorImpl(raw = raw, path = pluginPath ?: file, isBundled = isBundled, id = null, moduleName = null,
-                                              useCoreClassLoader = useCoreClassLoader)
+      useCoreClassLoader = useCoreClassLoader)
     descriptor.readExternal(raw = raw, pathResolver = pathResolver, context = context, isSub = false, dataLoader = dataLoader)
     descriptor.jarFiles = Collections.singletonList(file)
     return descriptor
@@ -139,15 +136,15 @@
     }
 
     val raw = readModuleDescriptor(input = dataLoader.load("META-INF/$fileName") ?: return null,
-                                   readContext = parentContext,
-                                   pathResolver = pathResolver,
-                                   dataLoader = dataLoader,
-                                   includeBase = null,
-                                   readInto = null,
-                                   locationSource = file.toString())
+      readContext = parentContext,
+      pathResolver = pathResolver,
+      dataLoader = dataLoader,
+      includeBase = null,
+      readInto = null,
+      locationSource = file.toString())
 
     val descriptor = IdeaPluginDescriptorImpl(raw = raw, path = pluginPath ?: file, isBundled = isBundled, id = null, moduleName = null,
-                                              useCoreClassLoader = useCoreClassLoader)
+      useCoreClassLoader = useCoreClassLoader)
     descriptor.readExternal(raw = raw, pathResolver = pathResolver, context = parentContext, isSub = false, dataLoader = dataLoader)
     descriptor.jarFiles = Collections.singletonList(descriptor.pluginPath)
     return descriptor
@@ -176,82 +173,66 @@
   override fun toString() = file.toString()
 }
 
-fun loadDescriptorFromFileOrDir(file: Path,
-                                context: DescriptorListLoadingContext,
-                                pathResolver: PathResolver,
-                                isBundled: Boolean,
-                                isEssential: Boolean,
-                                isDirectory: Boolean,
-                                useCoreClassLoader: Boolean): IdeaPluginDescriptorImpl? {
+fun loadDescriptorFromFileOrDir(
+  file: Path,
+  context: DescriptorListLoadingContext,
+  pathResolver: PathResolver,
+  isBundled: Boolean,
+  isEssential: Boolean,
+  isDirectory: Boolean,
+  useCoreClassLoader: Boolean,
+  isUnitTestMode: Boolean = false
+): IdeaPluginDescriptorImpl? {
   return when {
     isDirectory -> {
-      loadDescriptorFromDir(file = file,
-                            descriptorRelativePath = PluginManagerCore.PLUGIN_XML_PATH,
-                            pluginPath = null,
-                            context = context,
-                            isBundled = isBundled,
-                            isEssential = isEssential,
-                            pathResolver = pathResolver,
-                            useCoreClassLoader = useCoreClassLoader)?.let {
-        return it
-      }
-      loadFromPluginDir(file = file,
-                        parentContext = context,
-                        isBundled = isBundled,
-                        isEssential = isEssential,
-                        useCoreClassLoader = useCoreClassLoader,
-                        pathResolver = pathResolver)
+      loadFromPluginDir(
+        file = file,
+        parentContext = context,
+        isBundled = isBundled,
+        isEssential = isEssential,
+        useCoreClassLoader = useCoreClassLoader,
+        pathResolver = pathResolver,
+        isUnitTestMode = isUnitTestMode,
+      )
     }
     file.fileName.toString().endsWith(".jar", ignoreCase = true) -> {
       loadDescriptorFromJar(file = file,
-                            fileName = PluginManagerCore.PLUGIN_XML,
-                            pathResolver = pathResolver,
-                            parentContext = context,
-                            isBundled = isBundled,
-                            isEssential = isEssential,
-                            pluginPath = null,
-                            useCoreClassLoader = useCoreClassLoader)
+        fileName = PluginManagerCore.PLUGIN_XML,
+        pathResolver = pathResolver,
+        parentContext = context,
+        isBundled = isBundled,
+        isEssential = isEssential,
+        pluginPath = null,
+        useCoreClassLoader = useCoreClassLoader)
     }
     else -> null
   }
 }
 
-// classes + lib/*.jar
-// or
-// lib/*.jar
-private fun loadFromPluginDir(file: Path,
-                              parentContext: DescriptorListLoadingContext,
-                              isBundled: Boolean,
-                              isEssential: Boolean,
-                              useCoreClassLoader: Boolean,
-                              pathResolver: PathResolver): IdeaPluginDescriptorImpl? {
-  val pluginJarFiles = ArrayList<Path>()
-  try {
-    Files.newDirectoryStream(file.resolve("lib")).use { stream ->
-      for (childFile in stream) {
-        val path = childFile.toString()
-        if (path.endsWith(".jar", ignoreCase = true) || path.endsWith(".zip", ignoreCase = true)) {
-          pluginJarFiles.add(childFile)
-        }
-      }
-    }
-  }
-  catch (e: NoSuchFileException) {
-    return null
-  }
+// [META-INF] [classes] lib/*.jar
+private fun loadFromPluginDir(
+  file: Path,
+  parentContext: DescriptorListLoadingContext,
+  isBundled: Boolean,
+  isEssential: Boolean,
+  useCoreClassLoader: Boolean,
+  pathResolver: PathResolver,
+  isUnitTestMode: Boolean = false,
+): IdeaPluginDescriptorImpl? {
+  val pluginJarFiles = ArrayList(resolveArchives(file))
 
   if (!pluginJarFiles.isEmpty()) {
     putMoreLikelyPluginJarsFirst(file, pluginJarFiles)
     val pluginPathResolver = PluginXmlPathResolver(pluginJarFiles)
     for (jarFile in pluginJarFiles) {
       loadDescriptorFromJar(file = jarFile,
-                            fileName = PluginManagerCore.PLUGIN_XML,
-                            pathResolver = pluginPathResolver,
-                            parentContext = parentContext,
-                            isBundled = isBundled,
-                            isEssential = isEssential,
-                            pluginPath = file,
-                            useCoreClassLoader = useCoreClassLoader)?.let {
+        fileName = PluginManagerCore.PLUGIN_XML,
+        pathResolver = pluginPathResolver,
+        parentContext = parentContext,
+        isBundled = isBundled,
+        isEssential = isEssential,
+        pluginPath = file,
+        useCoreClassLoader = useCoreClassLoader)?.let {
         it.jarFiles = pluginJarFiles
         return it
       }
@@ -259,16 +240,24 @@
   }
 
   // not found, ok, let's check classes (but only for unbundled plugins)
-  if (!isBundled) {
+  if (!isBundled
+      || isUnitTestMode) {
     val classesDir = file.resolve("classes")
-    loadDescriptorFromDir(file = classesDir,
-                          descriptorRelativePath = PluginManagerCore.PLUGIN_XML_PATH,
-                          pluginPath = file,
-                          context = parentContext,
-                          isBundled = false,
-                          isEssential = isEssential,
-                          pathResolver = pathResolver,
-                          useCoreClassLoader = useCoreClassLoader)?.let {
+    sequenceOf(
+      classesDir,
+      file,
+    ).firstNotNullOfOrNull {
+      loadDescriptorFromDir(
+        file = it,
+        descriptorRelativePath = PluginManagerCore.PLUGIN_XML_PATH,
+        pluginPath = file,
+        context = parentContext,
+        isBundled = isBundled,
+        isEssential = isEssential,
+        pathResolver = pathResolver,
+        useCoreClassLoader = useCoreClassLoader,
+      )
+    }?.let {
       val classPath = ArrayList<Path>(pluginJarFiles.size + 1)
       classPath.add(classesDir)
       classPath.addAll(pluginJarFiles)
@@ -279,6 +268,21 @@
   return null
 }
 
+private fun resolveArchives(path: Path): List<Path> {
+  return try {
+    Files.newDirectoryStream(path.resolve("lib")).use { stream ->
+      stream.filter {
+        val childPath = it.toString()
+        childPath.endsWith(".jar", ignoreCase = true)
+        || childPath.endsWith(".zip", ignoreCase = true)
+      }
+    }
+  }
+  catch (e: NoSuchFileException) {
+    emptyList()
+  }
+}
+
 /*
  * Sort the files heuristically to load the plugin jar containing plugin descriptors without extra ZipFile accesses.
  * File name preference:
@@ -344,12 +348,12 @@
     val s = t.nextToken()
     val file = Paths.get(s)
     loadDescriptorFromFileOrDir(file = file,
-                                context = context,
-                                pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
-                                isBundled = false,
-                                isEssential = false,
-                                isDirectory = Files.isDirectory(file),
-                                useCoreClassLoader = useCoreClassLoaderForPluginsFromProperty)?.let {
+      context = context,
+      pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
+      isBundled = false,
+      isEssential = false,
+      isDirectory = Files.isDirectory(file),
+      useCoreClassLoader = useCoreClassLoaderForPluginsFromProperty)?.let {
       // plugins added via property shouldn't be overridden to avoid plugin root detection issues when running external plugin tests
       result.add(it, overrideUseIfCompatible = true)
     }
@@ -369,21 +373,21 @@
   }
 
   val context = DescriptorListLoadingContext(isMissingSubDescriptorIgnored = true,
-                                             isMissingIncludeIgnored = isUnitTestMode,
-                                             checkOptionalConfigFileUniqueness = isUnitTestMode || isRunningFromSources,
-                                             disabledPlugins = DisabledPluginsState.disabledPlugins(),
-                                             result = result)
+    isMissingIncludeIgnored = isUnitTestMode,
+    checkOptionalConfigFileUniqueness = isUnitTestMode || isRunningFromSources,
+    disabledPlugins = DisabledPluginsState.disabledPlugins(),
+    result = result)
   context.use {
     loadBundledDescriptorsAndDescriptorsFromDir(context = context,
-                                                customPluginDir = Paths.get(PathManager.getPluginsPath()),
-                                                bundledPluginDir = bundledPluginPath,
-                                                isUnitTestMode = isUnitTestMode,
-                                                isRunningFromSources = isRunningFromSources)
+      customPluginDir = Paths.get(PathManager.getPluginsPath()),
+      bundledPluginDir = bundledPluginPath,
+      isUnitTestMode = isUnitTestMode,
+      isRunningFromSources = isRunningFromSources)
     loadDescriptorsFromProperty(result, context)
     if (isUnitTestMode && result.enabledPluginCount() <= 1) {
       // we're running in unit test mode, but the classpath doesn't contain any plugins; try to load bundled plugins anyway
       ForkJoinPool.commonPool().invoke(LoadDescriptorsFromDirAction(Paths.get(PathManager.getPreInstalledPluginsPath()), context,
-                                                                    isBundled = true))
+        isBundled = true))
     }
   }
   context.result.finishLoading()
@@ -400,7 +404,6 @@
   var activity = StartUpMeasurer.startActivity("platform plugin collecting", ActivityCategory.DEFAULT)
 
   val platformPrefix = PlatformUtils.getPlatformPrefix()
-  // should be the only plugin in lib (only for Ultimate and WebStorm for now)
   val isInDevServerMode = java.lang.Boolean.getBoolean("idea.use.dev.build.server")
   val pathResolver = ClassPathXmlPathResolver(
     classLoader = classLoader,
@@ -409,80 +412,88 @@
   val useCoreClassLoader = pathResolver.isRunningFromSources ||
                            platformPrefix.startsWith("CodeServer") ||
                            java.lang.Boolean.getBoolean("idea.force.use.core.classloader")
+  // should be the only plugin in lib (only for Ultimate and WebStorm for now)
   if ((platformPrefix == PlatformUtils.IDEA_PREFIX || platformPrefix == PlatformUtils.WEB_PREFIX) &&
       (isInDevServerMode || (!isUnitTestMode && !isRunningFromSources))) {
-    val dataLoader = object : DataLoader {
-      override val pool: ZipFilePool
-        get() = throw IllegalStateException("must be not called")
+    loadCoreProductPlugin(data = classLoader.getResourceAsStream(PluginManagerCore.PLUGIN_XML_PATH)!!,
+      context = context,
+      pathResolver = pathResolver,
+      useCoreClassLoader = useCoreClassLoader)
+  }
+  else {
+    val fileName = "${platformPrefix}Plugin.xml"
+    if (classLoader is UrlClassLoader) {
+      classLoader.getResourceAsBytes("${PluginManagerCore.META_INF}$fileName", false)?.let {
+        loadCoreProductPlugin(data = ByteArrayInputStream(it), context, pathResolver, useCoreClassLoader)
+      }
+    }
+    else {
+      classLoader.getResourceAsStream("${PluginManagerCore.META_INF}$fileName")?.let {
+        loadCoreProductPlugin(data = it, context, pathResolver, useCoreClassLoader)
+      }
+    }
+
+    val urlToFilename = collectPluginFilesInClassPath(classLoader)
+    if (!urlToFilename.isEmpty()) {
+      activity = activity.endAndStart("plugin from classpath loading")
+      pool.invoke(LoadDescriptorsFromClassPathAction(urlToFilename = urlToFilename,
+        context = context,
+        pathResolver = pathResolver,
+        useCoreClassLoader = useCoreClassLoader))
+    }
+  }
+
+  activity = activity.endAndStart("plugin from user dir loading")
+  pool.invoke(LoadDescriptorsFromDirAction(customPluginDir, context, isBundled = false))
+  if (bundledPluginDir != null) {
+    activity = activity.endAndStart("plugin from bundled dir loading")
+    pool.invoke(LoadDescriptorsFromDirAction(bundledPluginDir, context, isBundled = true))
+  }
+  activity.end()
+}
+
+private fun loadCoreProductPlugin(data: InputStream,
+                                  context: DescriptorListLoadingContext,
+                                  pathResolver: ClassPathXmlPathResolver,
+                                  useCoreClassLoader: Boolean) {
+  val dataLoader = object : DataLoader {
+    override val pool: ZipFilePool
+      get() = throw IllegalStateException("must be not called")
 
-      override fun load(path: String) = throw IllegalStateException("must be not called")
+    override fun load(path: String) = throw IllegalStateException("must be not called")
 
-      override fun toString() = "product classpath"
-    }
+    override fun toString() = "product classpath"
+  }
 
-    val raw = readModuleDescriptor(input = classLoader.getResourceAsStream(PluginManagerCore.PLUGIN_XML_PATH)!!,
-                                   readContext = context,
-                                   pathResolver = pathResolver,
-                                   dataLoader = dataLoader,
-                                   includeBase = null,
-                                   readInto = null,
-                                   locationSource = null)
-    val descriptor = IdeaPluginDescriptorImpl(raw = raw,
-                                              path = Paths.get(PathManager.getLibPath()),
-                                              isBundled = true,
-                                              id = null,
-                                              moduleName = null,
-                                              useCoreClassLoader = useCoreClassLoader)
-    descriptor.readExternal(raw = raw, pathResolver = pathResolver, context = context, isSub = false, dataLoader = dataLoader)
-    context.result.add(descriptor, overrideUseIfCompatible = false)
-  }
-  else {
-    val urlToFilename = LinkedHashMap<URL, String>()
-    val platformPluginURL = computePlatformPluginUrlAndCollectPluginUrls(classLoader, urlToFilename, platformPrefix)
-    if (!urlToFilename.isEmpty()) {
-      activity = activity.endAndStart("plugin from classpath loading")
-      pool.invoke(LoadDescriptorsFromClassPathAction(urlToFilename = urlToFilename,
-                                                     context = context,
-                                                     platformPluginURL = platformPluginURL,
-                                                     pathResolver = pathResolver,
-        useCoreClassLoader = useCoreClassLoader))
-    }
-  }
-
-  activity = activity.endAndStart("plugin from user dir loading")
-  pool.invoke(LoadDescriptorsFromDirAction(customPluginDir, context, isBundled = false))
-  if (bundledPluginDir != null) {
-    activity = activity.endAndStart("plugin from bundled dir loading")
-    pool.invoke(LoadDescriptorsFromDirAction(bundledPluginDir, context, isBundled = true))
-  }
-  activity.end()
-}
-
-private fun computePlatformPluginUrlAndCollectPluginUrls(loader: ClassLoader,
-                                                         urls: MutableMap<URL, String>,
-                                                         platformPrefix: String?): URL? {
-  var result: URL? = null
-  if (platformPrefix != null) {
-    val fileName = "${platformPrefix}Plugin.xml"
-    loader.getResource("${PluginManagerCore.META_INF}$fileName")?.let {
-      urls.put(it, fileName)
-      result = it
-    }
-  }
-  collectPluginFilesInClassPath(loader, urls)
-  return result
-}
-
-private fun collectPluginFilesInClassPath(loader: ClassLoader, urls: MutableMap<URL, String>) {
+  val raw = readModuleDescriptor(data,
+    readContext = context,
+    pathResolver = pathResolver,
+    dataLoader = dataLoader,
+    includeBase = null,
+    readInto = null,
+    locationSource = null)
+  val descriptor = IdeaPluginDescriptorImpl(raw = raw,
+    path = Paths.get(PathManager.getLibPath()),
+    isBundled = true,
+    id = null,
+    moduleName = null,
+    useCoreClassLoader = useCoreClassLoader)
+  descriptor.readExternal(raw = raw, pathResolver = pathResolver, context = context, isSub = false, dataLoader = dataLoader)
+  context.result.add(descriptor, overrideUseIfCompatible = false)
+}
+
+private fun collectPluginFilesInClassPath(loader: ClassLoader): Map<URL, String> {
+  val urlToFilename = LinkedHashMap<URL, String>()
   try {
     val enumeration = loader.getResources(PluginManagerCore.PLUGIN_XML_PATH)
     while (enumeration.hasMoreElements()) {
-      urls.put(enumeration.nextElement(), PluginManagerCore.PLUGIN_XML)
+      urlToFilename.put(enumeration.nextElement(), PluginManagerCore.PLUGIN_XML)
     }
   }
   catch (e: IOException) {
     LOG.warn(e)
   }
+  return urlToFilename
 }
 
 /**
@@ -497,17 +508,17 @@
 @Throws(IOException::class)
 fun loadDescriptorFromArtifact(file: Path, buildNumber: BuildNumber?): IdeaPluginDescriptorImpl? {
   val context = DescriptorListLoadingContext(isMissingSubDescriptorIgnored = true,
-                                             disabledPlugins = DisabledPluginsState.disabledPlugins(),
-                                             result = createPluginLoadingResult(buildNumber),
-                                             transient = true)
+    disabledPlugins = DisabledPluginsState.disabledPlugins(),
+    result = createPluginLoadingResult(buildNumber),
+    transient = true)
 
   val descriptor = loadDescriptorFromFileOrDir(file = file,
-                                               context = context,
-                                               pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
-                                               isBundled = false,
-                                               isEssential = false,
-                                               isDirectory = false,
-                                               useCoreClassLoader = false)
+    context = context,
+    pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
+    isBundled = false,
+    isEssential = false,
+    isDirectory = false,
+    useCoreClassLoader = false)
   if (descriptor != null || !file.toString().endsWith(".zip")) {
     return descriptor
   }
@@ -519,12 +530,12 @@
       val rootDir = NioFiles.list(outputDir).firstOrNull()
       if (rootDir != null) {
         return loadDescriptorFromFileOrDir(file = rootDir,
-                                           context = context,
-                                           pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
-                                           isBundled = false,
-                                           isEssential = false,
-                                           isDirectory = true,
-                                           useCoreClassLoader = false)
+          context = context,
+          pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
+          isBundled = false,
+          isEssential = false,
+          isDirectory = true,
+          useCoreClassLoader = false)
       }
     }
     catch (ignore: NoSuchFileException) { }
@@ -542,12 +553,12 @@
                    pathResolver: PathResolver): IdeaPluginDescriptorImpl? {
   DescriptorListLoadingContext(disabledPlugins = disabledPlugins).use { context ->
     return loadDescriptorFromFileOrDir(file = file,
-                                       context = context,
-                                       pathResolver = pathResolver,
-                                       isBundled = isBundled,
-                                       isEssential = false,
-                                       isDirectory = Files.isDirectory(file),
-                                       useCoreClassLoader = false)
+      context = context,
+      pathResolver = pathResolver,
+      isBundled = isBundled,
+      isEssential = false,
+      isDirectory = Files.isDirectory(file),
+      useCoreClassLoader = false)
   }
 }
 
@@ -559,12 +570,12 @@
                             pluginsToMigrate: MutableList<IdeaPluginDescriptor?>,
                             incompatiblePlugins: MutableList<IdeaPluginDescriptor?>) {
   val loadingResult = PluginLoadingResult(brokenPluginVersions = brokenPluginVersions ?: PluginManagerCore.getBrokenPluginVersions(),
-                                          productBuildNumber = Supplier { compatibleBuildNumber ?: PluginManagerCore.getBuildNumber() }
+    productBuildNumber = Supplier { compatibleBuildNumber ?: PluginManagerCore.getBuildNumber() }
   )
   val context = DescriptorListLoadingContext(disabledPlugins = emptySet(),
-                                             result = loadingResult,
-                                             isMissingIncludeIgnored = true,
-                                             isMissingSubDescriptorIgnored = true)
+    result = loadingResult,
+    isMissingIncludeIgnored = true,
+    isMissingSubDescriptorIgnored = true)
   val effectiveBundledPluginPath = if (bundledPluginsPath != null || PluginManagerCore.isUnitTestMode) {
     bundledPluginsPath
   }
@@ -572,10 +583,10 @@
     Paths.get(PathManager.getPreInstalledPluginsPath())
   }
   loadBundledDescriptorsAndDescriptorsFromDir(context = context,
-                                              customPluginDir = dir,
-                                              bundledPluginDir = effectiveBundledPluginPath,
-                                              isUnitTestMode = PluginManagerCore.isUnitTestMode,
-                                              isRunningFromSources = PluginManagerCore.isRunningFromSources())
+    customPluginDir = dir,
+    bundledPluginDir = effectiveBundledPluginPath,
+    isUnitTestMode = PluginManagerCore.isUnitTestMode,
+    isRunningFromSources = PluginManagerCore.isRunningFromSources())
   for (descriptor in loadingResult.idMap.values) {
     if (!descriptor.isBundled) {
       if (loadingResult.isBroken(descriptor.pluginId)) {
@@ -595,17 +606,15 @@
 
 @TestOnly
 fun testLoadDescriptorsFromClassPath(loader: ClassLoader): List<IdeaPluginDescriptor> {
-  val urlToFilename = LinkedHashMap<URL, String>()
-  collectPluginFilesInClassPath(loader, urlToFilename)
+  val urlToFilename = collectPluginFilesInClassPath(loader)
   val buildNumber = BuildNumber.fromString("2042.42")!!
   val context = DescriptorListLoadingContext(disabledPlugins = Collections.emptySet(),
-                                             result = PluginLoadingResult(brokenPluginVersions = emptyMap(),
-                                                                          productBuildNumber = Supplier { buildNumber },
-                                                                          checkModuleDependencies = false))
+    result = PluginLoadingResult(brokenPluginVersions = emptyMap(),
+      productBuildNumber = Supplier { buildNumber },
+      checkModuleDependencies = false))
   LoadDescriptorsFromClassPathAction(
     urlToFilename = urlToFilename,
     context = context,
-    platformPluginURL = null,
     pathResolver = ClassPathXmlPathResolver(loader, isRunningFromSources = false),
     useCoreClassLoader = true
   ).compute()
@@ -616,56 +625,42 @@
 private class LoadDescriptorsFromDirAction(private val dir: Path,
                                            private val context: DescriptorListLoadingContext,
                                            private val isBundled: Boolean) : RecursiveAction() {
+
   override fun compute() {
-    val tasks = ArrayList<RecursiveTask<IdeaPluginDescriptorImpl?>>()
     try {
-      Files.newDirectoryStream(dir).use { dirStream ->
-        for (file in dirStream) {
-          tasks.add(object : RecursiveTask<IdeaPluginDescriptorImpl?>() {
+      val tasks: List<RecursiveTask<IdeaPluginDescriptorImpl?>> = Files.newDirectoryStream(dir).use { dirStream ->
+        dirStream.map { file ->
+          object : RecursiveTask<IdeaPluginDescriptorImpl?>() {
             override fun compute(): IdeaPluginDescriptorImpl? {
-              if (Files.isDirectory(file)) {
-                return loadFromPluginDir(file = file,
-                                         parentContext = context,
-                                         isBundled = isBundled,
-                                         isEssential = false,
-                                         pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
-                                         useCoreClassLoader = false)
-              }
-              else if (file.fileName.toString().endsWith(".jar", ignoreCase = true)) {
-                return loadDescriptorFromJar(file = file,
-                                             fileName = PluginManagerCore.PLUGIN_XML,
-                                             pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
-                                             parentContext = context,
-                                             isBundled = isBundled,
-                                             isEssential = false,
-                                             pluginPath = null,
-                                             useCoreClassLoader = false)
-              }
-              else {
-                return null
-              }
-            }
-          })
+              return loadDescriptorFromFileOrDir(
+                file = file,
+                context = context,
+                pathResolver = PluginXmlPathResolver.DEFAULT_PATH_RESOLVER,
+                isBundled = isBundled,
+                isDirectory = Files.isDirectory(file),
+                isEssential = false,
+                useCoreClassLoader = false,
+              )
+            }
+          }
         }
       }
-    }
-    catch (ignore: IOException) {
-      return
-    }
 
-    ForkJoinTask.invokeAll(tasks)
-    for (task in tasks) {
-      task.rawResult?.let {
-        context.result.add(it,  /* overrideUseIfCompatible = */false)
+      ForkJoinTask.invokeAll(tasks)
+      for (task in tasks) {
+        task.rawResult?.let {
+          context.result.add(it,  /* overrideUseIfCompatible = */false)
+        }
       }
     }
+    catch (ignore: IOException) {
+    }
   }
 }
 
 // urls here expected to be a file urls to plugin.xml
 private class LoadDescriptorsFromClassPathAction(private val urlToFilename: Map<URL, String>,
                                                  private val context: DescriptorListLoadingContext,
-                                                 private val platformPluginURL: URL?,
                                                  private val pathResolver: ClassPathXmlPathResolver,
                                                  private val useCoreClassLoader: Boolean) : RecursiveAction() {
   public override fun compute() {
@@ -673,17 +668,12 @@
     urlToFilename.forEach(BiConsumer { url, filename ->
       tasks.add(object : RecursiveTask<IdeaPluginDescriptorImpl?>() {
         override fun compute(): IdeaPluginDescriptorImpl? {
-          val isEssential = url == platformPluginURL
-          try {
-            return loadDescriptorFromResource(resource = url, filename = filename)
+          return try {
+            loadDescriptorFromResource(resource = url, filename = filename)
           }
           catch (e: Throwable) {
-            if (isEssential) {
-              throw e
-            }
-
             LOG.info("Cannot load $url", e)
-            return null
+            null
           }
         }
       })
@@ -732,16 +722,16 @@
       }
 
       val raw = readModuleDescriptor(input = input,
-                                     readContext = context,
-                                     pathResolver = pathResolver,
-                                     dataLoader = dataLoader,
-                                     includeBase = null,
-                                     readInto = null,
-                                     locationSource = file.toString())
+        readContext = context,
+        pathResolver = pathResolver,
+        dataLoader = dataLoader,
+        includeBase = null,
+        readInto = null,
+        locationSource = file.toString())
       // it is very important to not set useCoreClassLoader = true blindly
       // - product modules must uses own class loader if not running from sources
       val descriptor = IdeaPluginDescriptorImpl(raw = raw, path = basePath, isBundled = true, id = null, moduleName = null,
-                                                useCoreClassLoader = useCoreClassLoader)
+        useCoreClassLoader = useCoreClassLoader)
       descriptor.readExternal(raw = raw, pathResolver = pathResolver, context = context, isSub = false, dataLoader = dataLoader)
       // do not set jarFiles by intention - doesn't make sense
       return descriptor
Index: platform/util-class-loader/src/com/intellij/util/lang/UrlClassLoader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/platform/util-class-loader/src/com/intellij/util/lang/UrlClassLoader.java b/platform/util-class-loader/src/com/intellij/util/lang/UrlClassLoader.java
--- a/platform/util-class-loader/src/com/intellij/util/lang/UrlClassLoader.java	(revision aa678ccd2da3557cf2315f889b7f098e37591215)
+++ b/platform/util-class-loader/src/com/intellij/util/lang/UrlClassLoader.java	(date 1638530594275)
@@ -299,6 +299,11 @@
     return resource != null ? resource.getURL() : null;
   }
 
+  public byte @Nullable [] getResourceAsBytes(@NotNull String name, boolean checkParents) throws IOException {
+    Resource resource = classPath.findResource(name);
+    return resource == null ? null : resource.getBytes();
+  }
+
   @Override
   public @Nullable InputStream getResourceAsStream(@NotNull String name) {
     Resource resource = doFindResource(name);
