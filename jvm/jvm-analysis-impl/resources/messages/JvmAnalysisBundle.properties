jvm.inspections.group.name=JVM languages
jvm.inspections.test.frameworks.group.name=Test frameworks

jvm.inspections.unstable.api.usage.display.name=Unstable API Usage
jvm.inspections.unstable.api.usage.annotations.list=Unstable API annotations:
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignore inside imports
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Overridden method ''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Overridden method ''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' is unstable because its signature references unstable {1} ''{2}'' marked with @{3}

jvm.inspections.scheduled.for.removal.future.version=a future version
jvm.inspections.scheduled.for.removal.predefined.version=version {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=Overridden method ''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Overridden method ''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' is scheduled for removal because its signature references {1} ''{2}'' scheduled for removal in {3}

jvm.inspections.unstable.type.used.in.signature.display.name=Unstable type is used in signature
jvm.inspections.unstable.type.used.in.class.signature.description=Class must be marked with ''@{0}'' annotation because its declaration references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=Method must be marked with ''@{0}'' annotation because its signature references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=Field must be marked with ''@{0}'' annotation because its type references unstable type ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Missing '@Deprecated' annotation on scheduled for removal API
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Scheduled for removal API must also be marked with '@Deprecated' annotation
jvm.inspections.must.already.be.removed.api.display.name=API must already be removed
jvm.inspections.must.already.be.removed.api.earlier.version.description=API must have been removed in version {0} but the current version is {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API must be removed in the current version {0}
jvm.inspections.blocking.method.problem.descriptor=Possibly blocking call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.problem.wildcard.descriptor=Possibly blocking call in {0} could lead to thread starvation
jvm.inspections.blocking.method.display.name=Possibly blocking call in non-blocking context
jvm.inspections.blocking.method.annotation.blocking=Blocking Annotations
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking Annotations
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Add blocking annotation
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add non-blocking annotation
jvm.inspections.blocking.method.annotation.configure.empty.text=No annotations added.
jvm.inspections.blocking.method.consider.unknown.context.blocking=Consider unknown contexts blocking
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Consider unknown contexts non-blocking
jvm.inspections.blocking.method.intention.text=Enables the inspection option ''{0}''.

jvm.inspections.api.no.extension.display.name=Class, interface, or method should not be extended
jvm.inspections.api.no.extension.class.description=Class ''{0}'' must not be extended
jvm.inspections.api.no.extension.interface.implement.description=Interface ''{0}'' must not be implemented
jvm.inspections.api.no.extension.interface.extend.description=Interface ''{0}'' must not be extended
jvm.inspections.api.no.extension.method.overriding.description=Method ''{0}'' must not be overridden
jvm.inspections.api.override.only.display.name=Method can only be overridden
jvm.inspections.api.override.only.description=Method ''{0}'' can only be overridden

jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.configure.button.text=Configure dependency rules
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

jvm.inspections.dependency.on.internal.display.name=Illegal dependency on internal package
inspection.message.illegal.dependency.module.doesn.t.export=Illegal dependency: module ''{0}'' doesn''t export package ''{1}''

jvm.inspections.source.to.sink.flow.display.name=Non-safe string is passed to safe method
jvm.inspections.source.to.sink.flow.passed.unsafe=Unsafe string is used as safe parameter
jvm.inspections.source.to.sink.flow.passed.unknown=Unknown string is used as safe parameter
jvm.inspections.source.to.sink.flow.returned.unsafe=Unsafe string is returned from safe method
jvm.inspections.source.to.sink.flow.returned.unknown=Unknown string is returned from safe method
jvm.inspections.source.to.sink.flow.assigned.unsafe=Unsafe string is assigned to safe variable
jvm.inspections.source.to.sink.flow.assigned.unknown=Unknown string is assigned to safe variable
jvm.inspections.source.to.sink.flow.common.unsafe=Unsafe string is used in a safe context
jvm.inspections.source.to.sink.flow.common.unknown=Unknown string is used in a safe context
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Mark as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Mark ''{0}'' as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Mark as Requiring Validation
jvm.inspections.source.unsafe.to.sink.flow.preview.multiple.files=Add ''@Untainted'' annotation in {0}
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Propagate safe annotation
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Propagate safe annotation from ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Opens a tool window to configure the propagation of the safe annotation
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Select Members to Annotate as Safe
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Annotate All except Excluded
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Unsafe flow
propagated.from=Reason to mark as safe:
propagated.to=Target to mark as safe:
propagate.from.empty.text=Reason to mark as safe is shown here
propagate.to.empty.text=Target to mark as safe is shown here

jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code

jvm.inspections.test.method.without.assertion.display.name=Test method without assertions
jvm.inspections.test.method.without.assertion.problem.descriptor=Test method <code>#ref()</code> contains no assertions #loc

jvm.inspections.test.case.with.constructor.display.name=TestCase with non-trivial constructors
jvm.inspections.test.case.with.constructor.problem.descriptor=Initialization logic in constructor <code>#ref()</code> instead of 'setup()' life cycle method #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Initialization logic in initializer instead of 'setup()' life cycle method

jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' is not called from 'finally' block
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code> is not called from 'finally' block #loc

jvm.inspections.junit4.converter.display.name=JUnit 3 test can be JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> could be converted to JUnit4 test case
jvm.inspections.junit4.converter.quickfix.name=Convert to JUnit 4 test case
jvm.inspections.junit4.converter.quickfix.conflict.semantics=Method call {0} may change semantics when {1} is converted to JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=Migration of suite method for {0} has side effects which will be deleted
jvm.inspections.junit4.converter.quickfix.conflict.name=Method {0} will have a name collision with its super method
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=Method call {0} will not compile when {1} is converted to JUnit 4

jvm.inspections.junit5.converter.display.name=JUnit 4 test can be JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref can be JUnit 5 test
jvm.inspections.junit5.converter.quickfix=Migrate to JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=Convert Assertions
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=Class {0} can''t be converted to JUnit 5, cause there are incompatible inheritor(s): {1}

jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 obsolete assertions
jvm.inspections.junit5.assertions.converter.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with a call to a method from ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Replace with ''{0}'' method call
jvm.inspections.junit5.assertions.converter.familyName=Replace with JUnit 5 compatible call

jvm.inspections.unconstructable.test.case.display.name=JUnit unconstructable test case
jvm.inspections.unconstructable.test.case.not.public.descriptor=Test class <code>#ref</code> is not constructable because it is not 'public' #loc
jvm.inspections.unconstructable.test.case.junit3.descriptor=Test class <code>#ref</code> is not constructable because it does not have a 'public' no-arg or single 'String' parameter constructor #loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=Test class <code>#ref</code> is not constructable because it should have exactly one 'public' no-arg constructor #loc

jvm.inspections.test.case.in.product.source.display.name=Test in product source
jvm.inspections.test.case.in.product.source.problem.descriptor=Test case <code>#ref</code> should probably be placed in a test source tree #loc
jvm.inspections.test.method.in.product.source.problem.descriptor=Test method <code>#ref()</code> should probably be placed in a test source tree #loc

jvm.inspections.junit.malformed.declaration.name=JUnit malformed declaration
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignore test parameter if it is annotated by:
jvm.inspections.junit.malformed.no.arg.descriptor=Method <code>#ref</code> should be {0}, {1}{2, choice, 0# and have no parameters|1#, have no parameters and of type void}
jvm.inspections.junit.malformed.annotated.single.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2}
jvm.inspections.junit.malformed.annotated.double.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2} and {3}
jvm.inspections.junit.malformed.annotated.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be of type ''{2}''
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2} and of type ''{3}''
jvm.inspections.junit.malformed.annotated.double.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2}, {3} and of type ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameter ''{1}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameter ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameters {1} and ''{2}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameters {2} and ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameters ''{2}'' and ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameters ''{3}'' and ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameters {3} and ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameters {4} and ''{5}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not be a suspending function
jvm.inspections.junit.malformed.suspend.function.descriptor=Method <code>#ref</code> should not be a suspending function
jvm.inspections.junit.malformed.test.combination.descriptor=Suspicious combination of {0} and ''@{1}''
jvm.inspections.junit.malformed.repetition.number.descriptor=The number of repetitions must be greater than zero
jvm.inspections.junit.malformed.nested.class.descriptor=Class <code>#ref</code> annotated with ''@Nested'' should be {0, choice, 1#{1}|2#{1} and {2}}
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} should be registered at the class level
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=Cannot resolve target method source: ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Multiple parameters have to be wrapped in 'Arguments'
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=Method source ''{0}'' must have one of the following return types: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' or ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=Method source ''{0}'' should have no parameters
jvm.inspections.junit.malformed.param.method.source.static.descriptor=Method source ''{0}'' must be static
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No implicit conversion found to convert ''{0}'' to ''{1}''
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Duplicate 'enum' constant name
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=Can't resolve 'enum' constant reference.
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No value source is defined
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Exactly one type of input must be provided
jvm.inspections.junit.malformed.param.file.source.descriptor=Cannot resolve file source: ''{0}''
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' cannot provide an argument to method because method doesn''t have parameters
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' cannot provide an argument to method because method has an unsupported parameter of ''{1}'' type
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Multiple parameters are not supported by this source
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=No sources are provided, the suite would be empty
jvm.inspections.junit.malformed.fix.class.signature=Fix class signature
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Fix ''{0}'' class signature
jvm.inspections.junit.malformed.fix.method.signature=Fix method signature
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Fix ''{0}'' method signature
jvm.inspections.junit.malformed.fix.field.signature=Fix field signature
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Fix ''{0}'' field signature

jvm.inspections.junit.assertequals.on.array.display.name='assertEquals()' called on array
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code> called on array #loc

jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' may be 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> may be 'assertSame()' #loc

jvm.inspections.junit.ignored.test.display.name=JUnit test annotated with '@Ignore'/'@Disabled'
jvm.inspections.junit.ignored.test.ignore.reason.option=Only report annotations without reason
jvm.inspections.junit.ignored.test.class.problem.descriptor=Test class ''{0}'' is ignored/disabled {1, choice, 1#|2#without reason} #loc
jvm.inspections.junit.ignored.test.method.problem.descriptor=Test method ''{0}()'' is ignored/disabled {1, choice, 1#|2#without reason} #loc

jvm.inspections.migrate.assertion.name=JUnit assertion can be 'assertThat()' call
jvm.inspections.migrate.assert.to.matcher.option=Statically import matcher's methods
jvm.inspections.migrate.assert.to.matcher.description=Assert expression <code>#ref</code> can be replaced with ''{0}'' call #loc

jvm.inspection.test.failed.line.display.name=Failed line in test

jvm.inspections.thread.run.display.name=Call to 'Thread.run()'

jvm.inspections.serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc

jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> called without specifying a Locale using internationalized strings #loc

jvm.inspections.api.display.name=Usages of API which isn't available at the configured language level
assertequals.between.inconvertible.types.display.name='assertEquals()' between objects of inconvertible types
jvm.inspections.1.5.problem.descriptor=Usage of API documented as @since {0}+
jvm.inspections.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
jvm.inspections.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}

jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Redundant assertion: incompatible types are compared ''{0}'' and ''{1}''
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Possibly redundant assertion: incompatible types are compared ''{0}'' and ''{1}''

can.t.build.uast.tree.for.file=Can't build UAST tree for file
title.uast=UAST
current.version=Current version
dialog.title.choose.annotation=Choose {0}
jvm.inspections.dependency.intention.description=Opens a dialog to configure dependency rules between scopes.
