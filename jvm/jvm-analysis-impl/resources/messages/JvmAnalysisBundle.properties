jvm.inspections.group.name=JVM languages
jvm.inspections.test.frameworks.group.name=Test frameworks
jvm.inspections.logging.frameworks.group.name=Logging

jvm.inspections.unstable.api.usage.display.name=Unstable API Usage
jvm.inspections.unstable.api.usage.annotations.list=Unstable API annotations:
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignore inside imports
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Overridden method ''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Overridden method ''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' is unstable because its signature references unstable {1} ''{2}'' marked with @{3}

jvm.inspections.usages.of.obsolete.api.display.name=Usages of ApiStatus.@Obsolete
jvm.inspections.usages.of.obsolete.api.description=Obsolete API is used

jvm.inspections.scheduled.for.removal.future.version=a future version
jvm.inspections.scheduled.for.removal.predefined.version=version {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=Overridden method ''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Overridden method ''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' is scheduled for removal because its signature references {1} ''{2}'' scheduled for removal in {3}

jvm.inspections.unstable.type.used.in.signature.display.name=Unstable type is used in signature
jvm.inspections.unstable.type.used.in.class.signature.description=Class must be marked with ''@{0}'' annotation because its declaration references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=Method must be marked with ''@{0}'' annotation because its signature references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=Field must be marked with ''@{0}'' annotation because its type references unstable type ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Missing '@Deprecated' annotation on scheduled for removal API
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Scheduled for removal API must also be marked with '@Deprecated' annotation
jvm.inspections.must.already.be.removed.api.display.name=API must already be removed
jvm.inspections.must.already.be.removed.api.earlier.version.description=API must have been removed in version {0} but the current version is {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API must be removed in the current version {0}
jvm.inspections.blocking.method.problem.descriptor=Possibly blocking call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.problem.wildcard.descriptor=Possibly blocking call in {0} could lead to thread starvation
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=Possibly blocking call from implicit constructor call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=Possibly blocking call from implict constructor call in {0} could lead to thread starvation
jvm.inspections.blocking.method.display.name=Possibly blocking call in non-blocking context
jvm.inspections.blocking.method.annotation.blocking=Blocking annotations:
jvm.inspections.blocking.method.annotation.non-blocking=Non-blocking annotations:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Add Blocking Annotation
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add Non-Blocking Annotation
jvm.inspections.blocking.method.consider.unknown.context.blocking=Consider unknown contexts blocking
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Consider Kotlin suspend context non-blocking
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Consider unknown contexts non-blocking
jvm.inspections.blocking.method.intention.text=Enables the inspection option ''{0}''.

jvm.inspections.api.no.extension.display.name=Class, interface, or method should not be extended
jvm.inspections.api.no.extension.class.description=Class ''{0}'' must not be extended
jvm.inspections.api.no.extension.interface.implement.description=Interface ''{0}'' must not be implemented
jvm.inspections.api.no.extension.interface.extend.description=Interface ''{0}'' must not be extended
jvm.inspections.api.no.extension.method.overriding.description=Method ''{0}'' must not be overridden
jvm.inspections.api.override.only.display.name=Method can only be overridden
jvm.inspections.api.override.only.description=Method ''{0}'' can only be overridden

jvm.inspections.equals.hashcode.called.on.url.display.name=Call to 'equals()' or 'hashCode()' on 'URL' object
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=Call to ''{0}'' on URL object
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' may contain URL objects #loc

jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

jvm.inspections.dependency.on.internal.display.name=Illegal dependency on internal package
inspection.message.illegal.dependency.module.doesn.t.export=Illegal dependency: module ''{0}'' doesn''t export package ''{1}''

jvm.inspections.source.to.sink.flow.display.name=Non-safe string is passed to safe method
jvm.inspections.source.to.sink.flow.passed.unsafe=Unsafe string is used as safe parameter
jvm.inspections.source.to.sink.flow.passed.unknown=Unknown string is used as safe parameter
jvm.inspections.source.to.sink.flow.returned.unsafe=Unsafe string is returned from safe method
jvm.inspections.source.to.sink.flow.returned.unknown=Unknown string is returned from safe method
jvm.inspections.source.to.sink.flow.assigned.unsafe=Unsafe string is assigned to safe variable
jvm.inspections.source.to.sink.flow.assigned.unknown=Unknown string is assigned to safe variable
jvm.inspections.source.to.sink.flow.common.unsafe=Unsafe string is used in a safe context
jvm.inspections.source.to.sink.flow.common.unknown=Unknown string is used in a safe context
jvm.inspections.source.to.sink.flow.too.complex=Too complex to check that the string is safe in a safe context
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Mark as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Mark elements as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Mark as Requiring Validation
jvm.inspections.source.unsafe.to.sink.flow.preview=Add '@Untainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.config=Untainted annotation will be added to the inspection''s setting for element ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.impossible=Untainted annotation is not supported for element ''{0}''. The element will be skipped
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Show propagation tree
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Propagation tree
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Show propagation tree from here
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Opens a tool window to check the propagation of the safe annotation
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Unsafe Members
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Annotate All except Excluded
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Unsafe flow
propagated.from=Reason of Propagation:
propagated.to=Target to Propagate:
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=Arguments
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=Classes
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=Methods
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Methods to clean qualifiers:
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=These methods mark qualifiers as 'untainted' (Arguments must be split by comma)

jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Untainted parameters:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=These parameters are considered to have '@Untainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Tainted parameters:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=These parameters are considered to have '@Tainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Parameter Index
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=Class Name Of Context
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Method Name Regex Of Context
jvm.inspections.source.unsafe.to.sink.flow.not.number=Not a number
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Tainted annotations:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=These annotations will be used as '@Tainted' annotations during the analysis
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Untainted annotations:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=These annotations will be used as '@Untainted' annotations during the analysis. The first annotation from this list will be used for propagation if it exists in the classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Untainted methods:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=These methods are considered to return only safe objects
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Tainted methods:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=These methods are considered to return only non-safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Untainted fields:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=These fields are considered to contain only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Field Name
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Safe classes:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=These classes can't contain unsafe data
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Consider external methods untainted if receivers and arguments are untainted
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=If it is enabled, then external methods outside the current class will be considered as safe if their receivers and arguments are safe. In some cases, it is not applicable, but it can be useful for stateless classes. Otherwise, all external methods will be considered as unsafe
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex = Report if the case is too complex to check
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object = Report unknown object
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object = Report unsafe object
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment = Report objects, which cannot be checked because of their complexity
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods = Consider parameters of private methods as safe
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment = If it is enabled, then parameters of private methods are considered as safe, otherwise they will be considered as unknown
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Checked types:
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Analysis Depth inside the method:

jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code

jvm.inspections.test.method.without.assertion.display.name=Test method without assertions
jvm.inspections.test.method.without.assertion.problem.descriptor=Test method <code>#ref()</code> contains no assertions #loc

jvm.inspections.test.case.without.test.methods.display.name=Test class without tests
jvm.inspections.test.case.without.test.methods.option=Ignore test cases which have superclasses with test methods
jvm.inspections.test.case.without.test.methods.problem.descriptor=Test class <code>#ref</code> has no tests #loc


jvm.inspections.test.case.with.constructor.display.name=TestCase with non-trivial constructors
jvm.inspections.test.case.with.constructor.problem.descriptor=Initialization logic in constructor <code>#ref()</code> instead of 'setup()' life cycle method #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Initialization logic in initializer instead of 'setup()' life cycle method

jvm.inspections.test.case.in.product.source.display.name=Test in product source
jvm.inspections.test.case.in.product.source.problem.descriptor=Test case <code>#ref</code> should probably be placed in a test source tree #loc
jvm.inspections.test.method.in.product.source.problem.descriptor=Test method <code>#ref()</code> should probably be placed in a test source tree #loc

jvm.inspection.logging.string.template.as.argument.display.name=String template as argument to logging call
jvm.inspection.logging.string.template.as.argument.problem.descriptor=String template as argument to <code>#ref()</code> logging call #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Replace with placeholders
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=Do not warn when only expressions with primitive types, their wrappers or String are included
jvm.inspection.logging.string.template.as.argument.warn.on.label=Warn on:
jvm.inspection.logging.string.template.as.argument.all.levels.option=all log levels
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=warn level and lower
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=info level and lower
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=debug level and lower
jvm.inspection.logging.string.template.as.argument.trace.level.option=trace level

jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=Number of placeholders does not match number of arguments in logging call
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=More arguments provided ({0}) than placeholders specified ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=Fewer arguments provided ({0}) than placeholders specified (at least {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Fewer arguments provided ({0}) than placeholders specified ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Illegal format string specifier #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J uses Log4j 2 as implementation
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Check automatically
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Yes
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=No

jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=Log condition does not match logging call
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=Level of condition ''{0}'' does not match level of logging call ''{1}''

jvm.inspection.test.failed.line.display.name=Failed line in test

jvm.inspections.thread.run.display.name=Call to 'Thread.run()'

jvm.inspections.serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc

jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> called without specifying a Locale using internationalized strings #loc

jvm.inspections.api.display.name=Usages of API which isn't available at the configured language level
assertequals.between.inconvertible.types.display.name='assertEquals()' between objects of inconvertible types
jvm.inspections.1.5.problem.descriptor=Usage of API documented as @since {0}+
jvm.inspections.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
jvm.inspections.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}

jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Redundant assertion: incompatible types are compared ''{0}'' and ''{1}''
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Possibly redundant assertion: incompatible types are compared ''{0}'' and ''{1}''

jvm.inspections.system.get.property.display.name=Call to 'System.getProperty(str)' could be simplified
jvm.inspections.system.get.property.problem.descriptor=Call <code>#ref</code> can be simplified for ''{0}''

can.t.build.uast.tree.for.file=Can't build UAST tree for file
title.uast=UAST
current.version=Current version
dialog.title.choose.annotation=Choose {0}
jvm.inspections.dependency.intention.description=Opens a dialog to configure dependency rules between scopes.

jvm.class.filter.choose.calls=Similar Log Calls:

inspection.suppression.annotation.display.name=Inspection suppression annotation
inspection.suppression.annotation.problem.descriptor=Annotation suppresses {0} #loc
inspection.suppression.comment.problem.descriptor=Comment suppresses {0} #loc
ignored.suppressions=Ignored suppressions:
remove.suppress.comment.fix.family.name=Remove //{0}
allow.suppressions.fix.family.name=Allow suppressions
allow.suppressions.fix.text=Allow these suppressions

group.advanced.settings.jvm=JVM languages
advanced.setting.process.console.output.to.find.class.names=Process terminal output to find class names and highlight them
