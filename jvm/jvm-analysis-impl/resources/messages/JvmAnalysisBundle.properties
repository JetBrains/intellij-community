jvm.inspections.group.name=JVM languages
jvm.inspections.test.frameworks.group.name=Test frameworks
jvm.inspections.logging.frameworks.group.name=Logging

jvm.inspections.unstable.api.usage.display.name=Unstable API Usage
jvm.inspections.unstable.api.usage.annotations.list=Unstable API annotations:
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignore inside imports
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Overridden method ''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Overridden method ''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' is unstable because its signature references unstable {1} ''{2}'' marked with @{3}

jvm.inspections.usages.of.obsolete.api.display.name=Usages of ApiStatus.@Obsolete
jvm.inspections.usages.of.obsolete.api.description=Obsolete API is used

jvm.inspections.scheduled.for.removal.future.version=a future version
jvm.inspections.scheduled.for.removal.predefined.version=version {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=Overridden method ''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Overridden method ''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' is scheduled for removal because its signature references {1} ''{2}'' scheduled for removal in {3}

jvm.inspections.unstable.type.used.in.signature.display.name=Unstable type is used in signature
jvm.inspections.unstable.type.used.in.class.signature.description=Class must be marked with ''@{0}'' annotation because its declaration references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=Method must be marked with ''@{0}'' annotation because its signature references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=Field must be marked with ''@{0}'' annotation because its type references unstable type ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Missing '@Deprecated' annotation on scheduled for removal API
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Scheduled for removal API must also be marked with '@Deprecated' annotation
jvm.inspections.must.already.be.removed.api.display.name=API must already be removed
jvm.inspections.must.already.be.removed.api.earlier.version.description=API must have been removed in version {0} but the current version is {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API must be removed in the current version {0}
jvm.inspections.blocking.method.problem.descriptor=Possibly blocking call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.problem.wildcard.descriptor=Possibly blocking call in {0} could lead to thread starvation
jvm.inspections.blocking.method.in.implicit.ctr.problem.descriptor=Possibly blocking call from implicit constructor call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.in.implicit.ctr.problem.wildcard.descriptor=Possibly blocking call from implict constructor call in {0} could lead to thread starvation
jvm.inspections.blocking.method.display.name=Possibly blocking call in non-blocking context
jvm.inspections.blocking.method.annotation.blocking=Blocking annotations:
jvm.inspections.blocking.method.annotation.non-blocking=Non-blocking annotations:
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Add Blocking Annotation
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add Non-Blocking Annotation
jvm.inspections.blocking.method.consider.unknown.context.blocking=Consider unknown contexts blocking
jvm.inspections.blocking.method.consider.suspend.context.non.blocking=Consider Kotlin suspend context non-blocking
jvm.inspections.blocking.method.consider.unknown.context.nonblocking=Consider unknown contexts non-blocking
jvm.inspections.blocking.method.intention.text=Enables the inspection option ''{0}''.

jvm.inspections.api.no.extension.display.name=Class, interface, or method should not be extended
jvm.inspections.api.no.extension.class.description=Class ''{0}'' must not be extended
jvm.inspections.api.no.extension.interface.implement.description=Interface ''{0}'' must not be implemented
jvm.inspections.api.no.extension.interface.extend.description=Interface ''{0}'' must not be extended
jvm.inspections.api.no.extension.method.overriding.description=Method ''{0}'' must not be overridden
jvm.inspections.api.override.only.display.name=Method can only be overridden
jvm.inspections.api.override.only.description=Method ''{0}'' can only be overridden

jvm.inspections.equals.hashcode.called.on.url.display.name=Call to 'equals()' or 'hashCode()' on 'URL' object
jvm.inspections.equals.hashcode.called.on.url.problem.descriptor=Call to ''{0}'' on URL object
jvm.inspections.collection.contains.url.problem.descriptor=''{0}'' may contain URL objects #loc

jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

jvm.inspections.dependency.on.internal.display.name=Illegal dependency on internal package
inspection.message.illegal.dependency.module.doesn.t.export=Illegal dependency: module ''{0}'' doesn''t export package ''{1}''

jvm.inspections.source.to.sink.flow.display.name=Non-safe string is passed to safe method
jvm.inspections.source.to.sink.flow.passed.unsafe=Unsafe string is used as safe parameter
jvm.inspections.source.to.sink.flow.passed.unknown=Unknown string is used as safe parameter
jvm.inspections.source.to.sink.flow.returned.unsafe=Unsafe string is returned from safe method
jvm.inspections.source.to.sink.flow.returned.unknown=Unknown string is returned from safe method
jvm.inspections.source.to.sink.flow.assigned.unsafe=Unsafe string is assigned to safe variable
jvm.inspections.source.to.sink.flow.assigned.unknown=Unknown string is assigned to safe variable
jvm.inspections.source.to.sink.flow.common.unsafe=Unsafe string is used in a safe context
jvm.inspections.source.to.sink.flow.common.unknown=Unknown string is used in a safe context
jvm.inspections.source.to.sink.flow.too.complex=Too complex to check that the string is safe in a safe context
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Mark as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Mark elements as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Mark as Requiring Validation
jvm.inspections.source.unsafe.to.sink.flow.preview=Add '@Untainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.config=Untainted annotation will be added to the inspection''s setting for element ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.impossible=Untainted annotation is not supported for element ''{0}''. The element will be skipped
jvm.inspections.source.unsafe.to.sink.flow.preview.propagate=Show propagation tree
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Propagation tree
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Show propagation tree from here
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.preview=Opens a tool window to check the propagation of the safe annotation
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Unsafe Members
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Annotate All except Excluded
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Unsafe flow
propagated.from=Reason of Propagation:
propagated.to=Target to Propagate:
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.arguments=Arguments
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.classes=Classes
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.methods=Methods
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.table=Methods to clean qualifiers:
jvm.inspections.source.unsafe.to.sink.flow.qualifier.cleaner.comment=These methods mark qualifiers as 'untainted' (Arguments must be split by comma)

jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters=Untainted parameters:
jvm.inspections.source.unsafe.to.sink.flow.untainted.parameters.comment=These parameters are considered to have '@Untainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters=Tainted parameters:
jvm.inspections.source.unsafe.to.sink.flow.tainted.parameters.comment=These parameters are considered to have '@Tainted' annotation
jvm.inspections.source.unsafe.to.sink.flow.index.parameter=Parameter Index
jvm.inspections.source.unsafe.to.sink.flow.place.class.column.title=Class Name Of Context
jvm.inspections.source.unsafe.to.sink.flow.place.method.column.title=Method Name Regex Of Context
jvm.inspections.source.unsafe.to.sink.flow.not.number=Not a number
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations=Tainted annotations:
jvm.inspections.source.unsafe.to.sink.flow.tainted.annotations.comment=These annotations will be used as '@Tainted' annotations during the analysis
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations=Untainted annotations:
jvm.inspections.source.unsafe.to.sink.flow.untainted.annotations.comment=These annotations will be used as '@Untainted' annotations during the analysis. The first annotation from this list will be used for propagation if it exists in the classpath.
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods=Untainted methods:
jvm.inspections.source.unsafe.to.sink.flow.untainted.methods.comment=These methods are considered to return only safe objects
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods=Tainted methods:
jvm.inspections.source.unsafe.to.sink.flow.tainted.methods.comment=These methods are considered to return only non-safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields=Untainted fields:
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.comment=These fields are considered to contain only safe objects
jvm.inspections.source.unsafe.to.sink.flow.untainted.fields.name=Field Name
jvm.inspections.source.unsafe.to.sink.flow.safe.class=Safe classes:
jvm.inspections.source.unsafe.to.sink.flow.safe.class.comment=These classes can't contain unsafe data
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments=Consider external methods untainted if receivers and arguments are untainted
jvm.inspections.source.unsafe.to.sink.flow.untainted.process.as.qualifier.arguments.comment=If it is enabled, then external methods outside the current class will be considered as safe if their receivers and arguments are safe. In some cases, it is not applicable, but it can be useful for stateless classes. Otherwise, all external methods will be considered as unsafe
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex = Report if the case is too complex to check
jvm.inspections.source.unsafe.to.sink.flow.show.unknown.object = Report unknown object
jvm.inspections.source.unsafe.to.sink.flow.show.unsafe.object = Report unsafe object
jvm.inspections.source.unsafe.to.sink.flow.check.warn.if.complex.comment = Report objects, which cannot be checked because of their complexity
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods = Consider parameters of private methods as safe
jvm.inspections.source.unsafe.to.sink.flow.check.private.methods.comment = If it is enabled, then parameters of private methods are considered as safe, otherwise they will be considered as unknown
jvm.inspections.source.unsafe.to.sink.flow.checked.types=Checked types:
jvm.inspections.source.unsafe.to.sink.flow.depth.inside=Analysis Depth inside the method:

jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code

jvm.inspections.test.method.without.assertion.display.name=Test method without assertions
jvm.inspections.test.method.without.assertion.problem.descriptor=Test method <code>#ref()</code> contains no assertions #loc

jvm.inspections.test.case.without.test.methods.display.name=Test class without tests
jvm.inspections.test.case.without.test.methods.option=Ignore test cases which have superclasses with test methods
jvm.inspections.test.case.without.test.methods.problem.descriptor=Test class <code>#ref</code> has no tests #loc


jvm.inspections.test.case.with.constructor.display.name=TestCase with non-trivial constructors
jvm.inspections.test.case.with.constructor.problem.descriptor=Initialization logic in constructor <code>#ref()</code> instead of 'setup()' life cycle method #loc
jvm.inspections.test.case.with.constructor.problem.descriptor.initializer=Initialization logic in initializer instead of 'setup()' life cycle method

jvm.inspections.junit3.super.teardown.display.name=JUnit 3 'super.tearDown()' is not called from 'finally' block
jvm.inspections.junit3.super.teardown.problem.descriptor=<code>#ref()</code> is not called from 'finally' block #loc

jvm.inspections.junit.mixed.annotations.name=JUnit API usage from multiple versions in a single TestCase
jvm.inspections.junit.mixed.annotations.junit.descriptor=Method <code>#ref()</code> annotated with ''@{0}'' inside class extending JUnit {1} TestCase #loc

jvm.inspections.junit4.converter.display.name=JUnit 3 test can be JUnit 4
jvm.inspections.junit4.converter.problem.descriptor=<code>#ref</code> could be converted to JUnit4 test case
jvm.inspections.junit4.converter.quickfix.name=Convert to JUnit 4 test case
jvm.inspections.junit4.converter.quickfix.conflict.semantics=Method call {0} may change semantics when {1} is converted to JUnit 4
jvm.inspections.junit4.converter.quickfix.conflict.suite=Migration of suite method for {0} has side effects which will be deleted
jvm.inspections.junit4.converter.quickfix.conflict.name=Method {0} will have a name collision with its super method
jvm.inspections.junit4.converter.quickfix.conflict.call.compile=Method call {0} will not compile when {1} is converted to JUnit 4

jvm.inspections.junit4.inherited.runwith.display.name=@RunWith annotation already exists in a parent class
jvm.inspections.junit4.inherited.runwith.problem.descriptor=@RunWith annotation already exists in {0} class

jvm.inspections.junit5.converter.display.name=JUnit 4 test can be JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref can be JUnit 5 test
jvm.inspections.junit5.converter.quickfix=Migrate to JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=Convert Assertions
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=Class {0} can''t be converted to JUnit 5, cause there are incompatible inheritor(s): {1}

jvm.inspections.junit5.assertions.converter.display.name=JUnit 5 obsolete assertions
jvm.inspections.junit5.assertions.converter.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with a call to a method from ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Replace with ''{0}'' method call
jvm.inspections.junit5.assertions.converter.familyName=Replace with JUnit 5 compatible call

jvm.inspections.unconstructable.test.case.not.public.descriptor=Test class <code>#ref</code> is not constructable because it is not 'public' #loc
jvm.inspections.unconstructable.test.case.junit3.descriptor=Test class <code>#ref</code> is not constructable because it does not have a 'public' no-arg or single 'String' parameter constructor #loc
jvm.inspections.unconstructable.test.case.junit4.descriptor=Test class <code>#ref</code> is not constructable because it should have exactly one 'public' no-arg constructor #loc

jvm.inspections.test.case.in.product.source.display.name=Test in product source
jvm.inspections.test.case.in.product.source.problem.descriptor=Test case <code>#ref</code> should probably be placed in a test source tree #loc
jvm.inspections.test.method.in.product.source.problem.descriptor=Test method <code>#ref()</code> should probably be placed in a test source tree #loc

jvm.inspections.junit.malformed.declaration.name=JUnit malformed declaration
jvm.inspections.junit.malformed.option.ignore.test.parameter.if.annotated.by=Ignore test parameter if it is annotated by:
jvm.inspections.junit.malformed.no.arg.descriptor=Method <code>#ref</code> should be {0}, {1}{2, choice, 0# and have no parameters|1#, have no parameters and of type void}
jvm.inspections.junit.malformed.annotated.single.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2}
jvm.inspections.junit.malformed.annotated.double.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2} and {3}
jvm.inspections.junit.malformed.annotated.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be of type ''{2}''
jvm.inspections.junit.malformed.annotated.single.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2} and of type ''{3}''
jvm.inspections.junit.malformed.annotated.double.typed.descriptor={0, choice, 0#Field|1#Method} <code>#ref</code> annotated with ''@{1}'' should be {2}, {3} and of type ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameter ''{1}''
jvm.inspections.junit.malformed.annotated.method.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.single.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameter ''{2}''
jvm.inspections.junit.malformed.annotated.method.double.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameter ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.single.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameter ''{4}''
jvm.inspections.junit.malformed.annotated.method.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not declare parameters {1} and ''{2}''
jvm.inspections.junit.malformed.annotated.method.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be of type ''{1}'' and not declare parameters {2} and ''{3}''
jvm.inspections.junit.malformed.annotated.method.single.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1} and not declare parameters ''{2}'' and ''{3}''
jvm.inspections.junit.malformed.annotated.method.double.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2} and not declare parameters ''{3}'' and ''{4}''
jvm.inspections.junit.malformed.annotated.method.single.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, of type ''{2}'' and not declare parameters {3} and ''{4}''
jvm.inspections.junit.malformed.annotated.method.double.typed.param.double.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should be {1}, {2}, of type ''{3}'' and not declare parameters {4} and ''{5}''
jvm.inspections.junit.malformed.annotated.suspend.function.descriptor=Method <code>#ref</code> annotated with ''@{0}'' should not be a suspending function
jvm.inspections.junit.malformed.suspend.function.descriptor=Method <code>#ref</code> should not be a suspending function
jvm.inspections.junit.malformed.test.combination.descriptor=Suspicious combination of {0} and ''@{1}''
jvm.inspections.junit.malformed.repetition.number.descriptor=The number of repetitions must be greater than zero
jvm.inspections.junit.malformed.missing.nested.annotation.descriptor=Tests in nested class will not be executed
jvm.inspections.junit.malformed.extension.class.level.descriptor={0} should be registered at the class level
jvm.inspections.junit.malformed.param.method.source.unresolved.descriptor=Cannot resolve target method source: ''{0}''
jvm.inspections.junit.malformed.param.wrapped.in.arguments.descriptor=Multiple parameters have to be wrapped in 'Arguments'
jvm.inspections.junit.malformed.param.method.source.return.type.descriptor=Method source ''{0}'' must have one of the following return types: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' or ''Object[]''
jvm.inspections.junit.malformed.param.method.source.no.params.descriptor=Method source ''{0}'' should have no parameters
jvm.inspections.junit.malformed.param.method.source.static.descriptor=Method source ''{0}'' must be static
jvm.inspections.junit.malformed.param.method.source.assignable.descriptor=No implicit conversion found to convert ''{0}'' to ''{1}''
jvm.inspections.junit.malformed.param.duplicated.enum.descriptor=Duplicate 'enum' constant name
jvm.inspections.junit.malformed.param.unresolved.enum.descriptor=Can't resolve 'enum' constant reference.
jvm.inspections.junit.malformed.param.no.value.source.is.defined.descriptor=No value source is defined
jvm.inspections.junit.malformed.param.exactly.one.type.of.input.must.be.provided.descriptor=Exactly one type of input must be provided
jvm.inspections.junit.malformed.param.file.source.descriptor=Cannot resolve file source: ''{0}''
jvm.inspections.junit.malformed.source.without.params.descriptor=''@{0}'' cannot provide an argument to method because method doesn''t have parameters
jvm.inspections.junit.malformed.param.empty.source.unsupported.descriptor=''@{0}'' cannot provide an argument to method because method has an unsupported parameter of ''{1}'' type
jvm.inspections.junit.malformed.param.multiple.parameters.descriptor=Multiple parameters are not supported by this source
jvm.inspections.junit.malformed.param.no.sources.are.provided.descriptor=No sources are provided, the suite would be empty
jvm.inspections.junit.malformed.fix.class.signature=Fix class signature
jvm.inspections.junit.malformed.fix.class.signature.multi=Fix class signatures
jvm.inspections.junit.malformed.fix.class.signature.descriptor=Fix ''{0}'' class signature
jvm.inspections.junit.malformed.fix.method.signature=Fix method signature
jvm.inspections.junit.malformed.fix.method.signature.descriptor=Fix ''{0}'' method signature
jvm.inspections.junit.malformed.fix.field.signature=Fix field signature
jvm.inspections.junit.malformed.fix.field.signature.descriptor=Fix ''{0}'' field signature

jvm.inspections.junit.assertequals.on.array.display.name='assertEquals()' called on array
jvm.inspections.junit.assertequals.on.array.problem.descriptor=<code>#ref()</code> called on array #loc

jvm.inspections.junit.assertequals.may.be.assertsame.display.name='assertEquals()' may be 'assertSame()'
jvm.inspections.junit.assertequals.may.be.assertsame.problem.descriptor=<code>#ref()</code> may be 'assertSame()' #loc

jvm.inspections.junit.ignored.test.display.name=JUnit test annotated with '@Ignore'/'@Disabled'
jvm.inspections.junit.ignored.test.ignore.reason.option=Only report annotations without reason
jvm.inspections.junit.ignored.test.class.problem.descriptor=Test class ''{0}'' is ignored/disabled {1, choice, 1#|2#without reason} #loc
jvm.inspections.junit.ignored.test.method.problem.descriptor=Test method ''{0}()'' is ignored/disabled {1, choice, 1#|2#without reason} #loc

jvm.inspections.migrate.assertion.name=JUnit assertion can be 'assertThat()' call
jvm.inspections.migrate.assert.to.matcher.option=Statically import matcher's methods
jvm.inspections.migrate.assert.to.matcher.description=Assert expression <code>#ref</code> can be replaced with ''{0}'' call #loc

jvm.inspection.logging.string.template.as.argument.display.name=String template as argument to logging call
jvm.inspection.logging.string.template.as.argument.problem.descriptor=String template as argument to <code>#ref()</code> logging call #loc
jvm.inspection.logging.string.template.as.argument.quickfix.name=Replace with placeholders
jvm.inspection.logging.string.template.as.argument.skip.on.primitives=Do not warn when only expressions with primitive types, their wrappers or String are included
jvm.inspection.logging.string.template.as.argument.warn.on.label=Warn on:
jvm.inspection.logging.string.template.as.argument.all.levels.option=all log levels
jvm.inspection.logging.string.template.as.argument.warn.level.and.lower.option=warn level and lower
jvm.inspection.logging.string.template.as.argument.info.level.and.lower.option=info level and lower
jvm.inspection.logging.string.template.as.argument.debug.level.and.lower.option=debug level and lower
jvm.inspection.logging.string.template.as.argument.trace.level.option=trace level

jvm.inspection.logging.placeholder.count.matches.argument.count.display.name=Number of placeholders does not match number of arguments in logging call
jvm.inspection.logging.placeholder.count.matches.argument.count.more.problem.descriptor=More arguments provided ({0}) than placeholders specified ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.partial.descriptor=Fewer arguments provided ({0}) than placeholders specified (at least {1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.fewer.problem.descriptor=Fewer arguments provided ({0}) than placeholders specified ({1}) #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.incorrect.problem.descriptor=Illegal format string specifier #loc
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option=SLF4J uses Log4j 2 as implementation
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.auto=Check automatically
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.yes=Yes
jvm.inspection.logging.placeholder.count.matches.argument.count.slf4j.throwable.option.no=No

jvm.inspection.logging.condition.disagrees.with.log.statement.display.name=Log condition does not match logging call
jvm.inspection.logging.condition.disagrees.with.log.statement.problem.descriptor=Level of condition ''{0}'' does not match level of logging call ''{1}''

jvm.inspection.test.failed.line.display.name=Failed line in test

jvm.inspections.thread.run.display.name=Call to 'Thread.run()'

jvm.inspections.serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc

jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> called without specifying a Locale using internationalized strings #loc

jvm.inspections.api.display.name=Usages of API which isn't available at the configured language level
assertequals.between.inconvertible.types.display.name='assertEquals()' between objects of inconvertible types
jvm.inspections.1.5.problem.descriptor=Usage of API documented as @since {0}+
jvm.inspections.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
jvm.inspections.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}

jvm.inspections.assertequals.between.inconvertible.types.problem.descriptor=<code>#ref()</code> between objects of inconvertible types ''{0}'' and ''{1}'' #loc
jvm.inspections.assertnotsame.between.inconvertible.types.problem.descriptor=Redundant assertion: incompatible types are compared ''{0}'' and ''{1}''
jvm.inspections.assertnotequals.between.inconvertible.types.problem.descriptor=Possibly redundant assertion: incompatible types are compared ''{0}'' and ''{1}''

jvm.inspections.system.get.property.display.name=Call to 'System.getProperty(str)' could be simplified
jvm.inspections.system.get.property.problem.descriptor=Call <code>#ref</code> can be simplified for ''{0}''

can.t.build.uast.tree.for.file=Can't build UAST tree for file
title.uast=UAST
current.version=Current version
dialog.title.choose.annotation=Choose {0}
jvm.inspections.dependency.intention.description=Opens a dialog to configure dependency rules between scopes.
