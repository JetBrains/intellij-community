jvm.inspections.group.name=JVM languages

jvm.inspections.unstable.api.usage.display.name=Unstable API Usage
jvm.inspections.unstable.api.usage.annotations.list=Unstable API annotations:
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignore inside imports
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Overridden method ''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Overridden method ''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' is unstable because its signature references unstable {1} ''{2}'' marked with @{3}

jvm.inspections.scheduled.for.removal.future.version=a future version
jvm.inspections.scheduled.for.removal.predefined.version=version {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=Overridden method ''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Overridden method ''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' is scheduled for removal because its signature references {1} ''{2}'' scheduled for removal in {3}

jvm.inspections.unstable.type.used.in.signature.display.name=Unstable type is used in signature
jvm.inspections.unstable.type.used.in.class.signature.description=Class must be marked with ''@{0}'' annotation because its declaration references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=Method must be marked with ''@{0}'' annotation because its signature references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=Field must be marked with ''@{0}'' annotation because its type references unstable type ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Missing '@Deprecated' annotation on scheduled for removal API
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Scheduled for removal API must also be marked with '@Deprecated' annotation
jvm.inspections.must.already.be.removed.api.display.name=API must already be removed
jvm.inspections.must.already.be.removed.api.earlier.version.description=API must have been removed in version {0} but the current version is {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API must be removed in the current version {0}
jvm.inspections.blocking.method.problem.descriptor=Possibly blocking call in non-blocking context could lead to thread starvation
jvm.inspections.blocking.method.problem.wildcard.descriptor=Possibly blocking call in {0} could lead to thread starvation
jvm.inspections.blocking.method.display.name=Possibly blocking call in non-blocking context
jvm.inspections.blocking.method.annotation.blocking=Blocking Annotations
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking Annotations
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Add blocking annotation
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add non-blocking annotation
jvm.inspections.blocking.method.annotation.configure.empty.text=No annotations added.
jvm.inspections.blocking.method.consider.unknown.context.blocking=Consider unknown contexts blocking

jvm.inspections.api.no.extension.display.name=Class, interface, or method should not be extended
jvm.inspections.api.no.extension.class.description=Class ''{0}'' must not be extended
jvm.inspections.api.no.extension.interface.implement.description=Interface ''{0}'' must not be implemented
jvm.inspections.api.no.extension.interface.extend.description=Interface ''{0}'' must not be extended
jvm.inspections.api.no.extension.method.overriding.description=Method ''{0}'' must not be overridden
jvm.inspections.api.override.only.display.name=Method can only be overridden
jvm.inspections.api.override.only.description=Method ''{0}'' can only be overridden

jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.configure.button.text=Configure dependency rules
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

jvm.inspections.junit.rule.display.name=Malformed @Rule/@ClassRule field
jvm.inspections.junit.rule.problem.descriptor=Fields annotated with ''@{0}'' should be {1}
jvm.inspections.junit.rule.type.problem.descriptor=Field type should be subtype of 'org.junit.rules.TestRule'

jvm.inspections.source.to.sink.flow.display.name=Non-safe string is passed to safe method
jvm.inspections.source.to.sink.flow.passed.unsafe=Unsafe string is used as safe parameter
jvm.inspections.source.to.sink.flow.passed.unknown=Unknown string is used as safe parameter
jvm.inspections.source.to.sink.flow.returned.unsafe=Unsafe string is returned from safe method
jvm.inspections.source.to.sink.flow.returned.unknown=Unknown string is returned from safe method
jvm.inspections.source.to.sink.flow.assigned.unsafe=Unsafe string is assigned to safe variable
jvm.inspections.source.to.sink.flow.assigned.unknown=Unknown string is assigned to safe variable
jvm.inspections.source.to.sink.flow.common.unsafe=Unsafe string is used in a safe context
jvm.inspections.source.to.sink.flow.common.unknown=Unknown string is used in a safe context
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.family=Mark as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.text=Mark ''{0}'' as requiring validation
jvm.inspections.source.unsafe.to.sink.flow.mark.as.safe.command.name=Mark As Safe
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.family=Propagate safe annotation
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.text=Propagate safe annotation from ''{0}''
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.title=Select Members to Annotate as Safe
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.annotate=Annotate All
jvm.inspections.source.unsafe.to.sink.flow.propagate.safe.toolwindow.unsafe.flow=Unsafe flow
propagated.from=Reason to Mark as Safe
propagated.to=Target to Mark as Safe
propagate.from.empty.text=Reason to mark as safe is shown here
propagate.to.empty.text=Target to mark as safe is shown here

jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code

jvm.inspections.junit5.assertions.converter.display.name=Obsolete assertions in JUnit 5 tests
jvm.inspections.junit5.assertions.converter.problem.descriptor=Call to <code>#ref()</code> from ''{0}'' should be replaced with call to method from ''{1}'' #loc
jvm.inspections.junit5.assertions.converter.quickfix=Replace with ''{0}'' method call
jvm.inspections.junit5.assertions.converter.familyName=Replace with JUnit 5 compatible call

jvm.inspections.junit5.converter.display.name=JUnit 4 test can be JUnit 5
jvm.inspections.junit5.converter.problem.descriptor=#ref can be JUnit 5 test
jvm.inspections.junit5.converter.quickfix=Migrate to JUnit 5
jvm.inspections.junit5.converter.quickfix.presentation.text=Convert Assertions
jvm.inspections.junit5.converter.quickfix.conflict.inheritor=Class {0} can''t be converted to JUnit 5, cause there are incompatible inheritor(s): {1}

jvm.inspection.test.failed.line.display.name=Failed line in test

jvm.inspections.thread.run.display.name=Call to 'Thread.run()'

jvm.inspections.serializable.class.without.serialversionuid.display.name=Serializable class without 'serialVersionUID'
jvm.inspections.serializable.class.without.serialversionuid.problem.descriptor=<code>#ref</code> does not define a 'serialVersionUID' field #loc

jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> called without specifying a Locale using internationalized strings #loc

jvm.inspections.api.display.name=Usages of API which isn't available at the configured language level
jvm.inspections.1.5.problem.descriptor=Usage of API documented as @since {0}+
jvm.inspections.1.7.problem.descriptor=Usage of generified after 1.6 API which would cause compilation problems with JDK {0}
jvm.inspections.1.8.problem.descriptor=Default {0, choice, 0#|1#method is|2# methods are} not overridden. It would cause compilation problems with JDK {1}
jvm.inspections.1.8.problem.single.descriptor=Default method ''{0}'' is not overridden. It would cause compilation problems with JDK {1}

can.t.build.uast.tree.for.file=Can't build UAST tree for file
title.uast=UAST
current.version=Current version
dialog.title.choose.annotation=Choose {0}