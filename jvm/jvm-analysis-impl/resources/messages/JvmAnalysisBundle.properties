jvm.inspections.group.name=JVM languages

jvm.inspections.unstable.api.usage.display.name=Unstable API Usage
jvm.inspections.unstable.api.usage.annotations.list=Unstable API annotations:
jvm.inspections.unstable.api.usage.ignore.inside.imports=Ignore inside imports
jvm.inspections.unstable.api.usage.ignore.declared.inside.this.project=Ignore API declared in this project
jvm.inspections.unstable.api.usage.api.is.marked.unstable.itself=''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.api.is.declared.in.unstable.api=''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.overridden.method.is.marked.unstable.itself=Overridden method ''{0}'' is marked unstable with @{1}
jvm.inspections.unstable.api.usage.overridden.method.is.declared.in.unstable.api=Overridden method ''{0}'' is declared in unstable {1} ''{2}'' marked with @{3}
jvm.inspections.unstable.api.usage.unstable.type.is.used.in.signature.of.referenced.api=''{0}'' is unstable because its signature references unstable {1} ''{2}'' marked with @{3}

jvm.inspections.scheduled.for.removal.future.version=a future version
jvm.inspections.scheduled.for.removal.predefined.version=version {0}
jvm.inspections.scheduled.for.removal.api.is.marked.itself=''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.api.is.declared.in.marked.api=''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.method.overridden.marked.itself=Overridden method ''{0}'' is scheduled for removal in {1}
jvm.inspections.scheduled.for.removal.method.overridden.declared.in.marked.api=Overridden method ''{0}'' is declared in {1} ''{2}'' scheduled for removal in {3}
jvm.inspections.scheduled.for.removal.scheduled.for.removal.type.is.used.in.signature.of.referenced.api=''{0}'' is scheduled for removal because its signature references {1} ''{2}'' scheduled for removal in {3}

jvm.inspections.unstable.type.used.in.signature.display.name=Unstable type is used in signature
jvm.inspections.unstable.type.used.in.class.signature.description=Class must be marked with ''@{0}'' annotation because its declaration references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.method.signature.description=Method must be marked with ''@{0}'' annotation because its signature references unstable type ''{1}''
jvm.inspections.unstable.type.used.in.field.signature.description=Field must be marked with ''@{0}'' annotation because its type references unstable type ''{1}''

jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.display.name=Missing '@Deprecated' annotation on scheduled for removal API
jvm.inspections.missing.deprecated.annotation.on.scheduled.for.removal.api.description=Scheduled for removal API must also be marked with '@Deprecated' annotation
jvm.inspections.must.already.be.removed.api.display.name=API must already be removed
jvm.inspections.must.already.be.removed.api.earlier.version.description=API must have been removed in version {0} but the current version is {1}
jvm.inspections.must.already.be.removed.api.current.version.description=API must be removed in the current version {0}
jvm.inspections.blocking.method.problem.descriptor=Inappropriate blocking method call
jvm.inspections.blocking.method.display.name=Inappropriate thread-blocking method call
jvm.inspections.blocking.method.annotation.blocking=Blocking Annotations
jvm.inspections.blocking.method.annotation.non-blocking=Non-Blocking Annotations
jvm.inspections.blocking.method.annotation.configure.add.blocking.title=Add blocking annotation
jvm.inspections.blocking.method.annotation.configure.add.non-blocking.title=Add non-blocking annotation
jvm.inspections.blocking.method.annotation.configure.empty.text=No annotations added.

jvm.inspections.api.no.extension.display.name=Class, interface, or method should not be extended
jvm.inspections.api.no.extension.class.description=Class ''{0}'' must not be extended
jvm.inspections.api.no.extension.interface.implement.description=Interface ''{0}'' must not be implemented
jvm.inspections.api.no.extension.interface.extend.description=Interface ''{0}'' must not be extended
jvm.inspections.api.no.extension.method.overriding.description=Method ''{0}'' must not be overridden
jvm.inspections.api.override.only.display.name=Method can only be overridden
jvm.inspections.api.override.only.description=Method ''{0}'' can only be overridden

jvm.inspections.dependency.display.name=Illegal package dependencies
jvm.inspections.dependency.edit.rules.text=Edit dependency rule \"{0} \"
jvm.inspections.dependency.edit.rules.family=Edit dependency rules
jvm.inspections.dependency.configure.button.text=Configure dependency rules
jvm.inspections.dependency.violator.problem.descriptor=Dependency rule ''{0}.'' is violated

jvm.inspections.junit.rule.display.name=Malformed @Rule/@ClassRule field
jvm.inspections.junit.rule.problem.descriptor=Fields annotated with ''@{0}'' should be {1}
jvm.inspections.junit.rule.type.problem.descriptor=Field type should be subtype of 'org.junit.rules.TestRule'

jvm.inspections.testonly.display.name=Test-only usage in production code
jvm.inspections.testonly.class.reference=Test-only class is referenced in production code
jvm.inspections.testonly.field.reference=Test-only field is referenced in production code
jvm.inspections.testonly.method.call=Test-only method is called in production code
jvm.inspections.testonly.visiblefortesting=@VisibleForTesting makes little sense on @TestOnly code

jvm.inspection.test.failed.line.display.name=Failed line in test

jvm.inspections.string.touppercase.tolowercase.without.locale.description=<code>String.{0}()</code> called without specifying a Locale using internationalized strings #loc
can.t.build.uast.tree.for.file=Can't build UAST tree for file
title.uast=UAST
current.version=Current version
dialog.title.choose.annotation=Choose {0}
jvm.inspections.junit5.malformed.parameterized.display.name=Malformed Parameterized inspection
junit5.malformed.parameterized.inspection.description.method.source.unresolved=Cannot resolve target method source: ''{0}''
junit5.malformed.parameterized.inspection.description.wrapped.in.arguments=Multiple parameters have to be wrapped in 'Arguments'
junit5.malformed.parameterized.inspection.description.method.source.return.type=Method source ''{0}'' must have one of the following return type: ''Stream<?>'', ''Iterator<?>'', ''Iterable<?>'' or ''Object[]''
junit5.malformed.parameterized.inspection.description.method.source.no.params=Method source ''{0}'' should have no parameters
junit5.malformed.parameterized.inspection.description.method.source.static=Method source ''{0}'' must be static
junit5.malformed.parameterized.inspection.description.method.source.assignable=No implicit conversion found to convert object of type ''{0}'' to ''{1}''
junit5.malformed.parameterized.inspection.description.duplicated.enum=Duplicate 'enum' constant name
junit5.malformed.parameterized.inspection.description.unresolved.enum=Can't resolve 'enum' constant reference.
junit5.malformed.parameterized.inspection.description.no.value.source.is.defined=No value source is defined
junit5.malformed.parameterized.inspection.description.exactly.one.type.of.input.must.be.provided=Exactly one type of input must be provided
junit5.malformed.parameterized.inspection.description.file.source=Cannot resolve file source: ''{0}''
junit5.malformed.parameterized.fix.text=Change to ''{0}''
junit5.malformed.parameterized.inspection.description.suspicious.combination.test.and.parameterizedtest=Suspicious combination '@Test' and '@ParameterizedTest'
junit5.malformed.parameterized.inspection.description.suspicious.combination=Suspicious combination '@Test' and parameterized source
junit5.malformed.parameterized.inspection.description.multiple.parameters.are.not.supported.by.this.source=Multiple parameters are not supported by this source
junit5.malformed.parameterized.inspection.description.no.sources.are.provided=No sources are provided, the suite would be empty
junit5.malformed.parameterized.fix.family.name=Replace annotation